Directory structure:
└── algorandfoundation-puya-ts/
    ├── README.md
    ├── commitlint.config.cjs
    ├── CONTRIBUTING.md
    ├── eslint.config.mjs
    ├── LICENSE
    ├── package.json
    ├── rollup.config.ts
    ├── test.setup.ts
    ├── tsconfig.build.json
    ├── tsconfig.json
    ├── typedoc.json
    ├── vitest.config.mts
    ├── .editorconfig
    ├── .nsprc
    ├── .prettierignore
    ├── .prettierrc.cjs
    ├── .releaserc.json
    ├── .tstoolkitrc.ts
    ├── docs/
    │   ├── readme.md
    │   ├── abi-routing.md
    │   ├── cli.md
    │   ├── guiding-principles.md
    │   ├── language-guide.md
    │   ├── lg-itxns.md
    │   ├── lg-ops.md
    │   ├── lg-program-structure.md
    │   ├── lg-storage.md
    │   ├── lg-types.md
    │   ├── reference.md
    │   └── architecture-decisions/
    │       ├── 2024-05-21_primitive-bytes-and-strings.md
    │       └── 2024-05-21_primitive-integer-types.md
    ├── examples/
    │   ├── auction/
    │   │   └── contract.algo.ts
    │   ├── calculator/
    │   │   └── contract.algo.ts
    │   ├── hello-world/
    │   │   └── contract.algo.ts
    │   ├── hello-world-abi/
    │   │   └── contract.algo.ts
    │   ├── simple-voting/
    │   │   └── contract.algo.ts
    │   └── voting/
    │       └── contract.algo.ts
    ├── packages/
    │   └── algo-ts/
    │       ├── readme.md
    │       ├── eslint.config.mjs
    │       ├── package.json
    │       ├── rollup.config.ts
    │       ├── tsconfig.build.json
    │       ├── tsconfig.json
    │       ├── vitest.config.mts
    │       ├── .nsprc
    │       ├── .prettierignore
    │       ├── .prettierrc.cjs
    │       ├── .tstoolkitrc.ts
    │       └── src/
    │           ├── arc-28.ts
    │           ├── base-contract.ts
    │           ├── box.ts
    │           ├── compiled.ts
    │           ├── gtxn.ts
    │           ├── index.ts
    │           ├── itxn.ts
    │           ├── logic-sig.ts
    │           ├── mutable-array.ts
    │           ├── on-complete-action.ts
    │           ├── primitives.ts
    │           ├── reference.ts
    │           ├── state.ts
    │           ├── template-var.ts
    │           ├── transactions.ts
    │           ├── util.ts
    │           ├── arc4/
    │           │   ├── c2c.ts
    │           │   ├── encoded-types.ts
    │           │   └── index.ts
    │           └── internal/
    │               ├── errors.ts
    │               └── typescript-helpers.ts
    ├── scripts/
    │   ├── build-op-module.ts
    │   ├── code-gen.ts
    │   ├── generate-op-funcs.ts
    │   ├── generate-op-metadata.ts
    │   ├── generate-op-ptypes.ts
    │   ├── generate-txn-types.ts
    │   └── langspec.d.ts
    ├── src/
    │   ├── cli.ts
    │   ├── compile.ts
    │   ├── constants.ts
    │   ├── errors.ts
    │   ├── index.ts
    │   ├── options.ts
    │   ├── typescript-helpers.d.ts
    │   ├── write-artifact.ts
    │   ├── awst/
    │   │   ├── constant-evaluation.ts
    │   │   ├── index.ts
    │   │   ├── intrinsic-factory.ts
    │   │   ├── json-serialize-awst.ts
    │   │   ├── models.ts
    │   │   ├── node-factory.ts
    │   │   ├── nodes.ts
    │   │   ├── source-location.ts
    │   │   ├── to-code-visitor.ts
    │   │   ├── txn-fields.ts
    │   │   ├── util.ts
    │   │   ├── wtypes.ts
    │   │   └── validation/
    │   │       ├── arc4-approval-calls-router.ts
    │   │       ├── awst-traverser.ts
    │   │       └── index.ts
    │   ├── awst_build/
    │   │   ├── arc4-util.ts
    │   │   ├── constant-store.ts
    │   │   ├── index.ts
    │   │   ├── symbol-name.ts
    │   │   ├── txn-fields.ts
    │   │   ├── type-registry.ts
    │   │   ├── type-resolver.ts
    │   │   ├── ast-visitors/
    │   │   │   ├── base-visitor.ts
    │   │   │   ├── constructor-visitor.ts
    │   │   │   ├── contract-method-visitor.ts
    │   │   │   ├── contract-visitor.ts
    │   │   │   ├── decorator-visitor.ts
    │   │   │   ├── function-visitor.ts
    │   │   │   ├── logic-sig-program-visitor.ts
    │   │   │   ├── logic-sig-visitor.ts
    │   │   │   ├── source-file-visitor.ts
    │   │   │   ├── struct-visitor.ts
    │   │   │   ├── subroutine-visitor.ts
    │   │   │   ├── text-visitor.ts
    │   │   │   └── util.ts
    │   │   ├── context/
    │   │   │   ├── awst-build-context.ts
    │   │   │   ├── evaluation-context.ts
    │   │   │   ├── switch-loop-context.ts
    │   │   │   └── unique-name-resolver.ts
    │   │   ├── eb/
    │   │   │   ├── arc4-bare-method-decorator-builder.ts
    │   │   │   ├── assert-function-builder.ts
    │   │   │   ├── assert-match-function-builder.ts
    │   │   │   ├── biguint-expression-builder.ts
    │   │   │   ├── boolean-expression-builder.ts
    │   │   │   ├── bytes-expression-builder.ts
    │   │   │   ├── contract-builder.ts
    │   │   │   ├── ensure-budget.ts
    │   │   │   ├── folding.ts
    │   │   │   ├── free-subroutine-expression-builder.ts
    │   │   │   ├── index.ts
    │   │   │   ├── intrinsic-enum-builder.ts
    │   │   │   ├── iterable-iterator-expression-builder.ts
    │   │   │   ├── literal-expression-builder.ts
    │   │   │   ├── log-function-builder.ts
    │   │   │   ├── logic-sig-builder.ts
    │   │   │   ├── match-function-builder.ts
    │   │   │   ├── mutable-arrays.ts
    │   │   │   ├── namespace-builder.ts
    │   │   │   ├── native-array-expression-builder.ts
    │   │   │   ├── never-expression-builder.ts
    │   │   │   ├── omitted-expression-builder.ts
    │   │   │   ├── op-module-builder.ts
    │   │   │   ├── spread-expression-builder.ts
    │   │   │   ├── string-expression-builder.ts
    │   │   │   ├── template-var.ts
    │   │   │   ├── tuple-expression-builder.ts
    │   │   │   ├── uint64-enum-type-builder.ts
    │   │   │   ├── uint64-expression-builder.ts
    │   │   │   ├── unresolvable-expression-builder.ts
    │   │   │   ├── urange-function.ts
    │   │   │   ├── void-expression-builder.ts
    │   │   │   ├── arc28/
    │   │   │   │   └── arc-28-emit-function-builder.ts
    │   │   │   ├── arc4/
    │   │   │   │   ├── arrays.ts
    │   │   │   │   ├── base.ts
    │   │   │   │   ├── bool.ts
    │   │   │   │   ├── c2c.ts
    │   │   │   │   ├── string.ts
    │   │   │   │   ├── struct.ts
    │   │   │   │   ├── tuple.ts
    │   │   │   │   ├── ufixed.ts
    │   │   │   │   ├── uintn.ts
    │   │   │   │   └── util.ts
    │   │   │   ├── compiled/
    │   │   │   │   └── compile-function.ts
    │   │   │   ├── literal/
    │   │   │   │   ├── array-literal-expression-builder.ts
    │   │   │   │   ├── big-int-literal-expression-builder.ts
    │   │   │   │   ├── conditional-expression-builder.ts
    │   │   │   │   ├── object-expression-builder.ts
    │   │   │   │   └── object-literal-expression-builder.ts
    │   │   │   ├── reference/
    │   │   │   │   ├── account.ts
    │   │   │   │   ├── application.ts
    │   │   │   │   ├── asset.ts
    │   │   │   │   └── base.ts
    │   │   │   ├── shared/
    │   │   │   │   ├── arc4-copy-function-builder.ts
    │   │   │   │   ├── at-function-builder.ts
    │   │   │   │   ├── pop-function-builder.ts
    │   │   │   │   ├── push-function-builder.ts
    │   │   │   │   └── slice-function-builder.ts
    │   │   │   ├── storage/
    │   │   │   │   ├── global-state.ts
    │   │   │   │   ├── local-state.ts
    │   │   │   │   ├── util.ts
    │   │   │   │   ├── value-proxy.ts
    │   │   │   │   └── box/
    │   │   │   │       ├── base.ts
    │   │   │   │       ├── box-map.ts
    │   │   │   │       ├── box-ref.ts
    │   │   │   │       ├── box.ts
    │   │   │   │       ├── index.ts
    │   │   │   │       └── util.ts
    │   │   │   ├── traits/
    │   │   │   │   └── static-iterator.ts
    │   │   │   ├── transactions/
    │   │   │   │   ├── group-transactions.ts
    │   │   │   │   ├── inner-transaction-params.ts
    │   │   │   │   ├── inner-transactions.ts
    │   │   │   │   └── util.ts
    │   │   │   └── util/
    │   │   │       ├── arg-parsing.ts
    │   │   │       ├── avm-version.ts
    │   │   │       ├── compare-bytes.ts
    │   │   │       ├── compare-uint64.ts
    │   │   │       ├── get-bigint-or-uint64-expr.ts
    │   │   │       ├── index.ts
    │   │   │       ├── is-valid-literal-for-ptype.ts
    │   │   │       ├── require-constant-value.ts
    │   │   │       ├── resolve-compat-builder.ts
    │   │   │       ├── scratch-slots.ts
    │   │   │       ├── string-to-bigint.ts
    │   │   │       ├── translate-negative-index.ts
    │   │   │       └── array/
    │   │   │           ├── common.ts
    │   │   │           ├── concat.ts
    │   │   │           ├── index-access.ts
    │   │   │           └── length.ts
    │   │   ├── lib/
    │   │   │   └── index.ts
    │   │   ├── models/
    │   │   │   ├── app-storage-declaration.ts
    │   │   │   ├── contract-class-model.ts
    │   │   │   ├── decorator-data.ts
    │   │   │   └── logic-sig-class-model.ts
    │   │   └── ptypes/
    │   │       ├── arc4-types.ts
    │   │       ├── base.ts
    │   │       ├── for-export.ts
    │   │       ├── index.ts
    │   │       ├── intrinsic-enum-type.ts
    │   │       ├── op-ptypes.ts
    │   │       ├── register.ts
    │   │       ├── transient-type-errors.ts
    │   │       └── util.ts
    │   ├── cli/
    │   │   ├── app-version.ts
    │   │   ├── build-command.ts
    │   │   ├── check-node-version.ts
    │   │   ├── parse.ts
    │   │   └── util.ts
    │   ├── input-paths/
    │   │   ├── determine-out-dir.spec.ts
    │   │   ├── determine-out-dir.ts
    │   │   └── process-input-paths.ts
    │   ├── language-server/
    │   │   ├── diagnostics.ts
    │   │   ├── language-server.ts
    │   │   └── parse.ts
    │   ├── logger/
    │   │   ├── index.ts
    │   │   └── sinks/
    │   │       ├── console-log-sink.ts
    │   │       └── index.ts
    │   ├── parser/
    │   │   ├── index.ts
    │   │   ├── json-serialize-source-files.ts
    │   │   └── resolve-module-name-literals.ts
    │   ├── puya/
    │   │   ├── build-compilation-set-mapping.ts
    │   │   ├── check-puya-version.ts
    │   │   ├── index.ts
    │   │   ├── log-deserializer.ts
    │   │   ├── puya-binary.ts
    │   │   ├── resolve-puya-path.ts
    │   │   ├── run-puya.ts
    │   │   └── semver.ts
    │   ├── util/
    │   │   ├── add-postinstall-script.ts
    │   │   ├── arc4-signature-parser.spec.ts
    │   │   ├── arc4-signature-parser.ts
    │   │   ├── base-32.spec.ts
    │   │   ├── base-32.ts
    │   │   ├── base-85.ts
    │   │   ├── custom-key-map.ts
    │   │   ├── default-map.ts
    │   │   ├── generate-temp-file.ts
    │   │   ├── index.ts
    │   │   ├── invoke-cli.ts
    │   │   ├── lock-file.spec.ts
    │   │   ├── lock-file.ts
    │   │   ├── sleep.ts
    │   │   └── template-var-cli-parser.ts
    │   └── visitor/
    │       ├── syntax-names.ts
    │       └── visitor.ts
    ├── tests/
    │   ├── approvals.spec.ts
    │   ├── expected-output.spec.ts
    │   ├── virtual-file.spec.ts
    │   ├── approvals/
    │   │   ├── abi-decorators.algo.ts
    │   │   ├── accounts.algo.ts
    │   │   ├── arc-28-events.algo.ts
    │   │   ├── arc4-encode-decode.algo.ts
    │   │   ├── arc4-hybrid.algo.ts
    │   │   ├── arc4-method-selector.algo.ts
    │   │   ├── arc4-struct.algo.ts
    │   │   ├── arc4-types.algo.ts
    │   │   ├── array-destructuring.algo.ts
    │   │   ├── array-literals.algo.ts
    │   │   ├── assert-match.algo.ts
    │   │   ├── asset-proxy.algo.ts
    │   │   ├── avm11.algo.ts
    │   │   ├── biguint-expressions.algo.ts
    │   │   ├── boolean-conversions.algo.ts
    │   │   ├── boolean-expressions.algo.ts
    │   │   ├── box-enum-contract.algo.ts
    │   │   ├── box-proxies.algo.ts
    │   │   ├── byte-expressions.algo.ts
    │   │   ├── call-expressions.algo.ts
    │   │   ├── casting.algo.ts
    │   │   ├── conditional-expression.algo.ts
    │   │   ├── destructured-params.algo.ts
    │   │   ├── destructuring-iterators.algo.ts
    │   │   ├── do-loops.algo.ts
    │   │   ├── ensure-budget.algo.ts
    │   │   ├── extract-bytes.algo.ts
    │   │   ├── for-loops.algo.ts
    │   │   ├── for-of-loops.algo.ts
    │   │   ├── global-state.algo.ts
    │   │   ├── gtxns.algo.ts
    │   │   ├── implicit-create.algo.ts
    │   │   ├── inheritance-a.algo.ts
    │   │   ├── inheritance-b.algo.ts
    │   │   ├── intrinsic-calls.algo.ts
    │   │   ├── itxn.algo.ts
    │   │   ├── jsdoc.algo.ts
    │   │   ├── local-state.algo.ts
    │   │   ├── logic-sig.algo.ts
    │   │   ├── match-expr.algo.ts
    │   │   ├── module-constants.algo.ts
    │   │   ├── multi-inheritance-2.algo.ts
    │   │   ├── multi-inheritance.algo.ts
    │   │   ├── mutable-arrays.algo.ts
    │   │   ├── named-types.algo.ts
    │   │   ├── native-arrays.algo.ts
    │   │   ├── non-arc4.algo.ts
    │   │   ├── object-destructuring.algo.ts
    │   │   ├── ops.algo.ts
    │   │   ├── pre-approved-sale.algo.ts
    │   │   ├── precompiled-apps.algo.ts
    │   │   ├── precompiled-factory.algo.ts
    │   │   ├── precompiled-typed.algo.ts
    │   │   ├── prefix-postfix-operators.algo.ts
    │   │   ├── property-ordering.algo.ts
    │   │   ├── reserve-scratch.algo.ts
    │   │   ├── shadowed-variables.algo.ts
    │   │   ├── single-eval.algo.ts
    │   │   ├── state-totals.algo.ts
    │   │   ├── strings.algo.ts
    │   │   ├── super-calls.algo.ts
    │   │   ├── switch-statements.algo.ts
    │   │   ├── teal-script-conventions.algo.ts
    │   │   ├── template-var.algo.ts
    │   │   ├── uint64-expressions.algo.ts
    │   │   ├── urange.algo.ts
    │   │   └── while-loops.algo.ts
    │   ├── expected-output/
    │   │   ├── abi-decorators.algo.ts
    │   │   ├── arc28-events.algo.ts
    │   │   ├── arc4-encode-decode.algo.ts
    │   │   ├── arc4-hybrid.algo.ts
    │   │   ├── arc4-method-selector.algo.ts
    │   │   ├── arc4-struct.algo.ts
    │   │   ├── arc4-types.algo.ts
    │   │   ├── array-destructuring.algo.ts
    │   │   ├── array-literals.algo.ts
    │   │   ├── biguint-expressions.algo.ts
    │   │   ├── box-proxies.algo.ts
    │   │   ├── byte-expressions.algo.ts
    │   │   ├── cant-create.algo.ts
    │   │   ├── conditional-expression.algo.ts
    │   │   ├── dynamic-imports.algo.ts
    │   │   ├── extract-bytes.algo.ts
    │   │   ├── global-state.algo.ts
    │   │   ├── logic-sig.algo.ts
    │   │   ├── multi-inheritance.algo.ts
    │   │   ├── mutating-tuples.algo.ts
    │   │   ├── not-supported.algo.ts
    │   │   ├── null-values.algo.ts
    │   │   ├── numeric-literal-expressions.algo.ts
    │   │   ├── object-destructuring.algo.ts
    │   │   ├── prefix-postfix-operators.algo.ts
    │   │   ├── teal-script-conventions.algo.ts
    │   │   ├── template-var.algo.ts
    │   │   ├── uint64-expressions.algo.ts
    │   │   └── unsupported-tokens.algo.ts
    │   └── onchain/
    │       ├── abi-decorators.spec.ts
    │       ├── accounts.spec.ts
    │       ├── arc-28-events.spec.ts
    │       ├── arc4-hybrid.spec.ts
    │       ├── arc4-method-selector.spec.ts
    │       ├── arc4-types.spec.ts
    │       ├── array-destructuring.spec.ts
    │       ├── assert-match.spec.ts
    │       ├── asset-proxy.spec.ts
    │       ├── box-enum-contract.spec.ts
    │       ├── box-proxies.spec.ts
    │       ├── byte-expressions.spec.ts
    │       ├── destructured-params.spec.ts
    │       ├── do-loops.spec.ts
    │       ├── extract-bytes.spec.ts
    │       ├── for-loops.spec.ts
    │       ├── for-of-loops.spec.ts
    │       ├── global-state.spec.ts
    │       ├── gtxns.spec.ts
    │       ├── implicit-create.spec.ts
    │       ├── inheritance.spec.ts
    │       ├── itxn.spec.ts
    │       ├── local-state.spec.ts
    │       ├── match-expr.spec.ts
    │       ├── module-constants.spec.ts
    │       ├── multi-inheritance.spec.ts
    │       ├── mutable-arrays.spec.ts
    │       ├── native-arrays.spec.ts
    │       ├── ops.spec.ts
    │       ├── precompiled.spec.ts
    │       ├── prefix-postfix-operators.spec.ts
    │       ├── primitives.spec.ts
    │       ├── property-ordering.spec.ts
    │       ├── reserve-scratch.spec.ts
    │       ├── shadowed-variables.spec.ts
    │       ├── single-eval.spec.ts
    │       ├── state-totals.spec.ts
    │       ├── super-calls.spec.ts
    │       ├── switch-statements.spec.ts
    │       ├── teal-script-conventions.spec.ts
    │       ├── template-vars.spec.ts
    │       ├── urange.spec.ts
    │       ├── while-loops.spec.ts
    │       └── util/
    │           ├── decode-logs.ts
    │           └── test-fixture.ts
    └── .github/
        ├── dependabot.yml
        ├── ISSUE_TEMPLATE/
        │   ├── bug_report.md
        │   └── feature_request.md
        └── workflows/
            ├── ci-all.yml
            ├── gh-pages.yml
            ├── node-ci.yml
            ├── pr.yml
            └── release.yml

================================================
FILE: README.md
================================================
# Algorand TypeScript

Algorand TypeScript is a partial implementation of the TypeScript programming language that runs on the Algorand Virtual Machine (AVM). It includes a statically typed framework for development of Algorand smart contracts and logic signatures, with TypeScript interfaces to underlying AVM functionality that works with standard TypeScript tooling.

It maintains the syntax and semantics of TypeScript such that a developer who knows TypeScript can make safe assumptions
about the behaviour of the compiled code when running on the AVM. Algorand TypeScript is also executable TypeScript that can be run
and debugged on a Node.js virtual machine with transpilation to EcmaScript and run from automated tests.

Algorand TypeScript is compiled for execution on the AVM by PuyaTs, a TypeScript frontend for the [Puya](https://github.com/algorandfoundation/puya) optimising compiler that ensures the resulting AVM bytecode execution semantics that match the given TypeScript code. PuyaTs produces output that is directly compatible with AlgoKit typed clients to make deployment and calling easy.

## Documentation

- [Language Guide](https://algorandfoundation.github.io/puya-ts/documents/Algorand_TypeScript_Language_Guide.html)
- [API Docs](https://algorandfoundation.github.io/puya-ts/modules.html)
- [CLI Guide](https://algorandfoundation.github.io/puya-ts/documents/Compiler_CLI_Guide.html)
- [Contribution Guide](CONTRIBUTING.md)
- [Releases Notes](https://github.com/algorandfoundation/puya-ts/releases)



================================================
FILE: commitlint.config.cjs
================================================
module.exports = {
  extends: ['@commitlint/config-conventional'],
  rules: {
    'subject-case': [0, 'always', ['pascal-case', 'upper-case']],
    'type-empty': [1, 'never'],
    'subject-empty': [0, 'always'],
    'body-leading-blank': [0, 'always'],
    'body-max-line-length': [0, 'always', 200],
    'header-max-length': [0, 'always', 150],
    'footer-max-length': [0, 'always', 150],
    'footer-max-line-length': [0, 'always', 150],
  },
}




================================================
FILE: CONTRIBUTING.md
================================================
# Contributing to Puya-ts

Contributions are welcome. For new features, please open an issue to discuss first.

## Workflow

### Commits

We use [Conventional Commits](https://www.conventionalcommits.org/en/v1.0.0/#summary). User-facing changes should include at least one `fix:` or `feat:` commit for release notes. Other conventions like `docs:` or `test:` are optional but helpful.

### Branches

| Name      | Description                                                               |
| --------- | ------------------------------------------------------------------------- |
| `alpha`   | Commits to this branch will generate an alpha release of the npm packages |
| `main`    | Commits to this branch will generate a beta release of the npm packages   |
| `release` | Commits to this branch will generate a new release of the npm packages    |

In general, most changes should begin as a branch based on `alpha`. Once you are happy with the changes, open a PR to merge your branch into `alpha` and it will trigger a PR build to compile and test the code. When the build passes and you have relevant approvals - your code will be merged into `alpha` branch and after the release workflow has completed, you can install the published alpha packages from npm to check they are still working as expected.

Depending on the velocity of new changes, there will be a periodic merge of `alpha` branch into `main` in order to create a `beta` release. On a slower cycle again, changes will be promoted from `main` into `release`.

## Local Development

To set up the project locally:

1. **Install Node.js**: Download from [nodejs.org](https://nodejs.org/). See src/constants.ts `minNodeVersion` for minimum version.

1. **Install AlgoKit CLI**: Follow the guide from [Algokit](https://github.com/algorandfoundation/algokit-cli?tab=readme-ov-file#install).

1. **Start localnet**:

   ```sh
   algokit localnet start
   # or `algokit localnet reset --update` to update localnet docker images
   ```

1. **Install npm dependencies**:

   ```sh
   npm install
   ```

1. **Run tests**:
   ```sh
   npm test
   ```
> [!TIP]
> Windows users: The initial test run may fail due to CRLF/LF line ending differences. If so, run `git add .` which will force git to recognise and cache the new line endings and allow the tests to complete.

## Adding New Op Codes for New AVM Versions

1. Copy the latest [langspec.puya.json](./langspec.puya.json) from [puya](https://github.com/algorandfoundation/puya/blob/main/langspec.puya.json). Refer to the [contributing guide](https://github.com/algorandfoundation/puya/blob/main/CONTRIBUTING.md#updating-langspec-for-new-avm-versions) on the Puya repo for more information on how the file itself is updated for a new AVM version.

2. Run the following script to update relevant files:

   ```sh
   npm run script:code-gen
   ```

3. If a new `enum` type is required, add it to [ENUMS_TO_EXPOSE](./scripts/build-op-module.ts#L12). Re-run the scripts and update [index.ts](./packages/algo-ts/src/index.ts#L17).

4. Add an approval test to ensure the new op codes compile correctly; e.g., [AVM 11 approval test](./tests/approvals/avm11.algo.ts).



================================================
FILE: eslint.config.mjs
================================================
import { FlatCompat } from '@eslint/eslintrc'
import js from '@eslint/js'
import path from 'node:path'
import { fileURLToPath } from 'node:url'

const __filename = fileURLToPath(import.meta.url)
const __dirname = path.dirname(__filename)
const compat = new FlatCompat({
  baseDirectory: __dirname,
  recommendedConfig: js.configs.recommended,
  allConfig: js.configs.all,
})

export default [
  {
    ignores: ['*.cjs', '**/node_modules/', '**/dist/', '**/build/', '**/coverage/', '**/.idea', '**/.vscode', 'packages/**'],
  },
  ...compat.extends('@makerx/eslint-config'),
  {
    rules: {
      '@typescript-eslint/no-for-in-array': 'error',
      eqeqeq: 'error',
      '@typescript-eslint/consistent-type-imports': 'error',

      '@typescript-eslint/no-unused-vars': [
        'warn',
        {
          ignoreRestSiblings: true,
          args: 'none',
          destructuredArrayIgnorePattern: '^_',
          varsIgnorePattern: '(^_)',
          caughtErrorsIgnorePattern: '^_',
        },
      ],
      'no-unused-private-class-members': 'off',
    },
  },
  {
    files: ['tests/**/*.algo.ts'],
    rules: {
      '@typescript-eslint/no-unused-vars': 'off',
    },
  },
]



================================================
FILE: LICENSE
================================================
MIT License

Copyright (c) 2022 Algorand Foundation

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.



================================================
FILE: package.json
================================================
{
  "name": "@algorandfoundation/puya-ts",
  "version": "1.0.0",
  "description": "Compiles Algorand TypeScript into byte code which runs on the Algorand Virtual Machine (AVM)",
  "private": false,
  "types": "src/index.ts",
  "scripts": {
    "postinstall": "npm run algo-ts",
    "dev:examples": "tsx src/cli.ts examples --output-awst --output-awst-json",
    "dev:approvals": "tsx src/cli.ts tests/approvals --dry-run",
    "dev:expected-output": "tsx src/cli.ts tests/expected-output --dry-run",
    "dev:testing": "tsx src/cli.ts tests/approvals/arc4-encode-decode.algo.ts --no-output-source-map --log-level=info --out-dir out/unoptimized/[name] --optimization-level=0 --output-awst --output-awst-json --output-ssa-ir",
    "audit": "better-npm-audit audit",
    "audit-fix": "npm audit fix && cd packages/algo-ts && npm audit fix",
    "format": "prettier --write .",
    "lint": "eslint",
    "lint:fix": "eslint --fix",
    "build": "run-s build:*",
    "build:0-clean": "rimraf dist coverage",
    "build:1-lint": "eslint --max-warnings 0",
    "build:2-check-types": "tsc -p tsconfig.json",
    "build:3-build": "rollup -c --configPlugin typescript",
    "build:4-copy-pkg-json": "tstk copy-package-json -c",
    "build:5-copy-readme": "copyfiles ./README.md ./dist",
    "build:6-add-postinstall-script": "tsx src/util/add-postinstall-script.ts ./dist",
    "pretest": "tsx src/bin/download-puya-binary.ts",
    "test": "vitest run",
    "test:approvals": "vitest run tests/approvals.spec.ts",
    "test:expected-output": "vitest run tests/expected-output.spec.ts",
    "test:coverage": "vitest run --coverage",
    "test:ci": "vitest run --coverage --reporter junit --outputFile test-results.xml --reporter verbose",
    "install-local-packages": "npm run algo-ts",
    "watch-local-packages": "npm run algo-ts:build:watch",
    "algo-ts": "run-s algo-ts:*",
    "algo-ts:build": "cd packages/algo-ts && npm run build",
    "algo-ts:build:watch": "cd packages/algo-ts && npm run build:3-build:watch",
    "algo-ts:install": "npm i -S @algorandfoundation/algorand-typescript@./packages/algo-ts/dist",
    "npm-install-all": "cd packages/algo-ts && npm i && npm run build && cd ../../ && npm i",
    "script:code-gen": "tsx ./scripts/code-gen.ts",
    "script:documentation": "typedoc"
  },
  "author": "Algorand foundation",
  "license": "MIT",
  "devDependencies": {
    "@algorandfoundation/algokit-utils": "^9.0.0",
    "@commitlint/cli": "^19.8.0",
    "@commitlint/config-conventional": "^19.8.0",
    "@makerx/eslint-config": "4.2.0",
    "@makerx/prettier-config": "2.0.1",
    "@makerx/ts-toolkit": "^4.0.0-beta.24",
    "@rollup/plugin-commonjs": "28.0.3",
    "@rollup/plugin-json": "6.1.0",
    "@rollup/plugin-node-resolve": "16.0.1",
    "@rollup/plugin-typescript": "^12.1.2",
    "@tsconfig/node20": "20.1.5",
    "@types/argparse": "^2.0.17",
    "@types/cross-spawn": "^6.0.6",
    "@types/node": "22.13.14",
    "@types/tar": "^6.1.13",
    "@types/which": "^3.0.4",
    "@typescript-eslint/eslint-plugin": "8.28.0",
    "@typescript-eslint/parser": "8.28.0",
    "@vitest/coverage-v8": "3.0.9",
    "better-npm-audit": "3.11.0",
    "conventional-changelog-conventionalcommits": "^8.0.0",
    "copyfiles": "2.4.1",
    "cross-env": "^7.0.3",
    "eslint": "9.32.0",
    "eslint-config-prettier": "^10.1.1",
    "eslint-plugin-prettier": "^5.2.5",
    "npm-run-all2": "^8.0.4",
    "prettier": "3.5.3",
    "rimraf": "6.0.1",
    "rollup": "^4.37.0",
    "semantic-release": "^24.2.3",
    "tsx": "4.19.3",
    "typedoc": "^0.28.1",
    "typedoc-plugin-markdown": "^4.6.0",
    "typedoc-plugin-missing-exports": "^4.0.0",
    "vitest": "3.0.9"
  },
  "dependencies": {
    "@algorandfoundation/algorand-typescript": "file:packages/algo-ts/dist",
    "arcsecond": "^5.0.0",
    "argparse": "^2.0.1",
    "chalk": "^5.4.1",
    "change-case": "^5.4.4",
    "cross-spawn": "7.0.6",
    "glob": "^11.0.1",
    "minimatch": "^10.0.1",
    "polytype": "^0.17.0",
    "rxjs": "^7.8.2",
    "signal-exit": "^4.1.0",
    "tar": "^7.4.3",
    "tslib": "^2.8.1",
    "typescript": "^5.8.2",
    "upath": "^2.0.1",
    "vscode-languageserver": "^9.0.1",
    "vscode-languageserver-textdocument": "^1.0.12",
    "vscode-uri": "^3.1.0",
    "which": "^5.0.0",
    "zod": "^3.24.2"
  },
  "overrides": {
    "cross-spawn": "7.0.6",
    "npm": "10.9.1",
    "esbuild": "0.25.0"
  }
}



================================================
FILE: rollup.config.ts
================================================
import commonjs from '@rollup/plugin-commonjs'
import json from '@rollup/plugin-json'
import nodeResolve from '@rollup/plugin-node-resolve'
import typescript from '@rollup/plugin-typescript'
import type { RollupOptions } from 'rollup'

const config: RollupOptions = {
  input: {
    index: 'src/index.ts',
    cli: 'src/cli.ts',
    'bin/run-cli': 'src/bin/run-cli.ts',
    'bin/puyats-ls': 'src/bin/puyats-ls.ts',
    'bin/download-puya-binary': 'src/bin/download-puya-binary.ts',
  },
  output: [
    {
      dir: 'dist',
      format: 'es',
      exports: 'named',
      entryFileNames: '[name].mjs',
      preserveModules: false,
      sourcemap: true,
    },
  ],
  treeshake: {
    moduleSideEffects: true,
    propertyReadSideEffects: false,
  },
  external: [/node_modules/, /tslib/],
  plugins: [
    typescript({
      tsconfig: './tsconfig.build.json',
    }),
    commonjs(),
    nodeResolve(),
    json(),
  ],
  onwarn(log, defaultHandler) {
    if (log.code === 'CIRCULAR_DEPENDENCY') {
      throw new Error(log.message)
    } else {
      defaultHandler(log)
    }
  },
}

export default config



================================================
FILE: test.setup.ts
================================================
// Set max listeners to infinite for tests since vitest makes use of listeners per running test to detect errors
process.setMaxListeners(0)



================================================
FILE: tsconfig.build.json
================================================
{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "declarationDir": "./dist/",
    "noEmit": false,
    "declaration": true,
    "rootDir": "./src"
  },
  "include": ["src/**/*.ts"],
  "exclude": ["src/**/*.spec.ts", "src/**/*.test.ts", "src/**/tests/**", "packages/**/*.ts"]
}



================================================
FILE: tsconfig.json
================================================
{
  "extends": "@tsconfig/node20/tsconfig.json",
  "compilerOptions": {
    "lib": ["ESNext"],
    "noEmit": true,
    "target": "ES2023",
    "module": "ESNext",
    "moduleResolution": "Bundler",
    "resolveJsonModule": true,
    "esModuleInterop": true,
    "paths": {
      "@algorandfoundation/algorand-typescript": ["./packages/algo-ts/src"],
      "@algorandfoundation/algorand-typescript/*": ["./packages/algo-ts/src/*"]
    }
  },
  "include": [
    "src/**/*.ts",
    ".tstoolkitrc.ts",
    "scripts/**/*.ts",
    "examples/**/*.ts",
    "rollup.config.ts",
    "tests/**/*.ts",
    "vitest.config.mts",
    "eslint.config.mjs"
  ],
  "exclude": ["packages/**/*.ts"]
}



================================================
FILE: typedoc.json
================================================
{
  "$schema": "https://typedoc.org/schema.json",
  "entryPoints": [
    "./packages/algo-ts/src/index.ts",
    "./packages/algo-ts/src/op.ts",
    "./packages/algo-ts/src/itxn.ts",
    "./packages/algo-ts/src/gtxn.ts",
    "./packages/algo-ts/src/arc4/index.ts"
  ],
  "exclude": ["./packages/algo-ts/src/internal.ts"],
  "outputs": [
    {
      "name": "html",
      "path": "docs/_html"
    },
    {
      "name": "markdown",
      "path": "docs/_md"
    }
  ],
  "projectDocuments": ["docs/language-guide.md", "docs/cli.md", "docs/reference.md"],
  "plugin": ["typedoc-plugin-missing-exports", "typedoc-plugin-markdown"],
  "name": "Algorand TypeScript",
  "cleanOutputDir": true,
  "excludeReferences": true,
  "includeHierarchySummary": false,
  "readme": "docs/readme.md",
  "gitRevision": "main",
  "validation": {
    "notDocumented": true
  }
}



================================================
FILE: vitest.config.mts
================================================
import typescript from '@rollup/plugin-typescript'
import { defineConfig } from 'vitest/config'

export default defineConfig({
  resolve: {
    conditions: ['dev'],
  },
  esbuild: {},
  plugins: [
    typescript({
      target: 'ES2022',
      compilerOptions: {
        lib: ['ESNext'],
      },
    }),
  ],
  test: {
    setupFiles: 'test.setup.ts',
    globals: true,
    testTimeout: 30_000,
    exclude: ['packages/**', 'node_modules/**'],
  },
})



================================================
FILE: .editorconfig
================================================
[*]
charset = utf-8
insert_final_newline = true
end_of_line = lf
indent_style = space
indent_size = 2
tab_width = 2
max_line_length = 140
trim_trailing_whitespace = true



================================================
FILE: .nsprc
================================================
{
"1105444": {
  "notes": "There is currently (2025-06-13) no available fix. brace-expansion is a bundled transitive dependency of npm (semantic-release -> npm -> (bundled) minimatch -> brace-expansion). Even the current latest version of npm (11.4.2) still bundles a vulnerable version of brace-expansion through minimatch. All of this means that we can't fix this through overrides (bundled) and we can't upgrade semantic-release to indirectly upgrade npm (because all current versions of npm bundle a vulnerable version of brace-expansion)."
  }
}



================================================
FILE: .prettierignore
================================================
# don't ever format node_modules
node_modules
# don't lint format output (make sure it's set to your correct build folder name)
dist
build
# don't format nyc coverage output
coverage
# don't format generated types
**/generated/types.d.ts
**/generated/types.ts
# don't format ide files
.idea



================================================
FILE: .prettierrc.cjs
================================================
module.exports = {
  ...require('@makerx/prettier-config'),
}



================================================
FILE: .releaserc.json
================================================
{
  "branches": [
    {
      "name": "main",
      "prerelease": "beta"
    },
    {
      "name": "release"
    },
    {
      "name": "alpha",
      "prerelease": "alpha"
    }
  ],
  "plugins": [
    [
      "@semantic-release/commit-analyzer",
      {
        "preset": "conventionalcommits",
        "releaseRules": [
          {
            "type": "build",
            "release": "patch"
          },
          {
            "type": "chore",
            "release": "patch"
          },
          {
            "type": "refactor",
            "release": "patch"
          }
        ]
      }
    ],
    [
      "@semantic-release/release-notes-generator",
      {
        "preset": "conventionalcommits",
        "presetConfig": {
          "types": [
            {
              "type": "feat",
              "section": "Features"
            },
            {
              "type": "fix",
              "section": "Bug Fixes"
            },
            {
              "type": "build",
              "section": "Dependencies and Other Build Updates",
              "hidden": false
            }
          ]
        }
      }
    ],
    [
      "@semantic-release/npm",
      {
        "npmPublish": false,
        "pkgRoot": "artifacts/puya-ts"
      }
    ],
    "@semantic-release/github"
  ]
}



================================================
FILE: .tstoolkitrc.ts
================================================
import type { TsToolkitConfig } from '@makerx/ts-toolkit'

const config: TsToolkitConfig = {
  packageConfig: {
    srcDir: 'src',
    exportTypes: 'module',
    outDir: 'dist',
    moduleType: 'module',
    exports: {
      '.': 'index.ts',
      './cli': 'cli.ts',
    },
    bin: {
      'puya-ts': 'bin/run-cli.ts',
      puyats: 'bin/run-cli.ts',
      'puyats-ls': 'bin/puyats-ls.ts',
      'download-puya-binary': 'bin/download-puya-binary.ts',
    },
    customSections: ['bundledDependencies'],
  },
}
export default config



================================================
FILE: docs/readme.md
================================================
# Algorand TypeScript

Algorand TypeScript is a partial implementation of the TypeScript programming language that runs on the Algorand Virtual Machine (AVM). It includes a statically typed framework for development of Algorand smart contracts and logic signatures, with TypeScript interfaces to underlying AVM functionality that works with standard TypeScript tooling.

It maintains the syntax and semantics of TypeScript such that a developer who knows TypeScript can make safe assumptions
about the behaviour of the compiled code when running on the AVM. Algorand TypeScript is also executable TypeScript that can be run
and debugged on a Node.js virtual machine with transpilation to EcmaScript and run from automated tests.

Algorand TypeScript is compiled for execution on the AVM by PuyaTs, a TypeScript frontend for the [Puya](https://github.com/algorandfoundation/puya) optimising compiler that ensures the resulting AVM bytecode execution semantics that match the given TypeScript code. PuyaTs produces output that is directly compatible with AlgoKit typed clients to make deployment and calling easy.

- [Language Guide](./language-guide.md)
- [CLI Guide](./cli.md)
- [Reference docs](./reference.md)



================================================
FILE: docs/abi-routing.md
================================================
---
title: ABI Routing
---

# ABI Routing

Contracts in Algorand are created, called, updated, and deleted using [Application Call](https://dev.algorand.co/concepts/transactions/types/#application-call-transaction) transactions. That transaction type has a number of fields, with various ones being required depending on the type of call being made. This document aims to describe some of these scenarios and how they interact with an Algorand TypeScript smart contract.

## Approval and Clear State Programs

An Application Call Transaction passes or fails based on the result of running one of the programs associated with that application. The [OnComplete](https://dev.algorand.co/concepts/smart-contracts/avm/#oncomplete) (`apan`) field is used to decide which _program_ is run. If the on completion action is ClearState (`3`), the Clear State Program is run - for all other on complete actions the Approval Program is run.

### Approval Program

If the program runs without error and returns a non-zero result, the transaction is allowed (though another transaction in the group may cause the whole group to fail as transaction groups are all or nothing).

### Clear State Program

A transaction which invokes the clear state program will be allowed even if the logic errors.

## Application creating

The Application ID (`apid`) field determines if this is an application create call or not. If it is set to `0` then the call will create a new application using the program bytes attached to this transaction. If it is set to any other number, then the call will be processed by the application on the target network which has the matching id. If such an application does not exist, the transaction will fail. It is worth noting here that the same contract can be deployed to multiple networks, or multiple times to the same network; and it will receive a different application id.

If a new application is created, the transaction confirmation response will contain the id of the application.

## On Completion Actions

[On completion actions](https://dev.algorand.co/concepts/smart-contracts/avm/#oncomplete) are used for various application lifecycle events. They can be best interpreted as "The action that will have taken place upon completion of the processing of that transaction" (though it varies between these actions whether they occur before or after running the associated program).

## ABI method selector vs. Bare methods

[ARC004](https://github.com/algorandfoundation/ARCs/blob/main/ARCs/arc-0004.md) describes, among other things, a standard for routing application call transactions to specific methods of a contract. The approach is to use the first argument from the transaction's app args array (`apaa`) as a method selector. A method selector is defined as the first 4 bytes of the sha-512/256 hash of the method's arc4 signature. For example the method `sayHello(name: string, age: uint64): string` would have an arc4 signature of `sayHello(string,uint64)string`. Essentially the parameter names are ignored and we concatenate the param types. The hash of this string is `6ce0f4b5012a671bbe1b8355fe8f09f4aaa3b950115db8c71ee26162ecee8b9e` and the method selector is made of the first 4 bytes of this sequence. ie. `6ce0f4b5`.

When a program processes an application call it should check the value of the first application arg. If there are no application args, then this considered a `bare` request, otherwise the method with a matching method selector should be invoked and the remainder of the application args should be forwarded to that method.

## Pulling it all together

In Algorand TypeScript, if you choose to extend `BaseContract` directly, then the only routing provided will be to forward clear state transactions to the clear state program and all other transactions to the approval program.

If you choose to extend `Contract` however, there are a number of constructs used to determine which method will ultimately handle a given transaction. Clear state transactions are still handled by implementing a clear state program. A default implementation of this method is provided by the base class which always returns `true`. For all other transactions, a combination of the application creating status, on completion action, and method selector will be used to determine which method handles a transaction.

### Handling on create

The `abimethod` and `baremethod` decorators accept an `onCreate` configuration value of `"require"`, `"allow"`, or `"disallow"`. A method with `onCreate: "require"` will only be callable when the application is being created (ie. `apid` === 0).`onCreate: "disallow"` will only be callable when the application is NOT being created (ie. `apid` !== 0). `onCreate: "allow"` means the method CAN be called when the application is being created, but it is not _required_. The default value for this is `"disallow"`.

### Handling on completion actions

The `abimethod` and `baremethod` decorators accept an `allowActions` configuration value which can be one or more on completion actions. A method will be callable if the current transaction's on complete action matches one of the listed actions. If the method selector matches a particular method and that method does not list that on completion action, the transaction will be rejected. The default value for this is `NoOp`



================================================
FILE: docs/cli.md
================================================
---
title: Compiler CLI Guide
---

# Puya TS Cli

The puya-ts cli is a tool for compiling Algorand TypeScript code into artifacts which can be used to deploy smart contracts and logic signatures on the Algorand Virtual Machine (AVM). At a high level these include:

| Output                      | Description                                                                                                                                                                                                                                                           |
| --------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Teal code (`*.teal`)        | Teal is a low level, human readable stack based language which 'runs' on the AVM                                                                                                                                                                                      |
| Bytecode (`*.bin`)          | Bytecode, in this context, is a binary representation of teal code - and is what the AVM actually interprets                                                                                                                                                          |
| ARC32 Spec (`*.arc32.json`) | A specification file which describes an ARC4 contract and how to interact with it. It also includes an encoded copy of the teal approval and clear state programs of the contract. See [ARC32](https://github.com/algorandfoundation/ARCs/blob/main/ARCs/arc-0032.md) |
| ARC56 Spec (`*.arc56.json`) | A more recently defined specification file which describes an ARC4 contract and how to interact with it. See [ARC56](https://github.com/algorandfoundation/ARCs/blob/main/ARCs/arc-0056.md)                                                                           |

## Installation

### Puya-TS

Puya-TS can be installed from npm using the command

```shell
npm i @algorandfoundation/puya-ts [-g]
```

If installed globally (`-g`) it should be available on your PATH anywhere, otherwise you may need to use `npx puya-ts` to run it, or create an npm script.

```json
{
  "scripts": {
    "build": "puya-ts ..."
  }
}
```

IDEs such as Webstorm automatically add the local `node_modules/.bin` directory to the PATH of the built-in terminal window, meaning `puya-ts ...` should work without `npx` in that window.

You can verify a successful installation by running the command with no args

```shell
> puya-ts
usage: puya-ts [-h] [--version] {build} ...

positional arguments:
  ...
```

### Puya

Puya-ts is only the front end component of the compiler. After parsing and converting TypeScript into a common AST known as AWST, the remainder of the compilation is passed onto the Puya backend compiler. Puya is released as a binary on the Puya GitHub [repository](https://github.com/algorandfoundation/puya).

Currently, Puya binaries are available for:

- Linux (x64 and ARM)
- MacOS (x64 and Apple Silicon)
- Windows (x64 and ARM\*)

\*: ARM compatibility is supplied by Windows x64 emulation.

If your system is supported, puya-ts will automatically download the appropriate binary for your system.

### Puya (manual installation)

This section is relevant if your platform is not supported by the Puya binaries, or you need to run a custom version of Puya (eg. A pre-release version).

The most convenient way to install Puya manually is using `pipx`. You will require Python 3.12+ and to have pipx available on your path for the following to work.

```shell
pipx install puyapy
```

The latest puya-ts will generally target the latest puya version, but if you have issues and require a specific older version installed the command would look like:

```shell
pipx install puyapy==4.2.1 --force
```

`--force` may or may not be required depending on if you already have a version installed.

You can verify a successful installation by running the `puya` command with no args.

```shell
> puya
usage: puya [-h] [--version] [--log-level {notset,debug,info,warning,error,critical}] [--log-format {default,json}] --options OPTIONS --awst AWST [--source-annotations SOURCE_ANNOTATIONS]
puya: error: the following arguments are required: --options, --awst
```

After confirming that Puya is installed, you can pass the Puya path to `puya-ts` using the `--puya-path` option.

```shell
puya-ts build examples --output-awst --output-awst-json --puya-path puya
```

If you don't wish to install Puya using `pipx`, you can build the Puya binary yourself from source. Refer to the [Puya README](https://github.com/algorandfoundation/puya) for more information. Once you have a binary, you can pass the path to it using the `--puya-path /path/to/binary/puya` option.

## Commands

### Version

Shows the currently installed version of puya-ts, its targeted puya version, and supported AVM versions

```shell
puya-ts --version
```

### Build

Builds a smart contract or logic signature. This command takes one or more files or directories and will attempt to compile any matching `*.algo.ts` files, outputting artifacts for any smart contracts and logic signatures found within.

```shell
puya-ts build smart_contracts

puya-ts build smart_contracts/your-contract.algo.ts

puya-ts build smart_contracts/*
```

#### Arguments

Flag arguments are true when used in the base form `--my-flag` but can be negated by using the format `--no-my-flag`. The latter is necessary to disable options which are on by default.

| Arg                            | Type                                                       | Required                     | Description                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| ------------------------------ | ---------------------------------------------------------- | ---------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `PATHS`                        | String[]                                                   | Yes                          | The paths to be compiled. Can be exact path to a `*.algo.ts` contract file, a directory, or a path including wildcards. All subfolders in a directory will be searched for `*.algo.ts` files.                                                                                                                                                                                                                                                        |
| `--log-level`                  | Enum (error,info,warning,debug,critical)                   | No (default: info)           | The minimum log level to output to the console.                                                                                                                                                                                                                                                                                                                                                                                                      |
| `--out-dir`                    | String                                                     | No (default: 'out')          | The directory in which to write build artifacts. If absolute, artifacts will be written under sub-directories relative to the input PATH they were discovered by. If relative, this directory will be created relative to the input PATH. Artifacts will be written under sub-directories relative to the input PATH they were discovered by. Out directory can contain the placeholder `[name]` which will be replaced with the contract file name. |
| `--optimization-level`         | Enum (0,1,2)                                               | No (default: 1)              | Determines which optimizations are made to the compiled code, 0 None, 1 Normal, 2 Intensive                                                                                                                                                                                                                                                                                                                                                          |
| `--debug-level`                | Enum (0,1,2)                                               | No (default 1)               | Determines what debug information is included in the compiled code. 0 None, 1 Source code annotations, 2 Reserved for future use                                                                                                                                                                                                                                                                                                                     |
| `--dry-run`                    | Flag                                                       | No (default false)           | Skip `puya` compilation, and only perform the TypeScript parsing and compilation to AWST                                                                                                                                                                                                                                                                                                                                                             |
| `--skip-version-check`         | Flag                                                       | No (default false)           | Don't verify the installed version of `puya` matches the one targeted by `puya-ts` before invoking compilation.                                                                                                                                                                                                                                                                                                                                      |
| `--target-avm-version`         | Integer                                                    | No (default current version) | Which AVM version to target for compilation output of contracts which do not explicitly identify their target version. Will default to current version in `mainnet` (with a small lag). Number must be a supported version of the compiler.                                                                                                                                                                                                          |
| `--cli-template-definition`    | KeyValuePair[]                                             | No                           | A list of template variable definitions which will be used to replace place holders in the compiled output. Values should be in the format MY_VAR_NAME=123 where the variable name does not include the template variable prefix. Binary values can be specified in hex strings using MY_VAR=0x1234FF                                                                                                                                                |
| `--template-vars-prefix`       | String                                                     | No (default 'TMPL\_')        | The prefix used by template variables in the compilation targets.                                                                                                                                                                                                                                                                                                                                                                                    |
| `--locals-coalescing-strategy` | Enum (root_operand,root_operand_excluding_args,aggressive) | No (default root_operand)    | Determines the out-of-ssa variable name coalescing strategy used by the compiler. root_operand coalesces based on the original variable name, root_operand_excluding_args is the same but won't coalesce subroutine arguments whilst aggressive will attempt to minimise the number of local variables used regardless of name or type - based only on variable lifetimes. The strategy used can affect output code legibility and size.             |
| `--output-awst`                | Flag                                                       | No (default false)           | Output a human readable representation of the AWST generated by compilation.                                                                                                                                                                                                                                                                                                                                                                         |
| `--output-awst-json`           | Flag                                                       | No (default false)           | Output a json encoded representation of the AWST generated by compilation                                                                                                                                                                                                                                                                                                                                                                            |
| `--output-teal`                | Flag                                                       | No (default true)            | Output `*.approval.teal` and `*.clear.teal` files for smart contracts and `*.teal` files for logic signatures                                                                                                                                                                                                                                                                                                                                        |
| `--output-source-map`          | Flag                                                       | No (default true)            | Output debug source maps                                                                                                                                                                                                                                                                                                                                                                                                                             |
| `--output-arc32`               | Flag                                                       | No (default true)            | Output an ARC32 compliant spec file for ARC4 smart contracts.                                                                                                                                                                                                                                                                                                                                                                                        |
| `--output-arc56`               | Flag                                                       | No (default true)            | Output an ARC56 compliant spec file for ARC4 smart contracts.                                                                                                                                                                                                                                                                                                                                                                                        |
| `--output-bytecode`            | Flag                                                       | No (default false)           | Output `*.approval.bin` and `*.clear.bin` files for smart contracts and `*.bin` files for logic signatures. This will require any template variables to have a value                                                                                                                                                                                                                                                                                 |
| `--output-ssa-ir`              | Flag                                                       | No (default false)           | Output a representation of the SSA IR nodes for advanced debugging purposes                                                                                                                                                                                                                                                                                                                                                                          |
| `--output-destructured-ir`     | Flag                                                       | No (default false)           | Output a representation of the destructured (out of ssa) IR nodes for advanced debugging purposes                                                                                                                                                                                                                                                                                                                                                    |
| `--output-optimization-ir`     | Flag                                                       | No (default false)           | Output a representation of the IR nodes after each optimization round for advanced debugging purposes                                                                                                                                                                                                                                                                                                                                                |
| `--output-memory-ir`           | Flag                                                       | No (default false)           | Output a representation of the Memory IR nodes for advanced debugging purposes                                                                                                                                                                                                                                                                                                                                                                       |
| `--puya-path`                  | String                                                     | No                           | The Puya path used for compilation. If not provided, puya-ts will attempt to download a compatible binary for your platform from the puya GitHub releases page.                                                                                                                                                                                                                                                                                      |



================================================
FILE: docs/guiding-principles.md
================================================
---
title: Guiding Principals
---

# Guiding Principles

## Familiarity

Where the base language (TypeScript/EcmaScript) doesn't support a given feature natively (eg. unsigned fixed size integers),
prior art should be used to inspire an API that is familiar to a user of the base language and transpilation can be used to
ensure this code executes correctly.

## Leveraging TypeScript type system

TypeScript's type system should be used where ever possible to ensure code is type safe before compilation to create a fast
feedback loop and nudge users into the [pit of success](https://blog.codinghorror.com/falling-into-the-pit-of-success/).

## TEALScript compatibility

[TEALScript](https://github.com/algorandfoundation/tealscript/) is an existing TypeScript-like language to TEAL compiler however the source code is not executable TypeScript, and it does not prioritise semantic compatibility. Wherever possible, Algorand TypeScript should endeavour to be compatible with existing TEALScript contracts and where not possible migratable with minimal changes.

## Algorand Python

[Algorand Python](https://algorandfoundation.github.io/puya/) is the Python equivalent of Algorand TypeScript. Whilst there is a primary goal to produce an API which makes sense in the TypeScript ecosystem, a secondary goal is to minimise the disparity between the two APIs such that users who choose to, or are required to develop on both platforms are not facing a completely unfamiliar API.

# Architecture decisions

As part of developing Algorand TypeScript we are documenting key architecture decisions using [Architecture Decision Records (ADRs)](https://adr.github.io/). The following are the key decisions that have been made thus far:

- [2024-05-21: Primitive integer types](./architecture-decisions/2024-05-21_primitive-integer-types.md)
- [2024-05-21: Primitive byte and string types](./architecture-decisions/2024-05-21_primitive-bytes-and-strings.md)



================================================
FILE: docs/language-guide.md
================================================
---
title: Algorand TypeScript Language Guide
children:
  - ./lg-program-structure.md
  - ./lg-types.md
  - ./lg-storage.md
  - ./lg-ops.md
  - ./lg-itxns.md
---

# Algorand TypeScript Language Guide

Algorand TypeScript is a partial implementation of the TypeScript programming language that runs on the Algorand Virtual Machine (AVM). It defines a library of types, classes and functions to facilitate the development of smart contracts and logic signatures for the Algorand blockchain.

As a partial implementation of the TypeScript programming language, it maintains the syntax and semantics of TypeScript. The subset that is implemented may change over time, but it will never be a full implementation due to the restricted nature of the AVM as an execution environment. For example the `async` and `await` keywords do not make sense in a synchronous execution environment, and `try`/`catch` blocks are not possible as the AVM does not provide a mechanism for recovering from errors.

Being a partial implementation of TypeScript means that existing developer tooling such as syntax highlighting, linting, type checking, and auto formatters all work out of the box. Maintaining semantic compatability with the TypeScript language means that it is possible to reason about how an expression written in TypeScript will execute on the AVM. As an example, in the expression `a() || b()`, the function `b` will not execute if the function `a` returns a truthy value. Because we maintain this semantic compatability it is also possible to execute Algorand TypeScript locally in a NodeJs environment for testing and debugging purposes to gain a degree of confidence that the code will perform the same way on the AVM.

Having said that, there are some major limitations to defining a language and programming interface for authoring Algorand smart contracts in TypeScript which is ultimately restricted by what is presently possible in EcmaScript. This presented some tradeoffs between maintaining absolute semantic compatibility with TypeScript, and having an unwieldy developer experience; versus a solution that is not strictly executable TypeScript, but is something that _looks_ familiar to a TypeScript developer and the execution can be emulated by transpilation of the source code prior to execution in Node.

A concrete example of this is that EcmaScript (and hence TypeScript) does not support operator overloading (and the [proposal](https://github.com/tc39/proposal-operator-overloading) to add support for this seems dead in the water). As a result, it is not possible to introduce new numeric types in TypeScript which work with native math operators such as `+` and `-`, and existing numeric types (`number` and `BigInt`) in EcmaScript are not compatible with the unsigned integers used by the AVM.

Another example is the equality operator `===`, in EcmaScript this always operates on reference equality for non-primitive types. In Algorand TypeScript, reference equality is not a helpful construct - particularly for introduced types that present as a primitive (eg. binary data). It is beneficial to sacrifice absolute semantic compatability here for the convenience of being able to compare binary data with the `===` operator (and similarly, to be able to use binary values in `switch`/`case` expressions) as we are able to use a transpiler to have the TypeScript code execute on a compatible fashion in Node.

EcmaScript is extremely liberal in its type system when it comes to type coercion in comparison between types. Algorand TypeScript aims to be more restrictive in this regard as this behaviour can often lead to unintended bugs. For example, the comparison between unrelated types in EcmaScript will simply return `false` (or something [barely predicable](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Equality) if using the `==` operator). Algorand TypeScript will instead error as the comparison is likely a bug.

If you are interested in learning about the design of Algorand TypeScript, you can see our [Guiding Principles](./guiding-principles.md) for more detail including the Architectural Decision Records (ADRs) which got us here.

## Table of Contents

- [Program Structure](lg-program-structure.md)
- [Basic Types](lg-types.md)
- [Storage](lg-storage.md)
- [Ops](lg-ops.md)
- [Inner Transactions](lg-itxns.md)



================================================
FILE: docs/lg-itxns.md
================================================
---
title: Inner Transactions
---

# Inner Transactions

## Basic API

The `itxn` namespace exposes types for constructing inner transactions. There is a factory method for each transaction type which accepts an object containing fields specific to the transaction type. The factories then return a `*ItxnParams` object where `*` is the transaction type (eg. `PaymentItxnParams`). The params object has a `submit` to submit the transaction immediately, a `set` method to make further updates to the fields, and a `copy` method to clone the params object.

To submit multiple transactions in a group - use the `itxn.submitGroup` function.

```ts
import { itxn, Global, log } from '@algorandfoundation/algorand-typescript'

const assetParams = itxn.assetConfig({
  total: 1000,
  assetName: 'AST1',
  unitName: 'unit',
  decimals: 3,
  manager: Global.currentApplicationAddress,
  reserve: Global.currentApplicationAddress,
})

const asset1_txn = assetParams.submit()
log(asset1_txn.createdAsset.id)
```

Both the `submitGroup` and `params.submit()` functions return a `*InnerTxn` object per input params object which allow you to read application logs or created asset/application ids. There are restrictions on accessing these properties which come from the current AVM implementation. The restrictions are detailed below.

## Restrictions

The `*ItxnParams` objects cannot be passed between subroutines, or stored in arrays or application state. This is because they contain up to 20 fields each with many of the fields being of variable length. Storing this object would require encoding it to binary and would be very expensive and inefficient.

Submitting dynamic group sizes with `submitGroup` is not supported as the AVM is quite restrictive in how transaction results are accessed. [gitxn](https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/v11/#gitxn) op codes require transaction indexes to be referenced with a compile time constant value and this is obviously not possible with dynamic group sizes. An alternative API may be offered in the future which allows dynamic group sizes with the caveat of not having access to the transaction results.

## Pre-compiled contracts

If your contract needs to deploy other contracts then it's likely you will need access to the compiled approval and clear state programs. The `compile` method takes a contract class and returns the compiled byte code along with some basic schema information.

```ts
import { itxn, compile } from '@algorandfoundation/algorand-typescript'
import { encodeArc4, methodSelector } from '@algorandfoundation/algorand-typescript/arc4'

const compiled = compile(Hello)

const helloApp = itxn
  .applicationCall({
    appArgs: [methodSelector(Hello.prototype.create), encodeArc4('hello')],
    approvalProgram: compiled.approvalProgram,
    clearStateProgram: compiled.clearStateProgram,
    globalNumBytes: compiled.globalBytes,
  })
  .submit().createdApp
```

If the contract you are compiling makes use of template variables - these will need to be resolved to a constant value.

```ts
const compiled = compile(HelloTemplate, { templateVars: { GREETING: 'hey' } })
```

## Strongly typed contract to contract

Assuming the contract you wish to compile extends the ARC4 `Contract` type, you can make use of `compileArc4` to produce a contract proxy object that makes it easy to invoke application methods with
compile time type safety.

```ts
import { assert, itxn } from '@algorandfoundation/algorand-typescript'
import { compileArc4 } from '@algorandfoundation/algorand-typescript/arc4'

const compiled = compileArc4(Hello)

const app = compiled.call.create({
  args: ['hello'],
}).itxn.createdApp

const result = compiled.call.greet({
  args: ['world'],
  appId: app,
}).returnValue
assert(result === 'hello world')
```

The proxy will automatically include approval and clear state program bytes + schema properties from the compiled contract, but these can also be overridden if required.

## Strongly typed ABI calls

If your use case does not require deploying another contract, and instead you are just calling methods then the `abiCall` method will allow you to do this in a strongly typed manner provided you have at bare minimum a compatible stub implementation of the target contract.

**A sample stub implementation**

```ts
export abstract class HelloStubbed extends Contract {
  // Make sure the abi decorator matches the target implementation
  @abimethod()
  greet(name: string): string {
    // Stub implementations don't need method bodies, as long as the type information is correct
    err('stub only')
  }
}
```

**Invocation using the stub**

```ts
const result3 = abiCall(HelloStubbed.prototype.greet, {
  appId: app,
  args: ['stubbed'],
}).returnValue
assert(result3 === 'hello stubbed')
```



================================================
FILE: docs/lg-ops.md
================================================
---
title: AVM Operations
---

# AVM Operations

Algorand TypeScript allows you to express [every op code the AVM has available](https://dev.algorand.co/reference/algorand-teal/opcodes/) excluding those that manipulate the stack or control execution as these would interfere with the compiler. These are all exported from the [ops module](api/op/README.md). It is possible to import ops individually or via the entire namespace.

```ts
// Import op from module root
import { assert, Contract, op } from '@algorandfoundation/algorand-typescript'
// Import whole module from ./op
import * as op2 from '@algorandfoundation/algorand-typescript/op'
// Import individual ops
import { bzero } from '@algorandfoundation/algorand-typescript/op'

class MyContract extends Contract {
  test() {
    const a = bzero(8).bitwiseInvert()
    const b = op2.btoi(a)
    assert(b === 2 ** 64 - 1)

    const c = op.shr(b, 32)

    assert(c === 2 ** 32 - 1)
  }
}
```

## Txn, Global, and other Enums

Many of the AVM ops which take an enum argument have been abstracted into a static type with a property or function per enum member

```ts
import { Contract, Global, log, Txn } from '@algorandfoundation/algorand-typescript'
import { AppParams } from '@algorandfoundation/algorand-typescript/op'

class MyContract extends Contract {
  test() {
    log(Txn.sender)
    log(Txn.applicationArgs(0))
    log(Global.groupId)
    log(Global.creatorAddress)
    log(...AppParams.appAddress(123))
  }
}
```



================================================
FILE: docs/lg-program-structure.md
================================================
---
title: Program Structure
---

# Program Structure

An Algorand TypeScript program is declared in a TypeScript module with a file extension of `.algo.ts`. Declarations can be split across multiple files, and types can be imported between these files using standard TypeScript import statements. The commonjs `require` function is not supported, and the asynchronous `import(...)` expression is also not supported as imports must be compile-time constant.

Algorand TypeScript constructs and types can be imported from the `@algorandfoundation/algorand-typescript` module, or one of its submodules. Compilation artifacts do not need to be exported unless you require them in another module; any non-abstract contract or logic signature discovered in your entry files will be output. Contracts and logic signatures discovered in non-entry files will not be output.

## Constants

Constants declared at the module level have a compile-time constant value or a template variable. Some basic expressions are supported so long as they result in a compile time constant.

```ts
import { uint64 } from '@algorandfoundation/algorand-typescript'

const a: uint64 = 1000
const b: uint64 = 2000
const c: uint64 = a * b
```

## Free Subroutines

Free subroutines can be declared at the module level and called from any contract, logic signature, or other subroutine. Subroutines do not have any compiler output on their own unless they are called by a contract or logic signature.

```ts
import { uint64 } from '@algorandfoundation/algorand-typescript'

function add(a: uint64, b: uint64): uint64 {
  return a + b
}
```

## Contracts

A contract in Algorand TypeScript is defined by declaring a class which extends the `Contract`, or `BaseContract` types exported by `@algorandfoundation/algorand-typescript`. See [ABI routing](./abi-routing.md) docs for more on the differences between these two options.

### ARC4 Contract

Contracts which extend the `Contract` type are ARC4 compatible contracts. Any `public` methods on the class will be exposed as ABI methods, callable from other contracts and off-chain clients. `private` and `protected` methods can only be called from within the contract itself, or its subclasses. Note that TypeScript methods are `public` by default if no access modifier is present. A contract is considered valid even if it has no methods, though its utility is questionable.

```ts
import { Contract } from '@algorandfoundation/algorand-typescript'

class DoNothingContract extends Contract {}

class HelloWorldContract extends Contract {
  sayHello(name: string) {
    return `Hello ${name}`
  }
}
```

### Contract Options

The `contract` decorator allows you to specify additional options and configuration for a contract such as which AVM version it targets, which scratch slots it makes use of, or the total global and local state which should be reserved for it. It should be placed on your contract class declaration.

```ts
import { Contract, contract } from '@algorandfoundation/algorand-typescript'

@contract({ name: 'My Contracts Name', avmVersion: 11, scratchSlots: [1, 2, 3], stateTotals: { globalUints: 4, localUints: 0 } })
class MyContract extends Contract {}
```

### Application Lifecycle Methods and other method options

There are two approaches to handling application lifecycle events. By implementing a well-known method (convention based), or by using decorators (decorator based). It is also possible to use a combination of the two however decorators must not conflict with the implied behaviour of a well-known method.

#### Convention based

Application lifecycle methods can be handled by a convention of well-known method names. The easiest way to discover these method names is to `implement` the interface `ConventionalRouting` from the `@algorandfoundation/algorand-typescript/arc4` module.

- Explicit implementation of this interface is not required, but it will assist in auto complete suggestions for supported methods.
- Only implement the methods your application should support. I.e. don't implement `updateApplication` if your application should not be updatable.
- 'Well-known' methods can receive arguments and return values

```ts
import type { bytes, uint64 } from '@algorandfoundation/algorand-typescript'
import { Contract, log } from '@algorandfoundation/algorand-typescript'
import type { ConventionalRouting } from '@algorandfoundation/algorand-typescript/arc4'

export class TealScriptConventionsAlgo extends Contract implements ConventionalRouting {
  /**
   * The function to invoke when closing out of this application
   */
  closeOutOfApplication(arg: uint64) {
    return arg
  }

  /**
   * The function to invoke when creating this application
   */
  createApplication(value: bytes) {
    log(value)
  }

  /**
   * The function to invoke when deleting this application
   */
  deleteApplication() {}

  /**
   * The function to invoke when opting in to this application
   */
  optInToApplication() {}

  /**
   * The function to invoke when updating this application
   */
  updateApplication() {}

  /**
   * Any public method that is not one of the 'well-known' names exhibit the default behaviour detailed in
   * the next section.
   */
  customMethod() {}
}
```

#### Decorator based

The default `OnCompletionAction` (OCA) for public methods is `NoOp`. To change this, a method should be decorated with the `abimethod` or `baremethod` decorators. These decorators can also be used to change the exported name of the method, determine if a method should be available on application create or not, and specify default values for arguments. See the [ABI Routing guide](./abi-routing.md) for more details on how these various options work together.

```ts
import type { uint64 } from '@algorandfoundation/algorand-typescript'
import { abimethod, baremethod, Contract, Uint64 } from '@algorandfoundation/algorand-typescript'

class AbiDecorators extends Contract {
  @abimethod({ allowActions: 'NoOp' })
  public justNoop(): void {}

  @abimethod({ onCreate: 'require' })
  public createMethod(): void {}

  @abimethod({ allowActions: ['NoOp', 'OptIn', 'CloseOut', 'DeleteApplication', 'UpdateApplication'] })
  public allActions(): void {}

  @abimethod({ readonly: true, name: 'overrideReadonlyName' })
  public readonly(): uint64 {
    return 5
  }

  @baremethod()
  public noopBare() {}
}
```

### Constructor logic and implicit create method

If a contract does not define an explicit create method (ie. `onCreate: 'allow'` or `onCreate: 'require'`) then the compiler will attempt to add a `bare` create method with no implementation. Without this, you would not be able to deploy the contract.

Contracts which define custom constructor logic will have this logic executed once on application create immediately before any other logic is executed.

```ts
export class MyContract extends Contract {
  constructor() {
    super()
    log('This is executed on create only')
  }
}
```

### Custom approval and clear state programs

The default implementation of a clear state program on a contract is to just return `true`, custom logic can be added by overriding the base implementation

The default implementation of an approval program on a contract is to perform ABI routing. Custom logic can be added by overriding the base implementation. If your implementation does not call `super.approvalProgram()` at some point, ABI routing will not function.

```ts
class Arc4HybridAlgo extends Contract {
  override approvalProgram(): boolean {
    log('before')
    const result = super.approvalProgram()
    log('after')
    return result
  }

  override clearStateProgram(): boolean {
    log('clearing state')
    return true
  }

  someMethod() {
    log('some method')
  }
}
```

### Application State

Application state for a contract can be defined by declaring instance properties on a contract class using the relevant state proxy type. In the case of `GlobalState` it is possible to define an `initialValue` for the field. The logic to set this initial value will be injected into the contract's constructor. Global and local state keys default to the property name, but can be overridden with the `key` option. Box proxies always require an explicit key.

```ts
import { Contract, uint64, bytes, GlobalState, LocalState, Box } from '@algorandfoundation/algorand-typescript'

export class ContractWithState extends Contract {
  globalState = GlobalState<uint64>({ initialValue: 123, key: 'customKey' })
  localState = LocalState<string>()
  boxState = Box<bytes>({ key: 'boxKey' })
}
```

### Custom approval and clear state programs

Contracts can optional override the default implementation of the approval and clear state programs. This covers some more advanced scenarios where you might need to perform logic before or after an ABI method; or perform custom method routing entirely. In the case of the approval program, calling `super.approvalProgram()` will perform the default behaviour of ARC4 routing. Note that the 'Clear State' action will be taken regardless of the outcome of the `clearStateProgram`, so care should be taken to ensure any clean up actions required are done in a way which cannot fail.

```ts
import { Contract, log } from '@algorandfoundation/algorand-typescript'

class Arc4HybridAlgo extends Contract {
  override approvalProgram(): boolean {
    log('before')
    const result = super.approvalProgram()
    log('after')
    return result
  }

  override clearStateProgram(): boolean {
    log('clearing state')
    return true
  }

  someMethod() {
    log('some method')
  }
}
```

### Multi-inheritance

Javascript does not support multi-inheritance natively, but it is a useful feature for composing a larger contract out of several smaller ones. Algorand TypeScript supports multi-inheritance via the [Polytype](https://github.com/fasttime/Polytype) package and the compiled code matches the semantics of Polytype at runtime. Method resolution order is _depth first_ meaning the entire prototype hierarchy of the _first_ base type will be walked before moving onto the _second_ base type and so on.

```ts
import type { uint64 } from '@algorandfoundation/algorand-typescript'
import { Contract, GlobalState } from '@algorandfoundation/algorand-typescript'
import { classes } from 'polytype'

class StoreString extends Contract {
  stringStore = GlobalState<string>()

  setStore(value: string) {
    this.stringStore.value = value
  }
}

class StoreUint64 extends Contract {
  uint64Store = GlobalState<uint64>()

  setStore(value: uint64) {
    this.uint64Store.value = value
  }
}

class StoreBoth extends classes(StoreString, StoreUint64) {
  test(theString: string, theUint: uint64) {
    // setStore resolved from first base type
    this.setStore(theString)

    // Can explicitly resolve from other base type with .class
    super.class(StoreUint64).setStore(theUint)
  }
}
```

Whilst method names can overlap between base types (and resolved as above), properties (Local and Global State + Boxes) must be unique, and will result in a compile error if they are redefined.

## BaseContract

If ARC4 routing and/or interoperability is not required, a contract can extend the `BaseContract` type which gives full control to the developer to implement the approval and clear state programs. If this type is extended directly it will not be possible to output ARC-32 or ARC-56 app spec files and related artifacts. Transaction arguments will also need to be decoded manually.

```ts
import { BaseContract, log, op } from '@algorandfoundation/algorand-typescript'

class DoNothingContract extends BaseContract {
  public approvalProgram(): boolean {
    return true
  }
  public clearStateProgram(): boolean {
    return true
  }
}
class HelloWorldContract extends BaseContract {
  public approvalProgram(): boolean {
    const name = String(op.Txn.applicationArgs(0))
    log(`Hello, ${name}`)
    this.notRouted()
    return true
  }

  public notRouted() {
    log('This method is not public accessible')
  }
}
```

# Logic Signatures

Logic signatures or smart signatures as they are sometimes referred to are single program constructs which can be used to sign transactions. If the logic defined in the program runs without error, the signature is considered valid - if the program crashes, or returns `0` or `false`, the signature is not valid and the transaction will be rejected. It is possible to delegate signature privileges for any standard account to a logic signature program such that any transaction signed with the logic signature program will pass on behalf of the delegating account provided the program logic succeeds. This is obviously a dangerous proposition and such a logic signature program should be meticulously designed to avoid abuse. You can read more about logic signatures on Algorand [here](https://dev.algorand.co/concepts/smart-contracts/logic-sigs/).

Logic signature programs are stateless, and support a different subset of [op codes](https://dev.algorand.co/reference/algorand-teal/opcodes/) to smart contracts. The LogicSig class should only ever have a `program` method, complex signatures can make use of [free subroutines](#free-subroutines) to break up logic into smaller chunks.

```ts
import { assert, LogicSig, Txn, Uint64 } from '@algorandfoundation/algorand-typescript'

export class AlwaysAllow extends LogicSig {
  program() {
    return true
  }
}

function feeIsZero() {
  assert(Txn.fee === 0, 'Fee must be zero')
}

export class AllowNoFee extends LogicSig {
  program() {
    feeIsZero()
    return Uint64(1)
  }
}
```



================================================
FILE: docs/lg-storage.md
================================================
---
title: Storage
---

# Storage

Algorand smart contracts have [three different types of on-chain storage](https://dev.algorand.co/concepts/smart-contracts/storage/overview/)
they can utilise: [Global storage](#global-storage), [Local storage](#local-storage), and [Box Storage](#box-storage). They also have access to a transient form of storage in [Scratch space](#scratch-storage).

## Global storage

Global or Application storage is a key/value store of `bytes` or `uint64` values stored against a smart contract application. The number of values used must be declared when the application is first created and will affect the [minimum balance requirement](https://dev.algorand.co/concepts/smart-contracts/costs-constraints/#mbr) for the application. For ARC4 contracts this information is captured in the ARC32 and ARC56 specification files and automatically included in deployments.

Global storage values are declared using the [GlobalState](api/index/functions/GlobalState.md) function to create a [GlobalState](api/index/type-aliases/GlobalState.md) proxy object.

```ts
import { GlobalState, Contract, uint64, bytes, Uint64, contract } from '@algorandfoundation/algorand-typescript'

class DemoContract extends Contract {
  // The property name 'globalInt' will be used as the key
  globalInt = GlobalState<uint64>({ initialValue: Uint64(1) })
  // Explicitly override the key
  globalBytes = GlobalState<bytes>({ key: 'alternativeKey' })
}

// If using dynamic keys, state must be explicitly reserved
@contract({ stateTotals: { globalBytes: 5 } })
class DynamicAccessContract extends Contract {
  test(key: string, value: string) {
    // Interact with state using a dynamic key
    const dynamicAccess = GlobalState<string>({ key })
    dynamicAccess.value = value
  }
}
```

## Local storage

Local or Account storage is a key/value store of `bytes` or `uint64` stored against a smart contract application _and_ a single account which has opted into that contract. The number of values used must be declared when the application is first created and will affect the minimum balance requirement of an account which opts in to the contract. For ARC4 contracts this information is captured in the ARC32 and ARC56 specification files and automatically included in deployments.

```ts
import type { bytes, uint64 } from '@algorandfoundation/algorand-typescript'
import { abimethod, Contract, LocalState, Txn } from '@algorandfoundation/algorand-typescript'
import type { StaticArray, UintN } from '@algorandfoundation/algorand-typescript/arc4'

type SampleArray = StaticArray<UintN<64>, 10>

export class LocalStateDemo extends Contract {
  localUint = LocalState<uint64>({ key: 'l1' })
  localUint2 = LocalState<uint64>()
  localBytes = LocalState<bytes>({ key: 'b1' })
  localBytes2 = LocalState<bytes>()
  localEncoded = LocalState<SampleArray>()

  @abimethod({ allowActions: 'OptIn' })
  optIn() {}

  public setState({ a, b }: { a: uint64; b: bytes }, c: SampleArray) {
    this.localUint(Txn.sender).value = a
    this.localUint2(Txn.sender).value = a
    this.localBytes(Txn.sender).value = b
    this.localBytes2(Txn.sender).value = b
    this.localEncoded(Txn.sender).value = c.copy()
  }

  public getState() {
    return {
      localUint: this.localUint(Txn.sender).value,
      localUint2: this.localUint2(Txn.sender).value,
      localBytes: this.localBytes(Txn.sender).value,
      localBytes2: this.localBytes2(Txn.sender).value,
      localEncoded: this.localEncoded(Txn.sender).value.copy(),
    }
  }

  public clearState() {
    this.localUint(Txn.sender).delete()
    this.localUint2(Txn.sender).delete()
    this.localBytes(Txn.sender).delete()
    this.localBytes2(Txn.sender).delete()
    this.localEncoded(Txn.sender).delete()
  }
}
```

## Box storage

We provide 3 different types for accessing box storage: [Box](./api/index/functions/Box.md), [BoxMap](./api/index/functions/BoxMap.md), and [BoxRef](./api/index/functions/BoxRef.md). We also expose raw operations via the [AVM ops](./lg-ops.md) module.

Before using box storage, be sure to familiarise yourself with the [requirements and restrictions](https://dev.algorand.co/concepts/smart-contracts/storage/box/) of the underlying API.

The `Box` type provides an abstraction over storing a single value in a single box. A box can be declared as a class field (in which case the key must be a compile time constant); or as a local variable within any
subroutine. `Box` proxy instances can be passed around like any other value.

`BoxMap` is similar to the `Box` type, but allows for grouping a set of boxes with a common key and content type.
A `keyPrefix` is specified when the `BoxMap` is created and the item key can be a `Bytes` value, or anything that can be converted to `Bytes`. The final box name is the combination of `keyPrefix + key`.

`BoxRef` is a specialised type for interacting with boxes which contain binary data. In addition to being able to set and read the box value, there are operations for extracting and replacing just a portion of the box data which
is useful for minimizing the amount of reads and writes required, but also allows you to interact with byte arrays which are longer than the AVM can support (currently 4096).

```ts
import type { Account, uint64 } from '@algorandfoundation/algorand-typescript'
import { Box, BoxMap, BoxRef, Contract, Txn, assert } from '@algorandfoundation/algorand-typescript'
import { bzero } from '@algorandfoundation/algorand-typescript/op'

export class BoxContract extends Contract {
  boxOne = Box<string>({ key: 'one' })
  boxMapTwo = BoxMap<Account, uint64>({ keyPrefix: 'two' })
  boxRefThree = BoxRef({ key: 'three' })

  test(): void {
    if (!this.boxOne.exists) {
      this.boxOne.value = 'Hello World'
    }
    this.boxMapTwo(Txn.sender).value = Txn.sender.balance
    const boxForSender = this.boxMapTwo(Txn.sender)
    assert(boxForSender.exists)
    if (this.boxRefThree.exists) {
      this.boxRefThree.resize(8000)
    } else {
      this.boxRefThree.create({ size: 8000 })
    }

    this.boxRefThree.replace(0, bzero(0).bitwiseInvert())
    this.boxRefThree.replace(4000, bzero(0))
  }
}
```

## Scratch storage

Scratch storage persists for the lifetime of a group transaction and can be used to pass values between multiple calls and/or applications in the same group. Scratch storage for logic signatures is separate from that of the application calls and logic signatures do not have access to the scratch space of other transactions in the group.

Values can be written to scratch space using the `Scratch.store(...)` method and read from using `Scratch.loadUint64(...)` or `Scratch.loadBytes(...)` methods. These all take a scratch slot number between 0 and 255 inclusive and that scratch slot must be explicitly reserved by the contract using the `contract` options decorator.

```ts
import { assert, BaseContract, Bytes, contract } from '@algorandfoundation/algorand-typescript'
import { Scratch } from '@algorandfoundation/algorand-typescript/op'

@contract({ scratchSlots: [0, 1, { from: 10, to: 20 }] })
export class ReserveScratchAlgo extends BaseContract {
  setThings() {
    Scratch.store(0, 1)
    Scratch.store(1, Bytes('hello'))
    Scratch.store(15, 45)
  }

  approvalProgram(): boolean {
    this.setThings()

    assert(Scratch.loadUint64(0) === 1)
    assert(Scratch.loadBytes(1) === Bytes('hello'))
    assert(Scratch.loadUint64(15) === 45)
    return true
  }
}
```

Scratch space can be read from group transactions using the `gloadUint64` and `gloadBytes` ops. These ops take the group index of the target transaction, and a scratch slot number.

```ts
import { gloadBytes, gloadUint64 } from '@algorandfoundation/algorand-typescript/op'

function test() {
  const b = gloadBytes(0, 1)
  const u = gloadUint64(1, 2)
}
```



================================================
FILE: docs/lg-types.md
================================================
---
title: Types
---

# Types

Types in Algorand TypeScript can be divided into two camps, 'native' AVM types where the implementation is opaque, and it is up to the compiler and the AVM how the type is represented in memory; and 'ARC4 Encoded types' where the in memory representation is always a byte array, and the exact format is determined by the [ARC4 Spec](https://github.com/algorandfoundation/ARCs/blob/main/ARCs/arc-0004.md#encoding).

ARC4 defines an Application Binary Interface (ABI) for how data should be passed to and from a smart contract, and represents a sensible standard for how data should be represented at rest (eg. in Box storage or Application State). It is not necessarily the most optimal format for an in memory representation and for data which is being mutated. For this reason we offer both sets of types and a developer can choose the most appropriate one for their usage. As a beginner the native types will feel more natural to use, but it is useful to be aware of the encoded versions when it comes to optimizing your application.

## AVM Types

The most basic [types on the AVM](https://dev.algorand.co/concepts/smart-contracts/avm/#stack-types)
are `uint64` and `bytes`, representing unsigned 64-bit integers and byte arrays respectively.
These are represented by [`uint64`](./#uint64) and [`bytes`](./#bytes) in Algorand TypeScript.

There are further "bounded" types supported by the AVM, which are backed by these two simple primitives.
For example, `biguint` represents a variably sized (up to 512-bits), unsigned integer, but is actually
backed by a `byte[]`. This is represented by [`biguint`](./#biguint) in Algorand TypeScript.

### Uint64

`uint64` represents an unsigned 64-bit integer type that will error on both underflow (negative values) and overflows (values larger than 64-bit). It can be declared with a numeric literal and a type annotation of `uint64` or by using the `Uint64` factory method (think `number` (type) vs `Number` (a function for creating numbers))

```ts
import { Uint64, uint64 } from '@algorandfoundation/algorand-typescript'

const x: uint64 = 123
demo(x)
// Type annotation is not required when `uint64` can be inferred from usage
demo(456)

function demo(y: uint64) {}
// `Uint64` constructor can be used to define `uint64` values which `number` cannot safely represent
const z = Uint64(2n ** 54n)

// No arg (returns 0), similar to Number()
demo(Uint64())
// Create from string representation (must be a string literal)
demo(Uint64('123456'))
// Create from a boolean
demo(Uint64(true))
// Create from a numeric expression
demo(Uint64(34 + 3435))
```

Math operations with the `uint64` work the same as EcmaScript's `number` type however due to a hard limitation in TypeScript, it is not possible to control the type of these expressions - they will always be inferred as `number`. As a result, a type annotation will be required making use of the expression value if the type cannot be inferred from usage.

```ts
import { Uint64, uint64 } from '@algorandfoundation/algorand-typescript'

function add(x: uint64, y: uint64): uint64 {
  return x + y // uint64 inferred from function's return type
}
// uint64 inferred from assignment target
const x: uint64 = 123 + add(4, 5)

const a: uint64 = 50

// Error because type of `b` will be inferred as `number`
const b = a * x
// Ok
const c: uint64 = a * x
// Ok
const d = Uint64(a * x)
```

### BigUint

`biguint` represents an unsigned integer of up to 512-bit. The leading `0` padding is variable and not guaranteed. Operations made using a `biguint` are more expensive in terms of [opcode budget](https://dev.algorand.co/concepts/smart-contracts/languages/teal/#dynamic-operational-cost) by an order of magnitude, as such - the `biguint` type should only be used when dealing with integers which are larger than 64-bit. A `biguint` can be declared with a bigint literal (A number with an `n` suffix) and a type annotation of `biguint`, or by using the `BigUint` factory method. The same constraints of the `uint64` type apply here with regards to required type annotations.

```ts
import { BigUint, bigint } from '@algorandfoundation/algorand-typescript'

const x: bigint = 123n
demo(x)
// Type annotation is not required when `bigint` can be inferred from usage
demo(456n)

function demo(y: bigint) {}

// No arg (returns 0), similar to Number()
demo(BigUint())
// Create from string representation (must be a string literal)
demo(BigUint('123456'))
// Create from a boolean
demo(BigUint(true))
// Create from a numeric expression
demo(BigUint(34 + 3435))
```

### Bytes

`bytes` represents a variable length sequence of bytes up to a maximum length of 4096. Bytes values can be created from various string encodings using string literals using the `Bytes` factory function.

```ts
import { Bytes } from '@algorandfoundation/algorand-typescript'

const fromUtf8 = Bytes('abc')
const fromHex = Bytes.fromHex('AAFF')
const fromBase32 = Bytes.fromBase32('....')
const fromBase64 = Bytes.fromBase64('....')

const interpolated = Bytes`${fromUtf8}${fromHex}${fromBase32}${fromBase64}`
const concatenated = fromUtf8.concat(fromHex).concat(fromBase32).concat(fromBase64)
```

### String

`string` literals and values are supported in Algorand TypeScript however most of the prototype is not implemented. Strings in EcmaScript are implemented using utf-16 characters and achieving semantic compatability for any prototype method which slices or splits strings based on characters would be non-trivial (and opcode expensive) to implement on the AVM with no clear benefit as string manipulation tasks can easily be performed off-chain. Algorand TypeScript APIs which expect a `bytes` value will often also accept a `string` value. In these cases, the `string` will be interpreted as a `utf8` encoded value.

```ts
const a = 'Hello'
const b = 'world'

const interpolate = `${a} ${b}`
const concat = a + ' ' + b
```

### Boolean

`bool` literals and values are supported in Algorand TypeScript. The `Boolean` factory function can be used to evaluate other values as `true` or `false` based on whether the underlying value is `truthy` or `falsey`.

```ts
import { uint64 } from '@algorandfoundation/algorand-typescript'

const one: uint64 = 1
const zero: uint64 = 0

const trueValues = [true, Boolean(one), Boolean('abc')] as const
const falseValues = [false, Boolean(zero), Boolean('')] as const
```

### Account, Asset, Application

These types represent the underlying Algorand entity and expose methods and properties for retrieving data associated with that entity. They are created by passing the relevant identifier to the respective factory methods.

```ts
import { Application, Asset, Account } from '@algorandfoundation/algorand-typescript'

const app = Application(123n) // Create from application id
const asset = Asset(456n) // Create from asset id
const account = Account('A7NMWS3NT3IUDMLVO26ULGXGIIOUQ3ND2TXSER6EBGRZNOBOUIQXHIBGDE') // Create from account address
const account2 = Account(Bytes.fromHex('07DACB4B6D9ED141B17576BD459AE6421D486DA3D4EF2247C409A396B82EA221')) // Create from account public key bytes
```

They can also be used in ABI method parameters where they will be created referencing the relevant `foreign_*` array on the transaction. See [ARC4 reference types](https://github.com/algorandfoundation/ARCs/blob/main/ARCs/arc-0004.md#reference-types)

### Group Transactions

The group transaction types expose properties and methods for reading attributes of other transactions in the group. They can be created explicitly by calling `gtxn.Transaction(n)` where `n` is the index of the desired transaction in the group, or they can be used in ABI method signatures where the ARC4 router will take care of providing the relevant transaction specified by the client. They should not be confused with the [itxn](lg-itxns.md) namespace which contains types for composing inner transactions

```ts
import { gtxn, Contract } from '@algorandfoundation/algorand-typescript'

class Demo extends Contract {
  doThing(payTxn: gtxn.PayTxn): void {
    const assetConfig = gtxn.AssetConfigTxn(1)

    const txn = gtxn.Transaction(i)
    switch (txn.type) {
      case TransactionType.ApplicationCall:
        log(txn.appId.id)
        break
      case TransactionType.AssetTransfer:
        log(txn.xferAsset.id)
        break
      case TransactionType.AssetConfig:
        log(txn.configAsset.id)
        break
      case TransactionType.Payment:
        log(txn.receiver)
        break
      case TransactionType.KeyRegistration:
        log(txn.voteKey)
        break
      default:
        log(txn.freezeAsset.id)
        break
    }
  }
}
```

### Arrays

#### Immutable

```ts
const myArray: uint64[] = [1, 2, 3]
const myOtherArray = ['a', 'b', 'c']
```

Arrays in Algorand TypeScript can be declared using the array literal syntax and are explicitly typed using either the `T[]` shorthand or `Array<T>` full name. The type can usually be inferred but uints will require a type hint. Native arrays are currently considered immutable (as if they were declared `readonly T[]`) as the AVM offers limited resources for storing mutable reference types in a heap. "Mutations" can be done using the pure methods available on the Array prototype.

```ts
let myArray: uint64[] = [1, 2, 3]

// Instead of .push
myArray = [...myArray, 4]

// Instead of index assignment
myArray = myArray.with(2, 3)
```

Similar to other supported native types, much of the full prototype of Array is not supported but this coverage may expand over time.

#### Mutable

```ts
import { MutableArray, uint64 } from '@algorandfoundation/algorand-typescript'

const myMutable = new MutableArray<uint64>()
myMutable.push(1)
addToArray(myMutable)
assert(myMutable.pop() === 4)

function addToArray(x: MutableArray<uint64>) {
  x.push(4)
}
```

Mutable arrays can be declared using the [MutableArray](api/index/classes/MutableArray.md) type. This type makes use of [scratch space](https://dev.algorand.co/concepts/smart-contracts/languages/teal/#scratch-space-usage) as a heap in order to provide an array type with 'pass by reference' semantics. It is currently limited to fixed size item types.

### Tuples

```ts
import { Uint64, Bytes } from '@algorandfoundation/algorand-typescript'

const myTuple = [Uint64(1), 'test', false] as const

const myOtherTuple: [string, bytes] = ['hello', Bytes('World')]
const myOtherTuple2: readonly [string, bytes] = ['hello', Bytes('World')]
```

Tuples can be declared by appending the `as const` keywords to an array literal expression, or by adding an explicit type annotation. Tuples are considered immutable regardless of how they are declared meaning `readonly [T1, T2]` is equivalent to `[T1, T2]`. Including the `readonly` keyword will improve intellisense and TypeScript IDE feedback at the expense of verbosity.

### Objects

```ts
import { Uint64, Bytes, uint64 } from '@algorandfoundation/algorand-typescript'

type NamedObj = { x: uint64; y: uint64 }

const myObj = { a: Uint64(123), b: Bytes('test'), c: false }

function test(obj: NamedObj): uint64 {
  return (obj.x = obj.y)
}
```

Object types and literals are treated as named tuples. The types themselves can be declared with a name using a `type NAME = { ... }` expression, or anonymously using an inline type annotation `let x: { a: boolean } = { ... }`. If no type annotation is present, the type will be inferred from the assigned values. Object types are immutable and are treated as if they were declared with the `Readonly` helper type. i.e. `{ a: boolean }` is equivalent to `Readonly<{ a: boolean }>`. An object's property can be updated using a spread expression.

```ts
import { Uint64 } from '@algorandfoundation/algorand-typescript'

let obj = { first: 'John', last: 'Doh' }
obj = { ...obj, first: 'Jane' }
```

## ARC4 Encoded Types

ARC4 encoded types live in the `/arc4` module

Where supported, the native equivalent of an ARC4 type can be obtained via the `.native` property. It is possible to use native types in an ABI method and the router will automatically encode and decode these types to their ARC4 equivalent.

### Booleans

**Type:** `@algorandfoundation/algorand-typescript/arc4::Bool`<br>
**Encoding:** A single byte where the most significant bit is `1` for `True` and `0` for `False`<br>
**Native equivalent:** `bool`

### Unsigned ints

**Types:** `@algorandfoundation/algorand-typescript/arc4::UIntN`<br>
**Encoding:** A big endian byte array of N bits<br>
**Native equivalent:** `uint64` or `biguint`

Common bit sizes have also been aliased under `@algorandfoundation/algorand-typescript/arc4::UInt8`, `@algorandfoundation/algorand-typescript/arc4::UInt16` etc. A uint of any size between 8 and 512 bits (in intervals of 8bits) can be created using a generic parameter. `Byte` is an alias of `UintN<8>`

### Unsigned fixed point decimals

**Types:** `@algorandfoundation/algorand-typescript/arc4::UFixedNxM`<br>
**Encoding:** A big endian byte array of N bits where `encoded_value = value / (10^M)`<br>
**Native equivalent:** _none_

### Bytes and strings

**Types:** `@algorandfoundation/algorand-typescript/arc4::DynamicBytes` and `@algorandfoundation/algorand-typescript/arc4::Str`<br>
**Encoding:** A variable length byte array prefixed with a 16-bit big endian header indicating the length of the data<br>
**Native equivalent:** `bytes` and `string`

Strings are assumed to be utf-8 encoded and the length of a string is the total number of bytes, _not the total number of characters_.

### StaticBytes

**Types:** `@algorandfoundation/algorand-typescript/arc4::StaticBytes`<br>
**Encoding:** A fixed length byte array<br>
**Native equivalent:** `bytes`

Like `DynamicBytes` but the length header can be omitted as the data is assumed to be of the specified length.

### Static arrays

**Type:** `@algorandfoundation/algorand-typescript/arc4::StaticArray`<br>
**Encoding:** See [ARC4 Container Packing](#ARC4-Container-Packing)<br>
**Native equivalent:** _none_

An ARC4 StaticArray is an array of a fixed size. The item type is specified by the first generic parameter and the size is specified by the second.

### Address

**Type:** `@algorandfoundation/algorand-typescript/arc4::Address`<br>
**Encoding:** A byte array 32 bytes long<br>
**Native equivalent:** `Account`

Address represents an Algorand address' public key, and can be used instead of `Account` when needing to
reference an address in an ARC4 struct, tuple or return type. It is a subclass of `StaticArray<Byte, 32>`

### Dynamic arrays

**Type:** `@algorandfoundation/algorand-typescript/arc4::DynamicArray`<br>
**Encoding:** See [ARC4 Container Packing](#ARC4-Container-Packing)<br>
**Native equivalent:** _none_

An ARC4 DynamicArray is an array of a variable size. The item type is specified by the first generic parameter. Items can be added and removed via `.pop`, `.append`, and `.extend`.

The current length of the array is encoded in a 16-bit prefix similar to the `arc4.DynamicBytes` and `arc4.String` types

### Tuples

**Type:** `@algorandfoundation/algorand-typescript/arc4::Tuple`<br>
**Encoding:** See [ARC4 Container Packing](#ARC4-Container-Packing)<br>
**Native equivalent:** TypeScript tuple

ARC4 Tuples are immutable statically sized arrays of mixed item types. Item types can be specified via generic parameters or inferred from constructor parameters.

### Structs

**Type:** `@algorandfoundation/algorand-typescript/arc4::Struct`<br>
**Encoding:** See [ARC4 Container Packing](#ARC4-Container-Packing)<br>
**Native equivalent:** _None_

ARC4 Structs are named tuples. Items can be accessed via names instead of indexes. They are also mutable

### ARC4 Container Packing

ARC4 encoding rules are detailed explicitly in the [ARC](https://github.com/algorandfoundation/ARCs/blob/main/ARCs/arc-0004.md#encoding-rules). A summary is included here.

Containers are composed of a head and a tail portion, with a possible length prefix if the container length is dynamic.

```
[Length (2 bytes)][Head bytes][Tail bytes]
                  ^ Offsets are from the start of the head bytes
```

- Fixed length items (eg. bool, uintn, byte, or a static array of a fixed length item) are inserted directly into the head
- Variable length items (eg. bytes, string, dynamic array, or even a static array of a variable length item) are inserted into the tail. The head will include a 16-bit number representing the offset of the tail data, the offset is the total number of bytes in the head + the number of bytes preceding the tail data for this item (ie. the tail bytes of any previous items)
- Consecutive boolean values are packed into CEIL(N / 8) bytes where each bit will represent a single boolean value (big endian)



================================================
FILE: docs/reference.md
================================================
---
title: Reference docs
children:
  - ./abi-routing.md
  - ./guiding-principles.md
---

# Reference docs

## [ABI Routing Guides](./abi-routing.md)

Explains in more detail how ABI routing works with ARC4 contracts

## [Guiding Principles](./guiding-principles.md)

Outlines the guiding principles used when designing the Algorand TypeScript language



================================================
FILE: docs/architecture-decisions/2024-05-21_primitive-bytes-and-strings.md
================================================
# Architecture Decision Record - Primitive bytes and strings

- **Status**: Draft
- **Owner:** Tristan Menzel
- **Deciders**: Alessandro Cappellato (Algorand Foundation), Joe Polny (Algorand Foundation), Rob Moore (MakerX)
- **Date created**: 2024-05-21
- **Date decided**: N/A
- **Date updated**: 2024-05-31

## Context

See [Architecture Decision Record - Primitive integer types](./2024-05-21_primitive-integer-types.md) for related decision and context.

The AVM's only non-integer type is a variable length byte array. When _not_ being interpreted as a `biguint`, leading zeros are significant and length is constant unless explicitly manipulated. Strings can only be represented in the AVM if they are encoded as bytes. The AVM supports byte literals in the form of base16, base64, and UTF-8 encoded strings. Once a literal has been parsed, the AVM has no concept of the original encoding or of UTF-8 characters. As a result, whilst a byte array can be indexed to receive a single byte (or a slice of bytes); it cannot be indexed to return a single UTF-8 _character_ - unless one assumes all characters in the original string were ASCII (i.e. single byte) characters.

Algorand Python has specific [Bytes and String types](https://algorandfoundation.github.io/puya/lg-types.html#avm-types) that have semantics that exactly match the AVM semantics. Python allows for operator overloading so these types also use native operators (where they align to functionality in the underlying AVM).

## Requirements

- Support bytes AVM type and a string type that supports ASCII UTF-8 strings
- Use idiomatic TypeScript expressions for string expressions
- Semantic compatibility between AVM execution and TypeScript execution (e.g. in unit tests)

## Principles

- **[AlgoKit Guiding Principles](https://github.com/algorandfoundation/algokit-cli/blob/main/docs/algokit.md#guiding-principles)** - specifically Seamless onramp, Leverage existing ecosystem, Meet devs where they are
- **[Algorand Python Principles](https://algorandfoundation.github.io/puya/principles.html#principles)**
- **[Algorand TypeScript Guiding Principles](../guiding-principles)**

## Options

### Option 1 - Direct use of native EcmaScript types

EcmaScript provides two relevant types for bytes and strings.

- **string**: The native string type. Supports arbitrary length, concatenation, indexation/slicing of characters plus many utility methods (upper/lower/startswith/endswith/charcodeat/trim etc). Supports concat with binary `+` operator.
- **Uint8Array**: A variable length mutable array of 8-bit numbers. Supports indexing/slicing of 'bytes'.

```ts
const b1 = 'somebytes'

const b2 = new Uint8Array([1, 2, 3, 4])

const b3 = b1 + b1
```

Whilst binary data is often a representation of a utf-8 string, it is not always - so direct use of the string type is not a natural fit. It doesn't allow us to represent alternative encodings (b16/b64) and the existing api surface is very 'string' centric. Much of the api would also be expensive to implement on the AVM leading to a bunch of 'dead' methods hanging off the type (or a significant amount of work implementing all the methods). The signatures of these methods also use `number` which is [not a semantically relevant type](./2024-05-21_primitive-integer-types.md).

Achieving semantic compatability with EcmaScript's `String` type would also be very expensive as it uses utf-16 encoding underneath whilst an ABI string is utf-8 encoded. A significant number of ops (and program size) would be required to convert between the two. If we were to ignore this and use utf-8 at runtime, apis such as `.length` would return different results. For example `"😄".length` in ES returns `2` whilst utf-8 encoding would yield `1` codepoint or `4` bytes, similarly indexing and slicing would yield different results.

The Uint8Array type is fit for purpose as an encoding mechanism but the API is not as friendly as it could be for writing declarative contracts. The `new` keyword feels unnatural for something that is ostensibly a primitive type. The fact that it is mutable also complicates the implementation the compiler produces for the AVM.

### Option 2 - Branded strings (TEALScript approach)

TEALScript uses a branded `string` to represent `bytes` and native `string` to represent UTF-8 bytes. Base64/Base16 encoding/decoding is performed with specific methods.

```typescript
const someString = 'foo'
const someHexValue = hex('0xdeadbeef') // branded "bytes"
```

Bytes and UTF-8 strings are typed via branded `string` types. UTF-8 strings are the most common use case for strings, thus have the JavaScript `String` prototype functions when working with byteslice, which provides a familiar set of function signatures. This option also enables the usage of `+` for concatenation.

To differentiate between ABI `string` and AVM `byteslice`, a branded type, `bytes`, can be used to represent non-encoded byteslices that may or may not be UTF-8 strings.

Additional functions can be used when wanting to have string literals of a specific encoding represent a string or byteslice.

The downsides of using `string` are listed in Option 1.

### Option 3 - Define a class to represent Bytes

A `Bytes` class and `Str` (Name TBD) class are defined with a very specific API tailored to operations which are available on the AVM:

```ts
class Bytes {
  constructor(v: string) {
    this.v = v
  }

  concat(other: Bytes): Bytes {
    return new Bytes(this.v + other.v)
  }

  at(x: uint64): Bytes {
    return new Bytes(this.v[x])
  }

  /* etc */
}

class Str {
  /* implementation */
}
```

This solution provides great type safety and requires no transpilation to run _correctly_ on Node.js. However, non-primitive types in Node.js have equality checked by reference. Again the `new` keyword feels unnatural. Due to lack of overloading, `+` will not work as expected however concatenations do not require the same understanding of "order of operations" and nesting as numeric operations, so a `concat` method isn't as unwieldy (but still isn't idiomatic).

```ts
const a = new Bytes('Hello')
const b = new Bytes('World')
const c = new Str('Example string')
const ab = a.concat(b)

function testValue(x: Bytes) {
  // No compile error, but will work on reference not value
  switch (x) {
    case a:
      return b
    case b:
      return a
  }
  return new Bytes('default')
}
```

To have equality checks behave as expected we would need a transpilation step to replace bytes values in certain expressions with a primitive type.

### Option 4 - Implement bytes as a class but define it as a type + factory

We can iron out some of the rough edges of using a class by only exposing a factory method for `Bytes`/`Str` and a resulting type `bytes`/`str`. This removes the need for the `new` keyword and lets us use a 'primitive looking' type alias (`bytes` versus `Bytes`, `str` versus `Str` - much like `string` and `String`). We can use [tagged templates](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#tagged_templates) to improve the user experience of multipart concat expressions in lieu of having the `+` operator.

```ts
export type bytes = {
  readonly length: uint64

  at(i: Uint64Compat): bytes

  concat(other: BytesCompat): bytes
} & symbol

export function Bytes(value: TemplateStringsArray, ...replacements: BytesCompat[]): bytes
export function Bytes(value: BytesCompat): bytes
export function Bytes(value: BytesCompat | TemplateStringsArray, ...replacements: BytesCompat[]): bytes {
  /* implementation */
}

const a = Bytes('Hello')
const b = Bytes.fromHex('ABFF')
const c = Bytes.fromBase64('...')
const d = Bytes.fromInts(255, 123, 28, 20)
const e = Bytes`${a} World!`

function testValue(x: bytes, y: bytes): bytes {
  return Bytes`${x} and ${y}`
}

const f = Str`Example string`
```

Whilst we still can't accept string literals on their own, the tagged template is almost as concise.

Having `bytes` and `str` behave like a primitive value type (value equality) whilst not _actually_ being a primitive is not strictly semantically compatible with EcmaScript however the lowercase type names (plus factory with no `new` keyword) communicates the intention of it being a primitive value type and there is an existing precedence of introducing new value types to the language in a similar pattern (`bigint` and `BigInt`). Essentially - if EcmaScript were to have a primitive bytes type, this is most likely what it would look like.

## Preferred option

Option 3 can be excluded because the requirement for a `new` keyword feels unnatural for representing a primitive value type.

Option 1 and 2 are not preferred as they make maintaining semantic compatability with EcmaScript impractical.

Option 4 gives us the most natural feeling api whilst still giving us full control over the api surface. It doesn't support the `+` operator, but supports interpolation and `.concat` which gives us most of what `+` provides other than augmented assignment (ie. `+=`).

We should select an appropriate name for the type representing an AVM string. It should not conflict with the semantically incompatible EcmaScript type `string`.

- `str`/`Str`:
  - ✅ Short
  - ✅ obvious what it is
  - ✅ obvious equivalent in ABI types
  - ❌ NOT obvious how it differs from EcmaScript `string`
- `utf8`/`Utf8`:
  - ✅ Short
  - ✅ reasonably obvious what it is
  - 🤔 less obvious equivalent in ABI types
  - ✅ obvious how it differs to `string`
- `utf8string`/`Utf8String`
  - ❌ Verbose
  - ✅ obvious equivalent in ABI types
  - ✅ very obvious what it is
  - ✅ obvious how it differs to `string`

## Selected option

Option 4 has been selected as the best option



================================================
FILE: docs/architecture-decisions/2024-05-21_primitive-integer-types.md
================================================
# Architecture Decision Record - Primitive integer types

- **Status**: Draft
- **Owner:** Tristan Menzel
- **Deciders**: Alessandro Cappellato (Algorand Foundation), Joe Polny (Algorand Foundation), Rob Moore (MakerX)
- **Date created**: 2024-05-21
- **Date decided**: N/A
- **Date updated**: 2024-05-31

## Context

The AVM supports two integer types in its standard set of ops.

- **uint64**: An unsigned 64-bit integer where the AVM will error on over or under flows
- **biguint**: An unsigned variable bit, big-endian integer represented as an array of bytes with an indeterminate number of leading zeros which are truncated by several math ops. The max size of a biguint is 512-bits. Over and under flows will cause errors.

EcmaScript supports two numeric types.

- **number**: A floating point signed value with 64 bits of precision capable of a max safe integer value of 2^53 - 1. A number can be declared with a numeric literal, or with the `Number(...)` factory method.
- **bigint**: A signed arbitrary-precision integer with an implementation defined limit based on the platform. In practice this is greater than 512-bit. A bigint can be declared with a numeric literal and `n` suffix, or with the `BigInt(...)` factory method.

EcmaScript and TypeScript both do not support operator overloading, despite some [previous](https://github.com/tc39/notes/blob/main/meetings/2023-11/november-28.md#withdrawing-operator-overloading) [attempts](https://github.com/microsoft/TypeScript/issues/2319) to do so.

TealScript [makes use of branded `number` types](https://tealscript.netlify.app/guides/supported-types/numbers/) for all bit sizes from 8 => 512, although it doesn't allow `number` variables, you must specify the actual type you want (e.g. `uint64`). Since the source code is never executed, the safe limits of the `number` type are not a concern. Compiled code does not perform overflow checks on calculations until a return value is being encoded meaning a uint<8> is effectively a uint<64> until it's returned.

Algorand Python has specific [UInt64 and BigUint types](https://algorandfoundation.github.io/puya/lg-types.html#avm-types) that have semantics that exactly match the AVM semantics. Python allows for operator overloading so these types also use native operators (where they align to functionality in the underlying AVM).

## Requirements

- Support uint64 and biguint AVM types
- Use idiomatic TypeScript expressions for numeric expressions, including mathematical operators (`+`, `-`, `*`, `/`, etc.)
- Semantic compatibility between AVM execution and TypeScript execution (e.g. in unit tests)

## Principles

- **[AlgoKit Guiding Principles](https://github.com/algorandfoundation/algokit-cli/blob/main/docs/algokit.md#guiding-principles)** - specifically Seamless onramp, Leverage existing ecosystem, Meet devs where they are
- **[Algorand Python Principles](https://algorandfoundation.github.io/puya/principles.html#principles)**
- **[Algorand TypeScript Guiding Principles](../guiding-principles)**

## Options

### Option 1 - Native types

EcmaScript's `number` type is ill-suited to representing either AVM type reliably as it does not have the safe range to cover the full range of a uint64. Being a floating point number, it would also require truncating after division.

EcmaScript's `bigint` is a better fit for both types but does not underflow when presented with a negative number, nor does it overflow at any meaningful limit for the AVM types.

If we solved the over/under flow checking with a custom TypeScript transformer we still face an issue that `uint64` and `biguint` would not have discrete types for the compiler to know the difference between them and also we would have no type safety against accidentally passing a `biguint` to a method that expects a `uint64` and vice versa.

### Option 2 - Wrapper classes

A `UInt64` and `BigUint` class could be defined which make use of `bigint` internally to perform maths operations and check for over or under flows after each op.

```ts
class UInt64 {
  private value: bigint

  constructor(value: bigint | number) {
    this.value = this.checkBounds(value)
  }

  add(other: UInt64): UInt64 {
    return new UInt64(this.value + other.value)
  }

  /* etc */
}
```

This solution provides the ultimate in type safety and semantic/syntactic compatibility, and requires no custom TypeScript transformer to run _correctly_ on Node.js. The semantics should be obvious to anyone familiar with Object Oriented Programming. The downside is that neither EcmaScript nor TypeScript support operator overloading which results in more verbose and unwieldy math expressions. The lack of idiomatic TypeScript mathematical operators is a deal breaker that rules this option out.

```ts
const a = UInt64(500n)
const b = Uint64(256)

// Not supported (a compile error in TS)
const c1 = a + b
// Works, but is verbose and unwieldy for more complicated expressions and isn't idiomatic TypeScript
const c2 = a.add(b)
```

### Option 3 - Branded `bigint`

TypeScript allows you to intersect primitive types with a simple interface to brand a value in a way which is incompatible with another primitive branded with a different value within the type system. In this option the base type that is branded is `bigint`, which aligns to th discussion in Option 1 about the logical type to represent `uint64` and `biguint`.

```ts
// Constructors
declare function UInt64(v): uint64
declare function BigUint(v): uint64

// Branded types
type uint64 = bigint & { __type?: 'uint64' }
type biguint = bigint & { __type?: 'biguint' }

const a: uint64 = 323n // Declare with type annotation and raw `bigint` literal
const b = UInt64(12n) // Declare with factory
const b2 = UInt64(12) // Factory could also take `number` literals (compiler could check they aren't negative and are integers)

// c1 type is `bigint`, but we can mandate a type hint with the compiler (c2)
const c1 = a + b
const c2: uint64 = a + b

// No TypeScript type error, but semantically ambiguous - is a+b performed as a biguint op or a uint64 one and then converted?
// (We could detect this as a compiler error though)
const c3: biguint = a + b

// Type error on b: Argument of type 'uint64' is not assignable to parameter of type 'biguint'. Nice!
test(a, b)
function test(x: uint64, y: biguint) {
  // ...
}
```

This solution looks like normal TypeScript and results in math expressions that are much easier to read. The factory methods (e.g. `UInt64(4n)`) mimics native equivalents and should be familiar to existing developers.

The drawbacks of this solution are:

- Less implicit type safety for branded types as TypeScript will infer the type of any binary math expression to be the base numeric type (a type annotation will be required where ever an identifier is declared, and the compiler will need to enforce this)
- In order to have TypeScript execution semantics of a `uint64` or `biguint` match the AVM, a custom TypeScript transformer will be required to wrap numeric operations in logic that checks for over and under flows line-by-line; this is straightforward to write though and has been successfully spiked out
- Additional type checking will be required by the compiler to catch instances of assigning one numeric type to the other (accidental implicit assignment) e.g. assigning a `uint64` value to `biguint`.
- Literals will require an `n` suffix
- `bigint` cannot be used to index an object/array (only `number | string | symbol`)

### Option 4 Explicitly tagged brand types

A variation of option 3 with non-optional `__type` tags would prevent accidental implicit assignment errors when assigning between (say) `uint64` and `biguint`, but require explicit casting on all ops and any methods that return the base type.

```ts
declare function Uint64(v): uint64
declare function BigUint(v): uint64

type uint64 = bigint & { __type: 'uint64' }
type biguint = bigint & { __type: 'biguint' }

// Require factory or cast on declaration
const a: uint64 = 323n as uint64
const b = Uint64(12n)

// Also require factory or cast on math
let c2: uint64

c2 = a + b // error
c2 = Uint64(a + b) // ok
c2 = (a + b) as uint64 // ok
```

This introduces a degree of type safety with the in-built TypeScript type system at the significant expense of legibility and writability.

### Option 5 Branded `number` (TEALScript approach)

TEALScript uses a similar approach to option 3, but uses `number` as the underlying type rather than `bigint`. This has the advantage of being directly compatible with casting raw numbers (e.g. `const x: uint64 = 3` rather than `const x: uint64 = 3n`).

Furthermore, any JavaScript prototype methods that return `number` like `array.length` will be similarly able to be directly used and casted to `uint64` rather than wrapping in a factory method (e.g. `const x: uint64 = [1, 2, 3].length` rather than `const x = UInt64([1, 2, 3].length)`). It's not currently clear if any such methods will be exposed within the stub types that emerge in Algorand TypeScript though; if option 1 isn't chosen then ideally we would want to avoid exposing `number` within Algorand TypeScript altogether. Key prototypes that have `number` include `string` (see [Primitive bytes and strings](./2024-05-21_primitive-bytes-and-strings.md)) and array (but TypeScript allows you to define wrapper classes that support [iteration](https://www.typescriptlang.org/docs/handbook/iterators-and-generators.html) [and](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax) [spreading](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol/isConcatSpreadable) so we can likely avoid `Array<T>` prototype).

If `number` is used as the base brand type for `uint64` and `bigint` is used as the base brand type for `biguint` (a type that TEALScript doesn't implement, so not a breaking change) then accidental implicit assignment errors are prevented by the TypeScript type system.

A key issue with using `number` as the base type is that per option 1, it's semantically a floating point number, not an integer. It is possible for the compiler to check for and disallow non-integer constant literals though, which would prevent a non-integer value appearing outside of division. A custom TypeScript transformer will need to wrap division operations to allow the result to be truncated as an integer; this is a violation of the semantic compatibility principle, but given a branded type would be used rather than `number` (the fact the base type is `number` is largely hidden from the developer) it probably doesn't violate the principle of least surprise and may be considered an acceptable compromise.

The other problem with use of `number` as the base brand type is that you will lose precision and get linting errors when representing a number greater than 53-bits as a constant literal e.g. `const x: uint64 = 9007199254740992`. It _may_ be possible for a custom TypeScript transformer to get the value before precision is lost (needs investigation) and then disable that particular linting tool, but that is a fairly clear violation of semantic compatibility. The workaround would have to be that the compiler detects numbers > `Number.MAX_SAFE_INTEGER` and complains and instead you would have to use the factory syntax with a `bigint` constant literal e.g. `const x = UInt64(9007199254740992n)`.

## Preferred option

Either option 3 or option 5 depending on comfort level in using a floating point number type as the base type for `uint64`, requiring extra compiler checks & more complex custom transformers to overcome this, and not being able to cleanly represent very large integers as a constant literal vs lack of TypeScript protection against accidental implicit assignment of `uint64` and `biguint` (but can be checked by the compiler), and needing to avoid prototype methods that return `number` (although this matches semantic compatibility so may be a good idea anyway).

Option 3 is also a breaking change for TEALScript, which would require `number` literals to either be suffixed with the `bigint` suffix (`n`) or be wrapped in a `UInt64()` factory call.

Option 1 and 2 are excluded because they don't meet the requirements of semantic compatibility and least surprise. Option 4 is excluded, because the resulting syntax is unpractical.

## Selected option

Option 5 has been selected as the best option



================================================
FILE: examples/auction/contract.algo.ts
================================================
import type { gtxn, uint64 } from '@algorandfoundation/algorand-typescript'
import {
  abimethod,
  Account,
  assert,
  assertMatch,
  Asset,
  Contract,
  Global,
  GlobalState,
  itxn,
  LocalState,
  Txn,
} from '@algorandfoundation/algorand-typescript'

export class Auction extends Contract {
  previousBidder = GlobalState<Account>()

  auctionEnd = GlobalState<uint64>()

  previousBid = GlobalState<uint64>()

  asaAmt = GlobalState<uint64>()

  asa = GlobalState<Asset>()

  claimableAmount = LocalState<uint64>()

  @abimethod({ allowActions: 'NoOp', onCreate: 'require' })
  public createApplication(): void {
    this.auctionEnd.value = 0
    this.previousBid.value = 0
    this.asaAmt.value = 0
    this.asa.value = Asset()

    // Use zero address rather than an empty string for Account type safety
    this.previousBidder.value = Account()
  }

  public optIntoAsset(asset: Asset): void {
    /// Only allow app creator to opt the app account into a ASA
    assertMatch(Txn, { sender: Global.creatorAddress })

    /// Verify a ASA hasn't already been opted into
    assert(this.asa.value === Asset())

    /// Save ASA ID in global state
    this.asa.value = asset

    /// Submit opt-in transaction: 0 asset transfer to self
    itxn
      .assetTransfer({
        assetReceiver: Global.currentApplicationAddress,
        xferAsset: asset,
        assetAmount: 0,
      })
      .submit()
  }

  public startAuction(startingPrice: uint64, length: uint64, axfer: gtxn.AssetTransferTxn): void {
    assertMatch(Txn, { sender: Global.creatorAddress })

    /// Ensure the auction hasn't already been started
    assert(this.auctionEnd.value === 0)

    /// Verify axfer
    assertMatch(axfer, { assetReceiver: Global.currentApplicationAddress })

    /// Set global state
    this.asaAmt.value = axfer.assetAmount
    this.auctionEnd.value = Global.latestTimestamp + length
    this.previousBid.value = startingPrice
  }

  private pay(receiver: Account, amount: uint64): void {
    itxn
      .payment({
        receiver: receiver,
        amount: amount,
      })
      .submit()
  }

  @abimethod({ allowActions: 'OptIn' })
  public optInToApplication(): void {}

  public bid(payment: gtxn.PaymentTxn): void {
    /// Ensure auction hasn't ended
    assert(Global.latestTimestamp < this.auctionEnd.value)

    /// Verify payment transaction
    assertMatch(payment, {
      sender: Txn.sender,
      amount: { greaterThan: this.previousBid.value },
    })

    /// Set global state
    this.previousBid.value = payment.amount
    this.previousBidder.value = payment.sender

    /// Update claimable amount
    this.claimableAmount(Txn.sender).value = payment.amount
  }

  public claimBids(): void {
    const originalAmount = this.claimableAmount(Txn.sender).value
    let amount = originalAmount

    /// subtract previous bid if sender is previous bidder
    if (Txn.sender === this.previousBidder.value) amount = amount - this.previousBid.value

    this.pay(Txn.sender, amount)
    this.claimableAmount(Txn.sender).value = originalAmount - amount
  }

  public claimAsset(asset: Asset): void {
    assert(Global.latestTimestamp > this.auctionEnd.value)

    /// Send ASA to previous bidder
    itxn
      .assetTransfer({
        assetReceiver: this.previousBidder.value,
        xferAsset: asset,
        assetAmount: this.asaAmt.value,
        assetCloseTo: this.previousBidder.value,
      })
      .submit()
  }

  @abimethod({ allowActions: 'DeleteApplication' })
  public deleteApplication(): void {
    itxn
      .payment({
        receiver: Global.creatorAddress,
        closeRemainderTo: Global.creatorAddress,
        amount: 0,
      })
      .submit()
  }
}



================================================
FILE: examples/calculator/contract.algo.ts
================================================
import type { uint64 } from '@algorandfoundation/algorand-typescript'
import { assert, BaseContract, Bytes, err, log, op, Txn, Uint64 } from '@algorandfoundation/algorand-typescript'

const ADD = Uint64(1)
const SUB = Uint64(2)
const MUL = Uint64(3)
const DIV = Uint64(4)
function itoa(i: uint64): string {
  const digits = Bytes`0123456789`
  const radix = digits.length
  if (i < radix) {
    return digits.at(i).toString()
  }
  return itoa(i / radix).concat(digits.at(i % radix).toString())
}
export default class MyContract extends BaseContract {
  public approvalProgram(): boolean {
    const numArgs = Txn.numAppArgs
    let a: uint64, b: uint64, action: uint64
    if (numArgs === 0) {
      a = 0
      b = 0
      action = Uint64(0)
      log(a)
      log(b)
    } else {
      assert(numArgs === 3, 'Expected 3 args')
      action = op.btoi(Txn.applicationArgs(0))
      const a_bytes = Txn.applicationArgs(1)
      const b_bytes = Txn.applicationArgs(2)
      log(a_bytes)
      log(b_bytes)
      a = op.btoi(a_bytes)
      b = op.btoi(b_bytes)
    }
    const result = this.doCalc(action, a, b)
    const result_b = `${itoa(a)}${this.op(action)}${itoa(b)} = ${itoa(result)}`
    log(result_b)
    return true
  }
  public op(action: uint64): string {
    switch (action) {
      case ADD:
        return ` + `
      case SUB:
        return ` - `
      case MUL:
        return ` * `
      case DIV:
        return ` / `
      default:
        err('Unknown operation')
    }
  }

  public doCalc(action: uint64, a: uint64, b: uint64): uint64 {
    switch (action) {
      case ADD:
        return this.add(a, b)
      case SUB:
        return this.sub(a, b)
      case MUL:
        return this.mul(a, b)
      case DIV:
        return this.div(a, b)
      default:
        err('Unknown operation')
    }
  }

  private add(a: uint64, b: uint64): uint64 {
    return a + b
  }

  private sub(a: uint64, b: uint64): uint64 {
    return a - b
  }

  private mul(a: uint64, b: uint64): uint64 {
    return a * b
  }

  private div(a: uint64, b: uint64): uint64 {
    return a / b
  }

  public clearStateProgram(): boolean {
    return true
  }
}



================================================
FILE: examples/hello-world/contract.algo.ts
================================================
import { BaseContract, log, op } from '@algorandfoundation/algorand-typescript'

export default class HelloWorldContract extends BaseContract {
  public approvalProgram(): boolean {
    const name = String(op.Txn.applicationArgs(0))
    log(`Hello, ${name}`)
    return true
  }
}



================================================
FILE: examples/hello-world-abi/contract.algo.ts
================================================
import { arc4 } from '@algorandfoundation/algorand-typescript'

/**
 * An abstract base class for a simple example contract
 */
abstract class Intermediate extends arc4.Contract {
  /**
   * sayBananas method
   * @returns The string "Bananas"
   */
  @arc4.abimethod({ allowActions: ['NoOp'], readonly: true })
  public sayBananas(): string {
    return `Bananas`
  }
}

/**
 * A simple hello world example contract
 */
export default class HelloWorldContract extends Intermediate {
  /**
   * sayHello method
   * @param firstName The first name of the person to greet
   * @param lastName THe last name of the person to greet
   * @returns The string "Hello {firstName} {lastName"}
   */
  public sayHello(firstName: string, lastName: string): string {
    const result = `Hello ${firstName} ${lastName}`
    return result
  }
}



================================================
FILE: examples/simple-voting/contract.algo.ts
================================================
import type { Account, bytes, uint64 } from '@algorandfoundation/algorand-typescript'
import { assert, BaseContract, Bytes, GlobalState, LocalState, op, TransactionType, Uint64 } from '@algorandfoundation/algorand-typescript'

const VOTE_PRICE = Uint64(10_000)
export default class SimpleVotingContract extends BaseContract {
  topic = GlobalState({ initialValue: Bytes('default_topic'), key: Bytes('topic') })
  votes = GlobalState({ initialValue: Uint64(0), key: Bytes('votes') })
  voted = LocalState<uint64>()

  public approvalProgram(): uint64 {
    switch (op.Txn.applicationArgs(0)) {
      case Bytes('set_topic'): {
        this.setTopic(op.Txn.applicationArgs(1))
        return Uint64(1)
      }
      case Bytes('vote'): {
        return this.vote(op.Txn.sender) ? Uint64(1) : Uint64(0)
      }
      case Bytes('get_votes'): {
        return this.votes.value
      }
      default:
        return Uint64(0)
    }
  }

  public clearStateProgram(): boolean {
    return true
  }

  private setTopic(topic: bytes): void {
    this.topic.value = topic
  }

  private vote(voter: Account): boolean {
    assert(op.Global.groupSize === Uint64(2))
    assert(op.GTxn.amount(1) === VOTE_PRICE)
    assert(op.GTxn.typeEnum(1) === TransactionType.Payment)

    if (this.voted(voter).hasValue) {
      return false
    }
    this.votes.value = this.votes.value + 1
    this.voted(voter).value = Uint64(1)
    return true
  }
}



================================================
FILE: examples/voting/contract.algo.ts
================================================
import type { Account, Asset, bytes, gtxn, uint64 } from '@algorandfoundation/algorand-typescript'
import {
  abimethod,
  arc4,
  assert,
  assertMatch,
  BoxMap,
  BoxRef,
  Bytes,
  ensureBudget,
  Global,
  GlobalState,
  itxn,
  log,
  op,
  OpUpFeeSource,
  Txn,
  Uint64,
  urange,
} from '@algorandfoundation/algorand-typescript'

type VoteIndexArray = arc4.DynamicArray<arc4.UintN<8>>

const VOTE_INDEX_BYTES: uint64 = 1
const VOTE_COUNT_BYTES: uint64 = 8

// The min balance increase per box created
const BOX_FLAT_MIN_BALANCE: uint64 = 2500

// The min balance increase per byte of boxes (key included)
const BOX_BYTE_MIN_BALANCE: uint64 = 400

// The min balance increase for each asset opted into
const ASSET_MIN_BALANCE: uint64 = 100000

type VotingPreconditions = {
  is_voting_open: uint64
  is_allowed_to_vote: uint64
  has_already_voted: uint64
  current_time: uint64
}
export class VotingRoundApp extends arc4.Contract {
  isBootstrapped = GlobalState<boolean>({ initialValue: false })
  voterCount = GlobalState({ initialValue: Uint64(0) })
  closeTime = GlobalState<uint64>()
  tallyBox = BoxRef({ key: Bytes`V` })
  votesByAccount = BoxMap<Account, VoteIndexArray>({ keyPrefix: Bytes() })
  voteId = GlobalState<string>()
  snapshotPublicKey = GlobalState<bytes>()
  metadataIpfsCid = GlobalState<string>()
  startTime = GlobalState<uint64>()
  nftImageUrl = GlobalState<string>()
  endTime = GlobalState<uint64>()
  quorum = GlobalState<uint64>()
  optionCounts = GlobalState<VoteIndexArray>()
  totalOptions = GlobalState<uint64>()
  nftAsset = GlobalState<Asset>()

  @abimethod({ onCreate: 'require' })
  public create(
    voteId: string,
    snapshotPublicKey: bytes,
    metadataIpfsCid: string,
    startTime: uint64,
    endTime: uint64,
    optionCounts: VoteIndexArray,
    quorum: uint64,
    nftImageUrl: string,
  ): void {
    assert(startTime < endTime, 'End time should be after start time')
    assert(endTime >= Global.latestTimestamp, 'End time should be in the future')

    this.voteId.value = voteId
    this.snapshotPublicKey.value = snapshotPublicKey
    this.metadataIpfsCid.value = metadataIpfsCid
    this.startTime.value = startTime
    this.endTime.value = endTime
    this.quorum.value = quorum
    this.nftImageUrl.value = nftImageUrl
    this.storeOptionCounts(optionCounts)
  }

  public bootstrap(fundMinBalReq: gtxn.PaymentTxn): void {
    assert(!this.isBootstrapped.value, 'Must not be already bootstrapped')
    this.isBootstrapped.value = true
    assertMatch(
      fundMinBalReq,
      {
        receiver: Global.currentApplicationAddress,
      },
      'Payment must be to app address',
    )
    const tallyBoxSize: uint64 = this.totalOptions.value * VOTE_COUNT_BYTES

    const minBalanceReq: uint64 =
      ASSET_MIN_BALANCE * 2 + 1000 + BOX_FLAT_MIN_BALANCE + BOX_BYTE_MIN_BALANCE + tallyBoxSize * BOX_BYTE_MIN_BALANCE

    log(minBalanceReq)

    assertMatch(
      fundMinBalReq,
      {
        amount: minBalanceReq,
      },
      'Payment must be for the exact min balance requirement',
    )
    assert(this.tallyBox.create({ size: tallyBoxSize }))
  }

  public close() {
    ensureBudget(20000)
    assert(!this.closeTime.hasValue, 'Already closed')
    this.closeTime.value = Global.latestTimestamp

    // Do we need a way to declare string literals where we ignore leading whitespace?
    let note = `{
      "standard":"arc69",
      "description":"This is a voting result NFT for voting round with ID ${this.voteId.value}",
      "properties":{
        "metadata":"ipfs://${this.metadataIpfsCid.value}",
        "id":"${this.voteId.value}",
        "quorum":"${itoa(this.quorum.value)}}",
        "voterCount":"${itoa(this.voterCount.value)}",
        "tallies": [`

    let currentIndex = Uint64(0)
    for (const [questionIndex, questionOptions] of this.optionCounts.value.entries()) {
      if (questionIndex > 0) {
        note += ','
      }
      if (questionOptions.native > 0) {
        note += '['
        for (let optionIndex = Uint64(0); optionIndex <= questionOptions.native; optionIndex++) {
          if (optionIndex > 0) {
            note += ','
          }
          note += itoa(this.getVoteFromBox(currentIndex))
          currentIndex += 1
        }
        note += ']'
      }
    }
    note += ']}}'

    this.nftAsset.value = itxn
      .assetConfig({
        total: 1,
        decimals: 0,
        defaultFrozen: false,
        assetName: `[VOTE RESULT] ${this.voteId.value}`,
        unitName: `VOTERSLT`,
        url: this.nftImageUrl.value,
        note: note,
        fee: Global.minTxnFee,
      })
      .submit().configAsset
  }

  @abimethod({ readonly: true })
  public getPreconditions(signature: bytes): VotingPreconditions {
    return {
      is_allowed_to_vote: Uint64(this.allowedToVote(signature)),
      is_voting_open: Uint64(this.votingOpen()),
      has_already_voted: Uint64(this.alreadyVoted()),
      current_time: Global.latestTimestamp,
    }
  }

  private allowedToVote(signature: bytes): boolean {
    ensureBudget(2000)
    return op.ed25519verifyBare(Txn.sender.bytes, signature, this.snapshotPublicKey.value)
  }

  private alreadyVoted(): boolean {
    return this.votesByAccount(Txn.sender).exists
  }

  public vote(fundMinBalReq: gtxn.PaymentTxn, signature: bytes, answerIds: VoteIndexArray): void {
    ensureBudget(7700, OpUpFeeSource.GroupCredit)
    assert(this.allowedToVote(signature), 'Not allowed to vote')
    assert(this.votingOpen(), 'Voting not open')
    assert(!this.alreadyVoted(), 'Already voted')

    const questionsCount = this.optionCounts.value.length
    assertMatch(
      answerIds,
      {
        length: questionsCount,
      },
      'Number of answers incorrect',
    )
    const minBalReq: uint64 = BOX_FLAT_MIN_BALANCE + (32 + 2 + VOTE_INDEX_BYTES * answerIds.length) * BOX_BYTE_MIN_BALANCE
    log(minBalReq)
    assertMatch(
      fundMinBalReq,
      {
        receiver: Global.currentApplicationAddress,
        amount: minBalReq,
      },
      'Payment must be to app and for exactly min balance',
    )
    let cumulativeOffset = Uint64(0)
    for (const questionIndex of urange(questionsCount)) {
      const answerOptionIndex = answerIds.at(questionIndex).native
      const optionsCount = this.optionCounts.value.at(questionIndex).native
      assert(answerOptionIndex < optionsCount, 'Answer option index invalid')
      this.incrementVoteInBox(cumulativeOffset + answerOptionIndex)
      cumulativeOffset += optionsCount
      this.votesByAccount(Txn.sender).value = answerIds.copy()
      this.voterCount.value += 1
    }
  }

  private votingOpen(): boolean {
    return (
      this.isBootstrapped.value &&
      !this.closeTime.hasValue &&
      this.startTime.value <= Global.latestTimestamp &&
      Global.latestTimestamp <= this.endTime.value
    )
  }

  private storeOptionCounts(optionCounts: VoteIndexArray) {
    assertMatch(optionCounts, { length: { between: [Uint64(1), Uint64(112)] } })

    let totalOptions = Uint64(0)
    for (const item of optionCounts) {
      totalOptions += item.native
    }
    this.optionCounts.value = optionCounts.copy()
    this.totalOptions.value = totalOptions
  }

  private getVoteFromBox(index: uint64): uint64 {
    return op.btoi(this.tallyBox.extract(index, VOTE_COUNT_BYTES))
  }

  private incrementVoteInBox(index: uint64): void {
    const currentVote = this.getVoteFromBox(index)
    this.tallyBox.replace(index, op.itob(currentVote + 1))
  }
}
function itoa(i: uint64): string {
  const digits = Bytes`0123456789`
  const radix = digits.length
  if (i < radix) {
    return digits.at(i).toString()
  }
  return `${itoa(i / radix)}${digits.at(i % radix)}`
}



================================================
FILE: packages/algo-ts/readme.md
================================================
# Algorand TypeScript

This package contains definitions for the types which comprise Algorand TypeScript which can be compiled to run on the Algorand Virtual Machine using the Puya compiler.



================================================
FILE: packages/algo-ts/eslint.config.mjs
================================================
import globals from 'globals'
import path from 'node:path'
import { fileURLToPath } from 'node:url'
import js from '@eslint/js'
import { FlatCompat } from '@eslint/eslintrc'

const __filename = fileURLToPath(import.meta.url)
const __dirname = path.dirname(__filename)
const compat = new FlatCompat({
  baseDirectory: __dirname,
  recommendedConfig: js.configs.recommended,
  allConfig: js.configs.all,
})

export default [
  {
    ignores: [
      '**/.eslintrc.js',
      '**/node_modules',
      '**/dist',
      '**/build',
      '**/coverage',
      '**/generated/types.d.ts',
      '**/generated/types.ts',
      '**/.idea',
      '**/.vscode',
    ],
  },
  ...compat.extends('@makerx/eslint-config'),
  {
    languageOptions: {
      globals: {
        ...globals.node,
      },
    },

    rules: {
      '@typescript-eslint/no-unused-vars': 'off',
    },
  },
]



================================================
FILE: packages/algo-ts/package.json
================================================
{
  "name": "@algorandfoundation/algorand-typescript",
  "version": "1.0.0",
  "description": "This package contains definitions for the types which comprise Algorand TypeScript which can be compiled to run on the Algorand Virtual Machine using the Puya compiler.",
  "private": false,
  "main": "index.js",
  "types": "src/index.ts",
  "scripts": {
    "audit": "better-npm-audit audit",
    "format": "prettier --write .",
    "lint": "eslint \"src/**/*.ts\"",
    "lint:fix": "eslint \"src/**/*.ts\" --fix",
    "build": "run-s build:*",
    "build:0-clean": "rimraf dist coverage",
    "build:1-lint": "eslint \"src/**/*.ts\" --max-warnings 0",
    "build:2-check-types": "tsc -p tsconfig.json",
    "build:3-build": "rollup -c --configPlugin typescript",
    "build:4-copy-pkg-json": "tstk copy-package-json -c",
    "build:5-copy-readme": "copyfiles ./readme.md ./dist",
    "watch": "rollup -c -w --configPlugin typescript",
    "test": "echo 'No tests'"
  },
  "devDependencies": {
    "@eslint/eslintrc": "^3.3.1",
    "@eslint/js": "^9.23.0",
    "@makerx/eslint-config": "4.2.0",
    "@makerx/prettier-config": "2.0.1",
    "@makerx/ts-toolkit": "^4.0.0-beta.24",
    "@rollup/plugin-commonjs": "28.0.3",
    "@rollup/plugin-json": "6.1.0",
    "@rollup/plugin-node-resolve": "16.0.1",
    "@rollup/plugin-typescript": "12.1.2",
    "@tsconfig/node20": "20.1.5",
    "@types/node": "22.13.14",
    "@typescript-eslint/eslint-plugin": "8.28.0",
    "@typescript-eslint/parser": "8.28.0",
    "@vitest/coverage-v8": "3.0.9",
    "better-npm-audit": "3.11.0",
    "copyfiles": "2.4.1",
    "eslint": "9.32.0",
    "eslint-config-prettier": "^10.1.1",
    "eslint-plugin-prettier": "^5.2.5",
    "globals": "^16.0.0",
    "npm-run-all": "4.1.5",
    "prettier": "3.5.3",
    "rimraf": "6.0.1",
    "rollup": "4.37.0",
    "tsx": "4.19.3",
    "typescript": "^5.8.2",
    "vitest": "3.0.9"
  },
  "overrides": {
    "cross-spawn": "7.0.5",
    "npm": "10.9.1",
    "esbuild": "0.25.0"
  },
  "peerDependencies": {
    "tslib": "^2.6.2"
  }
}



================================================
FILE: packages/algo-ts/rollup.config.ts
================================================
import commonjs from '@rollup/plugin-commonjs'
import json from '@rollup/plugin-json'
import nodeResolve from '@rollup/plugin-node-resolve'
import typescript from '@rollup/plugin-typescript'
import type { RollupOptions } from 'rollup'

const config: RollupOptions = {
  input: {
    index: 'src/index.ts',
    'arc4/index': 'src/arc4/index.ts',
    op: 'src/op.ts',
    itxn: 'src/itxn.ts',
    gtxn: 'src/gtxn.ts',
  },
  output: [
    {
      dir: 'dist',
      format: 'es',
      exports: 'named',
      entryFileNames: '[name].mjs',
      preserveModules: false,
      sourcemap: true,
    },
  ],
  treeshake: {
    moduleSideEffects: false,
    propertyReadSideEffects: false,
  },
  external: [/node_modules/, /tslib/],
  plugins: [
    typescript({
      tsconfig: 'tsconfig.build.json',
    }),
    commonjs(),
    nodeResolve(),
    json(),
  ],
}

export default config



================================================
FILE: packages/algo-ts/tsconfig.build.json
================================================
{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "outDir": "./dist/",
    "noEmit": false,
    "declaration": true,
    "stripInternal": true
  },
  "include": ["src/**/*.ts"]
}



================================================
FILE: packages/algo-ts/tsconfig.json
================================================
{
  "extends": "@tsconfig/node20/tsconfig.json",
  "compilerOptions": {
    "noEmit": true,
    "lib": [
      "ES2023"
    ],
    "target": "ES2023",
    "module": "ESNext",
    "moduleResolution": "Bundler",
    "resolveJsonModule": true,
    "esModuleInterop": true
  },
  "include": ["src/**/*.ts","rollup.config.ts"]
}



================================================
FILE: packages/algo-ts/vitest.config.mts
================================================
import typescript from '@rollup/plugin-typescript'
import { defineConfig } from 'vitest/config'

export default defineConfig({
  plugins: [
    typescript({
      tsconfig: 'tsconfig.json',
    }),
  ],
})



================================================
FILE: packages/algo-ts/.nsprc
================================================
{}



================================================
FILE: packages/algo-ts/.prettierignore
================================================
# don't ever format node_modules
node_modules
# don't lint format output (make sure it's set to your correct build folder name)
dist
build
# don't format nyc coverage output
coverage
# don't format generated types
**/generated/types.d.ts
**/generated/types.ts
# don't format ide files
.idea



================================================
FILE: packages/algo-ts/.prettierrc.cjs
================================================
module.exports = {
  ...require('@makerx/prettier-config'),
}



================================================
FILE: packages/algo-ts/.tstoolkitrc.ts
================================================
import type { TsToolkitConfig } from '@makerx/ts-toolkit'

const config: TsToolkitConfig = {
  packageConfig: {
    srcDir: 'src',
    outDir: 'dist',
    moduleType: 'module',
    main: 'index.ts',
    exports: {
      '.': 'index.ts',
      './arc4': 'arc4/index.ts',
      './op': 'op.ts',
      './itxn': 'itxn.ts',
      './gtnx': 'gtxn.ts',
    },
  },
}
export default config



================================================
FILE: packages/algo-ts/src/arc-28.ts
================================================
import { NoImplementation } from './internal/errors'
import { DeliberateAny } from './internal/typescript-helpers'

/**
 * Emit an arc28 event log using either an ARC4Struct type or a named object type.
 * Object types must have an ARC4 equivalent type.
 *
 * Anonymous types cannot be used as the type name is used to determine the event prefix
 * @param event An ARC4Struct instance, or a plain object with a named type
 *
 * @example
 * class Demo extends Struct<{ a: UintN64 }> {}
 * emit(new Demo({ a: new UintN64(123) }))
 *
 * @example
 * type Demo = { a: uint64 }
 * emit<Demo>({a: 123})
 * // or
 * const d: Demo = { a: 123 }
 * emit(d)
 */
export function emit<TEvent extends Record<string, DeliberateAny>>(event: TEvent): void
/**
 * Emit an arc28 event log using an explicit name and inferred property/field types.
 * Property types must be ARC4 or have an ARC4 equivalent type.
 * @param eventName The name of the event (must be a compile time constant)
 * @param eventProps A set of event properties (order is significant)
 *
 * @example
 * emit("Demo", new UintN64(123))
 *
 * @example
 * const a: uint64 = 123
 * emit("Demo", a)
 */
export function emit<TProps extends [...DeliberateAny[]]>(eventName: string, ...eventProps: TProps): void
export function emit<T>(event: T | string, ...eventProps: unknown[]): void {
  throw new NoImplementation()
}



================================================
FILE: packages/algo-ts/src/base-contract.ts
================================================
import { NoImplementation } from './internal/errors'
import { ConstructorFor } from './internal/typescript-helpers'
import { uint64 } from './primitives'
import { NumberRange } from './util'

/**
 * The base type for all Algorand TypeScript contracts
 */
export abstract class BaseContract {
  /**
   * The program to be run when the On Completion Action is != ClearState (3)
   */
  public abstract approvalProgram(): boolean | uint64

  /**
   * The program to be run when the On Completion Action is == ClearState (3)
   */
  public clearStateProgram(): boolean | uint64 {
    return true
  }
}

/**
 * Options class to manually define the total amount of global and local state contract will use.
 *
 * This is not required when all state is assigned to `this.`, but is required if a
 * contract dynamically interacts with state via `AppGlobal.getBytes` etc, or if you want
 * to reserve additional state storage for future contract updates, since the Algorand protocol
 * doesn't allow increasing them after creation.
 */
export type StateTotals = {
  globalUints?: number
  globalBytes?: number
  localUints?: number
  localBytes?: number
}

/**
 * Additional configuration options for a contract
 */
export type ContractOptions = {
  /**
   * Determines which AVM version to use, this affects what operations are supported.
   * Defaults to value provided supplied on command line (which defaults to current mainnet version)
   */
  avmVersion?: 10 | 11

  /**
   * Override the name of the logic signature when generating build artifacts.
   * Defaults to the class name
   */
  name?: string
  /**
   * Allows you to mark a slot ID or range of slot IDs as "off limits" to Puya.
   * These slot ID(s) will never be written to or otherwise manipulating by the compiler itself.
   * This is particularly useful in combination with `op.gload_bytes` / `op.gload_uint64`
   * which lets a contract in a group transaction read from the scratch slots of another contract
   * that occurs earlier in the transaction group.
   *
   * In the case of inheritance, scratch slots reserved become cumulative. It is not an error
   * to have overlapping ranges or values either, so if a base class contract reserves slots
   * 0-5 inclusive and the derived contract reserves 5-10 inclusive, then within the derived
   * contract all slots 0-10 will be marked as reserved.
   */
  scratchSlots?: Array<number | NumberRange>
  /**
   * Allows defining what values should be used for global and local uint and bytes storage
   * values when creating a contract. Used when outputting ARC-32 application.json schemas.
   *
   * If left unspecified, the totals will be determined by the compiler based on state
   * variables assigned to `this`.
   *
   * This setting is not inherited, and only applies to the exact `Contract` it is specified
   * on. If a base class does specify this setting, and a derived class does not, a warning
   * will be emitted for the derived class. To resolve this warning, `stateTotals` must be
   * specified. An empty object may be provided in order to indicate that this contract should
   * revert to the default behaviour
   */
  stateTotals?: StateTotals
}

/**
 * The contract decorator can be used to specify additional configuration options for a smart contract
 * @param options An object containing the configuration options
 */
export function contract(options: ContractOptions) {
  return <T extends ConstructorFor<BaseContract>>(contract: T, ctx: ClassDecoratorContext) => {
    throw new NoImplementation()
  }
}



================================================
FILE: packages/algo-ts/src/box.ts
================================================
import { NoImplementation } from './internal/errors'
import { bytes, uint64 } from './primitives'

/**
 * A Box proxy
 * @typeParam TValue The type of the data stored in the box.
 */
export type Box<TValue> = {
  /**
   * Create the box for this proxy with a bzero value.
   *  - If options.size is specified, the box will be created with that length
   *  - Otherwise the box will be created with arc4EncodedLength(TValue). Errors if the encoded length is not fixed
   *
   * No op if the box already exists
   * @returns True if the box was created, false if it already existed
   */
  create(options?: { size?: uint64 }): boolean
  /**
   * Get the key used by this box proxy
   */
  readonly key: bytes
  /**
   * Get or set the value stored in the box
   *
   * Get will error if the box does not exist
   */
  value: TValue
  /**
   * Get a boolean indicating if the box exists or not
   */
  readonly exists: boolean
  /**
   * Get the value stored in the box, or return a specified default value if the box does not exist
   * @param options Options to specify a default value to be returned if no other value exists
   * @returns The value if the box exists, else the default value
   */
  get(options: { default: TValue }): TValue
  /**
   * Delete the box associated with this proxy if it exists.
   * @returns True if the box existed and was deleted, else false
   */
  delete(): boolean
  /**
   * Get the value stored in the box if available, and a boolean indicating if the box exists.
   *
   * If the box does not exist, the value returned at position 0 should not be relied on to have a valid value.
   * @returns A tuple with the first item being the box value, and the second item being a boolean indicating if the box exists.
   */
  maybe(): readonly [TValue, boolean]
  /**
   * Returns the length of the box, or error if the box does not exist
   */
  readonly length: uint64
}
/**
 * A BoxMap proxy
 * @typeParam TKey The type of the value used to key each box.
 * @typeParam TValue The type of the data stored in the box.
 */
export type BoxMap<TKey, TValue> = {
  /**
   * Get the bytes used to prefix each key
   */
  readonly keyPrefix: bytes

  /**
   * Get a Box proxy for a single item in the BoxMap
   * @param key The key of the box to retrieve a proxy for
   */
  (key: TKey): Box<TValue>
}

/**
 * A BoxRef proxy
 */
export type BoxRef = {
  /**
   * Get the key used by this box proxy
   */
  readonly key: bytes
  /**
   * Get a boolean indicating if the box exists or not
   */
  readonly exists: boolean
  /**
   * Get the value of the box.
   *
   * Error if this value is larger than what the `bytes` type supports
   * Error if getting the value and the box does not exist
   */
  value: bytes
  /**
   * Get the value stored in the box, or return a specified default value if the box does not exist
   * @param options Options to specify a default value to be returned if no other value exists
   * @returns The value if the box exists, else the default value
   */
  get(options: { default: bytes }): bytes
  /**
   * Puts the specified bytes into the box replacing any existing value.
   *
   * Creates the box if it does not exist
   * Errors if the box exists, but the length does not match the length of `value`
   * @param value The value to put into the box
   */
  put(value: bytes): void
  /**
   * Splice the specified bytes into the box starting at `start`, removing `length` bytes
   * from the existing value and replacing them with `value` before appending the remainder of the original box value.
   *
   * If the resulting byte value is larger than length, bytes will be trimmed from the end
   * If the resulting byte value is smaller than length, zero bytes will be appended to the end
   * Error if the box does not exist
   * @param start The index to start inserting the value
   * @param length The number of bytes after `start` to be omitted
   * @param value The value to be inserted
   */
  splice(start: uint64, length: uint64, value: bytes): void
  /**
   * Replace bytes in a box starting at `start`.
   *
   * Error if the box does not exist
   * Error if `start` + `value.length` is greater than the box size
   * @param start The index to start replacing
   * @param value The value to be written
   */
  replace(start: uint64, value: bytes): void
  /**
   * Extract a slice of bytes from the box
   *
   * Error if the box does not exist
   * Error if `start` + `length` is greater than the box size
   * @param start The index to start extracting
   * @param length The number of bytes to extract
   * @returns The extracted bytes
   */
  extract(start: uint64, length: uint64): bytes
  /**
   * Delete the box associated with this proxy if it exists.
   * @returns True if the box existed and was deleted, else false
   */
  delete(): boolean
  /**
   * Create the box for this proxy with the specified size if it does not exist
   *
   * No op if the box already exists
   * @param options The size of the box to create
   * @returns True if the box was created, false if it already existed
   */
  create(options: { size: uint64 }): boolean
  /**
   * Resize the box to the specified size.
   *
   * Adds zero bytes to the end if the new size is larger
   * Removes end bytes if the new size is smaller
   * Error if the box does not exist
   * @param newSize The new size for the box
   */
  resize(newSize: uint64): void
  /**
   * Get the value stored in the box if available, and a boolean indicating if the box exists.
   *
   * If the box does not exist, the value returned at position 0 will be an empty byte array.
   * @returns A tuple with the first item being the box value, and the second item being a boolean indicating if the box exists.
   */
  maybe(): readonly [bytes, boolean]
  /**
   * Returns the length of the box, or error if the box does not exist
   */
  readonly length: uint64
}

/**
 * Options for creating a Box proxy
 */
interface CreateBoxOptions {
  /**
   * The bytes which make up the key of the box
   */
  key: bytes | string
}

/**
 * Creates a Box proxy object offering methods of getting and setting the value stored in a single box.
 * @param options Options for creating the Box proxy
 * @typeParam TValue The type of the data stored in the box. This value will be encoded to bytes when stored and decoded on retrieval.
 */
export function Box<TValue>(options: CreateBoxOptions): Box<TValue> {
  throw new NoImplementation()
}

/**
 * Options for creating a BoxMap proxy
 */
interface CreateBoxMapOptions {
  /**
   * The bytes which prefix each key of the box map
   */
  keyPrefix: bytes | string
}

/**
 * Creates a BoxMap proxy object offering methods of getting and setting a set of values stored in individual boxes indexed by a common key type
 * @param options Options for creating the BoxMap proxy
 * @typeParam TKey The type of the value used to key each box. This key will be encoded to bytes and prefixed with `keyPrefix`
 * @typeParam TValue The type of the data stored in the box. This value will be encoded to bytes when stored and decoded on retrieval.
 */
export function BoxMap<TKey, TValue>(options: CreateBoxMapOptions): BoxMap<TKey, TValue> {
  throw new NoImplementation()
}

/**
 * Options for creating a BoxRef proxy
 */
interface CreateBoxRefOptions {
  /**
   * The bytes which make up the key of the box
   */
  key: bytes | string
}

/**
 * Creates a BoxRef proxy object offering methods for getting and setting binary data in a box under a single key. This proxy is particularly
 * relevant when dealing with binary data that is larger than what the AVM can handle in a single value.
 * @param options The options for creating the BoxRef proxy
 */
export function BoxRef(options: CreateBoxRefOptions): BoxRef {
  throw new NoImplementation()
}



================================================
FILE: packages/algo-ts/src/compiled.ts
================================================
import { BaseContract } from './base-contract'
import { NoImplementation } from './internal/errors'
import { ConstructorFor, DeliberateAny } from './internal/typescript-helpers'
import { LogicSig } from './logic-sig'
import { bytes, uint64 } from './primitives'
import { Account } from './reference'

/**
 * Provides compiled programs and state allocation values for a Contract. Created by calling `compile(ExampleContractType)`
 */
export type CompiledContract = {
  /**
   * Approval program pages for a contract, after template variables have been replaced and compiled to AVM bytecode
   */
  approvalProgram: [bytes, bytes]
  /**
   * Clear state program pages for a contract, after template variables have been replaced and compiled to AVM bytecode
   */
  clearStateProgram: [bytes, bytes]
  /**
   * By default, provides extra program pages required based on approval and clear state program size, can be overridden when calling `compile(ExampleContractType, { extraProgramPages: ... })`
   */
  extraProgramPages: uint64
  /**
   * By default, provides global num uints based on contract state totals, can be overridden when calling `compile(ExampleContractType, { globalUints: ... })`
   */
  globalUints: uint64
  /**
   * By default, provides global num bytes based on contract state totals, can be overridden when calling `compile(ExampleContractType, { globalBytes: ... })`
   */
  globalBytes: uint64
  /**
   * By default, provides local num uints based on contract state totals, can be overridden when calling `compile(ExampleContractType, { localUints: ... })`
   */
  localUints: uint64
  /**
   * By default, provides local num bytes based on contract state totals, can be overridden  when calling `compile(ExampleContractType, { localBytes: ... })`
   */
  localBytes: uint64
}

/**
 * Provides account for a Logic Signature. Created by calling `compile(LogicSigType)`
 */
export type CompiledLogicSig = {
  /**
   * Address of a logic sig program, after template variables have been replaced and compiled to AVM bytecode
   */
  account: Account
}

/**
 * Options for compiling a contract
 */
export type CompileContractOptions = {
  /**
   * Number of extra program pages, defaults to minimum required for contract
   */
  extraProgramPages?: uint64
  /**
   * Number of global uint64s, defaults to value defined for contract
   */
  globalUints?: uint64
  /**
   * Number of global bytes, defaults to value defined for contract
   */
  globalBytes?: uint64
  /**
   * Number of local uint64s, defaults to value defined for contract
   */
  localUints?: uint64
  /**
   * Number of local bytes, defaults to value defined for contract
   */
  localBytes?: uint64
  /**
   * Template variables to substitute into the contract, key should be without the prefix, must evaluate to a compile time constant
   * and match the type of the template var declaration
   */
  templateVars?: Record<string, DeliberateAny>
  /**
   * Prefix to add to provided template vars, defaults to the prefix supplied on command line (which defaults to TMPL_)
   */
  templateVarsPrefix?: string
}

/**
 * Options for compiling a logic signature
 */
export type CompileLogicSigOptions = {
  /**
   * Template variables to substitute into the contract, key should be without the prefix, must evaluate to a compile time constant
   * and match the type of the template var declaration
   */
  templateVars?: Record<string, DeliberateAny>
  /**
   * Prefix to add to provided template vars, defaults to the prefix supplied on command line (which defaults to TMPL_)
   */
  templateVarsPrefix?: string
}

/**
 * Compile a contract and return the resulting byte code for approval and clear state programs.
 * @param contract The contract class to compile
 * @param options Options for compiling the contract
 */
export function compile(contract: ConstructorFor<BaseContract>, options?: CompileContractOptions): CompiledContract
/**
 * Compile a logic signature and return an account ready for signing transactions.
 * @param logicSig The logic sig class to compile
 * @param options Options for compiling the logic sig
 */
export function compile(logicSig: ConstructorFor<LogicSig>, options?: CompileLogicSigOptions): CompiledLogicSig
export function compile(artefact: ConstructorFor<BaseContract> | ConstructorFor<LogicSig>): CompiledLogicSig | CompiledContract {
  throw new NoImplementation()
}



================================================
FILE: packages/algo-ts/src/gtxn.ts
================================================
/* THIS FILE IS GENERATED BY ~/scripts/generate-txn-types.ts - DO NOT MODIFY DIRECTLY */
import { OnCompleteAction } from './on-complete-action'
import { bytes, uint64 } from './primitives'
import { Account, Application, Asset } from './reference'
import { TransactionType } from './transactions'
import { NoImplementation } from './internal/errors'
const isGtxn = Symbol('isGtxn')
/**
 * A group transaction of type 'pay'
 */
export interface PaymentTxn {
  /** @hidden */
  [isGtxn]?: true
  /**
   * 32 byte address
   */
  readonly sender: Account
  /**
   * microalgos
   */
  readonly fee: uint64
  /**
   * round number
   */
  readonly firstValid: uint64
  /**
   * UNIX timestamp of block before txn.FirstValid. Fails if negative
   */
  readonly firstValidTime: uint64
  /**
   * round number
   */
  readonly lastValid: uint64
  /**
   * Any data up to 1024 bytes
   */
  readonly note: bytes
  /**
   * 32 byte lease value
   */
  readonly lease: bytes
  /**
   * Transaction type as bytes
   */
  readonly typeBytes: bytes
  /**
   * Transaction type
   */
  readonly type: TransactionType.Payment
  /**
   * Position of this transaction within an atomic group
   * A stand-alone transaction is implicitly element 0 in a group of 1
   */
  readonly groupIndex: uint64
  /**
   * The computed ID for this transaction. 32 bytes.
   */
  readonly txnId: bytes
  /**
   * 32 byte Sender's new AuthAddr
   */
  readonly rekeyTo: Account
  /**
   * 32 byte address
   */
  readonly receiver: Account
  /**
   * microalgos
   */
  readonly amount: uint64
  /**
   * 32 byte address
   */
  readonly closeRemainderTo: Account
}
/**
 * A group transaction of type 'keyreg'
 */
export interface KeyRegistrationTxn {
  /** @hidden */
  [isGtxn]?: true
  /**
   * 32 byte address
   */
  readonly sender: Account
  /**
   * microalgos
   */
  readonly fee: uint64
  /**
   * round number
   */
  readonly firstValid: uint64
  /**
   * UNIX timestamp of block before txn.FirstValid. Fails if negative
   */
  readonly firstValidTime: uint64
  /**
   * round number
   */
  readonly lastValid: uint64
  /**
   * Any data up to 1024 bytes
   */
  readonly note: bytes
  /**
   * 32 byte lease value
   */
  readonly lease: bytes
  /**
   * Transaction type as bytes
   */
  readonly typeBytes: bytes
  /**
   * Transaction type
   */
  readonly type: TransactionType.KeyRegistration
  /**
   * Position of this transaction within an atomic group
   * A stand-alone transaction is implicitly element 0 in a group of 1
   */
  readonly groupIndex: uint64
  /**
   * The computed ID for this transaction. 32 bytes.
   */
  readonly txnId: bytes
  /**
   * 32 byte Sender's new AuthAddr
   */
  readonly rekeyTo: Account
  /**
   * 32 byte address
   */
  readonly voteKey: bytes
  /**
   * 32 byte address
   */
  readonly selectionKey: bytes
  /**
   * The first round that the participation key is valid.
   */
  readonly voteFirst: uint64
  /**
   * The last round that the participation key is valid.
   */
  readonly voteLast: uint64
  /**
   * Dilution for the 2-level participation key
   */
  readonly voteKeyDilution: uint64
  /**
   * Marks an account nonparticipating for rewards
   */
  readonly nonparticipation: boolean
  /**
   * 64 byte state proof public key
   */
  readonly stateProofKey: bytes
}
/**
 * A group transaction of type 'acfg'
 */
export interface AssetConfigTxn {
  /** @hidden */
  [isGtxn]?: true
  /**
   * 32 byte address
   */
  readonly sender: Account
  /**
   * microalgos
   */
  readonly fee: uint64
  /**
   * round number
   */
  readonly firstValid: uint64
  /**
   * UNIX timestamp of block before txn.FirstValid. Fails if negative
   */
  readonly firstValidTime: uint64
  /**
   * round number
   */
  readonly lastValid: uint64
  /**
   * Any data up to 1024 bytes
   */
  readonly note: bytes
  /**
   * 32 byte lease value
   */
  readonly lease: bytes
  /**
   * Transaction type as bytes
   */
  readonly typeBytes: bytes
  /**
   * Transaction type
   */
  readonly type: TransactionType.AssetConfig
  /**
   * Position of this transaction within an atomic group
   * A stand-alone transaction is implicitly element 0 in a group of 1
   */
  readonly groupIndex: uint64
  /**
   * The computed ID for this transaction. 32 bytes.
   */
  readonly txnId: bytes
  /**
   * 32 byte Sender's new AuthAddr
   */
  readonly rekeyTo: Account
  /**
   * Asset ID in asset config transaction
   */
  readonly configAsset: Asset
  /**
   * The asset created by this transaction
   */
  readonly createdAsset: Asset
  /**
   * Total number of units of this asset created
   */
  readonly total: uint64
  /**
   * Number of digits to display after the decimal place when displaying the asset
   */
  readonly decimals: uint64
  /**
   * Whether the asset's slots are frozen by default or not, 0 or 1
   */
  readonly defaultFrozen: boolean
  /**
   * Unit name of the asset
   */
  readonly unitName: bytes
  /**
   * The asset name
   */
  readonly assetName: bytes
  /**
   * URL
   */
  readonly url: bytes
  /**
   * 32 byte commitment to unspecified asset metadata
   */
  readonly metadataHash: bytes
  /**
   * 32 byte address
   */
  readonly manager: Account
  /**
   * 32 byte address
   */
  readonly reserve: Account
  /**
   * 32 byte address
   */
  readonly freeze: Account
  /**
   * 32 byte address
   */
  readonly clawback: Account
}
/**
 * A group transaction of type 'axfer'
 */
export interface AssetTransferTxn {
  /** @hidden */
  [isGtxn]?: true
  /**
   * 32 byte address
   */
  readonly sender: Account
  /**
   * microalgos
   */
  readonly fee: uint64
  /**
   * round number
   */
  readonly firstValid: uint64
  /**
   * UNIX timestamp of block before txn.FirstValid. Fails if negative
   */
  readonly firstValidTime: uint64
  /**
   * round number
   */
  readonly lastValid: uint64
  /**
   * Any data up to 1024 bytes
   */
  readonly note: bytes
  /**
   * 32 byte lease value
   */
  readonly lease: bytes
  /**
   * Transaction type as bytes
   */
  readonly typeBytes: bytes
  /**
   * Transaction type
   */
  readonly type: TransactionType.AssetTransfer
  /**
   * Position of this transaction within an atomic group
   * A stand-alone transaction is implicitly element 0 in a group of 1
   */
  readonly groupIndex: uint64
  /**
   * The computed ID for this transaction. 32 bytes.
   */
  readonly txnId: bytes
  /**
   * 32 byte Sender's new AuthAddr
   */
  readonly rekeyTo: Account
  /**
   * Asset ID
   */
  readonly xferAsset: Asset
  /**
   * value in Asset's units
   */
  readonly assetAmount: uint64
  /**
   * 32 byte address. Source of assets if Sender is the Asset's Clawback address.
   */
  readonly assetSender: Account
  /**
   * 32 byte address
   */
  readonly assetReceiver: Account
  /**
   * 32 byte address
   */
  readonly assetCloseTo: Account
}
/**
 * A group transaction of type 'afrz'
 */
export interface AssetFreezeTxn {
  /** @hidden */
  [isGtxn]?: true
  /**
   * 32 byte address
   */
  readonly sender: Account
  /**
   * microalgos
   */
  readonly fee: uint64
  /**
   * round number
   */
  readonly firstValid: uint64
  /**
   * UNIX timestamp of block before txn.FirstValid. Fails if negative
   */
  readonly firstValidTime: uint64
  /**
   * round number
   */
  readonly lastValid: uint64
  /**
   * Any data up to 1024 bytes
   */
  readonly note: bytes
  /**
   * 32 byte lease value
   */
  readonly lease: bytes
  /**
   * Transaction type as bytes
   */
  readonly typeBytes: bytes
  /**
   * Transaction type
   */
  readonly type: TransactionType.AssetFreeze
  /**
   * Position of this transaction within an atomic group
   * A stand-alone transaction is implicitly element 0 in a group of 1
   */
  readonly groupIndex: uint64
  /**
   * The computed ID for this transaction. 32 bytes.
   */
  readonly txnId: bytes
  /**
   * 32 byte Sender's new AuthAddr
   */
  readonly rekeyTo: Account
  /**
   * Asset ID being frozen or un-frozen
   */
  readonly freezeAsset: Asset
  /**
   * 32 byte address of the account whose asset slot is being frozen or un-frozen
   */
  readonly freezeAccount: Account
  /**
   * The new frozen value
   */
  readonly frozen: boolean
}
/**
 * A group transaction of type 'appl'
 */
export interface ApplicationCallTxn {
  /** @hidden */
  [isGtxn]?: true
  /**
   * 32 byte address
   */
  readonly sender: Account
  /**
   * microalgos
   */
  readonly fee: uint64
  /**
   * round number
   */
  readonly firstValid: uint64
  /**
   * UNIX timestamp of block before txn.FirstValid. Fails if negative
   */
  readonly firstValidTime: uint64
  /**
   * round number
   */
  readonly lastValid: uint64
  /**
   * Any data up to 1024 bytes
   */
  readonly note: bytes
  /**
   * 32 byte lease value
   */
  readonly lease: bytes
  /**
   * Transaction type as bytes
   */
  readonly typeBytes: bytes
  /**
   * Transaction type
   */
  readonly type: TransactionType.ApplicationCall
  /**
   * Position of this transaction within an atomic group
   * A stand-alone transaction is implicitly element 0 in a group of 1
   */
  readonly groupIndex: uint64
  /**
   * The computed ID for this transaction. 32 bytes.
   */
  readonly txnId: bytes
  /**
   * 32 byte Sender's new AuthAddr
   */
  readonly rekeyTo: Account
  /**
   * ApplicationID from ApplicationCall transaction
   */
  readonly appId: Application
  /**
   * ApplicationCall transaction on completion action
   */
  readonly onCompletion: OnCompleteAction
  /**
   * Number of ApplicationArgs
   */
  readonly numAppArgs: uint64
  /**
   * Number of ApplicationArgs
   */
  readonly numAccounts: uint64
  /**
   * The first page of the Approval program
   */
  readonly approvalProgram: bytes
  /**
   * The first page of the Clear State program
   */
  readonly clearStateProgram: bytes
  /**
   * Number of Assets
   */
  readonly numAssets: uint64
  /**
   * Number of Applications
   */
  readonly numApps: uint64
  /**
   * Number of global state integers this application makes use of.
   */
  readonly globalNumUint: uint64
  /**
   * Number of global state byteslices this application makes use of.
   */
  readonly globalNumBytes: uint64
  /**
   * Number of local state integers this application makes use of.
   */
  readonly localNumUint: uint64
  /**
   * Number of local state byteslices this application makes use of.
   */
  readonly localNumBytes: uint64
  /**
   * Number of additional pages for each of the application's approval and clear state program
   */
  readonly extraProgramPages: uint64
  /**
   * The last message emitted. Empty bytes if none were emitted. App mode only
   */
  readonly lastLog: bytes
  /**
   * Read application logs
   * @param index Index of the log to get
   */
  logs(index: uint64): bytes
  /**
   * Number of Approval Program pages
   */
  readonly numApprovalProgramPages: uint64
  /**
   * All approval program pages
   * @param index Index of the page to get
   */
  approvalProgramPages(index: uint64): bytes
  /**
   * Number of Clear State Program pages
   */
  readonly numClearStateProgramPages: uint64
  /**
   * All clear state program pages
   * @param index Index of the page to get
   */
  clearStateProgramPages(index: uint64): bytes
  /**
   * Arguments passed to the application in the ApplicationCall transaction
   * @param index Index of the arg to get
   */
  appArgs(index: uint64): bytes
  /**
   * Accounts listed in the ApplicationCall transaction
   * @param index Index of the account to get
   */
  accounts(index: uint64): Account
  /**
   * Foreign Assets listed in the ApplicationCall transaction
   * @param index Index of the asset to get
   */
  assets(index: uint64): Asset
  /**
   * Foreign Apps listed in the ApplicationCall transaction
   * @param index Index of the application to get
   */
  apps(index: uint64): Application
  /**
   * The id of the created application
   */
  readonly createdApp: Application
  /**
   * Number of logs
   */
  readonly numLogs: uint64
}
/**
 * A group transaction of any type
 */
export type Transaction = PaymentTxn | KeyRegistrationTxn | AssetConfigTxn | AssetTransferTxn | AssetFreezeTxn | ApplicationCallTxn
/**
 * Get the nth transaction in the group without verifying its type
 * @param n The index of the txn in the group
 */
export function Transaction(n: uint64): Transaction {
  throw new NoImplementation()
}
/**
 * Get the nth transaction in the group
 * Verifies the txn type is 'pay'
 * @param n The index of the txn in the group
 */
export function PaymentTxn(n: uint64): PaymentTxn {
  throw new NoImplementation()
}
/**
 * Get the nth transaction in the group
 * Verifies the txn type is 'keyreg'
 * @param n The index of the txn in the group
 */
export function KeyRegistrationTxn(n: uint64): KeyRegistrationTxn {
  throw new NoImplementation()
}
/**
 * Get the nth transaction in the group
 * Verifies the txn type is 'acfg'
 * @param n The index of the txn in the group
 */
export function AssetConfigTxn(n: uint64): AssetConfigTxn {
  throw new NoImplementation()
}
/**
 * Get the nth transaction in the group
 * Verifies the txn type is 'axfer'
 * @param n The index of the txn in the group
 */
export function AssetTransferTxn(n: uint64): AssetTransferTxn {
  throw new NoImplementation()
}
/**
 * Get the nth transaction in the group
 * Verifies the txn type is 'afrz'
 * @param n The index of the txn in the group
 */
export function AssetFreezeTxn(n: uint64): AssetFreezeTxn {
  throw new NoImplementation()
}
/**
 * Get the nth transaction in the group
 * Verifies the txn type is 'appl'
 * @param n The index of the txn in the group
 */
export function ApplicationCallTxn(n: uint64): ApplicationCallTxn {
  throw new NoImplementation()
}



================================================
FILE: packages/algo-ts/src/index.ts
================================================
export * from './primitives'
export { log, err, assert, match, assertMatch, ensureBudget, urange, OpUpFeeSource } from './util'
export * from './reference'
export * as op from './op'
export { Txn, Global } from './op'
export * as arc4 from './arc4'
export { Contract, abimethod, baremethod } from './arc4'
export { BaseContract, contract } from './base-contract'
export { BoxRef, BoxMap, Box } from './box'
export * from './state'
export * as itxn from './itxn'
export * as gtxn from './gtxn'
export { TransactionType } from './transactions'
export { LogicSig, logicsig } from './logic-sig'
export { TemplateVar } from './template-var'
export { Base64, Ec, Ecdsa, MimcConfigurations, VrfVerify } from './op'
export { compile, CompiledContract, CompiledLogicSig, CompileContractOptions, CompileLogicSigOptions } from './compiled'
export { MutableArray } from './mutable-array'
export { emit } from './arc-28'
export { OnCompleteAction, OnCompleteActionStr } from './on-complete-action'



================================================
FILE: packages/algo-ts/src/itxn.ts
================================================
/* THIS FILE IS GENERATED BY ~/scripts/generate-txn-types.ts - DO NOT MODIFY DIRECTLY */
import { OnCompleteAction } from './on-complete-action'
import { bytes, uint64 } from './primitives'
import { Account, Application, Asset } from './reference'
import { TransactionType } from './transactions'
import { NoImplementation } from './internal/errors'
const isItxn = Symbol('isItxn')

/**
 * An inner transaction of type 'pay'
 */
export interface PaymentInnerTxn {
  /** @hidden */
  [isItxn]?: true
  /**
   * 32 byte address
   */
  readonly sender: Account
  /**
   * microalgos
   */
  readonly fee: uint64
  /**
   * round number
   */
  readonly firstValid: uint64
  /**
   * UNIX timestamp of block before txn.FirstValid. Fails if negative
   */
  readonly firstValidTime: uint64
  /**
   * round number
   */
  readonly lastValid: uint64
  /**
   * Any data up to 1024 bytes
   */
  readonly note: bytes
  /**
   * 32 byte lease value
   */
  readonly lease: bytes
  /**
   * Transaction type as bytes
   */
  readonly typeBytes: bytes
  /**
   * Transaction type
   */
  readonly type: TransactionType.Payment
  /**
   * Position of this transaction within an atomic group
   * A stand-alone transaction is implicitly element 0 in a group of 1
   */
  readonly groupIndex: uint64
  /**
   * The computed ID for this transaction. 32 bytes.
   */
  readonly txnId: bytes
  /**
   * 32 byte Sender's new AuthAddr
   */
  readonly rekeyTo: Account
  /**
   * 32 byte address
   */
  readonly receiver: Account
  /**
   * microalgos
   */
  readonly amount: uint64
  /**
   * 32 byte address
   */
  readonly closeRemainderTo: Account
}
/**
 * An inner transaction of type 'keyreg'
 */
export interface KeyRegistrationInnerTxn {
  /** @hidden */
  [isItxn]?: true
  /**
   * 32 byte address
   */
  readonly sender: Account
  /**
   * microalgos
   */
  readonly fee: uint64
  /**
   * round number
   */
  readonly firstValid: uint64
  /**
   * UNIX timestamp of block before txn.FirstValid. Fails if negative
   */
  readonly firstValidTime: uint64
  /**
   * round number
   */
  readonly lastValid: uint64
  /**
   * Any data up to 1024 bytes
   */
  readonly note: bytes
  /**
   * 32 byte lease value
   */
  readonly lease: bytes
  /**
   * Transaction type as bytes
   */
  readonly typeBytes: bytes
  /**
   * Transaction type
   */
  readonly type: TransactionType.KeyRegistration
  /**
   * Position of this transaction within an atomic group
   * A stand-alone transaction is implicitly element 0 in a group of 1
   */
  readonly groupIndex: uint64
  /**
   * The computed ID for this transaction. 32 bytes.
   */
  readonly txnId: bytes
  /**
   * 32 byte Sender's new AuthAddr
   */
  readonly rekeyTo: Account
  /**
   * 32 byte address
   */
  readonly voteKey: bytes
  /**
   * 32 byte address
   */
  readonly selectionKey: bytes
  /**
   * The first round that the participation key is valid.
   */
  readonly voteFirst: uint64
  /**
   * The last round that the participation key is valid.
   */
  readonly voteLast: uint64
  /**
   * Dilution for the 2-level participation key
   */
  readonly voteKeyDilution: uint64
  /**
   * Marks an account nonparticipating for rewards
   */
  readonly nonparticipation: boolean
  /**
   * 64 byte state proof public key
   */
  readonly stateProofKey: bytes
}
/**
 * An inner transaction of type 'acfg'
 */
export interface AssetConfigInnerTxn {
  /** @hidden */
  [isItxn]?: true
  /**
   * 32 byte address
   */
  readonly sender: Account
  /**
   * microalgos
   */
  readonly fee: uint64
  /**
   * round number
   */
  readonly firstValid: uint64
  /**
   * UNIX timestamp of block before txn.FirstValid. Fails if negative
   */
  readonly firstValidTime: uint64
  /**
   * round number
   */
  readonly lastValid: uint64
  /**
   * Any data up to 1024 bytes
   */
  readonly note: bytes
  /**
   * 32 byte lease value
   */
  readonly lease: bytes
  /**
   * Transaction type as bytes
   */
  readonly typeBytes: bytes
  /**
   * Transaction type
   */
  readonly type: TransactionType.AssetConfig
  /**
   * Position of this transaction within an atomic group
   * A stand-alone transaction is implicitly element 0 in a group of 1
   */
  readonly groupIndex: uint64
  /**
   * The computed ID for this transaction. 32 bytes.
   */
  readonly txnId: bytes
  /**
   * 32 byte Sender's new AuthAddr
   */
  readonly rekeyTo: Account
  /**
   * Asset ID in asset config transaction
   */
  readonly configAsset: Asset
  /**
   * The asset created by this transaction
   */
  readonly createdAsset: Asset
  /**
   * Total number of units of this asset created
   */
  readonly total: uint64
  /**
   * Number of digits to display after the decimal place when displaying the asset
   */
  readonly decimals: uint64
  /**
   * Whether the asset's slots are frozen by default or not, 0 or 1
   */
  readonly defaultFrozen: boolean
  /**
   * Unit name of the asset
   */
  readonly unitName: bytes
  /**
   * The asset name
   */
  readonly assetName: bytes
  /**
   * URL
   */
  readonly url: bytes
  /**
   * 32 byte commitment to unspecified asset metadata
   */
  readonly metadataHash: bytes
  /**
   * 32 byte address
   */
  readonly manager: Account
  /**
   * 32 byte address
   */
  readonly reserve: Account
  /**
   * 32 byte address
   */
  readonly freeze: Account
  /**
   * 32 byte address
   */
  readonly clawback: Account
}
/**
 * An inner transaction of type 'axfer'
 */
export interface AssetTransferInnerTxn {
  /** @hidden */
  [isItxn]?: true
  /**
   * 32 byte address
   */
  readonly sender: Account
  /**
   * microalgos
   */
  readonly fee: uint64
  /**
   * round number
   */
  readonly firstValid: uint64
  /**
   * UNIX timestamp of block before txn.FirstValid. Fails if negative
   */
  readonly firstValidTime: uint64
  /**
   * round number
   */
  readonly lastValid: uint64
  /**
   * Any data up to 1024 bytes
   */
  readonly note: bytes
  /**
   * 32 byte lease value
   */
  readonly lease: bytes
  /**
   * Transaction type as bytes
   */
  readonly typeBytes: bytes
  /**
   * Transaction type
   */
  readonly type: TransactionType.AssetTransfer
  /**
   * Position of this transaction within an atomic group
   * A stand-alone transaction is implicitly element 0 in a group of 1
   */
  readonly groupIndex: uint64
  /**
   * The computed ID for this transaction. 32 bytes.
   */
  readonly txnId: bytes
  /**
   * 32 byte Sender's new AuthAddr
   */
  readonly rekeyTo: Account
  /**
   * Asset ID
   */
  readonly xferAsset: Asset
  /**
   * value in Asset's units
   */
  readonly assetAmount: uint64
  /**
   * 32 byte address. Source of assets if Sender is the Asset's Clawback address.
   */
  readonly assetSender: Account
  /**
   * 32 byte address
   */
  readonly assetReceiver: Account
  /**
   * 32 byte address
   */
  readonly assetCloseTo: Account
}
/**
 * An inner transaction of type 'afrz'
 */
export interface AssetFreezeInnerTxn {
  /** @hidden */
  [isItxn]?: true
  /**
   * 32 byte address
   */
  readonly sender: Account
  /**
   * microalgos
   */
  readonly fee: uint64
  /**
   * round number
   */
  readonly firstValid: uint64
  /**
   * UNIX timestamp of block before txn.FirstValid. Fails if negative
   */
  readonly firstValidTime: uint64
  /**
   * round number
   */
  readonly lastValid: uint64
  /**
   * Any data up to 1024 bytes
   */
  readonly note: bytes
  /**
   * 32 byte lease value
   */
  readonly lease: bytes
  /**
   * Transaction type as bytes
   */
  readonly typeBytes: bytes
  /**
   * Transaction type
   */
  readonly type: TransactionType.AssetFreeze
  /**
   * Position of this transaction within an atomic group
   * A stand-alone transaction is implicitly element 0 in a group of 1
   */
  readonly groupIndex: uint64
  /**
   * The computed ID for this transaction. 32 bytes.
   */
  readonly txnId: bytes
  /**
   * 32 byte Sender's new AuthAddr
   */
  readonly rekeyTo: Account
  /**
   * Asset ID being frozen or un-frozen
   */
  readonly freezeAsset: Asset
  /**
   * 32 byte address of the account whose asset slot is being frozen or un-frozen
   */
  readonly freezeAccount: Account
  /**
   * The new frozen value
   */
  readonly frozen: boolean
}
/**
 * An inner transaction of type 'appl'
 */
export interface ApplicationCallInnerTxn {
  /** @hidden */
  [isItxn]?: true
  /**
   * 32 byte address
   */
  readonly sender: Account
  /**
   * microalgos
   */
  readonly fee: uint64
  /**
   * round number
   */
  readonly firstValid: uint64
  /**
   * UNIX timestamp of block before txn.FirstValid. Fails if negative
   */
  readonly firstValidTime: uint64
  /**
   * round number
   */
  readonly lastValid: uint64
  /**
   * Any data up to 1024 bytes
   */
  readonly note: bytes
  /**
   * 32 byte lease value
   */
  readonly lease: bytes
  /**
   * Transaction type as bytes
   */
  readonly typeBytes: bytes
  /**
   * Transaction type
   */
  readonly type: TransactionType.ApplicationCall
  /**
   * Position of this transaction within an atomic group
   * A stand-alone transaction is implicitly element 0 in a group of 1
   */
  readonly groupIndex: uint64
  /**
   * The computed ID for this transaction. 32 bytes.
   */
  readonly txnId: bytes
  /**
   * 32 byte Sender's new AuthAddr
   */
  readonly rekeyTo: Account
  /**
   * ApplicationID from ApplicationCall transaction
   */
  readonly appId: Application
  /**
   * ApplicationCall transaction on completion action
   */
  readonly onCompletion: OnCompleteAction
  /**
   * Number of ApplicationArgs
   */
  readonly numAppArgs: uint64
  /**
   * Number of ApplicationArgs
   */
  readonly numAccounts: uint64
  /**
   * The first page of the Approval program
   */
  readonly approvalProgram: bytes
  /**
   * The first page of the Clear State program
   */
  readonly clearStateProgram: bytes
  /**
   * Number of Assets
   */
  readonly numAssets: uint64
  /**
   * Number of Applications
   */
  readonly numApps: uint64
  /**
   * Number of global state integers this application makes use of.
   */
  readonly globalNumUint: uint64
  /**
   * Number of global state byteslices this application makes use of.
   */
  readonly globalNumBytes: uint64
  /**
   * Number of local state integers this application makes use of.
   */
  readonly localNumUint: uint64
  /**
   * Number of local state byteslices this application makes use of.
   */
  readonly localNumBytes: uint64
  /**
   * Number of additional pages for each of the application's approval and clear state program
   */
  readonly extraProgramPages: uint64
  /**
   * The last message emitted. Empty bytes if none were emitted. App mode only
   */
  readonly lastLog: bytes
  /**
   * Read application logs
   * @param index Index of the log to get
   */
  logs(index: uint64): bytes
  /**
   * Number of Approval Program pages
   */
  readonly numApprovalProgramPages: uint64
  /**
   * All approval program pages
   * @param index Index of the page to get
   */
  approvalProgramPages(index: uint64): bytes
  /**
   * Number of Clear State Program pages
   */
  readonly numClearStateProgramPages: uint64
  /**
   * All clear state program pages
   * @param index Index of the page to get
   */
  clearStateProgramPages(index: uint64): bytes
  /**
   * Arguments passed to the application in the ApplicationCall transaction
   * @param index Index of the arg to get
   */
  appArgs(index: uint64): bytes
  /**
   * Accounts listed in the ApplicationCall transaction
   * @param index Index of the account to get
   */
  accounts(index: uint64): Account
  /**
   * Foreign Assets listed in the ApplicationCall transaction
   * @param index Index of the asset to get
   */
  assets(index: uint64): Asset
  /**
   * Foreign Apps listed in the ApplicationCall transaction
   * @param index Index of the application to get
   */
  apps(index: uint64): Application
  /**
   * The id of the created application
   */
  readonly createdApp: Application
  /**
   * Number of logs
   */
  readonly numLogs: uint64
}
export interface PaymentFields {
  /**
   * 32 byte address
   */
  sender?: Account | bytes
  /**
   * microalgos
   */
  fee?: uint64
  /**
   * round number
   */
  firstValid?: uint64
  /**
   * UNIX timestamp of block before txn.FirstValid. Fails if negative
   */
  firstValidTime?: uint64
  /**
   * round number
   */
  lastValid?: uint64
  /**
   * Any data up to 1024 bytes
   */
  note?: bytes | string
  /**
   * 32 byte lease value
   */
  lease?: bytes
  /**
   * 32 byte Sender's new AuthAddr
   */
  rekeyTo?: Account | bytes
  /**
   * 32 byte address
   */
  receiver?: Account | bytes
  /**
   * microalgos
   */
  amount?: uint64
  /**
   * 32 byte address
   */
  closeRemainderTo?: Account | bytes
}
export interface KeyRegistrationFields {
  /**
   * 32 byte address
   */
  sender?: Account | bytes
  /**
   * microalgos
   */
  fee?: uint64
  /**
   * round number
   */
  firstValid?: uint64
  /**
   * UNIX timestamp of block before txn.FirstValid. Fails if negative
   */
  firstValidTime?: uint64
  /**
   * round number
   */
  lastValid?: uint64
  /**
   * Any data up to 1024 bytes
   */
  note?: bytes | string
  /**
   * 32 byte lease value
   */
  lease?: bytes
  /**
   * 32 byte Sender's new AuthAddr
   */
  rekeyTo?: Account | bytes
  /**
   * 32 byte address
   */
  voteKey?: bytes
  /**
   * 32 byte address
   */
  selectionKey?: bytes
  /**
   * The first round that the participation key is valid.
   */
  voteFirst?: uint64
  /**
   * The last round that the participation key is valid.
   */
  voteLast?: uint64
  /**
   * Dilution for the 2-level participation key
   */
  voteKeyDilution?: uint64
  /**
   * Marks an account nonparticipating for rewards
   */
  nonparticipation?: boolean
  /**
   * 64 byte state proof public key
   */
  stateProofKey?: bytes
}
export interface AssetConfigFields {
  /**
   * 32 byte address
   */
  sender?: Account | bytes
  /**
   * microalgos
   */
  fee?: uint64
  /**
   * round number
   */
  firstValid?: uint64
  /**
   * UNIX timestamp of block before txn.FirstValid. Fails if negative
   */
  firstValidTime?: uint64
  /**
   * round number
   */
  lastValid?: uint64
  /**
   * Any data up to 1024 bytes
   */
  note?: bytes | string
  /**
   * 32 byte lease value
   */
  lease?: bytes
  /**
   * 32 byte Sender's new AuthAddr
   */
  rekeyTo?: Account | bytes
  /**
   * Asset ID in asset config transaction
   */
  configAsset?: Asset | uint64
  /**
   * Total number of units of this asset created
   */
  total?: uint64
  /**
   * Number of digits to display after the decimal place when displaying the asset
   */
  decimals?: uint64
  /**
   * Whether the asset's slots are frozen by default or not, 0 or 1
   */
  defaultFrozen?: boolean
  /**
   * Unit name of the asset
   */
  unitName?: bytes | string
  /**
   * The asset name
   */
  assetName?: bytes | string
  /**
   * URL
   */
  url?: bytes | string
  /**
   * 32 byte commitment to unspecified asset metadata
   */
  metadataHash?: bytes
  /**
   * 32 byte address
   */
  manager?: Account | bytes
  /**
   * 32 byte address
   */
  reserve?: Account | bytes
  /**
   * 32 byte address
   */
  freeze?: Account | bytes
  /**
   * 32 byte address
   */
  clawback?: Account | bytes
}
export interface AssetTransferFields {
  /**
   * 32 byte address
   */
  sender?: Account | bytes
  /**
   * microalgos
   */
  fee?: uint64
  /**
   * round number
   */
  firstValid?: uint64
  /**
   * UNIX timestamp of block before txn.FirstValid. Fails if negative
   */
  firstValidTime?: uint64
  /**
   * round number
   */
  lastValid?: uint64
  /**
   * Any data up to 1024 bytes
   */
  note?: bytes | string
  /**
   * 32 byte lease value
   */
  lease?: bytes
  /**
   * 32 byte Sender's new AuthAddr
   */
  rekeyTo?: Account | bytes
  /**
   * Asset ID
   */
  xferAsset?: Asset | uint64
  /**
   * value in Asset's units
   */
  assetAmount?: uint64
  /**
   * 32 byte address. Source of assets if Sender is the Asset's Clawback address.
   */
  assetSender?: Account | bytes
  /**
   * 32 byte address
   */
  assetReceiver?: Account | bytes
  /**
   * 32 byte address
   */
  assetCloseTo?: Account | bytes
}
export interface AssetFreezeFields {
  /**
   * 32 byte address
   */
  sender?: Account | bytes
  /**
   * microalgos
   */
  fee?: uint64
  /**
   * round number
   */
  firstValid?: uint64
  /**
   * UNIX timestamp of block before txn.FirstValid. Fails if negative
   */
  firstValidTime?: uint64
  /**
   * round number
   */
  lastValid?: uint64
  /**
   * Any data up to 1024 bytes
   */
  note?: bytes | string
  /**
   * 32 byte lease value
   */
  lease?: bytes
  /**
   * 32 byte Sender's new AuthAddr
   */
  rekeyTo?: Account | bytes
  /**
   * Asset ID being frozen or un-frozen
   */
  freezeAsset?: Asset | uint64
  /**
   * 32 byte address of the account whose asset slot is being frozen or un-frozen
   */
  freezeAccount?: Account | bytes
  /**
   * The new frozen value
   */
  frozen?: boolean
}
export interface ApplicationCallFields {
  /**
   * 32 byte address
   */
  sender?: Account | bytes
  /**
   * microalgos
   */
  fee?: uint64
  /**
   * round number
   */
  firstValid?: uint64
  /**
   * UNIX timestamp of block before txn.FirstValid. Fails if negative
   */
  firstValidTime?: uint64
  /**
   * round number
   */
  lastValid?: uint64
  /**
   * Any data up to 1024 bytes
   */
  note?: bytes | string
  /**
   * 32 byte lease value
   */
  lease?: bytes
  /**
   * 32 byte Sender's new AuthAddr
   */
  rekeyTo?: Account | bytes
  /**
   * ApplicationID from ApplicationCall transaction
   */
  appId?: Application | uint64
  /**
   * ApplicationCall transaction on completion action
   */
  onCompletion?: OnCompleteAction
  /**
   * Number of global state integers this application makes use of.
   */
  globalNumUint?: uint64
  /**
   * Number of global state byteslices this application makes use of.
   */
  globalNumBytes?: uint64
  /**
   * Number of local state integers this application makes use of.
   */
  localNumUint?: uint64
  /**
   * Number of local state byteslices this application makes use of.
   */
  localNumBytes?: uint64
  /**
   * Number of additional pages for each of the application's approval and clear state program
   */
  extraProgramPages?: uint64
  /**
   * All approval program pages
   * @param index Index of the page to get
   */
  approvalProgram?: bytes | readonly [...bytes[]]
  /**
   * All clear state program pages
   * @param index Index of the page to get
   */
  clearStateProgram?: bytes | readonly [...bytes[]]
  /**
   * Arguments passed to the application in the ApplicationCall transaction
   * @param index Index of the arg to get
   */
  appArgs?: readonly [...unknown[]]
  /**
   * Accounts listed in the ApplicationCall transaction
   * @param index Index of the account to get
   */
  accounts?: readonly [...(Account | bytes)[]]
  /**
   * Foreign Assets listed in the ApplicationCall transaction
   * @param index Index of the asset to get
   */
  assets?: readonly [...(Asset | uint64)[]]
  /**
   * Foreign Apps listed in the ApplicationCall transaction
   * @param index Index of the application to get
   */
  apps?: readonly [...(Application | uint64)[]]
}
/**
 * A union of all ItxnParams types
 */
export type ItxnParams =
  | PaymentItxnParams
  | KeyRegistrationItxnParams
  | AssetConfigItxnParams
  | AssetTransferItxnParams
  | AssetFreezeItxnParams
  | ApplicationCallItxnParams
/**
 * Conditional type which returns the matching InnerTransaction types for a given tuple of ItxnParams types
 */
export type TxnFor<TFields extends [...ItxnParams[]]> = TFields extends [{ submit(): infer TTxn }, ...infer TRest extends [...ItxnParams[]]]
  ? [TTxn, ...TxnFor<TRest>]
  : []
/**
 * Submit a group of ItxnParams objects and return the InnerTransaction results
 */
export function submitGroup<TFields extends [...ItxnParams[]]>(...transactionFields: TFields): TxnFor<TFields> {
  throw new NoImplementation()
}
/**
 * Holds Payment fields which can be updated, cloned, or submitted.
 */
export abstract class PaymentItxnParams {
  /**
   * Submit an itxn with these fields and return the PaymentInnerTxn result
   */
  submit(): PaymentInnerTxn {
    throw new NoImplementation()
  }
  /**
   * Update one or more fields in this PaymentItxnParams object
   */
  set(fields: PaymentFields): void {
    throw new NoImplementation()
  }
  /**
   * Return a copy of this PaymentItxnParams object
   */
  copy(): PaymentItxnParams {
    throw new NoImplementation()
  }
}
/**
 * Create a new PaymentItxnParams object with the specified fields
 */
export function payment(fields: PaymentFields): PaymentItxnParams {
  throw new NoImplementation()
}
/**
 * Holds KeyRegistration fields which can be updated, cloned, or submitted.
 */
export abstract class KeyRegistrationItxnParams {
  /**
   * Submit an itxn with these fields and return the KeyRegistrationInnerTxn result
   */
  submit(): KeyRegistrationInnerTxn {
    throw new NoImplementation()
  }
  /**
   * Update one or more fields in this KeyRegistrationItxnParams object
   */
  set(fields: KeyRegistrationFields): void {
    throw new NoImplementation()
  }
  /**
   * Return a copy of this KeyRegistrationItxnParams object
   */
  copy(): KeyRegistrationItxnParams {
    throw new NoImplementation()
  }
}
/**
 * Create a new KeyRegistrationItxnParams object with the specified fields
 */
export function keyRegistration(fields: KeyRegistrationFields): KeyRegistrationItxnParams {
  throw new NoImplementation()
}
/**
 * Holds AssetConfig fields which can be updated, cloned, or submitted.
 */
export abstract class AssetConfigItxnParams {
  /**
   * Submit an itxn with these fields and return the AssetConfigInnerTxn result
   */
  submit(): AssetConfigInnerTxn {
    throw new NoImplementation()
  }
  /**
   * Update one or more fields in this AssetConfigItxnParams object
   */
  set(fields: AssetConfigFields): void {
    throw new NoImplementation()
  }
  /**
   * Return a copy of this AssetConfigItxnParams object
   */
  copy(): AssetConfigItxnParams {
    throw new NoImplementation()
  }
}
/**
 * Create a new AssetConfigItxnParams object with the specified fields
 */
export function assetConfig(fields: AssetConfigFields): AssetConfigItxnParams {
  throw new NoImplementation()
}
/**
 * Holds AssetTransfer fields which can be updated, cloned, or submitted.
 */
export abstract class AssetTransferItxnParams {
  /**
   * Submit an itxn with these fields and return the AssetTransferInnerTxn result
   */
  submit(): AssetTransferInnerTxn {
    throw new NoImplementation()
  }
  /**
   * Update one or more fields in this AssetTransferItxnParams object
   */
  set(fields: AssetTransferFields): void {
    throw new NoImplementation()
  }
  /**
   * Return a copy of this AssetTransferItxnParams object
   */
  copy(): AssetTransferItxnParams {
    throw new NoImplementation()
  }
}
/**
 * Create a new AssetTransferItxnParams object with the specified fields
 */
export function assetTransfer(fields: AssetTransferFields): AssetTransferItxnParams {
  throw new NoImplementation()
}
/**
 * Holds AssetFreeze fields which can be updated, cloned, or submitted.
 */
export abstract class AssetFreezeItxnParams {
  /**
   * Submit an itxn with these fields and return the AssetFreezeInnerTxn result
   */
  submit(): AssetFreezeInnerTxn {
    throw new NoImplementation()
  }
  /**
   * Update one or more fields in this AssetFreezeItxnParams object
   */
  set(fields: AssetFreezeFields): void {
    throw new NoImplementation()
  }
  /**
   * Return a copy of this AssetFreezeItxnParams object
   */
  copy(): AssetFreezeItxnParams {
    throw new NoImplementation()
  }
}
/**
 * Create a new AssetFreezeItxnParams object with the specified fields
 */
export function assetFreeze(fields: AssetFreezeFields): AssetFreezeItxnParams {
  throw new NoImplementation()
}
/**
 * Holds ApplicationCall fields which can be updated, cloned, or submitted.
 */
export abstract class ApplicationCallItxnParams {
  /**
   * Submit an itxn with these fields and return the ApplicationCallInnerTxn result
   */
  submit(): ApplicationCallInnerTxn {
    throw new NoImplementation()
  }
  /**
   * Update one or more fields in this ApplicationCallItxnParams object
   */
  set(fields: ApplicationCallFields): void {
    throw new NoImplementation()
  }
  /**
   * Return a copy of this ApplicationCallItxnParams object
   */
  copy(): ApplicationCallItxnParams {
    throw new NoImplementation()
  }
}
/**
 * Create a new ApplicationCallItxnParams object with the specified fields
 */
export function applicationCall(fields: ApplicationCallFields): ApplicationCallItxnParams {
  throw new NoImplementation()
}



================================================
FILE: packages/algo-ts/src/logic-sig.ts
================================================
import { ConstructorFor } from './internal/typescript-helpers'
import { uint64 } from './primitives'

/**
 * Base class for Algorand TypeScript Logic Signatures (also known as Smart Signatures)
 */
export abstract class LogicSig {
  /**
   * The logic signature program logic
   */
  abstract program(): boolean | uint64
}

/**
 * Alias for a numeric range specification.
 */
type NumberRange = {
  /**
   * The start point of the range (inclusive)
   */
  from: number
  /**
   * The end point of the range (inclusive)
   */
  to: number
}

/**
 * Defines optional configuration for a logic signature
 */
type LogicSigOptions = {
  /**
   * Determines which AVM version to use, this affects what operations are supported.
   * Defaults to value provided supplied on command line (which defaults to current mainnet version)
   */
  avmVersion?: 10 | 11
  /**
   * Override the name of the logic signature when generating build artifacts.
   * Defaults to the class name
   */
  name?: string
  /**
   * Allows you to mark a slot ID or range of slot IDs as "off limits" to Puya.
   * These slot ID(s) will never be written to or otherwise manipulating by the compiler itself.
   * This is particularly useful in combination with `op.gload_bytes` / `op.gload_uint64`
   * which lets a contract in a group transaction read from the scratch slots of another contract
   * that occurs earlier in the transaction group.
   */
  scratchSlots?: Array<number | NumberRange>
}

/**
 * The logicsig decorator can be used to specify additional configuration options for a logic signature
 * @param options An object containing the configuration options
 */
export function logicsig(options: LogicSigOptions) {
  return <T extends ConstructorFor<LogicSig>>(logicSig: T) => logicSig
}



================================================
FILE: packages/algo-ts/src/mutable-array.ts
================================================
import { NoImplementation } from './internal/errors'
import { uint64, Uint64Compat } from './primitives'

/**
 * An in memory mutable array which is passed by reference
 */
export class MutableArray<TItem> {
  /**
   * Create a new MutableArray with the specified items
   * @param items The initial items for the array
   */
  constructor(...items: TItem[]) {}

  /**
   * Returns the current length of this array
   */
  get length(): uint64 {
    throw new NoImplementation()
  }

  /**
   * Returns the item at the given index.
   * Negative indexes are taken from the end.
   * @param index The index of the item to retrieve
   */
  at(index: Uint64Compat): TItem {
    throw new NoImplementation()
  }

  /**
   * Create a new Dynamic array with all items from this array
   * @internal Not supported yet
   */
  slice(): MutableArray<TItem>
  /**
   * Create a new MutableArray with all items up till `end`.
   * Negative indexes are taken from the end.
   * @param end An index in which to stop copying items.
   * @internal Not supported yet
   */
  slice(end: Uint64Compat): MutableArray<TItem>
  /**
   * Create a new MutableArray with items from `start`, up until `end`
   * Negative indexes are taken from the end.
   * @param start An index in which to start copying items.
   * @param end An index in which to stop copying items
   * @internal Not supported yet
   */
  slice(start: Uint64Compat, end: Uint64Compat): MutableArray<TItem>
  slice(start?: Uint64Compat, end?: Uint64Compat): MutableArray<TItem> {
    throw new NoImplementation()
  }

  /**
   * Returns an iterator for the items in this array
   */
  [Symbol.iterator](): IterableIterator<TItem> {
    throw new NoImplementation()
  }

  /**
   * Returns an iterator for a tuple of the indexes and items in this array
   */
  entries(): IterableIterator<readonly [uint64, TItem]> {
    throw new NoImplementation()
  }

  /**
   * Returns an iterator for the indexes in this array
   */
  keys(): IterableIterator<uint64> {
    throw new NoImplementation()
  }

  /**
   * Get or set the item at the specified index.
   * Negative indexes are not supported
   */
  [index: uint64]: TItem

  /**
   * Push a number of items into this array
   * @param items The items to be added to this array
   */
  push(...items: TItem[]): void {
    throw new NoImplementation()
  }

  /**
   * Pop a single item from this array
   */
  pop(): TItem {
    throw new NoImplementation()
  }

  /**
   * Create a copy of this array
   */
  copy(): MutableArray<TItem> {
    throw new NoImplementation()
  }
}



================================================
FILE: packages/algo-ts/src/on-complete-action.ts
================================================
/**
 * The possible on complete actions a method can handle, represented as a string
 */
export type OnCompleteActionStr = 'NoOp' | 'OptIn' | 'ClearState' | 'CloseOut' | 'UpdateApplication' | 'DeleteApplication'

/**
 * The possible on complete actions a method can handle, represented as an integer
 */
export enum OnCompleteAction {
  /**
   * Do nothing after the transaction has completed
   */
  NoOp = 0,
  /**
   * Opt the calling user into the contract
   */
  OptIn = 1,
  /**
   * Close the calling user out of the contract
   */
  CloseOut = 2,
  /**
   * Run the clear state program and forcibly close the user out of the contract
   */
  ClearState = 3,
  /**
   * Replace the application's approval and clear state programs with the bytes from this transaction
   */
  UpdateApplication = 4,
  /**
   * Delete the application
   */
  DeleteApplication = 5,
}



================================================
FILE: packages/algo-ts/src/primitives.ts
================================================
import { NoImplementation } from './internal/errors'

/**
 * An alias for types which can be converted to a uint64
 */
export type Uint64Compat = uint64 | bigint | boolean | number
/**
 * An alias for types which can be converted to a biguint
 */
export type BigUintCompat = bigint | bytes | number | boolean
/**
 * An alias for types which can be converted to a string
 */
export type StringCompat = string
/**
 * An alias for types which can be converted to a bytes sequence
 */
export type BytesCompat = bytes | string

/**
 * An unsigned integer of exactly 64 bits
 */
export type uint64 = {
  /**
   * @hidden
   */
  __type?: 'uint64'
} & number

/**
 * Create a uint64 with the default value of 0
 */
export function Uint64(): uint64
/**
 * Create a uint64 from a string literal
 */
export function Uint64(v: string): uint64
/**
 * Create a uint64 from a bigint literal
 */
export function Uint64(v: bigint): uint64
/**
 * Create a uint64 from a number literal
 */
export function Uint64(v: number): uint64
/**
 * Create a uint64 from a boolean value. True is 1, False is 0
 */
export function Uint64(v: boolean): uint64
export function Uint64(v?: Uint64Compat | string): uint64 {
  throw new NoImplementation()
}

/**
 * An unsigned integer of up to 512 bits
 *
 * Stored as a big-endian variable byte array
 */
export type biguint = {
  /**
   * @hidden
   */
  __type?: 'biguint'
} & bigint

/**
 * Create a biguint from a bigint literal
 */
export function BigUint(v: bigint): biguint
/**
 * Create a biguint from a boolean value (true = 1, false = 0)
 */
export function BigUint(v: boolean): biguint
/**
 * Create a biguint from a uint64 value
 */
export function BigUint(v: uint64): biguint
/**
 * Create a biguint from a number literal
 */
export function BigUint(v: number): biguint
/**
 * Create a biguint from a byte array interpreted as a big-endian number
 */
export function BigUint(v: bytes): biguint
/**
 * Create a biguint from a string literal containing the decimal digits
 */
export function BigUint(v: string): biguint
/**
 * Create a biguint with the default value of 0
 */
export function BigUint(): biguint
export function BigUint(v?: BigUintCompat | string): biguint {
  throw new NoImplementation()
}

/**
 * A sequence of zero or more bytes (ie. byte[])
 */
export type bytes = {
  /**
   * Retrieve the length of the byte sequence
   */
  readonly length: uint64

  /**
   * Retrieve the byte at the index i
   * @param i The index to read. Can be negative to read from the end
   * @returns The byte found at the index, or an empty bytes value
   */
  at(i: Uint64Compat): bytes

  /**
   * Concatenate this bytes value with another bytes value
   * @param other The other bytes value
   * @returns The concatenation result
   */
  concat(other: BytesCompat): bytes

  /**
   * Perform a bitwise AND operation with this bytes value and another bytes value.
   *
   * The shorter of the two values will be zero-left extended to the larger length.
   * @param other The other bytes value
   * @returns The bitwise operation result
   */
  bitwiseAnd(other: BytesCompat): bytes

  /**
   * Perform a bitwise OR operation with this bytes value and another bytes value
   *
   * The shorter of the two values will be zero-left extended to the larger length.
   * @param other The other bytes value
   * @returns The bitwise operation result
   */
  bitwiseOr(other: BytesCompat): bytes

  /**
   * Perform a bitwise XOR operation with this bytes value and another bytes value.
   *
   * The shorter of the two values will be zero-left extended to the larger length.
   * @param other The other bytes value
   * @returns The bitwise operation result
   */
  bitwiseXor(other: BytesCompat): bytes

  /**
   * Perform a bitwise INVERT operation with this bytes value
   * @returns The bitwise operation result
   */
  bitwiseInvert(): bytes

  /**
   * Compares this bytes value with another.
   * @param other The other bytes value
   * @returns True if both values represent the same byte sequence
   */
  equals(other: BytesCompat): boolean

  /**
   * Returns a copy of this bytes sequence
   */
  slice(): bytes
  /**
   * Returns a slice of this bytes sequence from the specified start to the end
   * @param start The index to start slicing from. Can be negative to count from the end.
   */
  slice(start: Uint64Compat): bytes
  /**
   * Returns a slice of this bytes sequence from the specified start to the specified end
   * @param start The index to start slicing from. Can be negative to count from the end.
   * @param end The index to end the slice. Can be negative to count from the end.
   */
  slice(start: Uint64Compat, end: Uint64Compat): bytes
  /**
   * @hidden
   */
  slice(start?: Uint64Compat, end?: Uint64Compat): bytes

  /**
   * Interpret this byte sequence as a utf-8 string
   */
  toString(): string
}

/**
 * Create a byte array from a string interpolation template and compatible replacements
 * @param value
 * @param replacements
 */
export function Bytes(value: TemplateStringsArray, ...replacements: BytesCompat[]): bytes
/**
 * Create a byte array from a utf8 string
 */
export function Bytes(value: string): bytes
/**
 * No op, returns the provided byte array.
 */
export function Bytes(value: bytes): bytes
/**
 * Create a byte array from a biguint value encoded as a variable length big-endian number
 */
export function Bytes(value: biguint): bytes
/**
 * Create a byte array from a uint64 value encoded as a fixed length 64-bit number
 */
export function Bytes(value: uint64): bytes
/**
 * Create a byte array from an Iterable<uint64> where each item is interpreted as a single byte and must be between 0 and 255 inclusively
 */
export function Bytes(value: Iterable<uint64>): bytes
/**
 * Create an empty byte array
 */
export function Bytes(): bytes
export function Bytes(
  value?: BytesCompat | TemplateStringsArray | biguint | uint64 | Iterable<number>,
  ...replacements: BytesCompat[]
): bytes {
  throw new NoImplementation()
}

/**
 * Create a new bytes value from a hexadecimal encoded string
 * @param hex A literal string of hexadecimal characters
 */
Bytes.fromHex = (hex: string): bytes => {
  throw new NoImplementation()
}
/**
 * Create a new bytes value from a base 64 encoded string
 * @param b64 A literal string of b64 encoded characters
 */
Bytes.fromBase64 = (b64: string): bytes => {
  throw new NoImplementation()
}

/**
 * Create a new bytes value from a base 32 encoded string
 * @param b32 A literal string of b32 encoded characters
 */
Bytes.fromBase32 = (b32: string): bytes => {
  throw new NoImplementation()
}

/**
 * An interface for types which are backed by the AVM bytes type
 */
export interface BytesBacked {
  /**
   * Retrieve the underlying bytes representing this value
   */
  get bytes(): bytes
}

/**
 * Declare a homogeneous tuple with the item type T and length N.
 *
 * Eg.
 * NTuple<uint64, 3> === [uint64, uint64, uint64]
 */
export type NTuple<T, N extends number> = N extends N ? (number extends N ? T[] : _TupleOf<T, N, readonly []>) : never

type _TupleOf<T, N extends number, R extends readonly unknown[]> = R['length'] extends N ? R : _TupleOf<T, N, readonly [T, ...R]>



================================================
FILE: packages/algo-ts/src/reference.ts
================================================
import { NoImplementation } from './internal/errors'
import { bytes, uint64 } from './primitives'

/**
 * Represents an Algorand Account and exposes properties and methods for reading account data
 */
export type Account = {
  /**
   * Get the accounts address in bytes
   */
  readonly bytes: bytes

  /**
   * Account balance in microalgos
   *
   * Account must be an available resource
   */
  readonly balance: uint64

  /**
   * Minimum required balance for account, in microalgos
   *
   * Account must be an available resource
   */
  readonly minBalance: uint64

  /**
   * Address the account is rekeyed to
   *
   * Account must be an available resource
   */
  readonly authAddress: Account

  /**
   * The total number of uint64 values allocated by this account in Global and Local States.
   *
   * Account must be an available resource
   */
  readonly totalNumUint: uint64

  /**
   * The total number of byte array values allocated by this account in Global and Local States.
   *
   * Account must be an available resource
   */
  readonly totalNumByteSlice: uint64

  /**
   * The number of extra app code pages used by this account.
   *
   * Account must be an available resource
   */
  readonly totalExtraAppPages: uint64

  /**
   * The number of existing apps created by this account.
   *
   * Account must be an available resource
   */
  readonly totalAppsCreated: uint64

  /**
   * The number of apps this account is opted into.
   *
   * Account must be an available resource
   */
  readonly totalAppsOptedIn: uint64

  /**
   * The number of existing ASAs created by this account.
   *
   * Account must be an available resource
   */
  readonly totalAssetsCreated: uint64

  /**
   * The numbers of ASAs held by this account (including ASAs this account created).
   *
   * Account must be an available resource
   */
  readonly totalAssets: uint64

  /**
   * The number of existing boxes created by this account's app.
   *
   * Account must be an available resource
   */
  readonly totalBoxes: uint64

  /**
   * The total number of bytes used by this account's app's box keys and values.
   *
   * Account must be an available resource
   */
  readonly totalBoxBytes: uint64

  /**
   * Returns true if this account is opted in to the specified Asset or Application.
   * Note: Account and Asset/Application must be an available resource
   *
   * @param assetOrApp
   */
  isOptedIn(assetOrApp: Asset | Application): boolean
}

/**
 * Create a new account object representing the zero address
 */
export function Account(): Account
/**
 * Create a new account object representing the provided public key bytes
 * @param publicKey A 32-byte Algorand account public key
 */
export function Account(publicKey: bytes): Account
/**
 * Create a new account object representing the provided address
 * @param address A 56 character base-32 encoded Algorand address
 * @constructor
 */
export function Account(address: string): Account
export function Account(publicKeyOrAddress?: bytes | string): Account {
  throw new NoImplementation()
}

/**
 * Creates a new Asset object represent the asset id 0 (an invalid ID)
 */
export function Asset(): Asset
/**
 * Creates a new Asset object representing the asset with the specified id
 * @param assetId The id of the asset
 */
export function Asset(assetId: uint64): Asset
export function Asset(assetId?: uint64): Asset {
  throw new NoImplementation()
}
/**
 * An Asset on the Algorand network.
 */
export type Asset = {
  /**
   * Returns the id of the Asset
   */
  readonly id: uint64

  /**
   * Total number of units of this asset
   */
  readonly total: uint64

  /**
   * @see AssetParams.decimals
   */
  readonly decimals: uint64

  /**
   * Frozen by default or not
   */
  readonly defaultFrozen: boolean

  /**
   * Asset unit name
   */
  readonly unitName: bytes

  /**
   * Asset name
   */
  readonly name: bytes

  /**
   * URL with additional info about the asset
   */
  readonly url: bytes

  /**
   * Arbitrary commitment
   */
  readonly metadataHash: bytes

  /**
   * Manager address
   */
  readonly manager: Account

  /**
   * Reserve address
   */
  readonly reserve: Account

  /**
   * Freeze address
   */
  readonly freeze: Account

  /**
   * Clawback address
   */
  readonly clawback: Account

  /**
   * Creator address
   */
  readonly creator: Account

  /**
   * Amount of the asset unit held by this account. Fails if the account has not
   * opted in to the asset.
   * Asset and supplied Account must be an available resource
   * @param account Account
   * @return balance: uint64
   */
  balance(account: Account): uint64

  /**
   * Is the asset frozen or not. Fails if the account has not
   * opted in to the asset.
   * Asset and supplied Account must be an available resource
   * @param account Account
   * @return isFrozen: boolean
   */
  frozen(account: Account): boolean
}

/**
 * Creates a new Application object represent the application id 0 (an invalid ID)
 */
export function Application(): Application
/**
 * Creates a new Application object representing the application with the specified id
 * @param applicationId The id of the application
 */
export function Application(applicationId: uint64): Application
export function Application(applicationId?: uint64): Application {
  throw new NoImplementation()
}

/**
 * An Application on the Algorand network.
 */
export type Application = {
  /**
   * The id of this application on the current network
   */
  readonly id: uint64
  /**
   * Bytecode of Approval Program
   */
  readonly approvalProgram: bytes

  /**
   * Bytecode of Clear State Program
   */
  readonly clearStateProgram: bytes

  /**
   * Number of uint64 values allowed in Global State
   */
  readonly globalNumUint: uint64

  /**
   * Number of byte array values allowed in Global State
   */
  readonly globalNumBytes: uint64

  /**
   * Number of uint64 values allowed in Local State
   */
  readonly localNumUint: uint64

  /**
   * Number of byte array values allowed in Local State
   */
  readonly localNumBytes: uint64

  /**
   * Number of Extra Program Pages of code space
   */
  readonly extraProgramPages: uint64

  /**
   * Creator address
   */
  readonly creator: Account

  /**
   * Address for which this application has authority
   */
  readonly address: Account
}



================================================
FILE: packages/algo-ts/src/state.ts
================================================
import { NoImplementation } from './internal/errors'
import { bytes } from './primitives'
import { Account } from './reference'

/**
 * A proxy for manipulating a global state field
 * @typeParam ValueType The type of the value being stored - must be a serializable type
 */
export type GlobalState<ValueType> = {
  /**
   * Get or set the value of this global state field
   */
  value: ValueType
  /**
   * Delete the stored value of this global state field
   */
  delete(): void
  /**
   * Gets a boolean value indicating if global state field currently has a value
   */
  readonly hasValue: boolean
}
/**
 * Options for declaring a global state field
 */
export type GlobalStateOptions<ValueType> = {
  /**
   * The key to be used for this global state field.
   *
   * Defaults to the name of the property this proxy is assigned to
   */
  key?: bytes | string
  /**
   * An initial value to assign to this global state field when the application is created
   */
  initialValue?: ValueType
}

/**
 * Creates a new proxy for manipulating a global state field
 * @param options Options for configuring this field
 * @typeParam ValueType The type of the value being stored - must be a serializable type
 */
export function GlobalState<ValueType>(options?: GlobalStateOptions<ValueType>): GlobalState<ValueType> {
  throw new NoImplementation()
}

/**
 * A proxy for manipulating a local state field for a single account
 */
export type LocalStateForAccount<ValueType> = {
  /**
   * Get or set the value of this local state field for a single account
   */
  value: ValueType
  /**
   * Delete the stored value of this local state field for a single account
   */
  delete(): void
  /**
   * Gets a boolean value indicating if local state field for a single account currently has a value
   */
  readonly hasValue: boolean
}

/**
 * A proxy for manipulating a local state field for any account
 */
export type LocalState<ValueType> = {
  /**
   * Gets the LocalState proxy for a specific account
   * @param account The account to read or write state for. This account must be opted into the contract
   */
  (account: Account): LocalStateForAccount<ValueType>
}
/**
 * Options for declaring a local state field
 */
export type LocalStateOptions = {
  /**
   * The key to be used for this local state field.
   *
   * Defaults to the name of the property this proxy is assigned to
   */
  key?: bytes | string
}

/**
 * Creates a new proxy for manipulating a local state field
 * @param options Options for configuring this field
 */
export function LocalState<ValueType>(options?: LocalStateOptions): LocalState<ValueType> {
  throw new NoImplementation()
}



================================================
FILE: packages/algo-ts/src/template-var.ts
================================================
import { NoImplementation } from './internal/errors'

/**
 * Declare a template variable which can be replaced at compile time with an environment specific value.
 *
 * The final variable name will be `prefix + variableName`
 * @param variableName The key used to identify the variable.
 * @param prefix The prefix to apply the variable name (Defaults to 'TMPL_')
 */
export function TemplateVar<T>(variableName: string, prefix = 'TMPL_'): T {
  throw new NoImplementation()
}



================================================
FILE: packages/algo-ts/src/transactions.ts
================================================
/**
 * The different transaction types available in a transaction
 */
export enum TransactionType {
  /**
   * A Payment transaction
   */
  Payment = 1,
  /**
   * A Key Registration transaction
   */
  KeyRegistration = 2,
  /**
   * An Asset Config transaction
   */
  AssetConfig = 3,
  /**
   * An Asset Transfer transaction
   */
  AssetTransfer = 4,
  /**
   * An Asset Freeze transaction
   */
  AssetFreeze = 5,
  /**
   * An Application Call transaction
   */
  ApplicationCall = 6,
}



================================================
FILE: packages/algo-ts/src/util.ts
================================================
import { NoImplementation } from './internal/errors'
import { biguint, BigUintCompat, BytesBacked, BytesCompat, StringCompat, uint64, Uint64Compat } from './primitives'

/**
 * Write one or more values to the transaction log.
 *
 * Each value is converted to bytes and concatenated
 * @param args The values to write
 */
export function log(...args: Array<Uint64Compat | BytesCompat | BigUintCompat | StringCompat | BytesBacked>): void {
  throw new NoImplementation()
}

/**
 * Asserts that `condition` is truthy, otherwise error and halt execution.
 * @param condition An expression that can be evaluated as truthy of falsy
 * @param message The message to show if `condition` is falsy and an error is raised.
 */
export function assert(condition: unknown, message?: string): asserts condition {
  throw new NoImplementation()
}

/**
 * Raise an error and halt execution
 * @param message The message to accompany the error
 */
export function err(message?: string): never {
  throw new NoImplementation()
}

/**
 * Defines possible comparison expressions for numeric types
 */
type NumericComparison<T> =
  | T
  | {
      /**
       * Is the subject less than the specified value
       */
      lessThan: T
    }
  | {
      /**
       * Is the subject greater than the specified value
       */
      greaterThan: T
    }
  | {
      /**
       * Is the subject greater than or equal to the specified value
       */
      greaterThanEq: T
    }
  | {
      /**
       * Is the subject less than or equal to the specified value
       */
      lessThanEq: T
    }
  | {
      /**
       * Is the subject between the specified values (inclusive)
       */
      between: [T, T]
    }

/**
 * Returns compatible comparison expressions for a type `T`
 * @typeParam T The type requiring comparison
 */
type ComparisonFor<T> = T extends uint64 | biguint ? NumericComparison<T> : T

/**
 * A set of tests to apply to the match subject
 * @typeParam T The type of the test subject
 */
type MatchTest<T> = {
  [key in keyof T]?: ComparisonFor<T[key]>
}

/**
 * Applies all tests in `test` against `subject` and returns a boolean indicating if they all pass
 * @param subject An object or tuple to be tested
 * @param test An object containing one or more tests to be applied to the subject
 * @typeParam T The type of the subject
 * @returns True if all tests pass, otherwise false
 */
export function match<T>(subject: T, test: MatchTest<T>): boolean {
  throw new NoImplementation()
}

/**
 *
 * Applies all tests in `test` against `subject` and asserts they all pass
 * @param subject An object or tuple to be tested
 * @param test An object containing one or more tests to be applied to the subject
 * @param message An optional message to show if the assertion fails
 * @typeParam T The type of the subject
 */
export function assertMatch<T>(subject: T, test: MatchTest<T>, message?: string): boolean {
  throw new NoImplementation()
}

/**
 * Defines the source of fees for the OpUp utility
 */
export enum OpUpFeeSource {
  /**
   * Only the excess fee (credit) on the outer group should be used (itxn.fee = 0)
   */
  GroupCredit = 0,
  /**
   * The app's account will cover all fees (itxn.fee = Global.minTxFee)
   */
  AppAccount = 1,
  /**
   * First the excess will be used, then remaining fees taken from the app account
   */
  Any = 2,
}

/**
 * Ensure the available op code budget is greater than or equal to requiredBudget.
 *
 * This is done by adding AppCall itxns to the group to increase the available budget. These itxns must be paid for
 * by the caller or the application.
 * @param requiredBudget The total required budget
 * @param feeSource Which source to withdraw txn fees from.
 */
export function ensureBudget(requiredBudget: uint64, feeSource: OpUpFeeSource = OpUpFeeSource.GroupCredit) {
  throw new NoImplementation()
}

/**
 * Generates an iterable sequence from 0...stop inclusive
 * @param stop The stop number of the sequence
 */
export function urange(stop: Uint64Compat): IterableIterator<uint64>
/**
 * Generates an iterable sequence from start...stop inclusive
 * @param start The start number of the sequence
 * @param stop The stop number of the sequence
 */
export function urange(start: Uint64Compat, stop: Uint64Compat): IterableIterator<uint64>
/**
 * Generates an iterable sequence from start...stop inclusive with increments of size step
 * @param start The start number of the sequence
 * @param stop The stop number of the sequence
 * @param step The step size of the sequence
 */
export function urange(start: Uint64Compat, stop: Uint64Compat, step: Uint64Compat): IterableIterator<uint64>
export function urange(a: Uint64Compat, b?: Uint64Compat, c?: Uint64Compat): IterableIterator<uint64> {
  throw new NoImplementation()
}

/**
 * Defines a numeric range including all numbers between from and to
 */
export type NumberRange = { from: number; to: number }



================================================
FILE: packages/algo-ts/src/arc4/c2c.ts
================================================
import { CompileContractOptions, CompiledContract } from '../compiled'
import * as gtxn from '../gtxn'
import { NoImplementation } from '../internal/errors'
import { AnyFunction, ConstructorFor, DeliberateAny, InstanceMethod } from '../internal/typescript-helpers'
import * as itxn from '../itxn'
import { ApplicationCallFields, ApplicationCallInnerTxn } from '../itxn'
import { Contract } from './index'

/**
 * Defines txn fields that are available for a bare create application call.
 *
 * This is the regular application call fields minus:
 *  - appId: because the appId is not known when creating an application
 *  - appArgs: because a bare call cannot have arguments
 */
export type BareCreateApplicationCallFields = Omit<ApplicationCallFields, 'appId' | 'appArgs'>

/**
 * Conditional type which given a group transaction type, returns the equivalent inner transaction
 * params type.
 */
export type GtxnToItxnFields<T extends gtxn.Transaction> = T extends gtxn.PaymentTxn
  ? itxn.PaymentItxnParams
  : T extends gtxn.KeyRegistrationTxn
    ? itxn.KeyRegistrationItxnParams
    : T extends gtxn.AssetConfigTxn
      ? itxn.AssetConfigItxnParams
      : T extends gtxn.AssetTransferTxn
        ? itxn.AssetTransferItxnParams
        : T extends gtxn.AssetFreezeTxn
          ? itxn.AssetFreezeItxnParams
          : T extends gtxn.ApplicationCallTxn
            ? itxn.ApplicationCallItxnParams
            : itxn.ItxnParams

/**
 * Conditional type which given an application argument, returns the input type for that argument.
 *
 * The input type will usually be the original type apart from group transactions which will be substituted
 * with their equivalent inner transaction type.
 */
export type TypedApplicationArg<TArg> = TArg extends gtxn.Transaction ? GtxnToItxnFields<TArg> : TArg

/**
 * Conditional type which maps a tuple of application arguments to a tuple of input types for specifying those arguments.
 */
export type TypedApplicationArgs<TArgs> = TArgs extends []
  ? []
  : TArgs extends [infer TArg, ...infer TRest]
    ? [TypedApplicationArg<TArg>, ...TypedApplicationArgs<TRest>]
    : never

/**
 * Application call fields with `appArgs` replaced with an `args` property that is strongly typed to the actual arguments for the
 * given application call.
 */
export type TypedApplicationCallFields<TArgs> = Omit<ApplicationCallFields, 'appArgs'> &
  (TArgs extends [] ? { args?: TypedApplicationArgs<TArgs> } : { args: TypedApplicationArgs<TArgs> })

/**
 * The response type of a typed application call. Includes the raw itxn result object and the parsed ABI return value if applicable.
 */
export type TypedApplicationCallResponse<TReturn> = TReturn extends void
  ? { itxn: ApplicationCallInnerTxn }
  : { itxn: ApplicationCallInnerTxn; returnValue: TReturn }

/**
 * Conditional type which maps an ABI method to a factory method for constructing an application call transaction to call that method.
 */
export type ContractProxyMethod<TMethod> = TMethod extends (...args: infer TArgs) => infer TReturn
  ? (fields?: TypedApplicationCallFields<TArgs>) => TypedApplicationCallResponse<TReturn>
  : never

/**
 * Conditional type which maps an ARC4 compatible contract to a proxy object which allows for constructing application call transactions for
 * all available ABI and bare methods. Also includes the compiled contract result data.
 */
export type ContractProxy<TContract extends Contract> = CompiledContract & {
  /**
   * Get methods for calling ABI and bare methods on the target contract
   */
  call: {
    /**
     * Invoke this method via an inner transaction call
     */
    [key in keyof TContract as key extends 'approvalProgram' | 'clearStateProgram'
      ? never
      : TContract[key] extends AnyFunction
        ? key
        : never]: ContractProxyMethod<TContract[key]>
  }
  /**
   * Create a bare application call itxn to create the contract.
   * @param fields Specify values for transaction fields which should override the default values.
   */
  bareCreate(fields?: BareCreateApplicationCallFields): ApplicationCallInnerTxn
}

/**
 * Pre compile the target ARC4 contract and return a proxy object for constructing inner transactions to call an instance of that contract.
 * @param contract An ARC4 contract class
 * @param options Compile contract arguments
 */
export function compileArc4<TContract extends Contract>(
  contract: ConstructorFor<TContract>,
  options?: CompileContractOptions,
): ContractProxy<TContract> {
  throw new NoImplementation()
}

/**
 * Invokes the target ABI method using a strongly typed fields object.
 * @param method An ABI method function reference.
 * @param fields Specify values for transaction fields.
 */
export function abiCall<TArgs extends DeliberateAny[], TReturn>(
  method: InstanceMethod<Contract, TArgs, TReturn>,
  fields: TypedApplicationCallFields<TArgs>,
): TypedApplicationCallResponse<TReturn> {
  throw new NoImplementation()
}



================================================
FILE: packages/algo-ts/src/arc4/encoded-types.ts
================================================
import { NoImplementation } from '../internal/errors'
import { biguint, BigUintCompat, bytes, BytesBacked, BytesCompat, NTuple, StringCompat, uint64, Uint64Compat } from '../primitives'
import { Account } from '../reference'

/**
 * Defines UintN bit sizes which are compatible with the uint64 type
 */
type UintBitSize = 8 | 16 | 24 | 32 | 40 | 48 | 56 | 64
/**
 * Defines UintN bit sizes which are only compatible with the biguint type
 */
type BigUintBitSize =
  | 72
  | 80
  | 88
  | 96
  | 104
  | 112
  | 120
  | 128
  | 136
  | 144
  | 152
  | 160
  | 168
  | 176
  | 184
  | 192
  | 200
  | 208
  | 216
  | 224
  | 232
  | 240
  | 248
  | 256
  | 264
  | 272
  | 280
  | 288
  | 296
  | 304
  | 312
  | 320
  | 328
  | 336
  | 344
  | 352
  | 360
  | 368
  | 376
  | 384
  | 392
  | 400
  | 408
  | 416
  | 424
  | 432
  | 440
  | 448
  | 456
  | 464
  | 472
  | 480
  | 488
  | 496
  | 504
  | 512
/**
 * Defines supported bit sizes for the UintN and UFixedNxM types
 */
export type BitSize = UintBitSize | BigUintBitSize
/**
 * Conditional type which returns the native equivalent type for a given UintN bit size
 */
type NativeForArc4Int<N extends BitSize> = N extends UintBitSize ? uint64 : biguint
/**
 * Conditional type which returns the compat type relevant to a given UintN bit size
 */
type CompatForArc4Int<N extends BitSize> = N extends UintBitSize ? Uint64Compat : BigUintCompat

/**
 * @hidden
 */
const TypeProperty = Symbol('ARC4Type')

/**
 * A base type for ARC4 encoded values
 */
export abstract class ARC4Encoded implements BytesBacked {
  /** @hidden */
  abstract [TypeProperty]?: string

  /**
   * Retrieve the encoded bytes for this type
   */
  get bytes(): bytes {
    throw new NoImplementation()
  }
}

/**
 * A utf8 encoded string prefixed with its length expressed as a 2 byte uint
 */
export class Str extends ARC4Encoded {
  /** @hidden */
  [TypeProperty]?: 'arc4.Str'

  /**
   * Create a new Str instance
   * @param s The native string to initialize this Str from
   */
  constructor(s?: StringCompat) {
    super()
  }

  /**
   * Retrieve the decoded native string
   */
  get native(): string {
    throw new NoImplementation()
  }
}

/**
 * A fixed bit size unsigned int
 */
export class UintN<N extends BitSize> extends ARC4Encoded {
  /** @hidden */
  [TypeProperty]?: `arc4.UintN<${N}>`

  /**
   * Create a new UintN instance
   * @param v The native uint64 or biguint value to initialize this UintN from
   */
  constructor(v?: CompatForArc4Int<N>) {
    super()
  }

  /**
   * Retrieve the decoded native uint64 or biguint
   */
  get native(): NativeForArc4Int<N> {
    throw new NoImplementation()
  }
}

/**
 * An alias for UintN<8>
 */
export class Byte extends UintN<8> {}

/**
 * An alias for UintN<8>
 */
export class UintN8 extends UintN<8> {}

/**
 * An alias for UintN<16>
 */
export class UintN16 extends UintN<16> {}

/**
 * An alias for UintN<32>
 */
export class UintN32 extends UintN<32> {}

/**
 * An alias for UintN<64>
 */
export class UintN64 extends UintN<64> {}

/**
 * An alias for UintN<128>
 */
export class UintN128 extends UintN<128> {}

/**
 * An alias for UintN<256>
 */
export class UintN256 extends UintN<256> {}

/**
 * A fixed bit size, fixed decimal unsigned value
 */
export class UFixedNxM<N extends BitSize, M extends number> extends ARC4Encoded {
  /** @hidden */
  [TypeProperty]?: `arc4.UFixedNxM<${N}x${M}>`

  /**
   * Create a new UFixedNxM value
   * @param v A string representing the integer and fractional portion of the number
   */
  constructor(v?: `${number}.${number}`) {
    super()
  }

  /**
   * Retrieve the decoded native uint64 or biguint where the returned integer represents the fixed decimal value * (10 ^ M)
   */
  get native(): NativeForArc4Int<N> {
    throw new NoImplementation()
  }
}

/**
 * A boolean value
 */
export class Bool extends ARC4Encoded {
  /** @hidden */
  [TypeProperty]?: `arc4.Bool`

  /**
   * Create a new Bool value
   * @param v The native boolean to initialize this value from
   */
  constructor(v?: boolean) {
    super()
  }

  /**
   * Get the decoded native boolean for this value
   */
  get native(): boolean {
    throw new NoImplementation()
  }
}

/**
 * A base type for arc4 array types
 */
abstract class Arc4ArrayBase<TItem extends ARC4Encoded> extends ARC4Encoded {
  protected constructor() {
    super()
  }

  /**
   * Returns the current length of this array
   */
  get length(): uint64 {
    throw new NoImplementation()
  }

  /**
   * Returns the item at the given index.
   * Negative indexes are taken from the end.
   * @param index The index of the item to retrieve
   */
  at(index: Uint64Compat): TItem {
    throw new NoImplementation()
  }

  /** @internal
   * Create a new Dynamic array with all items from this array
   */
  slice(): DynamicArray<TItem>
  /** @internal
   * Create a new DynamicArray with all items up till `end`.
   * Negative indexes are taken from the end.
   * @param end An index in which to stop copying items.
   */
  slice(end: Uint64Compat): DynamicArray<TItem>
  /** @internal
   * Create a new DynamicArray with items from `start`, up until `end`
   * Negative indexes are taken from the end.
   * @param start An index in which to start copying items.
   * @param end An index in which to stop copying items
   */
  slice(start: Uint64Compat, end: Uint64Compat): DynamicArray<TItem>
  slice(start?: Uint64Compat, end?: Uint64Compat): DynamicArray<TItem> {
    throw new NoImplementation()
  }

  /**
   * Returns an iterator for the items in this array
   */
  [Symbol.iterator](): IterableIterator<TItem> {
    throw new NoImplementation()
  }

  /**
   * Returns an iterator for a tuple of the indexes and items in this array
   */
  entries(): IterableIterator<readonly [uint64, TItem]> {
    throw new NoImplementation()
  }

  /**
   * Returns an iterator for the indexes in this array
   */
  keys(): IterableIterator<uint64> {
    throw new NoImplementation()
  }

  /**
   * Get or set the item at the specified index.
   * Negative indexes are not supported
   */
  [index: uint64]: TItem
}

/**
 * A fixed sized array of arc4 items
 * @typeParam TItem The type of a single item in the array
 * @typeParam TLength The fixed length of the array
 */
export class StaticArray<TItem extends ARC4Encoded, TLength extends number> extends Arc4ArrayBase<TItem> {
  /** @hidden */
  [TypeProperty]?: `arc4.StaticArray<${TItem[typeof TypeProperty]}, ${TLength}>`

  /**
   * Create a new StaticArray instance
   */
  constructor()
  /**
   * Create a new StaticArray instance with the specified items
   * @param items The initial items for the array
   */
  constructor(...items: TItem[] & { length: TLength })
  constructor(...items: TItem[] & { length: TLength }) {
    super()
  }

  /**
   * Returns a copy of this array
   */
  copy(): StaticArray<TItem, TLength> {
    throw new NoImplementation()
  }

  /**
   * Returns a new array containing all items from _this_ array, and _other_ array
   * @param other Another array to concat with this one
   */
  concat(other: Arc4ArrayBase<TItem>): DynamicArray<TItem> {
    throw new NoImplementation()
  }

  /**
   * Return the array items as a native tuple
   */
  get native(): NTuple<TItem, TLength> {
    throw new NoImplementation()
  }
}

/**
 * A dynamic sized array of arc4 items
 * @typeParam TItem The type of a single item in the array
 */
export class DynamicArray<TItem extends ARC4Encoded> extends Arc4ArrayBase<TItem> {
  /** @hidden */
  [TypeProperty]?: `arc4.DynamicArray<${TItem[typeof TypeProperty]}>`

  /**
   * Create a new DynamicArray with the specified items
   * @param items The initial items for the array
   */
  constructor(...items: TItem[]) {
    super()
  }

  /**
   * Push a number of items into this array
   * @param items The items to be added to this array
   */
  push(...items: TItem[]): void {
    throw new NoImplementation()
  }

  /**
   * Pop a single item from this array
   */
  pop(): TItem {
    throw new NoImplementation()
  }

  /**
   * Returns a copy of this array
   */
  copy(): DynamicArray<TItem> {
    throw new NoImplementation()
  }

  /**
   * Returns a new array containing all items from _this_ array, and _other_ array
   * @param other Another array to concat with this one
   */
  concat(other: Arc4ArrayBase<TItem>): DynamicArray<TItem> {
    throw new NoImplementation()
  }

  /**
   * Return the array items as a native immutable array
   */
  get native(): TItem[] {
    throw new NoImplementation()
  }
}

/**
 * @hidden
 */
type ExpandTupleType<T extends ARC4Encoded[]> = T extends [infer T1 extends ARC4Encoded, ...infer TRest extends ARC4Encoded[]]
  ? TRest extends []
    ? `${T1[typeof TypeProperty]}`
    : `${T1[typeof TypeProperty]},${ExpandTupleType<TRest>}`
  : ''

/**
 * An arc4 encoded tuple of values
 * @typeParam TTuple A type representing the native tuple of item types
 */
export class Tuple<TTuple extends [ARC4Encoded, ...ARC4Encoded[]]> extends ARC4Encoded {
  /** @hidden */
  [TypeProperty]?: `arc4.Tuple<${ExpandTupleType<TTuple>}>`

  /**
   * Create a new Tuple with the default zero values for items
   */
  constructor()
  /**
   * Create a new Tuple with the specified items
   * @param items The tuple items
   */
  constructor(...items: TTuple)
  constructor(...items: TTuple | []) {
    super()
  }

  /**
   * Returns the item at the specified index
   * @param index The index of the item to get. Must be a positive literal representing a tuple index
   */
  at<TIndex extends keyof TTuple>(index: TIndex): TTuple[TIndex] {
    throw new NoImplementation()
  }

  /**
   * Returns the length of this tuple
   */
  get length(): TTuple['length'] & uint64 {
    throw new NoImplementation()
  }

  /**
   * Returns the decoded native tuple (with arc4 encoded items)
   */
  get native(): TTuple {
    throw new NoImplementation()
  }
}

/**
 * A 32 byte Algorand Address
 */
export class Address extends Arc4ArrayBase<Byte> {
  /** @hidden */
  [TypeProperty]?: `arc4.Address`

  /**
   * Create a new Address instance
   * @param value An Account, base 32 address string, or the address bytes
   */
  constructor(value?: Account | string | bytes) {
    super()
  }

  /**
   * Returns an Account instance for this Address
   */
  get native(): Account {
    throw new NoImplementation()
  }
}

/**
 * The base type for arc4 structs
 */
class StructBase<T> extends ARC4Encoded {
  /** @hidden */
  [TypeProperty] = 'arc4.Struct'

  get native(): T {
    throw new NoImplementation()
  }

  /**
   * Returns a deep copy of this struct
   */
  copy(): this {
    throw new NoImplementation()
  }
}

/**
 * Type alias for the Struct constructor function
 * @typeParam T The shape of the arc4 struct
 */
type StructConstructor = {
  new <T extends Record<string, ARC4Encoded>>(initial: T): StructBase<T> & T
}

/**
 * The base type of arc4 structs
 *
 * Usage:
 * ```
 * class MyStruct extends Struct<{ x: UintN8, y: Str, z: DynamicBytes }> {}
 * ```
 */
export const Struct = StructBase as unknown as StructConstructor

/**
 * A variable length sequence of bytes prefixed with its length expressed as a 2 byte uint
 */
export class DynamicBytes extends Arc4ArrayBase<Byte> {
  /** @hidden */
  [TypeProperty]?: `arc4.DynamicBytes`

  /**
   * Create a new DynamicBytes instance
   * @param value The bytes or utf8 interpreted string to initialize this type
   */
  constructor(value?: bytes | string) {
    super()
  }

  /**
   * Get the native bytes value (excludes the length prefix)
   */
  get native(): bytes {
    throw new NoImplementation()
  }

  /**
   * Returns a dynamic bytes object containing all bytes from _this_ and _other_
   * @param other Another array of bytes to concat with this one
   */
  concat(other: Arc4ArrayBase<Byte>): DynamicBytes {
    throw new NoImplementation()
  }
}

/**
 * A fixed length sequence of bytes
 */
export class StaticBytes<TLength extends number = 0> extends Arc4ArrayBase<Byte> {
  /** @hidden */
  [TypeProperty]?: `arc4.StaticBytes<${TLength}>`

  /**
   * Create a new StaticBytes instance
   * @param value THe bytes or utf8 interpreted string to initialize this type
   */
  constructor(value?: bytes | string) {
    super()
  }

  /**
   * Get the native bytes value
   */
  get native(): bytes {
    throw new NoImplementation()
  }

  /**
   * Returns a dynamic bytes object containing all bytes from _this_ and _other_
   * @param other Another array of bytes to concat with this one
   */
  concat(other: Arc4ArrayBase<Byte>): DynamicBytes {
    throw new NoImplementation()
  }
}



================================================
FILE: packages/algo-ts/src/arc4/index.ts
================================================
import { BaseContract } from '../base-contract'
import { NoImplementation } from '../internal/errors'
import { AnyFunction, DeliberateAny, InstanceMethod } from '../internal/typescript-helpers'
import { OnCompleteActionStr } from '../on-complete-action'
import { bytes, BytesCompat, uint64 } from '../primitives'
import { ARC4Encoded } from './encoded-types'

export * from './encoded-types'
export * from './c2c'

/**
 * The base type for all ARC4 contracts in Algorand TypeScript
 */
export class Contract extends BaseContract {
  /**
   * Default implementation of an ARC4 approval program, routes transactions to ABI or bare methods based on application
   * args and on completion actions
   */
  override approvalProgram(): boolean {
    throw new NoImplementation()
  }
}

/**
 * Defines conventional routing method names. When used, methods with these names will be implicitly routed to the corresponding
 * application lifecycle event.
 *
 * @remarks This behaviour is independent of a contract explicitly implementing this interface. The interface is provided simply to improve
 * the developer experience of using this feature.
 */
export interface ConventionalRouting {
  /**
   * The function to invoke when closing out of this application
   */
  closeOutOfApplication?: AnyFunction
  /**
   * The function to invoke when creating this application
   */
  createApplication?: AnyFunction
  /**
   * The function to invoke when deleting this application
   */
  deleteApplication?: AnyFunction
  /**
   * The function to invoke when opting in to this application
   */
  optInToApplication?: AnyFunction
  /**
   * The function to invoke when updating this application
   */
  updateApplication?: AnyFunction
}

/**
 * The possible options for a method being available on application create
 *
 * allow: This method CAN be called when the application is being created, but it is not required
 * disallow: This method CANNOT be called when the application is being created
 * require: This method CAN ONLY be called when the application is being created
 */
export type CreateOptions = 'allow' | 'disallow' | 'require'

/**
 * Type alias for a default argument schema
 * @typeParam TContract The type of the contract containing the method this default argument is for
 */
export type DefaultArgument<TContract extends Contract> =
  | {
      /**
       * A compile time constant value to be used as a default
       */
      constant: string | boolean | number | bigint
    }
  | {
      /**
       * Retrieve the default value from a member of this contract. The member can be
       *
       * LocalState: The value is retrieved from the calling user's local state before invoking this method
       * GlobalState: The value is retrieved from the specified global state key before invoking this method
       * Method: Any readonly abimethod with no arguments can be used as a source
       */
      from: keyof TContract
    }
/**
 * Configuration options for an abi method
 * @typeParam TContract the type of the contract this method is a part of
 */
export type AbiMethodConfig<TContract extends Contract> = {
  /**
   * Which on complete action(s) are allowed when invoking this method.
   * @default 'NoOp'
   */
  allowActions?: OnCompleteActionStr | OnCompleteActionStr[]
  /**
   * Whether this method should be callable when creating the application.
   * @default 'disallow'
   */
  onCreate?: CreateOptions
  /**
   * Does the method only perform read operations (no mutation of chain state)
   * @default false
   */
  readonly?: boolean
  /**
   * Override the name used to generate the abi method selector
   */
  name?: string

  /**
   * Specify default arguments that can be populated by clients calling this method.
   *
   * A map of parameter names to the default argument source
   */
  defaultArguments?: Record<string, DefaultArgument<TContract>>
}

/**
 * Declares the decorated method as an abimethod that is called when the first transaction arg matches the method selector
 * @param config The config for this abi method
 * @typeParam TContract the type of the contract this method is a part of
 */
export function abimethod<TContract extends Contract>(config?: AbiMethodConfig<TContract>) {
  return function <TArgs extends DeliberateAny[], TReturn>(
    target: (this: TContract, ...args: TArgs) => TReturn,
    ctx: ClassMethodDecoratorContext<TContract>,
  ): (this: TContract, ...args: TArgs) => TReturn {
    throw new NoImplementation()
  }
}

/**
 * Configuration options for a bare method
 */
export type BareMethodConfig = {
  /**
   * Which on complete action(s) are allowed when invoking this method.
   * @default 'NoOp'
   */
  allowActions?: OnCompleteActionStr | OnCompleteActionStr[]
  /**
   * Whether this method should be callable when creating the application.
   * @default 'disallow'
   */
  onCreate?: CreateOptions
}

/**
 * Declares the decorated method as a baremethod that can only be called with no transaction args
 * @param config The config for this bare method
 * @typeParam TContract the type of the contract this method is a part of
 */
export function baremethod<TContract extends Contract>(config?: BareMethodConfig) {
  return function <TArgs extends DeliberateAny[], TReturn>(
    target: (this: TContract, ...args: TArgs) => TReturn,
    ctx: ClassMethodDecoratorContext<TContract>,
  ): (this: TContract, ...args: TArgs) => TReturn {
    throw new NoImplementation()
  }
}
/**
 * Returns the ARC4 method selector for a given ARC4 method signature. The method selector is the first
 * 4 bytes of the SHA512/256 hash of the method signature.
 * @param methodSignature An ARC4 contract method reference. (Eg. `MyContract.prototype.myMethod`)
 * @returns The ARC4 method selector. Eg. `02BECE11`
 */
export function methodSelector(methodSignature: InstanceMethod<Contract>): bytes
/**
 * Returns the ARC4 method selector for a given ARC4 method signature. The method selector is the first
 * 4 bytes of the SHA512/256 hash of the method signature.
 * @param methodSignature An ARC4 method signature string (Eg. `hello(string)string`.  Must be a compile time constant)
 * @returns The ARC4 method selector. Eg. `02BECE11`
 */
export function methodSelector(methodSignature: string): bytes
export function methodSelector(methodSignature: string | InstanceMethod<Contract>): bytes {
  throw new NoImplementation()
}

/**
 * Interpret the provided bytes as an ARC4 encoded type with no validation
 * @param bytes An arc4 encoded bytes value
 * @param prefix The prefix (if any), present in the bytes value. This prefix will be validated and removed
 */
export function interpretAsArc4<T extends ARC4Encoded>(bytes: BytesCompat, prefix: 'none' | 'log' = 'none'): T {
  throw new NoImplementation()
}

/**
 * Decode the provided bytes to a native Algorand TypeScript value
 * @param bytes An arc4 encoded bytes value
 * @param prefix The prefix (if any), present in the bytes value. This prefix will be validated and removed
 */
export function decodeArc4<T>(bytes: BytesCompat, prefix: 'none' | 'log' = 'none'): T {
  throw new NoImplementation()
}

/**
 * Encode the provided Algorand TypeScript value as ARC4 bytes
 * @param value Any native Algorand TypeScript value with a supported ARC4 encoding
 */
export function encodeArc4<const T>(value: T): bytes {
  throw new NoImplementation()
}

/**
 * Return the total number of bytes required to store T as ARC4 bytes.
 *
 * T must represent a type with a fixed length encoding scheme.
 * @typeParam T Any native or arc4 type with a fixed encoding size.
 */
export function arc4EncodedLength<T>(): uint64 {
  throw new NoImplementation()
}



================================================
FILE: packages/algo-ts/src/internal/errors.ts
================================================
/**
 * This error can be used in stub implementations that are expected to be overridden
 * by the testing framework
 */
export class NoImplementation extends Error {
  constructor() {
    super('This method is intentionally not implemented')
  }
}



================================================
FILE: packages/algo-ts/src/internal/typescript-helpers.ts
================================================
// Sometimes only an 'any' will do. Don't use this just to be lazy though
/* eslint-disable-next-line @typescript-eslint/no-explicit-any */
export type DeliberateAny = any
export type AnyFunction = (...args: DeliberateAny[]) => DeliberateAny
export type ConstructorFor<T, TArgs extends DeliberateAny[] = DeliberateAny[]> = new (...args: TArgs) => T
export type InstanceMethod<TClass, TArgs extends DeliberateAny[] = DeliberateAny[], TReturn = DeliberateAny> = (
  this: TClass,
  ...args: TArgs
) => TReturn



================================================
FILE: scripts/build-op-module.ts
================================================
import { camelCase, pascalCase } from 'change-case'
import langSpec from '../langspec.puya.json'
import { hasFlags, invariant } from '../src/util'
import type { Op } from './langspec'

function range(start: number, end: number) {
  return Array(end - start)
    .fill(0)
    .map((_, i) => start + i)
}
export const ENUMS_TO_EXPOSE = new Set(['EC', 'ECDSA', 'vrf_verify', 'base64', 'Mimc Configurations'])

const EXCLUDED_OPCODES = new Set([
  // low level flow control
  'bnz',
  'bz',
  'b',
  'callsub',
  'retsub',
  'proto',
  'switch',
  'match',
  // low level stack manipulation
  'intc',
  ...range(0, 4).map((i) => `intc_${i}`),
  'bytec',
  ...range(0, 4).map((i) => `bytec_${i}`),
  'pushbytes',
  'pushbytess',
  'pushint',
  'pushints',
  'frame_dig',
  'frame_bury',
  'bury',
  'cover',
  'dig',
  'dup',
  'dup2',
  'dupn',
  'pop',
  'popn',
  'swap',
  'uncover',
  // program scratch slot read/modification (for current program)
  'load',
  'store',
  // maninuplates what other low level ops point to
  'intcblock',
  'bytecblock',
  // implicit immediates, covered by optimiser and/or assembler
  ...[...Array(4).keys()].map((i) => `arg_${i}`),
  // have a higher level abstraction that supersedes it
  'log',
  // skip as the version with more parameters is available
  'arg',
  'replace2',
  'substring',
  'extract',
  'extract3',
  'gaid',
  'gload',
  'gloads',
  // has overload with stack params
  'txna',
  'itxna',
  'gtxna',
  'gtxn',
  'gtxnsa',
  'gtxnas',
  'gitxna',
  // Manually crafted
  'assert',
  'err',
  'return',

  // Special handling
  'select',
  'setbit',
])

const OPERATOR_OPCODES = new Set([
  '!',
  '!=',
  '%',
  '&',
  '&&',
  '*',
  '+',
  '-',
  '/',
  '<',
  '<=',
  '==',
  '>',
  '>=',
  '^',
  'b!=',
  'b%',
  'b&',
  'b*',
  'b+',
  'b-',
  'b/',
  'b<',
  'b<=',
  'b==',
  'b>',
  'b>=',
  'b^',
  'b|',
  'b~',
  '|',
  '||',
  '~',
])

export enum AlgoTsType {
  None = 0,
  Bytes = 1 << 0,
  Uint64 = 1 << 1,
  Boolean = 1 << 2,
  Account = 1 << 3,
  Asset = 1 << 4,
  Application = 1 << 5,
  Void = 1 << 6,
  BigUint = 1 << 7,
  String = 1 << 8,
  OnCompletion = 1 << 9,
  TransactionType = 1 << 10,
  Enum = 1 << 11,
}

export type EnumValue = {
  name: string
  value: string
  doc: string
  stackType: AlgoTsType | null
  mode: string
  minAvmVersion: number
}

export type EnumDef = {
  typeFlag: number
  name: string
  tsName: string
  members: EnumValue[]
}

const TYPE_MAP: Record<string, AlgoTsType> = {
  account: AlgoTsType.Account,
  address: AlgoTsType.Account,
  address_or_index: AlgoTsType.Account | AlgoTsType.Uint64,
  application: AlgoTsType.Application,
  asset: AlgoTsType.Asset,
  bool: AlgoTsType.Boolean,
  boxName: AlgoTsType.Bytes,
  stateKey: AlgoTsType.Bytes,
  uint8: AlgoTsType.Uint64,
  uint64: AlgoTsType.Uint64,
  bigint: AlgoTsType.BigUint,

  '[]byte': AlgoTsType.Bytes,
  '[8]byte': AlgoTsType.Bytes,
  '[32]byte': AlgoTsType.Bytes,
  '[33]byte': AlgoTsType.Bytes,
  '[64]byte': AlgoTsType.Bytes,
  '[80]byte': AlgoTsType.Bytes,
  '[1232]byte': AlgoTsType.Bytes,
  '[1793]byte': AlgoTsType.Bytes,
  any: AlgoTsType.Uint64 | AlgoTsType.Bytes,
}

const INPUT_ALGOTS_TYPE_MAP: Record<AlgoTsType, AlgoTsType> = {
  [AlgoTsType.None]: AlgoTsType.None,
  [AlgoTsType.Asset]: AlgoTsType.Asset | AlgoTsType.Uint64,
  [AlgoTsType.Application]: AlgoTsType.Application | AlgoTsType.Uint64,
  [AlgoTsType.Bytes]: AlgoTsType.Bytes,
  [AlgoTsType.String]: AlgoTsType.String,
  [AlgoTsType.Uint64]: AlgoTsType.Uint64,
  [AlgoTsType.Boolean]: AlgoTsType.Boolean,
  [AlgoTsType.Account]: AlgoTsType.Account,
  [AlgoTsType.Void]: AlgoTsType.Void,
  [AlgoTsType.BigUint]: AlgoTsType.BigUint,
  [AlgoTsType.OnCompletion]: AlgoTsType.OnCompletion | AlgoTsType.Uint64,
  [AlgoTsType.TransactionType]: AlgoTsType.TransactionType | AlgoTsType.Uint64,
  [AlgoTsType.Enum]: AlgoTsType.Enum,
}

const ARG_ENUMS = Object.entries(langSpec.arg_enums).map(([name, values], index): EnumDef => {
  const enumValues = values.map(
    (v): EnumValue => ({
      name: v.name,
      value: v.name,
      doc: v.doc ?? '',
      mode: v.mode,
      minAvmVersion: v.min_avm_version,
      stackType: v.stack_type === null ? null : getEnumStackType(name, v.name, v.stack_type),
    }),
  )

  return {
    typeFlag: (AlgoTsType.Enum << (index + 1)) | AlgoTsType.Enum,
    name,
    tsName: pascalCase(name),
    members: enumValues,
  }
})

function getEnumStackType(enumName: string, enumMember: string, documentedType: string) {
  switch (enumName) {
    case 'txn':
      switch (enumMember) {
        case 'OnCompletion':
          return AlgoTsType.OnCompletion
        case 'TypeEnum':
          return AlgoTsType.TransactionType
      }
  }
  return getMappedType(documentedType, null)
}

const RENAMED_OPCODES_MAP = new Map([
  ['args', 'arg'],
  ['return', 'exit'],
  ['replace3', 'replace'],
  ['substring3', 'substring'],
  ['gaids', 'gaid'],
  ['gloadss', 'gload'],
  ['setbit', 'setBit'],
  ['bitlen', 'bitLength'],
  ['setbyte', 'setByte'],
  ['getbyte', 'getByte'],
  ['getbit', 'getBit'],
])
type OpNameConfig = {
  nameOverride?: string
  prefix?: string
}

const GROUPED_OPCODES: { name: string; doc: string; ops: { [key: string]: OpNameConfig } }[] = [
  {
    name: 'AppGlobal',
    doc: 'Get or modify Global app state',
    ops: {
      app_global_get: { nameOverride: 'get' },
      app_global_get_ex: { nameOverride: 'get_ex' },
      app_global_del: { nameOverride: 'delete' },
      app_global_put: { nameOverride: 'put' },
    },
  },
  {
    name: 'AppLocal',
    doc: 'Get or modify Local app state',
    ops: {
      app_local_get: { nameOverride: 'get' },
      app_local_get_ex: { nameOverride: 'get_ex' },
      app_local_del: { nameOverride: 'delete' },
      app_local_put: { nameOverride: 'put' },
    },
  },
  {
    name: 'Box',
    doc: 'Get or modify box state',
    ops: {
      box_create: { nameOverride: 'create' },
      box_del: { nameOverride: 'delete' },
      box_extract: { nameOverride: 'extract' },
      box_get: { nameOverride: 'get' },
      box_len: { nameOverride: 'length' },
      box_put: { nameOverride: 'put' },
      box_replace: { nameOverride: 'replace' },
      box_resize: { nameOverride: 'resize' },
      box_splice: { nameOverride: 'splice' },
    },
  },
  {
    name: 'EllipticCurve',
    doc: 'Elliptic Curve functions',
    ops: {
      ec_add: { nameOverride: 'add' },
      ec_map_to: { nameOverride: 'map_to' },
      ec_multi_scalar_mul: { nameOverride: 'scalar_mul_multi' },
      ec_pairing_check: { nameOverride: 'pairing_check' },
      ec_scalar_mul: { nameOverride: 'scalar_mul' },
      ec_subgroup_check: { nameOverride: 'subgroup_check' },
    },
  },
  {
    name: 'ITxnCreate',
    doc: 'Create inner transactions',
    ops: {
      itxn_begin: { nameOverride: 'begin' },
      itxn_next: { nameOverride: 'next' },
      itxn_submit: { nameOverride: 'submit' },
      itxn_field: { prefix: 'set' },
    },
  },
  {
    name: 'Scratch',
    doc: 'Load or store scratch values',
    ops: { loads: { nameOverride: 'load' }, stores: { nameOverride: 'store' } },
  },
  { name: 'AcctParams', doc: '', ops: { acct_params_get: {} } },
  { name: 'AppParams', doc: '', ops: { app_params_get: {} } },
  { name: 'AssetHolding', doc: '', ops: { asset_holding_get: {} } },
  { name: 'AssetParams', doc: '', ops: { asset_params_get: {} } },
  { name: 'VoterParams', doc: '', ops: { voter_params_get: {} } },
  { name: 'Global', doc: '', ops: { global: {} } },
  { name: 'Block', doc: '', ops: { block: {} } },
  { name: 'JsonRef', doc: '', ops: { json_ref: {} } },
  { name: 'Txn', doc: 'Get values for the current executing transaction', ops: { txn: {}, txnas: {} } },
  { name: 'GTxn', doc: 'Get values for transactions in the current group', ops: { gtxns: {}, gtxnsas: {} } },
  { name: 'GITxn', doc: 'Get values for inner transaction in the last group submitted', ops: { gitxn: {}, gitxnas: {} } },
  { name: 'ITxn', doc: 'Get values for the last inner transaction', ops: { itxn: {}, itxnas: {} } },
]

export type OpArg = {
  name: string
  type: AlgoTsType
  optional?: boolean
}

export type EnumArgMeta = {
  member: string
  pos: number
}

export type OpOverloadedFunction = {
  type: 'op-overloaded-function'
  minAvmVersion: number
  signatures: Array<{ immediateArgs: OpArg[]; stackArgs: OpArg[]; returnTypes: AlgoTsType[]; docs: string[] | string }>
  name: string
  opCode: string
}

export type OpFunction = {
  type: 'op-function'
  enumArg?: EnumArgMeta
  immediateArgs: OpArg[]
  stackArgs: OpArg[]
  returnTypes: AlgoTsType[]
  name: string
  opCode: string
  minAvmVersion: number
  docs: string[] | string
}

export type OpGrouping = {
  type: 'op-grouping'
  name: string
  functions: Record<string, OpFunction>
  docs: string[] | string
}

export type OpModule = {
  items: Array<OpFunction | OpGrouping | OpOverloadedFunction>
  enums: EnumDef[]
}

const atomicTypes = [
  AlgoTsType.Bytes,
  AlgoTsType.Uint64,
  AlgoTsType.Boolean,
  AlgoTsType.Account,
  AlgoTsType.Asset,
  AlgoTsType.Application,
  AlgoTsType.Void,
  AlgoTsType.BigUint,
]
function isSplitableUnion(t: AlgoTsType): boolean {
  return !(hasFlags(t, AlgoTsType.Enum) || atomicTypes.includes(t))
}
/**
 * If a function returns a union type, split into multiple functions for each part of the union
 *
 * eg.
 * get(): bytes | uint64
 * becomes
 * getBytes(): bytes
 * getUint64(): uint64
 *
 * We do this because union types can't be introspected on the AVM
 * @param opFunction
 */
function* splitUnionReturnTypes(opFunction: OpFunction): IterableIterator<OpFunction> {
  const indexOfUnionReturnType = opFunction.returnTypes.findIndex(isSplitableUnion)
  if (indexOfUnionReturnType === -1) {
    yield opFunction
  } else {
    const unionReturnType = opFunction.returnTypes[indexOfUnionReturnType]
    for (const atomicType of atomicTypes) {
      if (!hasFlags(unionReturnType, atomicType)) continue
      yield {
        ...opFunction,
        name: opFunction.name + AlgoTsType[atomicType],
        returnTypes: opFunction.returnTypes.map((t, i) => (i === indexOfUnionReturnType ? atomicType : t)),
      }
    }
  }
}

export function buildOpModule() {
  const opModule: OpModule = {
    items: [],
    enums: ARG_ENUMS,
  }

  function tryGetGroup(opCode: string): [OpGrouping | undefined, OpNameConfig] {
    const groupDef = GROUPED_OPCODES.find((g) => Object.hasOwn(g.ops, opCode))
    if (groupDef === undefined) return [undefined, {}]

    let group = opModule.items.find((g): g is OpGrouping => g.type === 'op-grouping' && g.name === groupDef.name)
    if (!group) {
      group = { name: groupDef.name, functions: {}, type: 'op-grouping', docs: groupDef.doc }
      opModule.items.push(group)
    }
    return [group, groupDef.ops[opCode]]
  }

  for (const [opCode, def] of Object.entries(langSpec.ops)) {
    if (EXCLUDED_OPCODES.has(opCode)) continue
    if (OPERATOR_OPCODES.has(opCode)) continue

    const [group, opNameConfig] = tryGetGroup(opCode)

    const opFunctions: OpFunction[] = []

    const enumArg = def.immediate_args.find((a) => a.arg_enum)
    const enumDef = ARG_ENUMS.find((e) => e.name === enumArg?.arg_enum)

    if (enumDef && enumArg && (enumArg.modifies_stack_output !== null || enumArg.modifies_stack_input !== null)) {
      for (const member of enumDef.members) {
        opFunctions.push({
          type: 'op-function',
          minAvmVersion: member.minAvmVersion || def.min_avm_version,
          opCode,
          enumArg: {
            member: member.name,
            pos: def.immediate_args.findIndex((a) => a === enumArg),
          },
          docs: member.doc,
          name: getEnumOpName(member.name, opNameConfig),
          immediateArgs: def.immediate_args.map((i) => ({
            name: camelCase(i.name),
            type: expandInputType(getMappedType(i.immediate_type, i.arg_enum)),
          })),
          stackArgs: def.stack_inputs.map((sa, i) => {
            if (i === enumArg.modifies_stack_input) {
              invariant(member.stackType, 'Member must have stack type')
              return { name: camelCase(sa.name), type: expandInputType(member.stackType) }
            }
            return { name: camelCase(sa.name), type: expandInputType(getMappedType(sa.stack_type, null)) }
          }),
          returnTypes: def.stack_outputs.map((o, i) => {
            if (i === enumArg.modifies_stack_output) {
              invariant(member.stackType, 'Member must have stackType')
              return member.stackType
            }
            return getMappedType(o.stack_type, null)
          }),
        })
      }
    } else {
      opFunctions.push(
        ...splitUnionReturnTypes({
          type: 'op-function',
          opCode: opCode,
          minAvmVersion: def.min_avm_version,
          name: getOpName(def.name, opNameConfig),
          immediateArgs: def.immediate_args.map((i) => ({
            name: camelCase(i.name),
            type: expandInputType(getMappedType(i.immediate_type, i.arg_enum)),
          })),
          stackArgs: def.stack_inputs.map((i) => ({ name: camelCase(i.name), type: expandInputType(getMappedType(i.stack_type, null)) })),
          returnTypes: def.stack_outputs.map((o) => getMappedType(o.stack_type, null)),
          docs: getOpDocs(def),
        }),
      )
    }
    for (const opFunction of opFunctions) {
      if (group) {
        group.functions[opFunction.name] = opFunction
      } else {
        opModule.items.push(opFunction)
      }
    }
  }

  // Manually handle select overloads
  opModule.items.push({
    type: 'op-overloaded-function',
    name: 'extract',
    minAvmVersion: 5,
    signatures: [
      {
        stackArgs: [
          {
            name: 'a',
            type: AlgoTsType.Bytes,
          },
          {
            name: 'b',
            type: AlgoTsType.Uint64,
          },
        ],
        immediateArgs: [],
        returnTypes: [AlgoTsType.Bytes],
        docs: ['A range of bytes from A starting at B up to the end of the sequence'],
      },
      {
        stackArgs: [
          {
            name: 'a',
            type: AlgoTsType.Bytes,
          },
          {
            name: 'b',
            type: AlgoTsType.Uint64,
          },
          {
            name: 'c',
            type: AlgoTsType.Uint64,
          },
        ],
        immediateArgs: [],
        returnTypes: [AlgoTsType.Bytes],
        docs: [
          'A range of bytes from A starting at B up to but not including B+C. If B+C is larger than the array length, the program fails',
        ],
      },
    ],
    opCode: 'extract3',
  })
  opModule.items.push({
    type: 'op-overloaded-function',
    name: 'select',
    minAvmVersion: 3,
    signatures: [
      {
        stackArgs: [
          {
            name: 'a',
            type: AlgoTsType.Bytes,
          },
          {
            name: 'b',
            type: AlgoTsType.Bytes,
          },
          {
            name: 'c',
            type: AlgoTsType.Uint64,
          },
        ],
        immediateArgs: [],
        returnTypes: [AlgoTsType.Bytes],
        docs: ['selects one of two values based on top-of-stack: B if C != 0, else A'],
      },
      {
        stackArgs: [
          {
            name: 'a',
            type: AlgoTsType.Uint64,
          },
          {
            name: 'b',
            type: AlgoTsType.Uint64,
          },
          {
            name: 'c',
            type: AlgoTsType.Uint64,
          },
        ],
        immediateArgs: [],
        returnTypes: [AlgoTsType.Uint64],
        docs: ['selects one of two values based on top-of-stack: B if C != 0, else A'],
      },
    ],
    opCode: 'select',
  })

  // Manually handle set bit overloads
  opModule.items.push({
    type: 'op-overloaded-function',
    name: 'setBit',
    minAvmVersion: 3,
    signatures: [
      {
        stackArgs: [
          {
            name: 'target',
            type: AlgoTsType.Bytes,
          },
          {
            name: 'n',
            type: AlgoTsType.Uint64,
          },
          {
            name: 'c',
            type: AlgoTsType.Uint64,
          },
        ],
        immediateArgs: [],
        returnTypes: [AlgoTsType.Bytes],
        docs: ['Set the nth bit of target to the value of c (1 or 0)'],
      },
      {
        stackArgs: [
          {
            name: 'target',
            type: AlgoTsType.Uint64,
          },
          {
            name: 'n',
            type: AlgoTsType.Uint64,
          },
          {
            name: 'c',
            type: AlgoTsType.Uint64,
          },
        ],
        immediateArgs: [],
        returnTypes: [AlgoTsType.Uint64],
        docs: ['Set the nth bit of target to the value of c (1 or 0)'],
      },
    ],
    opCode: 'setbit',
  })

  return opModule
}

function getOpName(opCode: string, config: OpNameConfig): string {
  return camelCase([config.prefix, RENAMED_OPCODES_MAP.get(opCode) ?? config.nameOverride ?? opCode].filter(Boolean).join('_'))
}

function getEnumOpName(enumMember: string, config: OpNameConfig): string {
  return camelCase([config.prefix, enumMember].filter(Boolean).join('_'))
}

function getMappedType(t: string | null, enumName: string | null): AlgoTsType {
  invariant(t !== 'arg_enum' || enumName !== undefined, 'Must provide enumName for arg_enum types')
  if (t === null || t === undefined) {
    throw new Error('Missing type')
  }
  if (t === 'arg_enum') {
    const enumDef = ARG_ENUMS.find((a) => a.name === enumName)
    invariant(enumDef, `Definition must exist for ${enumName}`)
    return enumDef.typeFlag
  }
  const mappedType = TYPE_MAP[t ?? '']
  invariant(mappedType, `Mapped type must exist for ${t}`)
  return mappedType
}

function splitBitFlags<T extends number>(aType: T): T[] {
  if (!aType) return []
  return new Array(Math.floor(Math.log2(aType)) + 1).fill(null).flatMap((_, i) => {
    const n = (2 ** i) as T
    return n & aType ? n : []
  })
}

function expandInputType(aType: AlgoTsType): AlgoTsType {
  return splitBitFlags(aType).reduce((acc, cur) => acc | (cur in INPUT_ALGOTS_TYPE_MAP ? INPUT_ALGOTS_TYPE_MAP[cur] : cur), AlgoTsType.None)
}

const getOpDocs = (op: Op): string[] => [
  ...(op.doc ?? [])
    .filter(Boolean)
    .map((d: string) => `${d.replace('params: ', '@param ').replace('Return: ', '\n * @return ')}`.split('\n').map((s) => s.trimEnd()))
    .flat(),
  `@see Native TEAL opcode: [\`${op.name}\`](https://dev.algorand.co/reference/algorand-teal/opcodes#${op.name})`,
]



================================================
FILE: scripts/code-gen.ts
================================================
/* eslint-disable no-console */
import chalk from 'chalk'
import { sync } from 'cross-spawn'
import fs from 'fs'
import upath from 'upath'
import type { OpModule } from './build-op-module'
import { buildOpModule } from './build-op-module'
import { emitOpFuncTypes } from './generate-op-funcs'
import { emitOpMetaData } from './generate-op-metadata'
import { emitOpPTypes } from './generate-op-ptypes'
import { emitGTxnTypes, emitITxnTypes } from './generate-txn-types'

/**
 * Generate several files from the langspec.puya.json. This file is created by a script in the puya project
 * which tweaks the base langspec.json which is generated by go-algorand.
 * @param puyaTsRootDir The root directory of the puya-ts project
 */
function runCodeGen(puyaTsRootDir: string) {
  console.log(chalk.cyan(`Generating code for project ${puyaTsRootDir}`))

  const opModule = buildOpModule()

  const files: Record<
    string,
    {
      emitFn: (module: OpModule) => Generator<string, void>
      projectRoot: string
      outPath: string
      disabled?: boolean
      skipLint?: boolean
    }
  > = {
    'op-module': {
      emitFn: function* (opModule) {
        yield JSON.stringify(opModule, undefined, 2)
      },
      projectRoot: '',
      outPath: 'scripts/temp/ops.json',
      disabled: true,
      skipLint: true,
    },
    'op function types': {
      emitFn: emitOpFuncTypes,
      projectRoot: 'packages/algo-ts',
      outPath: 'src/op.ts',
    },
    'op builder metadata': {
      emitFn: emitOpMetaData,
      projectRoot: '',
      outPath: 'src/awst_build/op-metadata.ts',
    },
    'op ptypes': {
      emitFn: emitOpPTypes,
      projectRoot: '',
      outPath: 'src/awst_build/ptypes/op-ptypes.ts',
    },
    gtxn: {
      emitFn: emitGTxnTypes,
      projectRoot: 'packages/algo-ts',
      outPath: 'src/gtxn.ts',
    },
    itxn: {
      emitFn: emitITxnTypes,
      projectRoot: 'packages/algo-ts',
      outPath: 'src/itxn.ts',
    },
  }

  for (const [desc, { emitFn, projectRoot, outPath, skipLint, disabled }] of Object.entries(files)) {
    if (disabled) {
      console.log(chalk.gray(`Skipping disabled ${desc}`))
      continue
    }
    console.log(chalk.blueBright(`Generating ${desc}`))

    const fullPath = upath.join(puyaTsRootDir, projectRoot, outPath)
    console.log(chalk.blue(`Writing text to ${fullPath}`))
    fs.writeFileSync(fullPath, Array.from(emitFn(opModule)).join(''), 'utf8')
    if (skipLint) {
      console.log(chalk.gray(`Skipping linting ${fullPath}`))
      continue
    }
    console.log(chalk.blue(`Linting ${fullPath}`))
    lintFile(upath.join(puyaTsRootDir, projectRoot), outPath)
  }
  console.log(chalk.green('Done!'))
}

function lintFile(cwd: string, path: string) {
  sync('npx', ['-c', `eslint ${path} --fix`], {
    stdio: 'inherit',
    cwd,
  })
}

/**
 * Resolve the project root form the current working directory.
 * Assumes the script is either run from the project root, or from the scripts directory (which would happen if you
 * were to right-click this file and select 'run code-gen.ts' in a supporting IDE)
 */
function resolveProjectRoot() {
  const cwd = process.cwd()
  if (cwd.endsWith('scripts')) {
    return upath.join(cwd, '../')
  }
  return cwd
}

runCodeGen(resolveProjectRoot())



================================================
FILE: scripts/generate-op-funcs.ts
================================================
import { camelCase } from 'change-case'
import { distinct, enumerate, hasFlags } from '../src/util'
import type { OpArg, OpModule, OpOverloadedFunction } from './build-op-module'
import { AlgoTsType, ENUMS_TO_EXPOSE } from './build-op-module'

export function* emitOpFuncTypes(module: OpModule) {
  function* emitHeader() {
    yield `/* THIS FILE IS GENERATED BY ~/scripts/generate-op-funcs.ts - DO NOT MODIFY DIRECTLY */
import { NoImplementation } from "./internal/errors";
import { bytes, uint64, biguint } from './primitives'
import { Account, Application, Asset } from './reference'
import { OnCompleteAction } from "./on-complete-action";
import { TransactionType } from "./transactions";
`
  }
  function* noImplementation() {
    yield '{'
    yield `throw new NoImplementation()`
    yield '}'
  }

  function* emitDoc(doc: string | string[], minAvmVersion?: number) {
    if (Array.isArray(doc)) {
      yield '\n/**'
      for (const row of doc) {
        yield '\n  * '
        yield row
      }
    } else if (doc) {
      yield '\n/**'
      yield '\n  * '
      yield doc
    } else {
      return
    }
    if (minAvmVersion !== undefined) yield `\n  * Min AVM version: ${minAvmVersion}`
    yield '\n  */'
    yield '\n'
  }
  function* emitEnums() {
    for (const enumDef of module.enums) {
      if (!ENUMS_TO_EXPOSE.has(enumDef.name)) continue

      yield `export enum ${enumDef.tsName} {`
      for (const member of enumDef.members) {
        yield* emitDoc(member.doc)
        yield `${member.name} = '${member.value}',`
      }

      yield `}\n`
    }
  }

  function* emitReturnType(returnType: AlgoTsType) {
    if (hasFlags(returnType, AlgoTsType.Application)) yield 'Application'
    if (hasFlags(returnType, AlgoTsType.Account)) yield 'Account'
    if (hasFlags(returnType, AlgoTsType.Asset)) yield 'Asset'
    if (hasFlags(returnType, AlgoTsType.Uint64)) yield 'uint64'
    if (hasFlags(returnType, AlgoTsType.Bytes)) yield 'bytes'
    if (hasFlags(returnType, AlgoTsType.String)) yield 'string'
    if (hasFlags(returnType, AlgoTsType.Boolean)) yield 'boolean'
    if (hasFlags(returnType, AlgoTsType.BigUint)) yield 'biguint'
    if (hasFlags(returnType, AlgoTsType.Void)) yield 'void'
    if (hasFlags(returnType, AlgoTsType.TransactionType)) yield 'TransactionType'
    if (hasFlags(returnType, AlgoTsType.OnCompletion)) yield 'OnCompleteAction'
    if (hasFlags(returnType, AlgoTsType.Enum)) {
      for (const enumDef of module.enums.filter((a) => hasFlags(a.typeFlag, returnType))) {
        yield enumDef.tsName
      }
    }
  }
  function* emitReturnTypes(returnTypes: AlgoTsType[]) {
    switch (returnTypes.length) {
      case 0:
        yield 'void'
        break
      case 1:
        yield Array.from(emitReturnType(returnTypes[0])).join(' | ')
        break
      default:
        yield 'readonly ['
        for (const rt of returnTypes) {
          yield Array.from(emitReturnType(rt)).join(' | ')
          yield ','
        }
        yield ']'
        break
    }
  }
  function* emitArgType(argType: AlgoTsType) {
    if (hasFlags(argType, AlgoTsType.Application)) yield 'Application'
    if (hasFlags(argType, AlgoTsType.Account)) yield 'Account'
    if (hasFlags(argType, AlgoTsType.Asset)) yield 'Asset'
    if (hasFlags(argType, AlgoTsType.Uint64)) yield 'uint64'
    if (hasFlags(argType, AlgoTsType.Bytes)) yield 'bytes'
    if (hasFlags(argType, AlgoTsType.String)) yield 'string'
    if (hasFlags(argType, AlgoTsType.Boolean)) yield 'boolean'
    if (hasFlags(argType, AlgoTsType.BigUint)) yield 'biguint'
    if (hasFlags(argType, AlgoTsType.Void)) yield 'void'
    if (hasFlags(argType, AlgoTsType.TransactionType)) yield 'TransactionType'
    if (hasFlags(argType, AlgoTsType.OnCompletion)) yield 'OnCompleteAction'
    if (hasFlags(argType, AlgoTsType.Enum)) {
      for (const enumDef of module.enums.filter((a) => hasFlags(argType, a.typeFlag))) {
        yield enumDef.tsName
      }
    }
  }
  function* emitArg(arg: OpArg) {
    yield arg.name
    if (arg.optional) {
      yield '?'
    }
    yield ':'
    yield Array.from(emitArgType(arg.type)).join(' | ')
    yield ','
  }

  function combineReturnTypes(op: OpOverloadedFunction): string {
    return op.signatures
      .map((s) => Array.from(emitReturnTypes(s.returnTypes)).join(''))
      .filter(distinct())
      .join(' | ')
  }

  yield* emitHeader()

  yield* emitEnums()

  for (const item of module.items) {
    if (item.type === 'op-function') {
      yield* emitDoc(item.docs, item.minAvmVersion)
      yield `export function ${camelCase(item.name)}(`
      for (const arg of item.immediateArgs) {
        yield* emitArg(arg)
      }
      for (const arg of item.stackArgs) {
        yield* emitArg(arg)
      }
      yield `): `
      yield* emitReturnTypes(item.returnTypes)
      yield* noImplementation()
    } else if (item.type === 'op-overloaded-function') {
      for (const signature of item.signatures) {
        yield* emitDoc(signature.docs)
        yield `export function ${camelCase(item.name)}(`
        for (const arg of signature.immediateArgs) {
          yield* emitArg(arg)
        }
        for (const arg of signature.stackArgs) {
          yield* emitArg(arg)
        }
        yield `): `
        yield* emitReturnTypes(signature.returnTypes)
        yield '\n'
      }
      yield `export function ${camelCase(item.name)}(`
      const args = item.signatures
        .map((s) => s.immediateArgs.concat(s.stackArgs))
        .reduce((acc, cur) =>
          new Array(Math.max(acc.length, cur.length)).fill(null).map((_, i): OpArg => {
            const left = acc[i]
            const right = cur[i]
            return left
              ? right
                ? {
                    name: left.name,
                    type: left.type | right.type,
                  }
                : {
                    ...left,
                    optional: true,
                  }
              : {
                  ...right,
                  optional: true,
                }
          }),
        )
      for (const arg of args) {
        yield* emitArg(arg)
      }
      yield '): '
      yield combineReturnTypes(item)
      yield* noImplementation()
    } else {
      yield* emitDoc(item.docs)

      yield `export const ${item.name} = {`

      for (const ol of Object.values(item.functions)) {
        yield '\n'
        yield* emitDoc(ol.docs, ol.minAvmVersion)
        if (ol.stackArgs.length === 0 && ol.immediateArgs.length === 1) {
          yield 'get '
        }
        yield `${ol.name}(`
        for (const [index, arg] of enumerate(ol.immediateArgs)) {
          if (index === ol.enumArg?.pos) continue

          yield* emitArg(arg)
        }
        for (const arg of ol.stackArgs) {
          yield* emitArg(arg)
        }
        yield `):`
        yield* emitReturnTypes(ol.returnTypes)
        yield* noImplementation()
        yield ',\n'
      }

      yield `}\n`
    }
    yield `\n`
  }
}



================================================
FILE: scripts/generate-op-metadata.ts
================================================
import { camelCase } from 'change-case'
import { enumerate, hasFlags } from '../src/util'
import type { OpFunction, OpGrouping, OpModule, OpOverloadedFunction } from './build-op-module'
import { AlgoTsType } from './build-op-module'

export function* emitOpMetaData(opModule: OpModule) {
  function* emitHeader() {
    yield `
/* THIS FILE IS GENERATED BY ~/scripts/generate-op-metadata.ts - DO NOT MODIFY DIRECTLY */
import * as ptypes from './ptypes'
import { Expression } from '../awst/nodes'

export type ImmediateArgMapping = {
  name: string
  ptypes: ptypes.PType[]
}


export type StackArg = {
  name: string
  ptypes: ptypes.PType[]
}

export type Signature = {
  argNames: string[]
  immediateArgs: Array<ImmediateArgMapping | bigint | string>
  stackArgs: Array<StackArg | Expression>
  returnType: ptypes.PType
}

export type IntrinsicOpMapping = {
  type: 'op-mapping'
  op: string
  signatures: Signature[]
}
export type IntrinsicOpGrouping = {
  type: 'op-grouping'
  name: string
  ops: Record<string, IntrinsicOpMapping>
}
`
  }

  function* algoTsToPType(t: AlgoTsType) {
    if (hasFlags(t, AlgoTsType.Enum)) {
      for (const enumDef of opModule.enums) {
        if (hasFlags(t, enumDef.typeFlag)) {
          yield `ptypes.${camelCase(enumDef.tsName)}PType`
          t ^= enumDef.typeFlag ^ AlgoTsType.Enum
        }
      }
      t ^= AlgoTsType.Enum
    }
    if (hasFlags(t, AlgoTsType.Asset)) {
      t ^= AlgoTsType.Asset
      yield 'ptypes.assetPType'
    }
    if (hasFlags(t, AlgoTsType.Account)) {
      t ^= AlgoTsType.Account
      yield 'ptypes.accountPType'
    }
    if (hasFlags(t, AlgoTsType.Application)) {
      t ^= AlgoTsType.Application
      yield 'ptypes.applicationPType'
    }
    if (hasFlags(t, AlgoTsType.Uint64)) {
      t ^= AlgoTsType.Uint64
      yield 'ptypes.uint64PType'
    }
    if (hasFlags(t, AlgoTsType.BigUint)) {
      t ^= AlgoTsType.BigUint
      yield 'ptypes.biguintPType'
    }
    if (hasFlags(t, AlgoTsType.Boolean)) {
      t ^= AlgoTsType.Boolean
      yield 'ptypes.boolPType'
    }
    if (hasFlags(t, AlgoTsType.Void)) {
      t ^= AlgoTsType.Void
      yield 'ptypes.voidPType'
    }
    if (hasFlags(t, AlgoTsType.Bytes)) {
      t ^= AlgoTsType.Bytes
      yield 'ptypes.bytesPType'
    }
    if (hasFlags(t, AlgoTsType.String)) {
      t ^= AlgoTsType.String
      yield 'ptypes.stringPType'
    }
    if (hasFlags(t, AlgoTsType.OnCompletion)) {
      t ^= AlgoTsType.OnCompletion
      yield 'ptypes.onCompleteActionType.memberType'
    }
    if (hasFlags(t, AlgoTsType.TransactionType)) {
      t ^= AlgoTsType.TransactionType
      yield 'ptypes.transactionTypeType.memberType'
    }
    if (Number(t) !== 0) throw new Error(`Unhandled flags ${t}`)
  }

  function* algoTsToLiteralPType(t: AlgoTsType) {
    if (hasFlags(t, AlgoTsType.Enum)) {
      for (const enumDef of opModule.enums) {
        if (hasFlags(t, enumDef.typeFlag)) {
          yield `ptypes.${camelCase(enumDef.tsName)}PType`
          t ^= enumDef.typeFlag ^ AlgoTsType.Enum
        }
      }
      t ^= AlgoTsType.Enum
    }
    if (hasFlags(t, AlgoTsType.Uint64)) {
      t ^= AlgoTsType.Uint64
      yield 'ptypes.uint64PType'
    }
    if (Number(t) !== 0) throw new Error(`Unhandled flags ${t}`)
  }

  function mapReturnType(returnTypes: AlgoTsType[]) {
    if (returnTypes.length === 0) {
      return 'ptypes.voidPType'
    }
    const ptypes = returnTypes.map((t) => {
      const mapped = Array.from(algoTsToPType(t))
      if (mapped.length === 1) {
        return mapped[0]
      }
      throw new Error(`Cannot have union return types: ${ptypes.join(' | ')}`)
    })
    if (ptypes.length === 1) {
      return ptypes[0]
    }
    return `new ptypes.TuplePType({items: [${ptypes.join(', ')}]})`
  }

  function* emitTypes() {
    function* emitOpMapping(op: OpFunction) {
      yield `'${op.name}': `
      yield `{`
      yield `type: 'op-mapping',`
      yield `op: '${op.opCode}',`
      yield `signatures: [{`
      yield `argNames: [`
      for (const [index, arg] of enumerate(op.immediateArgs)) {
        if (index === op.enumArg?.pos) continue
        yield `'${arg.name}',`
      }
      yield op.stackArgs.map((a) => `'${a.name}'`).join(', ')
      yield '],'
      yield 'immediateArgs: ['
      for (const [index, ia] of enumerate(op.immediateArgs)) {
        if (op.enumArg?.pos === index) {
          yield `'${op.enumArg.member}',`
        } else {
          yield `{ name: '${ia.name}', ptypes: [${Array.from(algoTsToLiteralPType(ia.type)).join(', ')}] },`
        }
      }
      yield '],'
      yield 'stackArgs: ['
      for (const sa of op.stackArgs) {
        yield `{ name: '${sa.name}', ptypes: [${Array.from(algoTsToPType(sa.type)).join(', ')}] },`
      }
      yield '],'
      yield `returnType: ${mapReturnType(op.returnTypes)},`
      yield `}]`
      yield '},'
    }

    function* emitOpOverloadedMapping(op: OpOverloadedFunction) {
      yield `'${op.name}': `
      yield `{`
      yield `type: 'op-mapping',`
      yield `op: '${op.opCode}',`
      yield `signatures: [`
      for (const signature of op.signatures) {
        yield '{'
        yield `argNames: [`
        for (const arg of signature.immediateArgs) {
          yield `'${arg.name}',`
        }
        yield signature.stackArgs.map((a) => `'${a.name}'`).join(', ')
        yield '],'
        yield 'immediateArgs: ['
        for (const ia of signature.immediateArgs) {
          yield `{ name: '${ia.name}', ptypes: [${Array.from(algoTsToLiteralPType(ia.type)).join(', ')}] },`
        }
        yield '],'
        yield 'stackArgs: ['
        for (const sa of signature.stackArgs) {
          yield `{ name: '${sa.name}', ptypes: [${Array.from(algoTsToPType(sa.type)).join(', ')}] },`
        }
        yield '],'
        yield `returnType: ${mapReturnType(signature.returnTypes)},`
        yield '},'
      }
      yield `]`
      yield '},'
    }

    function* emitOpGrouping(group: OpGrouping) {
      yield `${group.name}: `
      yield `{`
      yield `type: 'op-grouping',`
      yield `name: '${group.name}',`
      yield `ops: {`

      for (const op of Object.values(group.functions)) {
        yield* emitOpMapping(op)
      }

      yield `}`
      yield '},'
    }

    yield* emitHeader()
    yield `export const OP_METADATA: Record<string, IntrinsicOpMapping | IntrinsicOpGrouping> = {\n`
    for (const item of opModule.items) {
      if (item.type === 'op-function') {
        yield* emitOpMapping(item)
      } else if (item.type === 'op-overloaded-function') {
        yield* emitOpOverloadedMapping(item)
      } else {
        yield* emitOpGrouping(item)
      }
    }
    yield `\n}`
  }

  yield* emitTypes()
}



================================================
FILE: scripts/generate-op-ptypes.ts
================================================
import { camelCase, pascalCase } from 'change-case'
import type { EnumDef, OpModule } from './build-op-module'
import { ENUMS_TO_EXPOSE } from './build-op-module'

function* emitHeader() {
  yield `
  /* THIS FILE IS GENERATED BY ~/scripts/generate-op-ptypes.ts - DO NOT MODIFY DIRECTLY */
  import { IntrinsicEnumType } from './intrinsic-enum-type'
  import { Constants } from "../../constants";


`
}

export function* emitOpPTypes(module: OpModule) {
  function* emitEnumPType(enumDef: EnumDef) {
    yield `export const ${camelCase(enumDef.tsName)}PType = new IntrinsicEnumType({
      name: '${pascalCase(enumDef.name)}',
      module: \`\${Constants.algoTsPackage}/op.d.ts\`,
      members: [`
    for (const member of enumDef.members) {
      yield `['${member.name}', '${member.value}'],`
    }
    yield `]});`
  }

  yield* emitHeader()
  for (const enumDef of module.enums) {
    if (!ENUMS_TO_EXPOSE.has(enumDef.name)) continue
    yield* emitEnumPType(enumDef)
  }
  yield `export const ALL_OP_ENUMS = [`
  yield module.enums
    .filter((e) => ENUMS_TO_EXPOSE.has(e.name))
    .map((e) => `${camelCase(e.tsName)}PType`)
    .join(', ')
  yield '];'
  yield `\n`
}



================================================
FILE: scripts/generate-txn-types.ts
================================================
import { camelCase } from 'change-case'
import { TxnField } from '../src/awst/txn-fields'
import type { PType } from '../src/awst_build/ptypes'
import type { TxnFieldMetaData, TxnFieldsMetaData } from '../src/awst_build/txn-fields'
import {
  applicationCallTxnFields,
  assetConfigTxnFields,
  assetFreezeTxnFields,
  assetTransferTxnFields,
  keyRegistrationTxnFields,
  paymentTxnFields,
} from '../src/awst_build/txn-fields'

const txnTypes: Record<string, TxnFieldsMetaData> = {
  Payment: paymentTxnFields,
  KeyRegistration: keyRegistrationTxnFields,
  AssetConfig: assetConfigTxnFields,
  AssetTransfer: assetTransferTxnFields,
  AssetFreeze: assetFreezeTxnFields,
  ApplicationCall: applicationCallTxnFields,
}

function txnTypeName(type: string) {
  switch (type) {
    case 'Payment':
      return 'pay'
    case 'KeyRegistration':
      return 'keyreg'
    case 'AssetConfig':
      return 'acfg'
    case 'AssetTransfer':
      return 'axfer'
    case 'AssetFreeze':
      return 'afrz'
    case 'ApplicationCall':
      return 'appl'
    default:
      throw new Error(`Invalid type ${type}`)
  }
}

export function* emitGTxnTypes() {
  yield '/* THIS FILE IS GENERATED BY ~/scripts/generate-txn-types.ts - DO NOT MODIFY DIRECTLY */\n'
  yield `import { OnCompleteAction } from './on-complete-action';`
  yield `import { bytes, uint64 } from './primitives';`
  yield `import { Account, Application, Asset } from './reference';`
  yield `import { TransactionType } from './transactions';`
  yield `import { NoImplementation } from "./internal/errors";`
  yield ''
  yield `const isGtxn = Symbol('isGtxn');`
  yield ''
  for (const [txnType, fields] of Object.entries(txnTypes)) {
    yield* emitComment(`A group transaction of type '${txnTypeName(txnType)}'`)
    yield `export interface ${txnType}Txn {`
    yield '\n  /** @hidden */'
    yield '\n  [isGtxn]?: true;'
    for (const [fieldName, fieldMetadata] of Object.entries(fields)) {
      yield* emitTxnField(txnType, fieldName, fieldMetadata)
    }
    yield '}'
  }

  yield* emitComment('A group transaction of any type')
  yield `export type Transaction = ${Object.keys(txnTypes)
    .map((t) => `${t}Txn`)
    .join(' | ')}`

  yield* emitComment(['Get the nth transaction in the group without verifying its type', '@param n The index of the txn in the group'])
  yield `export function Transaction(n: uint64): Transaction {`
  yield 'throw new NoImplementation()'
  yield '}'
  for (const txnType of Object.keys(txnTypes)) {
    yield* emitComment([
      'Get the nth transaction in the group',
      `Verifies the txn type is '${txnTypeName(txnType)}'`,
      '@param n The index of the txn in the group',
    ])
    yield `export function ${txnType}Txn(n: uint64): ${txnType}Txn {`
    yield 'throw new NoImplementation()'
    yield '}'
  }
}

export function* emitITxnTypes() {
  yield '/* THIS FILE IS GENERATED BY ~/scripts/generate-txn-types.ts - DO NOT MODIFY DIRECTLY */\n'
  yield `import { OnCompleteAction } from './on-complete-action';`
  yield `import { bytes, uint64 } from './primitives';`
  yield `import { Account, Application, Asset } from './reference';`
  yield `import { TransactionType } from './transactions';`
  yield `import { NoImplementation } from "./internal/errors";`
  yield ''
  yield `const isItxn = Symbol('isItxn');`
  yield '\n'

  for (const [txnType, fields] of Object.entries(txnTypes)) {
    yield* emitComment(`An inner transaction of type '${txnTypeName(txnType)}'`)

    yield `export interface ${txnType}InnerTxn {`
    yield '\n  /** @hidden */'
    yield '\n  [isItxn]?: true;'
    for (const [fieldName, fieldMetadata] of Object.entries(fields)) {
      yield* emitTxnField(txnType, fieldName, fieldMetadata)
    }
    yield '}'
  }
  for (const [txnType, fields] of Object.entries(txnTypes)) {
    yield `export interface ${txnType}Fields {`
    for (const [fieldName, fieldMetadata] of Object.entries(fields)) {
      yield* emitTxnInputField(fieldName, fieldMetadata)
    }
    yield '}'
  }

  yield* emitComment('A union of all ItxnParams types')
  yield `export type ItxnParams = ${Object.keys(txnTypes)
    .map((t) => `${t}ItxnParams`)
    .join(' | ')};`

  yield* emitComment('Conditional type which returns the matching InnerTransaction types for a given tuple of ItxnParams types')
  yield `export type TxnFor<TFields extends [...ItxnParams[]]> = TFields extends [{ submit(): infer TTxn }, ...infer TRest extends [...ItxnParams[]]]
  ? [TTxn, ...TxnFor<TRest>]
  : [];`

  yield* emitComment('Submit a group of ItxnParams objects and return the InnerTransaction results')
  yield `export function submitGroup<TFields extends [...ItxnParams[]]>(...transactionFields: TFields): TxnFor<TFields>`
  yield* emitNoImplementation()

  for (const txnType of Object.keys(txnTypes)) {
    yield* emitComment(`Holds ${txnType} fields which can be updated, cloned, or submitted.`)
    yield `export abstract class ${txnType}ItxnParams {`
    yield* emitComment(`Submit an itxn with these fields and return the ${txnType}InnerTxn result`)
    yield `submit(): ${txnType}InnerTxn`
    yield* emitNoImplementation()
    yield* emitComment(`Update one or more fields in this ${txnType}ItxnParams object`)
    yield `set(fields: ${txnType}Fields): void`
    yield* emitNoImplementation()
    yield* emitComment(`Return a copy of this ${txnType}ItxnParams object`)
    yield `copy(): ${txnType}ItxnParams`
    yield* emitNoImplementation()
    yield '}'
    yield* emitComment(`Create a new ${txnType}ItxnParams object with the specified fields`)
    yield `export function ${camelCase(txnType)}(fields: ${txnType}Fields): ${txnType}ItxnParams ;`
    yield* emitNoImplementation()
  }
}

function* emitNoImplementation() {
  yield '{'
  yield 'throw new NoImplementation()'
  yield '}'
}

function* emitComment(comment: string | string[]) {
  yield '\n/**'
  if (Array.isArray(comment)) {
    for (const line of comment) {
      yield `\n * ${line}`
    }
  } else {
    yield `\n * ${comment}`
  }
  yield '\n */\n'
}

function* emitTxnField(txnType: string, fieldName: string, field: TxnFieldMetaData) {
  yield* emitComment(field.comment)

  if (field.indexable) {
    yield `${fieldName}(index: uint64): ${field.ptype.name}`
  } else {
    yield `readonly ${fieldName}: ${field.ptype.name}${fieldName === 'type' ? `.${txnType}` : ''} `
  }
}
function* emitTxnInputField(fieldName: string, field: TxnFieldMetaData) {
  if (field.computed) return
  yield* emitComment(field.comment)

  const typeName = getInputTypeUnion(field.field, field.ptype)
  switch (fieldName) {
    case 'approvalProgramPages':
      yield 'approvalProgram?: '
      break
    case 'clearStateProgramPages':
      yield 'clearStateProgram?: '
      break
    default:
      yield `${fieldName}?: `
      break
  }

  if (fieldName === 'appArgs') {
    yield 'readonly [...unknown[]]'
    return
  }

  if (field.indexable) {
    if (field.arrayPromote) yield `${typeName} |`
    yield `readonly [...(${typeName})[]]`
  } else {
    yield typeName
  }
}

function getInputTypeUnion(field: TxnField, inputType: PType) {
  switch (inputType.name) {
    case 'Asset':
      return 'Asset | uint64'
    case 'Account':
      return 'Account | bytes'
    case 'Application':
      return 'Application | uint64'
    case 'bytes':
      switch (field) {
        case TxnField.ConfigAssetName:
        case TxnField.ConfigAssetUnitName:
        case TxnField.ConfigAssetURL:
        case TxnField.Note:
          // Accept bytes | string for fields that are commonly utf8 encoded
          return 'bytes | string'
      }
  }
  return inputType.name
}



================================================
FILE: scripts/langspec.d.ts
================================================
export interface LangSpec {
  ops: { [key: string]: Op }
  arg_enums: ArgEnum
}

export interface Op {
  name: string
  size: number
  doc: string[]
  cost: Cost
  min_avm_version: number
  halts: boolean
  mode: string
  groups: string[]
  stack_inputs: StackInputOutput[]
  immediate_args: ImmediateArg[]
  stack_outputs: StackInputOutput[]
}

export interface Cost {
  value: number | null
  doc: string
}

export interface ImmediateArg {
  name: string
  immediate_type: string
  arg_enum: string | null
  modifies_stack_input: number | null
  modifies_stack_output: number | null
  doc: string
}

export interface StackInputOutput {
  name: string
  stack_type: string
  doc: string[] | null
}

export interface ArgEnum {
  [key: string]: ArgEnumValue[]
}

export interface ArgEnumValue {
  name: string
  doc: string | null
  stack_type: string | null
  mode: string
}



================================================
FILE: src/cli.ts
================================================
import { parseCliArguments } from './cli/parse'

void parseCliArguments()



================================================
FILE: src/compile.ts
================================================
import type ts from 'typescript'
import type { AWST } from './awst/nodes'
import { validateAwst } from './awst/validation'
import { buildAwst } from './awst_build'
import type { CompilationSet } from './awst_build/models/contract-class-model'
import { registerPTypes } from './awst_build/ptypes/register'
import { typeRegistry } from './awst_build/type-registry'
import { logger, LoggingContext } from './logger'
import type { CompileOptions } from './options'
import { createTsProgram } from './parser'
import { invokePuya } from './puya'

export type CompileResult = {
  programDirectory: string
  awst?: AWST[]
  ast?: Record<string, ts.SourceFile>
  compilationSet?: CompilationSet
}

export async function compile(options: CompileOptions): Promise<CompileResult> {
  const loggerCtx = LoggingContext.current
  registerPTypes(typeRegistry)
  const programResult = createTsProgram(options)
  if (loggerCtx.hasErrors()) {
    logger.info(undefined, 'Compilation halted due to parse errors')
    return {
      programDirectory: programResult.programDirectory,
      ast: programResult.sourceFiles,
    }
  }
  const [moduleAwst, compilationSet] = buildAwst(programResult, options)
  validateAwst(moduleAwst)

  if (loggerCtx.hasErrors()) {
    logger.info(undefined, 'Compilation halted due to errors')
    return {
      programDirectory: programResult.programDirectory,
      awst: moduleAwst,
      ast: programResult.sourceFiles,
      compilationSet,
    }
  }
  if (!options.dryRun) {
    await invokePuya({
      options,
      moduleAwst,
      programDirectory: programResult.programDirectory,
      compilationSet,
      sourceFiles: programResult.sourceFiles,
    })
  }

  return {
    programDirectory: programResult.programDirectory,
    awst: moduleAwst,
    ast: programResult.sourceFiles,
    compilationSet,
  }
}



================================================
FILE: src/constants.ts
================================================
const algoTsPackage = '@algorandfoundation/algorand-typescript'

export const Constants = {
  algoTsPackage,
  moduleNames: {
    polytype: 'polytype/lib/polytype-module.d.ts',
    algoTs: {
      arc28: `${algoTsPackage}/arc-28.d.ts`,
      arc4: {
        index: `${algoTsPackage}/arc4/index.d.ts`,
        encodedTypes: `${algoTsPackage}/arc4/encoded-types.d.ts`,
        c2c: `${algoTsPackage}/arc4/c2c.d.ts`,
      },
      baseContract: `${algoTsPackage}/base-contract.d.ts`,
      box: `${algoTsPackage}/box.d.ts`,
      compiled: `${algoTsPackage}/compiled.d.ts`,
      itxn: `${algoTsPackage}/itxn.d.ts`,
      gtxn: `${algoTsPackage}/gtxn.d.ts`,
      logicSig: `${algoTsPackage}/logic-sig.d.ts`,
      mutableArray: `${algoTsPackage}/mutable-array.d.ts`,
      onCompleteAction: `${algoTsPackage}/on-complete-action.d.ts`,
      op: `${algoTsPackage}/op.d.ts`,
      primitives: `${algoTsPackage}/primitives.d.ts`,
      reference: `${algoTsPackage}/reference.d.ts`,
      state: `${algoTsPackage}/state.d.ts`,
      templateVar: `${algoTsPackage}/template-var.d.ts`,
      transactions: `${algoTsPackage}/transactions.d.ts`,
      util: `${algoTsPackage}/util.d.ts`,
    },
  },

  symbolNames: {
    approvalProgramMethodName: 'approvalProgram',
    clearStateProgramMethodName: 'clearStateProgram',
    arc4BareDecoratorName: 'arc4.baremethod',
    arc4AbiDecoratorName: 'arc4.abimethod',
    contractOptionsDecoratorName: 'contract',
    logicSigOptionsDecoratorName: 'logicsig',
    constructorMethodName: 'constructor',
    logicSigProgramMethodName: 'program',
    defaultCreateMethodName: '__algots__.defaultCreate',
    conventionalRouting: {
      closeOutOfApplicationMethodName: 'closeOutOfApplication',
      createApplicationMethodName: 'createApplication',
      deleteApplicationMethodName: 'deleteApplication',
      optInToApplicationMethodName: 'optInToApplication',
      updateApplicationMethodName: 'updateApplication',
    },
  },

  algo: {
    arc4: {
      logPrefixHex: '151F7C75',
    },
    addressLength: 32,
    encodedAddressLength: 58,
    maxTransactionGroupSize: 16,
    zeroAddressB32: 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAY5HFKQ',
  },

  supportedAvmVersions: [10n, 11n],
  targetedPuyaVersion: '4.7.0',
  puyaGithubRepo: 'algorandfoundation/puya',
  minNodeVersion: '22.14.0',
  languageServerSource: 'puyats',
} as const

export type SupportedAvmVersion = (typeof Constants.supportedAvmVersions)[number]



================================================
FILE: src/errors.ts
================================================
import type { SourceLocation } from './awst/source-location'
import type { PType, PTypeOrClass } from './awst_build/ptypes'

type PuyaErrorOptions = {
  cause?: Error
  sourceLocation?: SourceLocation
}

export class PuyaError extends Error {
  readonly sourceLocation: SourceLocation | undefined
  constructor(message?: string, options?: PuyaErrorOptions) {
    super(message, options)
    this.sourceLocation = options?.sourceLocation
  }
}

/**
 * Any error that is 'caused' by a user of Puya
 */
export abstract class UserError extends PuyaError {}

/**
 * Thrown when the user's code is invalid, or not supported
 */
export class CodeError extends UserError {
  static unexpectedUnhandledArgs({ sourceLocation }: { sourceLocation: SourceLocation }) {
    return new CodeError('Unexpected/unhandled args', {
      sourceLocation,
    })
  }
  static unexpectedTypeArgs({ sourceLocation }: { sourceLocation: SourceLocation }) {
    return new CodeError('Function does not accept type arguments', {
      sourceLocation,
    })
  }
  static expectedCompileTimeConstant({ sourceLocation }: { sourceLocation: SourceLocation }) {
    return new CodeError('Expected compile time constant', {
      sourceLocation,
    })
  }
  static invalidAssignmentTarget({ sourceLocation, name }: { sourceLocation: SourceLocation; name: string }) {
    return new CodeError(`${name} is not a valid assignment target`, {
      sourceLocation,
    })
  }
  static cannotResolveToType({
    sourceType,
    targetType,
    sourceLocation,
  }: {
    sourceLocation: SourceLocation
    sourceType: PType
    targetType: PTypeOrClass
  }) {
    const targetName = targetType instanceof Function ? targetType.name : targetType.fullName
    return new CodeError(`Cannot resolve ${sourceType} to ${targetName}`, { sourceLocation })
  }
}

/**
 * Thrown when the compiler ends up in an unrecoverable state
 */
export class InternalError extends PuyaError {
  static shouldBeUnreachable() {
    return new InternalError('Code should be unreachable')
  }
}
export class NotSupported extends CodeError {
  constructor(featureName: string, options?: PuyaErrorOptions) {
    super(`Not Supported: ${featureName}`, options)
  }
}

/**
 * Thrown when the user's environment is not set up correctly
 */
export class EnvironmentError extends UserError {}

export const throwError = (error: Error): never => {
  throw error
}
export const wrapInCodeError = <T>(func: () => T, sourceLocation: SourceLocation) => {
  try {
    return func()
  } catch (e) {
    if (e instanceof Error) {
      throw new CodeError(e.message, { sourceLocation, cause: e })
    } else {
      throw new CodeError(String(e), { sourceLocation })
    }
  }
}



================================================
FILE: src/index.ts
================================================
import {
  base32ToUint8Array,
  base64ToUint8Array,
  bigIntToUint8Array,
  hexToUint8Array,
  uint8ArrayToBase32,
  uint8ArrayToBase64,
  uint8ArrayToBigInt,
  uint8ArrayToHex,
  uint8ArrayToUtf8,
  utf8ToUint8Array,
} from './util'

export { SourceLocation } from './awst/source-location'
export * as ptypes from './awst_build/ptypes/for-export'
export { registerPTypes } from './awst_build/ptypes/register'
export { typeRegistry } from './awst_build/type-registry'
export { TypeResolver } from './awst_build/type-resolver'
export { compile } from './compile'
export { processInputPaths } from './input-paths/process-input-paths'
export { LoggingContext } from './logger'
export { CompileOptions } from './options'

export const encodingUtil = {
  utf8ToUint8Array,
  bigIntToUint8Array,
  hexToUint8Array,
  base32ToUint8Array,
  base64ToUint8Array,
  uint8ArrayToUtf8,
  uint8ArrayToHex,
  uint8ArrayToBase32,
  uint8ArrayToBase64,
  uint8ArrayToBigInt,
}



================================================
FILE: src/options.ts
================================================
import { LogLevel } from './logger'
import type { Props } from './typescript-helpers'

export interface AlgoFile {
  sourceFile: string
  outDir: string
  fileContents?: string
}

export class CompileOptions {
  public readonly filePaths: AlgoFile[]
  public readonly logLevel: LogLevel
  public readonly outputAwst: boolean
  public readonly outputAwstJson: boolean
  public readonly skipVersionCheck: boolean
  /**
   * Don't generate artifacts for puya, or invoke puya
   */
  public readonly dryRun: boolean
  public readonly outputTeal: boolean
  public readonly outputArc32: boolean
  public readonly outputArc56: boolean
  public readonly outputSsaIr: boolean
  public readonly outputOptimizationIr: boolean
  public readonly outputDestructuredIr: boolean
  public readonly outputMemoryIr: boolean
  public readonly outputBytecode: boolean
  public readonly outputSourceMap: boolean
  public readonly debugLevel: number
  public readonly optimizationLevel: number
  public readonly targetAvmVersion: number
  public readonly cliTemplateDefinitions: Record<string, Uint8Array | bigint>
  public readonly templateVarsPrefix: string
  public readonly localsCoalescingStrategy: LocalsCoalescingStrategy
  public readonly customPuyaPath?: string

  constructor(options: Partial<Props<CompileOptions>> & { filePaths: AlgoFile[] }) {
    this.filePaths = options.filePaths
    this.logLevel = options.logLevel ?? LogLevel.Info
    this.outputAwst = options.outputAwst ?? false
    this.outputAwstJson = options.outputAwstJson ?? false
    this.skipVersionCheck = options.skipVersionCheck ?? false
    this.dryRun = options.dryRun ?? false
    this.outputTeal = options.outputTeal ?? false
    this.outputArc32 = options.outputArc32 ?? false
    this.outputArc56 = options.outputArc56 ?? false
    this.outputSsaIr = options.outputSsaIr ?? false
    this.outputOptimizationIr = options.outputOptimizationIr ?? false
    this.outputDestructuredIr = options.outputDestructuredIr ?? false
    this.outputMemoryIr = options.outputMemoryIr ?? false
    this.outputBytecode = options.outputBytecode ?? false
    this.outputSourceMap = options.outputSourceMap ?? false
    this.debugLevel = options.debugLevel ?? defaultPuyaOptions.debugLevel
    this.optimizationLevel = options.optimizationLevel ?? defaultPuyaOptions.optimizationLevel
    this.targetAvmVersion = options.targetAvmVersion ?? defaultPuyaOptions.targetAvmVersion
    this.cliTemplateDefinitions = options.cliTemplateDefinitions ?? defaultPuyaOptions.cliTemplateDefinitions
    this.templateVarsPrefix = options.templateVarsPrefix ?? defaultPuyaOptions.templateVarsPrefix
    this.localsCoalescingStrategy = options.localsCoalescingStrategy ?? defaultPuyaOptions.localsCoalescingStrategy
    this.customPuyaPath = options.customPuyaPath
  }

  buildPuyaOptions(compilationSet: CompilationSetMapping) {
    return new PuyaOptions({ ...this, compilationSet })
  }
}

export enum LocalsCoalescingStrategy {
  root_operand = 'root_operand',
  root_operand_excluding_args = 'root_operand_excluding_args',
  aggressive = 'aggressive',
}
export type CompilationSetMapping = Record<string, string>

export const defaultPuyaOptions: PuyaPassThroughOptions = {
  outputTeal: true,
  outputArc32: true,
  outputArc56: true,
  outputSsaIr: false,
  outputSourceMap: true,
  outputOptimizationIr: false,
  outputDestructuredIr: false,
  outputMemoryIr: false,
  outputBytecode: false,
  debugLevel: 1,
  optimizationLevel: 1,
  targetAvmVersion: 10,
  cliTemplateDefinitions: {},
  templateVarsPrefix: 'TMPL_',
  localsCoalescingStrategy: LocalsCoalescingStrategy.root_operand,
}
export type PuyaPassThroughOptions = Omit<PuyaOptions, 'compilationSet'>

export class PuyaOptions {
  outputTeal: boolean
  outputArc32: boolean
  outputArc56: boolean
  outputSsaIr: boolean
  outputOptimizationIr: boolean
  outputDestructuredIr: boolean
  outputMemoryIr: boolean
  outputBytecode: boolean
  outputSourceMap: boolean
  debugLevel: number
  optimizationLevel: number
  targetAvmVersion: number
  cliTemplateDefinitions: Record<string, Uint8Array | bigint>
  templateVarsPrefix: string
  localsCoalescingStrategy: LocalsCoalescingStrategy

  compilationSet: CompilationSetMapping
  constructor(options: Props<PuyaOptions>) {
    this.compilationSet = options.compilationSet
    this.outputTeal = options.outputTeal
    this.outputArc32 = options.outputArc32
    this.outputArc56 = options.outputArc56
    this.outputSsaIr = options.outputSsaIr
    this.outputOptimizationIr = options.outputOptimizationIr
    this.outputDestructuredIr = options.outputDestructuredIr
    this.outputMemoryIr = options.outputMemoryIr
    this.outputBytecode = options.outputBytecode
    this.debugLevel = options.debugLevel
    this.optimizationLevel = options.optimizationLevel
    this.targetAvmVersion = options.targetAvmVersion
    this.cliTemplateDefinitions = options.cliTemplateDefinitions
    this.templateVarsPrefix = options.templateVarsPrefix
    this.localsCoalescingStrategy = options.localsCoalescingStrategy
    this.outputSourceMap = options.outputSourceMap
  }
}



================================================
FILE: src/typescript-helpers.d.ts
================================================
// Sometimes only an 'any' will do. Don't use this just to be lazy though
/* eslint-disable-next-line @typescript-eslint/no-explicit-any */
export type DeliberateAny = any
export type AnyFunction = (...args: DeliberateAny[]) => DeliberateAny

export type Expand<T> = T extends (...args: infer A) => infer R
  ? (...args: Expand<A>) => Expand<R>
  : T extends infer O
    ? { [K in keyof O]: O[K] }
    : never

type IsProperty<TKey extends keyof TObj, TObj> = TKey extends DeliberateAny ? (TObj[TKey] extends AnyFunction ? never : TKey) : never

export type Props<T> = Pick<T, IsProperty<keyof T, T>>

export type ReplaceTupleItemType<T extends [...unknown[]], TNew> = {
  [Index in keyof T]: TNew
} & { length: T['length'] }

export type Tuple<T, N extends number> = N extends N ? (number extends N ? T[] : _TupleOf<T, N, []>) : never
type _TupleOf<T, N extends number, R extends unknown[]> = R['length'] extends N ? R : _TupleOf<T, N, [T, ...R]>



================================================
FILE: src/write-artifact.ts
================================================
import * as fs from 'node:fs'
import upath from 'upath'
import { logger } from './logger'
import { mkDirIfNotExists } from './util'

export enum ArtifactKind {
  Awst,
  AwstJson,
}

export function writeArtifact<TObj>({
  sourceFile,
  outDir,
  kind,
  obj,
  buildArtifact,
}: {
  sourceFile: string
  outDir: string
  kind: ArtifactKind
  artifactName?: string
  buildArtifact(obj: TObj): string
  obj: TObj
}) {
  let outFilePath: string
  switch (kind) {
    case ArtifactKind.Awst:
      outFilePath = upath.join(outDir, `${upath.basename(sourceFile, '.algo.ts')}.awst`)
      break
    case ArtifactKind.AwstJson:
      outFilePath = upath.join(outDir, `${upath.basename(sourceFile, '.algo.ts')}.awst.json`)
      break
  }

  const content = buildArtifact(obj)
  logger.info(undefined, `Writing ${outFilePath}`)
  mkDirIfNotExists(upath.dirname(outFilePath))
  fs.writeFileSync(outFilePath, content, 'utf-8')
}



================================================
FILE: src/awst/constant-evaluation.ts
================================================
import { BigUIntBinaryOperator, BinaryBooleanOperator, UInt64BinaryOperator } from './nodes'

export const constantEvaluation = {
  booleanBinary(op: BinaryBooleanOperator, left: boolean, right: boolean) {
    switch (op) {
      case BinaryBooleanOperator.and:
        return left && right
      case BinaryBooleanOperator.or:
        return left || right
    }
  },
  uint64Binary(op: UInt64BinaryOperator, left: bigint, right: bigint) {
    switch (op) {
      case UInt64BinaryOperator.add:
        return left + right
      case UInt64BinaryOperator.sub:
        return left - right
      case UInt64BinaryOperator.mult:
        return left * right
      case UInt64BinaryOperator.floorDiv:
        return left / right
      case UInt64BinaryOperator.mod:
        return left % right
      case UInt64BinaryOperator.pow:
        return left ** right
      case UInt64BinaryOperator.lshift:
        return left << right
      case UInt64BinaryOperator.rshift:
        return left >> right
      case UInt64BinaryOperator.bitOr:
        return left | right
      case UInt64BinaryOperator.bitXor:
        return left ^ right
      case UInt64BinaryOperator.bitAnd:
        return left & right
    }
  },
  biguintBinary(op: BigUIntBinaryOperator, left: bigint, right: bigint) {
    switch (op) {
      case BigUIntBinaryOperator.add:
        return left + right
      case BigUIntBinaryOperator.sub:
        return left - right
      case BigUIntBinaryOperator.mult:
        return left * right
      case BigUIntBinaryOperator.floorDiv:
        return left / right
      case BigUIntBinaryOperator.mod:
        return left % right
      case BigUIntBinaryOperator.bitOr:
        return left | right
      case BigUIntBinaryOperator.bitXor:
        return left ^ right
      case BigUIntBinaryOperator.bitAnd:
        return left & right
    }
  },
}



================================================
FILE: src/awst/index.ts
================================================
export * as awst from './nodes'
export * from './util'
export type ConstantValue = bigint | Uint8Array | boolean | string



================================================
FILE: src/awst/intrinsic-factory.ts
================================================
import type { DeliberateAny } from '../typescript-helpers'
import { bigIntToUint8Array } from '../util'
import { nodeFactory } from './node-factory'
import type { Expression } from './nodes'
import * as awst from './nodes'
import { BytesConstant, BytesEncoding, StringConstant } from './nodes'
import type { SourceLocation } from './source-location'
import { wtypes } from './wtypes'

export const intrinsicFactory = {
  bytesConcat({ left, right, sourceLocation }: { left: awst.Expression; right: awst.Expression; sourceLocation: SourceLocation }) {
    if (left.wtype.equals(right.wtype)) {
      if (left instanceof BytesConstant && right instanceof BytesConstant) {
        const concatValue = new Uint8Array(left.value.length + right.value.length)
        concatValue.set(left.value, 0)
        concatValue.set(right.value, left.value.length)
        return nodeFactory.bytesConstant({
          value: concatValue,
          wtype: left.wtype,
          encoding: left.encoding,
          sourceLocation,
        })
      } else if (left instanceof StringConstant && right instanceof StringConstant) {
        return nodeFactory.stringConstant({
          value: left.value + right.value,
          sourceLocation,
        })
      }
    }

    return nodeFactory.intrinsicCall({
      sourceLocation,
      stackArgs: [left, right],
      immediates: [],
      wtype: left.wtype,
      opCode: 'concat',
    })
  },
  err({ sourceLocation, comment }: { sourceLocation: SourceLocation; comment: string | null }) {
    return nodeFactory.assertExpression({
      condition: null,
      sourceLocation,
      wtype: wtypes.voidWType,
      errorMessage: comment,
    })
  },
  assert({ sourceLocation, comment, condition }: { sourceLocation: SourceLocation; comment: string | null; condition: Expression }) {
    return nodeFactory.assertExpression({
      sourceLocation,
      condition,
      wtype: wtypes.voidWType,
      errorMessage: comment,
    })
  },
  bytesLen({ value, sourceLocation }: { value: awst.Expression; sourceLocation: SourceLocation }) {
    return nodeFactory.intrinsicCall({
      opCode: 'len',
      stackArgs: [value],
      sourceLocation: sourceLocation,
      immediates: [],
      wtype: wtypes.uint64WType,
    })
  },
  bitLen({ value, sourceLocation }: { value: awst.Expression; sourceLocation: SourceLocation }) {
    return nodeFactory.intrinsicCall({
      opCode: 'bitlen',
      stackArgs: [value],
      sourceLocation: sourceLocation,
      immediates: [],
      wtype: wtypes.uint64WType,
    })
  },
  itob({ value, sourceLocation }: { value: awst.Expression; sourceLocation: SourceLocation }): awst.Expression {
    if (value instanceof awst.IntegerConstant) {
      return nodeFactory.bytesConstant({
        sourceLocation,
        value: bigIntToUint8Array(value.value, value.wtype.equals(wtypes.uint64WType) ? 8 : 'dynamic'),
        encoding: BytesEncoding.base16,
      })
    }
    return nodeFactory.intrinsicCall({
      sourceLocation,
      stackArgs: [value],
      immediates: [],
      wtype: wtypes.bytesWType,
      opCode: 'itob',
    })
  },
  btoi({ value, sourceLocation }: { value: awst.Expression; sourceLocation: SourceLocation }): awst.IntrinsicCall {
    return nodeFactory.intrinsicCall({
      sourceLocation,
      stackArgs: [value],
      immediates: [],
      wtype: wtypes.uint64WType,
      opCode: 'btoi',
    })
  },
  bzero({ size, sourceLocation, wtype = wtypes.bytesWType }: { size: bigint; sourceLocation: SourceLocation; wtype: wtypes.WType }) {
    return nodeFactory.intrinsicCall({
      opCode: 'bzero',
      immediates: [],
      stackArgs: [
        nodeFactory.uInt64Constant({
          value: size,
          sourceLocation,
        }),
      ],
      sourceLocation,
      wtype: wtype,
    })
  },
} satisfies Record<string, (args: DeliberateAny) => awst.Expression>



================================================
FILE: src/awst/json-serialize-awst.ts
================================================
import { snakeCase } from 'change-case'
import path from 'node:path'
import { Constants } from '../constants'
import { InternalError } from '../errors'
import { invariant } from '../util'
import { buildBase85Encoder } from '../util/base-85'
import { ContractReference, LogicSigReference } from './models'
import type { RootNode } from './nodes'
import { IntrinsicCall, SingleEvaluation } from './nodes'
import { SourceLocation } from './source-location'
import { SymbolToNumber } from './util'

type JSONWithRaw = typeof JSON & {
  /**
   * This method exists in Node 21+ and several browsers but hasn't made its way into the typescript lib
   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/rawJSON
   *
   *
   */
  rawJSON?(value: string): string
}

function serializeBigInt(value: bigint): unknown {
  const jsonWithRaw = JSON as unknown as JSONWithRaw
  if (jsonWithRaw.rawJSON) {
    return jsonWithRaw.rawJSON(`${value}`)
  }
  if (value < 0n) {
    if (value < Number.MIN_SAFE_INTEGER) {
      throw new InternalError(`Cannot safely serialize ${value} to JSON`)
    }
    return Number(value)
  } else {
    if (value > Number.MAX_SAFE_INTEGER) {
      return `${value}`
    }
    return Number(value)
  }
}

export class SnakeCaseSerializer<T> {
  constructor(private readonly spaces = 2) {}
  public serialize(obj: T): string {
    return JSON.stringify(obj, (k, v) => this.serializerFunction(k, v), this.spaces)
  }
  private b85 = buildBase85Encoder()

  protected serializerFunction(key: string, value: unknown): unknown {
    if (typeof value === 'bigint') {
      return serializeBigInt(value)
    }
    if (value instanceof Uint8Array) {
      return this.b85.encode(value)
    }
    if (value instanceof Object && value.constructor.name !== 'Date' && value.constructor.name !== 'Object') {
      return {
        ...Object.fromEntries(Object.entries(value).map(([key, value]) => [snakeCase(key), value])),
      }
    }
    return value
  }
}

export class AwstSerializer extends SnakeCaseSerializer<RootNode[]> {
  constructor(
    private options?: {
      sourcePaths?: 'absolute' | 'relative'
      programDirectory?: string
    },
  ) {
    super()
  }
  #singleEvals = new SymbolToNumber()

  protected serializerFunction(key: string, value: unknown): unknown {
    if (value instanceof Set) {
      return Array.from(value.keys())
    }
    if (value instanceof Array) {
      return value
    }
    if (value instanceof Map) {
      if (value.size === 0) return {}
      const keyType = typeof value.keys().next().value
      if (keyType === 'string' || keyType === 'number') {
        return Object.fromEntries(value.entries())
      }
      if (keyType === 'bigint') {
        return Object.fromEntries(Array.from(value.entries()).map(([k, v]) => [`${k}`, v]))
      }
      return Array.from(value.entries())
    }
    if (value instanceof Uint8Array) {
      return super.serializerFunction(key, value)
    }
    if (value instanceof ContractReference || value instanceof LogicSigReference) {
      return value.toString()
    }
    if (value instanceof IntrinsicCall) {
      // Convert bigint immediates to number so they serialize without quotes and can be disambiguated from string immediates
      return {
        _type: IntrinsicCall.name,
        ...(super.serializerFunction(key, value) as object),
        immediates: value.immediates.map((i) => {
          if (typeof i === 'bigint') {
            return serializeBigInt(i)
          }
          return i
        }),
      }
    }
    if (value instanceof SourceLocation && value.file) {
      let filePath: string = value.file
      if (this.options?.sourcePaths === 'absolute' && !path.isAbsolute(value.file)) {
        invariant(this.options.programDirectory, 'Program directory must be supplied for absolute paths')
        if (value.file.startsWith(Constants.algoTsPackage)) {
          filePath = path.join(this.options.programDirectory, 'node_modules', value.file)
        } else {
          filePath = path.join(this.options.programDirectory, value.file)
        }
      }
      return {
        ...(super.serializerFunction(key, value) as object),
        scope: undefined,
        file: filePath,
      }
    }
    if (value instanceof SingleEvaluation) {
      return {
        _type: SingleEvaluation.name,
        ...(super.serializerFunction(key, value) as object),
        _id: String(this.#singleEvals.forSymbol(value.id)[0]),
      }
    }

    if (value instanceof Object && value.constructor.name !== 'Object') {
      return {
        _type: value.constructor.name,
        ...(super.serializerFunction(key, value) as object),
      }
    }
    return super.serializerFunction(key, value)
  }
}

export function jsonSerializeAwst(awst: RootNode[]): string {
  return new AwstSerializer().serialize(awst)
}



================================================
FILE: src/awst/models.ts
================================================
import type { ContractClassPType, LogicSigPType } from '../awst_build/ptypes'

export enum OnCompletionAction {
  NoOp = 0,
  OptIn = 1,
  CloseOut = 2,
  ClearState = 3,
  UpdateApplication = 4,
  DeleteApplication = 5,
}

class ModelBase {
  /**
   * This field prevents us from accidentally passing an object literal with structural equality to
   * a model class instead of any instance of the class, which would stuff up the serialization
   * @private
   */
  #isModel = true
}

export class ContractReference extends ModelBase {
  constructor({ className, moduleName }: { className: string; moduleName: string }) {
    super()
    this.className = className
    this.moduleName = moduleName
  }
  readonly className: string
  readonly moduleName: string

  get id() {
    return `${this.moduleName}::${this.className}`
  }

  toString(): string {
    return this.id
  }

  static fromPType(contractPType: ContractClassPType): ContractReference {
    return new ContractReference({
      className: contractPType.name,
      moduleName: contractPType.module,
    })
  }
}
export class LogicSigReference extends ModelBase {
  constructor({ name, moduleName }: { name: string; moduleName: string }) {
    super()
    this.name = name
    this.moduleName = moduleName
  }
  readonly name: string
  readonly moduleName: string

  get id() {
    return `${this.moduleName}::${this.name}`
  }

  toString(): string {
    return this.id
  }

  static fromPType(logicSigPType: LogicSigPType): LogicSigReference {
    return new LogicSigReference({
      name: logicSigPType.name,
      moduleName: logicSigPType.module,
    })
  }
}

export enum TransactionKind {
  pay = 1,
  keyreg = 2,
  acfg = 3,
  axfer = 4,
  afrz = 5,
  appl = 6,
}



================================================
FILE: src/awst/node-factory.ts
================================================
import { getInnerTransactionType } from '../awst_build/eb/transactions/util'
import { anyItxnType } from '../awst_build/ptypes'
import { CodeError } from '../errors'
import type { DeliberateAny, Props } from '../typescript-helpers'
import { codeInvariant, instanceOfAny, invariant } from '../util'
import { constantEvaluation } from './constant-evaluation'
import type { Expression, Statement } from './nodes'
import {
  ArrayLength,
  ArrayReplace,
  AssignmentExpression,
  AssignmentStatement,
  BigUIntBinaryOperation,
  Block,
  BoolConstant,
  BooleanBinaryOperation,
  BytesComparisonExpression,
  BytesConstant,
  BytesEncoding,
  CheckedMaybe,
  concreteNodes,
  Copy,
  ExpressionStatement,
  IntegerConstant,
  MethodDocumentation,
  Not,
  NumericComparisonExpression,
  ReinterpretCast,
  SingleEvaluation,
  StringConstant,
  SubmitInnerTransaction,
  TupleExpression,
  TupleItemExpression,
  UInt64BinaryOperation,
  VoidConstant,
} from './nodes'
import type { SourceLocation } from './source-location'
import { wtypes } from './wtypes'
import WInnerTransactionFields = wtypes.WInnerTransactionFields
import WTuple = wtypes.WTuple

type ConcreteNodes = typeof concreteNodes

const explicitNodeFactory = {
  voidConstant(props: { sourceLocation: SourceLocation }): VoidConstant {
    return new VoidConstant({
      ...props,
      wtype: wtypes.voidWType,
    })
  },
  bytesConstant(props: {
    value: Uint8Array
    encoding?: BytesEncoding
    sourceLocation: SourceLocation
    wtype?: wtypes.WType
  }): BytesConstant {
    return new BytesConstant({
      encoding: BytesEncoding.unknown,
      wtype: wtypes.bytesWType,
      ...props,
    })
  },
  stringConstant(props: { value: string; sourceLocation: SourceLocation; wtype?: wtypes.WType }): StringConstant {
    return new StringConstant({
      ...props,
      wtype: props.wtype ?? wtypes.stringWType,
    })
  },
  uInt64Constant({
    value,
    tealAlias,
    sourceLocation,
  }: {
    value: bigint
    tealAlias?: string
    sourceLocation: SourceLocation
  }): IntegerConstant {
    if (value < 0n || value >= 2n ** 64n) {
      throw new CodeError(`uint64 overflow or underflow: ${value}`, { sourceLocation })
    }
    return new IntegerConstant({
      value,
      sourceLocation,
      wtype: wtypes.uint64WType,
      tealAlias: tealAlias ?? null,
    })
  },
  bigUIntConstant({ value, sourceLocation }: { value: bigint; sourceLocation: SourceLocation }): IntegerConstant {
    if (value < 0n || value >= 2n ** 512n) {
      throw new CodeError(`biguint overflow or underflow: ${value}`, { sourceLocation })
    }
    return new IntegerConstant({
      value,
      sourceLocation,
      wtype: wtypes.biguintWType,
      tealAlias: null,
    })
  },
  not(props: { expr: Expression; sourceLocation: SourceLocation }): Not {
    return new Not({
      ...props,
      wtype: wtypes.boolWType,
    })
  },
  uInt64BinaryOperation(props: Omit<Props<UInt64BinaryOperation>, 'wtype'>): UInt64BinaryOperation | IntegerConstant {
    if (props.left instanceof IntegerConstant && props.right instanceof IntegerConstant) {
      invariant(props.left.wtype.equals(wtypes.uint64WType) && props.right.wtype.equals(wtypes.uint64WType), 'left & right must be uint64')
      return new IntegerConstant({
        value: constantEvaluation.uint64Binary(props.op, props.left.value, props.right.value),
        tealAlias: null,
        sourceLocation: props.sourceLocation,
        wtype: wtypes.uint64WType,
      })
    }
    return new UInt64BinaryOperation({
      ...props,
      wtype: wtypes.uint64WType,
    })
  },
  bigUIntBinaryOperation(props: Omit<Props<BigUIntBinaryOperation>, 'wtype'>): BigUIntBinaryOperation | IntegerConstant {
    if (props.left instanceof IntegerConstant && props.right instanceof IntegerConstant) {
      invariant(
        props.left.wtype.equals(wtypes.biguintWType) && props.right.wtype.equals(wtypes.biguintWType),
        'left & right must be biguint',
      )
      return new IntegerConstant({
        value: constantEvaluation.biguintBinary(props.op, props.left.value, props.right.value),
        tealAlias: null,
        sourceLocation: props.sourceLocation,
        wtype: wtypes.biguintWType,
      })
    }
    return new BigUIntBinaryOperation({
      ...props,
      wtype: wtypes.biguintWType,
    })
  },
  numericComparisonExpression(props: Omit<Props<NumericComparisonExpression>, 'wtype'>): NumericComparisonExpression {
    return new NumericComparisonExpression({
      ...props,
      wtype: wtypes.boolWType,
    })
  },
  bytesComparisonExpression(props: Omit<Props<BytesComparisonExpression>, 'wtype'>): BytesComparisonExpression {
    codeInvariant(
      props.lhs.wtype.equals(props.rhs.wtype),
      `Operands type mismatch. lhs is ${props.lhs.wtype}, rhs is ${props.rhs.wtype}`,
      props.sourceLocation,
    )
    return new BytesComparisonExpression({
      ...props,
      wtype: wtypes.boolWType,
    })
  },
  boolConstant(props: { value: boolean; sourceLocation: SourceLocation; wtype?: wtypes.WType }): BoolConstant {
    return new BoolConstant({
      ...props,
      wtype: props.wtype ?? wtypes.boolWType,
    })
  },
  singleEvaluation({ source }: { source: Expression }) {
    return new SingleEvaluation({
      id: Symbol(),
      sourceLocation: source.sourceLocation,
      wtype: source.wtype,
      source,
    })
  },
  expressionStatement({ expr }: { expr: Expression }) {
    if (expr instanceof AssignmentExpression) {
      return new AssignmentStatement({
        ...expr,
      })
    }

    return new ExpressionStatement({
      expr,
      sourceLocation: expr.sourceLocation,
    })
  },
  block(
    { sourceLocation, comment, label }: { sourceLocation: SourceLocation; comment?: string; label?: string },
    ...statements: Array<Statement | Statement[]>
  ) {
    return new Block({
      body: statements.flat(),
      sourceLocation,
      comment: comment ?? null,
      label: label ?? null,
    })
  },
  booleanBinaryOperation(props: Omit<Props<BooleanBinaryOperation>, 'wtype'>) {
    if (props.left instanceof BoolConstant && props.right instanceof BoolConstant) {
      return new BoolConstant({
        value: constantEvaluation.booleanBinary(props.op, props.left.value, props.right.value),
        sourceLocation: props.sourceLocation,
        wtype: wtypes.boolWType,
      })
    }
    return new BooleanBinaryOperation({
      ...props,
      wtype: wtypes.boolWType,
    })
  },
  assignmentExpression({
    target,
    value,
    sourceLocation,
  }: {
    target: AssignmentExpression['target']
    value: Expression
    sourceLocation: SourceLocation
  }) {
    codeInvariant(target.wtype.equals(value.wtype), `Assignment target type ${target.wtype} must match assigned value type ${value.wtype}`)
    return new AssignmentExpression({
      target,
      value,
      wtype: value.wtype,
      sourceLocation,
    })
  },
  assignmentStatement({
    target,
    value,
    sourceLocation,
  }: {
    target: AssignmentStatement['target']
    value: Expression
    sourceLocation: SourceLocation
  }) {
    codeInvariant(target.wtype.equals(value.wtype), `Assignment target type ${target.wtype} must match assigned value type ${value.wtype}`)
    return new AssignmentStatement({
      target,
      value,
      sourceLocation,
    })
  },
  tupleExpression(props: Omit<Props<TupleExpression>, 'wtype'> & { wtype?: wtypes.WTuple }) {
    return new TupleExpression({
      ...props,
      wtype: props.wtype ?? new wtypes.WTuple({ types: props.items.map((i) => i.wtype), immutable: true }),
    })
  },
  methodDocumentation(props?: { description?: string | null; args?: Map<string, string>; returns?: string | null }) {
    return new MethodDocumentation({
      args: props?.args ?? new Map(),
      description: props?.description ?? null,
      returns: props?.returns ?? null,
    })
  },
  copy({ value, sourceLocation }: { value: Expression; sourceLocation: SourceLocation }) {
    return new Copy({
      value,
      sourceLocation,
      wtype: value.wtype,
    })
  },
  checkedMaybe({ expr, comment }: { expr: Expression; comment: string }) {
    invariant(expr.wtype instanceof wtypes.WTuple && expr.wtype.types.length === 2, 'expr WType must be WTuple of 2')
    invariant(expr.wtype.types[1].equals(wtypes.boolWType), '2nd tuple item type must be bool')
    return new CheckedMaybe({
      expr,
      comment,
      sourceLocation: expr.sourceLocation,
      wtype: expr.wtype.types[0],
    })
  },
  tupleItemExpression(props: Omit<Props<TupleItemExpression>, 'wtype'>) {
    invariant(
      instanceOfAny(props.base.wtype, wtypes.WTuple, wtypes.ARC4Tuple) && props.base.wtype.types.length > Number(props.index),
      'expr.base must be tuple type with length greater than index',
    )
    return new TupleItemExpression({
      ...props,
      wtype: props.base.wtype.types[Number(props.index)],
    })
  },
  reinterpretCast({ expr, wtype, sourceLocation }: { expr: Expression; wtype: wtypes.WType; sourceLocation: SourceLocation }) {
    if (expr instanceof BytesConstant) {
      return new BytesConstant({
        ...expr,
        wtype,
        sourceLocation,
      })
    }

    return new ReinterpretCast({
      expr,
      wtype,
      sourceLocation,
    })
  },
  arrayLength({ array, sourceLocation }: { array: Expression; sourceLocation: SourceLocation }) {
    return new ArrayLength({
      array,
      sourceLocation,
      wtype: wtypes.uint64WType,
    })
  },
  arrayReplace({
    base,
    index,
    value,
    sourceLocation,
  }: {
    base: Expression
    index: Expression
    value: Expression
    sourceLocation: SourceLocation
  }) {
    invariant(base.wtype instanceof wtypes.StackArray, 'base must have wtype of StackArray', base.sourceLocation)
    return new ArrayReplace({
      base,
      index,
      value,
      sourceLocation,
      wtype: base.wtype,
    })
  },
  submitInnerTransaction({ itxns, sourceLocation }: Omit<Props<SubmitInnerTransaction>, 'wtype'>) {
    const itxnWTypes = itxns.map(({ wtype }, index) => {
      invariant(
        wtype instanceof WInnerTransactionFields,
        `WType at index ${index} must be WInnerTransactionFields with type`,
        sourceLocation,
      )
      return wtype.transactionType === null ? anyItxnType.wtype : getInnerTransactionType(wtype.transactionType).wtype
    })
    return new SubmitInnerTransaction({
      itxns,
      sourceLocation,
      wtype: itxnWTypes.length === 1 ? itxnWTypes[0] : new WTuple({ types: itxnWTypes, immutable: true }),
    })
  },
} satisfies { [key in keyof ConcreteNodes]?: (...args: DeliberateAny[]) => DeliberateAny }

type ExplicitNodeFactory = typeof explicitNodeFactory

type DefaultNodeFactory<TKey extends keyof ConcreteNodes> = (
  ...args: ConstructorParameters<ConcreteNodes[TKey]>
) => InstanceType<ConcreteNodes[TKey]>

export type NodeFactory = {
  [key in keyof ConcreteNodes]: FactoryMethod<key>
}

type FactoryMethod<TKey extends keyof ConcreteNodes> = TKey extends keyof ExplicitNodeFactory
  ? ExplicitNodeFactory[TKey]
  : DefaultNodeFactory<TKey>

function isNodeName(value: string | symbol): value is keyof ConcreteNodes {
  return typeof value === 'string' && Object.hasOwn(concreteNodes, value)
}

function hasExplicitFactory(value: string): value is keyof typeof explicitNodeFactory {
  return Object.hasOwn(explicitNodeFactory, value)
}

export const nodeFactory: NodeFactory = new Proxy({} as unknown as NodeFactory, {
  get(_, property) {
    invariant(isNodeName(property), 'Property must be the name of a concrete node')

    if (hasExplicitFactory(property)) {
      return explicitNodeFactory[property]
    }
    return (props: DeliberateAny) => new concreteNodes[property](props)
  },
})



================================================
FILE: src/awst/nodes.ts
================================================
/* AUTOGENERATED FILE - DO NOT EDIT (see puya/scripts/generate_ts_nodes.py) */
import { classes } from 'polytype'
import type { Props } from '../typescript-helpers'
import type { ContractReference, LogicSigReference, OnCompletionAction } from './models'
import type { SourceLocation } from './source-location'
import type { TxnField } from './txn-fields'
import type { wtypes } from './wtypes'

export abstract class Node {
  constructor(props: Props<Node>) {
    this.sourceLocation = props.sourceLocation
  }
  readonly sourceLocation: SourceLocation
}
export abstract class Statement extends Node {
  constructor(props: Props<Statement>) {
    super(props)
  }
  abstract accept<T>(visitor: StatementVisitor<T>): T
}
export abstract class Expression extends Node {
  constructor(props: Props<Expression>) {
    super(props)
    this.wtype = props.wtype
  }
  readonly wtype: wtypes.WType
  abstract accept<T>(visitor: ExpressionVisitor<T>): T
}
export class ExpressionStatement extends Statement {
  constructor(props: Props<ExpressionStatement>) {
    super(props)
    this.expr = props.expr
    this.sourceLocation = props.sourceLocation
  }
  readonly expr: Expression
  readonly sourceLocation: SourceLocation
  accept<T>(visitor: StatementVisitor<T>): T {
    return visitor.visitExpressionStatement(this)
  }
}
export class Block extends Statement {
  constructor(props: Props<Block>) {
    super(props)
    this.body = props.body
    this.label = props.label
    this.comment = props.comment
  }
  readonly body: Array<Statement>
  readonly label: string | null
  readonly comment: string | null
  accept<T>(visitor: StatementVisitor<T>): T {
    return visitor.visitBlock(this)
  }
}
export class Goto extends Statement {
  constructor(props: Props<Goto>) {
    super(props)
    this.target = props.target
  }
  readonly target: string
  accept<T>(visitor: StatementVisitor<T>): T {
    return visitor.visitGoto(this)
  }
}
export class IfElse extends Statement {
  constructor(props: Props<IfElse>) {
    super(props)
    this.condition = props.condition
    this.ifBranch = props.ifBranch
    this.elseBranch = props.elseBranch
  }
  readonly condition: Expression
  readonly ifBranch: Block
  readonly elseBranch: Block | null
  accept<T>(visitor: StatementVisitor<T>): T {
    return visitor.visitIfElse(this)
  }
}
export class Switch extends Statement {
  constructor(props: Props<Switch>) {
    super(props)
    this.value = props.value
    this.cases = props.cases
    this.defaultCase = props.defaultCase
  }
  readonly value: Expression
  readonly cases: Map<Expression, Block>
  readonly defaultCase: Block | null
  accept<T>(visitor: StatementVisitor<T>): T {
    return visitor.visitSwitch(this)
  }
}
export class WhileLoop extends Statement {
  constructor(props: Props<WhileLoop>) {
    super(props)
    this.condition = props.condition
    this.loopBody = props.loopBody
  }
  readonly condition: Expression
  readonly loopBody: Block
  accept<T>(visitor: StatementVisitor<T>): T {
    return visitor.visitWhileLoop(this)
  }
}
export class LoopExit extends Statement {
  constructor(props: Props<LoopExit>) {
    super(props)
  }
  accept<T>(visitor: StatementVisitor<T>): T {
    return visitor.visitLoopExit(this)
  }
}
export class LoopContinue extends Statement {
  constructor(props: Props<LoopContinue>) {
    super(props)
  }
  accept<T>(visitor: StatementVisitor<T>): T {
    return visitor.visitLoopContinue(this)
  }
}
export class ReturnStatement extends Statement {
  constructor(props: Props<ReturnStatement>) {
    super(props)
    this.value = props.value
  }
  readonly value: Expression | null
  accept<T>(visitor: StatementVisitor<T>): T {
    return visitor.visitReturnStatement(this)
  }
}
export class AssertExpression extends Expression {
  constructor(props: Props<AssertExpression>) {
    super(props)
    this.condition = props.condition
    this.errorMessage = props.errorMessage
    this.wtype = props.wtype
  }
  readonly condition: Expression | null
  readonly errorMessage: string | null
  readonly wtype: wtypes.WType
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitAssertExpression(this)
  }
}
export class IntegerConstant extends Expression {
  constructor(props: Props<IntegerConstant>) {
    super(props)
    this.wtype = props.wtype
    this.value = props.value
    this.tealAlias = props.tealAlias
  }
  readonly wtype: wtypes.WType
  readonly value: bigint
  readonly tealAlias: string | null
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitIntegerConstant(this)
  }
}
export class DecimalConstant extends Expression {
  constructor(props: Props<DecimalConstant>) {
    super(props)
    this.wtype = props.wtype
    this.value = props.value
  }
  readonly wtype: wtypes.ARC4UFixedNxM
  readonly value: string
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitDecimalConstant(this)
  }
}
export class BoolConstant extends Expression {
  constructor(props: Props<BoolConstant>) {
    super(props)
    this.value = props.value
    this.wtype = props.wtype
  }
  readonly value: boolean
  readonly wtype: wtypes.WType
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitBoolConstant(this)
  }
}
export enum BytesEncoding {
  unknown = 'unknown',
  base16 = 'base16',
  base32 = 'base32',
  base64 = 'base64',
  utf8 = 'utf8',
}
export class BytesConstant extends Expression {
  constructor(props: Props<BytesConstant>) {
    super(props)
    this.wtype = props.wtype
    this.value = props.value
    this.encoding = props.encoding
  }
  readonly wtype: wtypes.WType
  readonly value: Uint8Array
  readonly encoding: BytesEncoding
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitBytesConstant(this)
  }
}
export class StringConstant extends Expression {
  constructor(props: Props<StringConstant>) {
    super(props)
    this.value = props.value
    this.wtype = props.wtype
  }
  readonly value: string
  readonly wtype: wtypes.WType
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitStringConstant(this)
  }
}
export class VoidConstant extends Expression {
  constructor(props: Props<VoidConstant>) {
    super(props)
    this.wtype = props.wtype
  }
  readonly wtype: wtypes.WType
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitVoidConstant(this)
  }
}
export class TemplateVar extends Expression {
  constructor(props: Props<TemplateVar>) {
    super(props)
    this.wtype = props.wtype
    this.name = props.name
  }
  readonly wtype: wtypes.WType
  readonly name: string
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitTemplateVar(this)
  }
}
export class MethodConstant extends Expression {
  constructor(props: Props<MethodConstant>) {
    super(props)
    this.wtype = props.wtype
    this.value = props.value
  }
  readonly wtype: wtypes.WType
  readonly value: string
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitMethodConstant(this)
  }
}
export class AddressConstant extends Expression {
  constructor(props: Props<AddressConstant>) {
    super(props)
    this.wtype = props.wtype
    this.value = props.value
  }
  readonly wtype: wtypes.WType
  readonly value: string
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitAddressConstant(this)
  }
}
export class ARC4Encode extends Expression {
  constructor(props: Props<ARC4Encode>) {
    super(props)
    this.value = props.value
    this.wtype = props.wtype
  }
  readonly value: Expression
  readonly wtype: wtypes.ARC4Type
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitARC4Encode(this)
  }
}
export class Copy extends Expression {
  constructor(props: Props<Copy>) {
    super(props)
    this.value = props.value
    this.wtype = props.wtype
  }
  readonly value: Expression
  readonly wtype: wtypes.WType
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitCopy(this)
  }
}
export class ArrayConcat extends Expression {
  constructor(props: Props<ArrayConcat>) {
    super(props)
    this.left = props.left
    this.right = props.right
    this.wtype = props.wtype
  }
  readonly left: Expression
  readonly right: Expression
  readonly wtype: wtypes.ARC4DynamicArray | wtypes.StackArray
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitArrayConcat(this)
  }
}
export class ArrayExtend extends Expression {
  constructor(props: Props<ArrayExtend>) {
    super(props)
    this.base = props.base
    this.other = props.other
    this.wtype = props.wtype
  }
  readonly base: Expression
  readonly other: Expression
  readonly wtype: wtypes.WType
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitArrayExtend(this)
  }
}
export class ArrayPop extends Expression {
  constructor(props: Props<ArrayPop>) {
    super(props)
    this.base = props.base
    this.wtype = props.wtype
  }
  readonly base: Expression
  readonly wtype: wtypes.WType
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitArrayPop(this)
  }
}
export class ArrayReplace extends Expression {
  constructor(props: Props<ArrayReplace>) {
    super(props)
    this.base = props.base
    this.index = props.index
    this.value = props.value
    this.wtype = props.wtype
  }
  readonly base: Expression
  readonly index: Expression
  readonly value: Expression
  readonly wtype: wtypes.StackArray
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitArrayReplace(this)
  }
}
export class ARC4Decode extends Expression {
  constructor(props: Props<ARC4Decode>) {
    super(props)
    this.value = props.value
  }
  readonly value: Expression
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitARC4Decode(this)
  }
}
export class IntrinsicCall extends Expression {
  constructor(props: Props<IntrinsicCall>) {
    super(props)
    this.opCode = props.opCode
    this.immediates = props.immediates
    this.stackArgs = props.stackArgs
  }
  readonly opCode: string
  readonly immediates: Array<string | bigint>
  readonly stackArgs: Array<Expression>
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitIntrinsicCall(this)
  }
}
export class CreateInnerTransaction extends Expression {
  constructor(props: Props<CreateInnerTransaction>) {
    super(props)
    this.wtype = props.wtype
    this.fields = props.fields
  }
  readonly wtype: wtypes.WInnerTransactionFields
  readonly fields: Map<TxnField, Expression>
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitCreateInnerTransaction(this)
  }
}
export class UpdateInnerTransaction extends Expression {
  constructor(props: Props<UpdateInnerTransaction>) {
    super(props)
    this.itxn = props.itxn
    this.fields = props.fields
    this.wtype = props.wtype
  }
  readonly itxn: Expression
  readonly fields: Map<TxnField, Expression>
  readonly wtype: wtypes.WType
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitUpdateInnerTransaction(this)
  }
}
export class GroupTransactionReference extends Expression {
  constructor(props: Props<GroupTransactionReference>) {
    super(props)
    this.index = props.index
    this.wtype = props.wtype
  }
  readonly index: Expression
  readonly wtype: wtypes.WGroupTransaction
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitGroupTransactionReference(this)
  }
}
export class CheckedMaybe extends Expression {
  constructor(props: Props<CheckedMaybe>) {
    super(props)
    this.expr = props.expr
    this.comment = props.comment
    this.wtype = props.wtype
    this.sourceLocation = props.sourceLocation
  }
  readonly expr: Expression
  readonly comment: string
  readonly wtype: wtypes.WType
  readonly sourceLocation: SourceLocation
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitCheckedMaybe(this)
  }
}
export class TupleExpression extends Expression {
  constructor(props: Props<TupleExpression>) {
    super(props)
    this.items = props.items
    this.wtype = props.wtype
  }
  readonly items: Array<Expression>
  readonly wtype: wtypes.WTuple
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitTupleExpression(this)
  }
}
export class TupleItemExpression extends Expression {
  constructor(props: Props<TupleItemExpression>) {
    super(props)
    this.base = props.base
    this.index = props.index
    this.wtype = props.wtype
  }
  readonly base: Expression
  readonly index: bigint
  readonly wtype: wtypes.WType
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitTupleItemExpression(this)
  }
}
export class VarExpression extends Expression {
  constructor(props: Props<VarExpression>) {
    super(props)
    this.name = props.name
  }
  readonly name: string
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitVarExpression(this)
  }
}
export class InnerTransactionField extends Expression {
  constructor(props: Props<InnerTransactionField>) {
    super(props)
    this.itxn = props.itxn
    this.field = props.field
    this.arrayIndex = props.arrayIndex
  }
  readonly itxn: Expression
  readonly field: TxnField
  readonly arrayIndex: Expression | null
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitInnerTransactionField(this)
  }
}
export class SubmitInnerTransaction extends Expression {
  constructor(props: Props<SubmitInnerTransaction>) {
    super(props)
    this.itxns = props.itxns
    this.wtype = props.wtype
  }
  readonly itxns: Array<Expression>
  readonly wtype: wtypes.WType
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitSubmitInnerTransaction(this)
  }
}
export class FieldExpression extends Expression {
  constructor(props: Props<FieldExpression>) {
    super(props)
    this.base = props.base
    this.name = props.name
    this.wtype = props.wtype
  }
  readonly base: Expression
  readonly name: string
  readonly wtype: wtypes.WType
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitFieldExpression(this)
  }
}
export class IndexExpression extends Expression {
  constructor(props: Props<IndexExpression>) {
    super(props)
    this.base = props.base
    this.index = props.index
  }
  readonly base: Expression
  readonly index: Expression
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitIndexExpression(this)
  }
}
export class SliceExpression extends Expression {
  constructor(props: Props<SliceExpression>) {
    super(props)
    this.base = props.base
    this.beginIndex = props.beginIndex
    this.endIndex = props.endIndex
  }
  readonly base: Expression
  readonly beginIndex: Expression | null
  readonly endIndex: Expression | null
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitSliceExpression(this)
  }
}
export class IntersectionSliceExpression extends Expression {
  constructor(props: Props<IntersectionSliceExpression>) {
    super(props)
    this.base = props.base
    this.beginIndex = props.beginIndex
    this.endIndex = props.endIndex
  }
  readonly base: Expression
  readonly beginIndex: Expression | bigint | null
  readonly endIndex: Expression | bigint | null
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitIntersectionSliceExpression(this)
  }
}
export class AppStateExpression extends Expression {
  constructor(props: Props<AppStateExpression>) {
    super(props)
    this.key = props.key
    this.existsAssertionMessage = props.existsAssertionMessage
  }
  readonly key: Expression
  readonly existsAssertionMessage: string | null
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitAppStateExpression(this)
  }
}
export class AppAccountStateExpression extends Expression {
  constructor(props: Props<AppAccountStateExpression>) {
    super(props)
    this.key = props.key
    this.existsAssertionMessage = props.existsAssertionMessage
    this.account = props.account
  }
  readonly key: Expression
  readonly existsAssertionMessage: string | null
  readonly account: Expression
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitAppAccountStateExpression(this)
  }
}
export class BoxValueExpression extends Expression {
  constructor(props: Props<BoxValueExpression>) {
    super(props)
    this.key = props.key
    this.existsAssertionMessage = props.existsAssertionMessage
  }
  readonly key: Expression
  readonly existsAssertionMessage: string | null
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitBoxValueExpression(this)
  }
}
export class SingleEvaluation extends Expression {
  constructor(props: Props<SingleEvaluation>) {
    super(props)
    this.source = props.source
    this.id = props.id
    this.wtype = props.wtype
    this.sourceLocation = props.sourceLocation
  }
  readonly source: Expression
  readonly id: symbol
  readonly wtype: wtypes.WType
  readonly sourceLocation: SourceLocation
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitSingleEvaluation(this)
  }
}
export class ReinterpretCast extends Expression {
  constructor(props: Props<ReinterpretCast>) {
    super(props)
    this.expr = props.expr
  }
  readonly expr: Expression
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitReinterpretCast(this)
  }
}
export class NewArray extends Expression {
  constructor(props: Props<NewArray>) {
    super(props)
    this.wtype = props.wtype
    this.values = props.values
  }
  readonly wtype: wtypes.ARC4DynamicArray | wtypes.ARC4StaticArray | wtypes.ReferenceArray | wtypes.StackArray
  readonly values: Array<Expression>
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitNewArray(this)
  }
}
export class ArrayLength extends Expression {
  constructor(props: Props<ArrayLength>) {
    super(props)
    this.array = props.array
    this.wtype = props.wtype
  }
  readonly array: Expression
  readonly wtype: wtypes.WType
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitArrayLength(this)
  }
}
export class ConditionalExpression extends Expression {
  constructor(props: Props<ConditionalExpression>) {
    super(props)
    this.condition = props.condition
    this.trueExpr = props.trueExpr
    this.falseExpr = props.falseExpr
    this.wtype = props.wtype
  }
  readonly condition: Expression
  readonly trueExpr: Expression
  readonly falseExpr: Expression
  readonly wtype: wtypes.WType
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitConditionalExpression(this)
  }
}
export class AssignmentStatement extends Statement {
  constructor(props: Props<AssignmentStatement>) {
    super(props)
    this.target = props.target
    this.value = props.value
  }
  readonly target:
    | VarExpression
    | FieldExpression
    | IndexExpression
    | TupleExpression
    | AppStateExpression
    | AppAccountStateExpression
    | BoxValueExpression
  readonly value: Expression
  accept<T>(visitor: StatementVisitor<T>): T {
    return visitor.visitAssignmentStatement(this)
  }
}
export class AssignmentExpression extends Expression {
  constructor(props: Props<AssignmentExpression>) {
    super(props)
    this.target = props.target
    this.value = props.value
    this.wtype = props.wtype
  }
  readonly target:
    | VarExpression
    | FieldExpression
    | IndexExpression
    | TupleExpression
    | AppStateExpression
    | AppAccountStateExpression
    | BoxValueExpression
  readonly value: Expression
  readonly wtype: wtypes.WType
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitAssignmentExpression(this)
  }
}
export enum EqualityComparison {
  eq = '==',
  ne = '!=',
}
export enum NumericComparison {
  eq = '==',
  ne = '!=',
  lt = '<',
  lte = '<=',
  gt = '>',
  gte = '>=',
}
export class NumericComparisonExpression extends Expression {
  constructor(props: Props<NumericComparisonExpression>) {
    super(props)
    this.wtype = props.wtype
    this.lhs = props.lhs
    this.operator = props.operator
    this.rhs = props.rhs
  }
  readonly wtype: wtypes.WType
  readonly lhs: Expression
  readonly operator: NumericComparison
  readonly rhs: Expression
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitNumericComparisonExpression(this)
  }
}
export class BytesComparisonExpression extends Expression {
  constructor(props: Props<BytesComparisonExpression>) {
    super(props)
    this.wtype = props.wtype
    this.lhs = props.lhs
    this.operator = props.operator
    this.rhs = props.rhs
  }
  readonly wtype: wtypes.WType
  readonly lhs: Expression
  readonly operator: EqualityComparison
  readonly rhs: Expression
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitBytesComparisonExpression(this)
  }
}
export class SubroutineID {
  constructor(props: Props<SubroutineID>) {
    this.target = props.target
  }
  readonly target: string
}
export class InstanceMethodTarget {
  constructor(props: Props<InstanceMethodTarget>) {
    this.memberName = props.memberName
  }
  readonly memberName: string
}
export class InstanceSuperMethodTarget {
  constructor(props: Props<InstanceSuperMethodTarget>) {
    this.memberName = props.memberName
  }
  readonly memberName: string
}
export class ContractMethodTarget {
  constructor(props: Props<ContractMethodTarget>) {
    this.cref = props.cref
    this.memberName = props.memberName
  }
  readonly cref: ContractReference
  readonly memberName: string
}
export class CallArg {
  constructor(props: Props<CallArg>) {
    this.name = props.name
    this.value = props.value
  }
  readonly name: string | null
  readonly value: Expression
}
export class SubroutineCallExpression extends Expression {
  constructor(props: Props<SubroutineCallExpression>) {
    super(props)
    this.target = props.target
    this.args = props.args
  }
  readonly target: SubroutineID | InstanceMethodTarget | InstanceSuperMethodTarget | ContractMethodTarget
  readonly args: Array<CallArg>
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitSubroutineCallExpression(this)
  }
}
export class PuyaLibData {
  constructor(props: Props<PuyaLibData>) {
    this.id = props.id
    this.params = props.params
    this.wtype = props.wtype
  }
  readonly id: string
  readonly params: Map<string, wtypes.WType>
  readonly wtype: wtypes.WType
}
export enum PuyaLibFunction {
  ensureBudget = 'ensure_budget',
  isSubstring = 'is_substring',
}
export class PuyaLibCall extends Expression {
  constructor(props: Props<PuyaLibCall>) {
    super(props)
    this.func = props.func
    this.args = props.args
    this.wtype = props.wtype
  }
  readonly func: PuyaLibFunction
  readonly args: Array<CallArg>
  readonly wtype: wtypes.WType
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitPuyaLibCall(this)
  }
}
export enum UInt64BinaryOperator {
  add = '+',
  sub = '-',
  mult = '*',
  floorDiv = '//',
  mod = '%',
  pow = '**',
  lshift = '<<',
  rshift = '>>',
  bitOr = '|',
  bitXor = '^',
  bitAnd = '&',
}
export enum BigUIntBinaryOperator {
  add = '+',
  sub = '-',
  mult = '*',
  floorDiv = '//',
  mod = '%',
  bitOr = '|',
  bitXor = '^',
  bitAnd = '&',
}
export enum BytesBinaryOperator {
  add = '+',
  bitOr = '|',
  bitXor = '^',
  bitAnd = '&',
}
export enum BytesUnaryOperator {
  bitInvert = '~',
}
export enum UInt64UnaryOperator {
  bitInvert = '~',
}
export enum UInt64PostfixUnaryOperator {
  increment = '++',
  decrement = '--',
}
export class UInt64UnaryOperation extends Expression {
  constructor(props: Props<UInt64UnaryOperation>) {
    super(props)
    this.op = props.op
    this.expr = props.expr
    this.wtype = props.wtype
  }
  readonly op: UInt64UnaryOperator
  readonly expr: Expression
  readonly wtype: wtypes.WType
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitUInt64UnaryOperation(this)
  }
}
export class UInt64PostfixUnaryOperation extends Expression {
  constructor(props: Props<UInt64PostfixUnaryOperation>) {
    super(props)
    this.op = props.op
    this.target = props.target
    this.wtype = props.wtype
  }
  readonly op: UInt64PostfixUnaryOperator
  readonly target:
    | VarExpression
    | FieldExpression
    | IndexExpression
    | TupleExpression
    | AppStateExpression
    | AppAccountStateExpression
    | BoxValueExpression
  readonly wtype: wtypes.WType
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitUInt64PostfixUnaryOperation(this)
  }
}
export enum BigUIntPostfixUnaryOperator {
  increment = '++',
  decrement = '--',
}
export class BigUIntPostfixUnaryOperation extends Expression {
  constructor(props: Props<BigUIntPostfixUnaryOperation>) {
    super(props)
    this.op = props.op
    this.target = props.target
    this.wtype = props.wtype
  }
  readonly op: BigUIntPostfixUnaryOperator
  readonly target: Expression
  readonly wtype: wtypes.WType
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitBigUIntPostfixUnaryOperation(this)
  }
}
export class BytesUnaryOperation extends Expression {
  constructor(props: Props<BytesUnaryOperation>) {
    super(props)
    this.op = props.op
    this.expr = props.expr
    this.wtype = props.wtype
  }
  readonly op: BytesUnaryOperator
  readonly expr: Expression
  readonly wtype: wtypes.WType
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitBytesUnaryOperation(this)
  }
}
export class UInt64BinaryOperation extends Expression {
  constructor(props: Props<UInt64BinaryOperation>) {
    super(props)
    this.left = props.left
    this.op = props.op
    this.right = props.right
    this.wtype = props.wtype
  }
  readonly left: Expression
  readonly op: UInt64BinaryOperator
  readonly right: Expression
  readonly wtype: wtypes.WType
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitUInt64BinaryOperation(this)
  }
}
export class BigUIntBinaryOperation extends Expression {
  constructor(props: Props<BigUIntBinaryOperation>) {
    super(props)
    this.left = props.left
    this.op = props.op
    this.right = props.right
    this.wtype = props.wtype
  }
  readonly left: Expression
  readonly op: BigUIntBinaryOperator
  readonly right: Expression
  readonly wtype: wtypes.WType
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitBigUIntBinaryOperation(this)
  }
}
export class BytesBinaryOperation extends Expression {
  constructor(props: Props<BytesBinaryOperation>) {
    super(props)
    this.left = props.left
    this.op = props.op
    this.right = props.right
    this.wtype = props.wtype
  }
  readonly left: Expression
  readonly op: BytesBinaryOperator
  readonly right: Expression
  readonly wtype: wtypes.WType
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitBytesBinaryOperation(this)
  }
}
export enum BinaryBooleanOperator {
  and = 'and',
  or = 'or',
}
export class BooleanBinaryOperation extends Expression {
  constructor(props: Props<BooleanBinaryOperation>) {
    super(props)
    this.left = props.left
    this.op = props.op
    this.right = props.right
    this.wtype = props.wtype
  }
  readonly left: Expression
  readonly op: BinaryBooleanOperator
  readonly right: Expression
  readonly wtype: wtypes.WType
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitBooleanBinaryOperation(this)
  }
}
export class Not extends Expression {
  constructor(props: Props<Not>) {
    super(props)
    this.expr = props.expr
    this.wtype = props.wtype
  }
  readonly expr: Expression
  readonly wtype: wtypes.WType
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitNot(this)
  }
}
export class UInt64AugmentedAssignment extends Statement {
  constructor(props: Props<UInt64AugmentedAssignment>) {
    super(props)
    this.target = props.target
    this.op = props.op
    this.value = props.value
  }
  readonly target:
    | VarExpression
    | FieldExpression
    | IndexExpression
    | TupleExpression
    | AppStateExpression
    | AppAccountStateExpression
    | BoxValueExpression
  readonly op: UInt64BinaryOperator
  readonly value: Expression
  accept<T>(visitor: StatementVisitor<T>): T {
    return visitor.visitUInt64AugmentedAssignment(this)
  }
}
export class BigUIntAugmentedAssignment extends Statement {
  constructor(props: Props<BigUIntAugmentedAssignment>) {
    super(props)
    this.target = props.target
    this.op = props.op
    this.value = props.value
  }
  readonly target:
    | VarExpression
    | FieldExpression
    | IndexExpression
    | TupleExpression
    | AppStateExpression
    | AppAccountStateExpression
    | BoxValueExpression
  readonly op: BigUIntBinaryOperator
  readonly value: Expression
  accept<T>(visitor: StatementVisitor<T>): T {
    return visitor.visitBigUIntAugmentedAssignment(this)
  }
}
export class BytesAugmentedAssignment extends Statement {
  constructor(props: Props<BytesAugmentedAssignment>) {
    super(props)
    this.target = props.target
    this.op = props.op
    this.value = props.value
  }
  readonly target:
    | VarExpression
    | FieldExpression
    | IndexExpression
    | TupleExpression
    | AppStateExpression
    | AppAccountStateExpression
    | BoxValueExpression
  readonly op: BytesBinaryOperator
  readonly value: Expression
  accept<T>(visitor: StatementVisitor<T>): T {
    return visitor.visitBytesAugmentedAssignment(this)
  }
}
export class Emit extends Expression {
  constructor(props: Props<Emit>) {
    super(props)
    this.signature = props.signature
    this.value = props.value
    this.wtype = props.wtype
  }
  readonly signature: string
  readonly value: Expression
  readonly wtype: wtypes.WType
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitEmit(this)
  }
}
export class Range extends Expression {
  constructor(props: Props<Range>) {
    super(props)
    this.wtype = props.wtype
    this.start = props.start
    this.stop = props.stop
    this.step = props.step
  }
  readonly wtype: wtypes.WType
  readonly start: Expression
  readonly stop: Expression
  readonly step: Expression
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitRange(this)
  }
}
export class Enumeration extends Expression {
  constructor(props: Props<Enumeration>) {
    super(props)
    this.expr = props.expr
    this.wtype = props.wtype
  }
  readonly expr: Expression
  readonly wtype: wtypes.WEnumeration
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitEnumeration(this)
  }
}
export class Reversed extends Expression {
  constructor(props: Props<Reversed>) {
    super(props)
    this.expr = props.expr
    this.wtype = props.wtype
  }
  readonly expr: Expression
  readonly wtype: wtypes.WType
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitReversed(this)
  }
}
export class ForInLoop extends Statement {
  constructor(props: Props<ForInLoop>) {
    super(props)
    this.sequence = props.sequence
    this.items = props.items
    this.loopBody = props.loopBody
  }
  readonly sequence: Expression
  readonly items:
    | VarExpression
    | FieldExpression
    | IndexExpression
    | TupleExpression
    | AppStateExpression
    | AppAccountStateExpression
    | BoxValueExpression
  readonly loopBody: Block
  accept<T>(visitor: StatementVisitor<T>): T {
    return visitor.visitForInLoop(this)
  }
}
export class StateGet extends Expression {
  constructor(props: Props<StateGet>) {
    super(props)
    this.field = props.field
    this.default = props.default
    this.wtype = props.wtype
  }
  readonly field: AppStateExpression | AppAccountStateExpression | BoxValueExpression
  readonly default: Expression
  readonly wtype: wtypes.WType
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitStateGet(this)
  }
}
export class StateGetEx extends Expression {
  constructor(props: Props<StateGetEx>) {
    super(props)
    this.field = props.field
    this.wtype = props.wtype
  }
  readonly field: AppStateExpression | AppAccountStateExpression | BoxValueExpression
  readonly wtype: wtypes.WTuple
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitStateGetEx(this)
  }
}
export class StateExists extends Expression {
  constructor(props: Props<StateExists>) {
    super(props)
    this.field = props.field
    this.wtype = props.wtype
  }
  readonly field: AppStateExpression | AppAccountStateExpression | BoxValueExpression
  readonly wtype: wtypes.WType
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitStateExists(this)
  }
}
export class StateDelete extends Expression {
  constructor(props: Props<StateDelete>) {
    super(props)
    this.field = props.field
    this.wtype = props.wtype
  }
  readonly field: AppStateExpression | AppAccountStateExpression | BoxValueExpression
  readonly wtype: wtypes.WType
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitStateDelete(this)
  }
}
export class NewStruct extends Expression {
  constructor(props: Props<NewStruct>) {
    super(props)
    this.wtype = props.wtype
    this.values = props.values
  }
  readonly wtype: wtypes.WStructType | wtypes.ARC4Struct
  readonly values: Map<string, Expression>
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitNewStruct(this)
  }
}
export abstract class RootNode extends Node {
  constructor(props: Props<RootNode>) {
    super(props)
  }
  abstract accept<T>(visitor: RootNodeVisitor<T>): T
}
export class SubroutineArgument {
  constructor(props: Props<SubroutineArgument>) {
    this.name = props.name
    this.sourceLocation = props.sourceLocation
    this.wtype = props.wtype
  }
  readonly name: string
  readonly sourceLocation: SourceLocation
  readonly wtype: wtypes.WType
}
export class MethodDocumentation {
  constructor(props: Props<MethodDocumentation>) {
    this.description = props.description
    this.args = props.args
    this.returns = props.returns
  }
  readonly description: string | null
  readonly args: Map<string, string>
  readonly returns: string | null
}
export abstract class _Function extends Node {
  constructor(props: Props<_Function>) {
    super(props)
    this.args = props.args
    this.returnType = props.returnType
    this.body = props.body
    this.documentation = props.documentation
    this.inline = props.inline
  }
  readonly args: Array<SubroutineArgument>
  readonly returnType: wtypes.WType
  readonly body: Block
  readonly documentation: MethodDocumentation
  readonly inline: boolean | null
}
export class Subroutine extends classes(_Function, RootNode) {
  constructor(props: Props<Subroutine>) {
    super([props], [props])
    this.id = props.id
    this.name = props.name
  }
  readonly id: string
  readonly name: string
  accept<T>(visitor: RootNodeVisitor<T>): T {
    return visitor.visitSubroutine(this)
  }
}
export abstract class ContractMemberNode extends Node {
  constructor(props: Props<ContractMemberNode>) {
    super(props)
  }
  abstract accept<T>(visitor: ContractMemberNodeVisitor<T>): T
}
export class ContractMethod extends classes(_Function, ContractMemberNode) {
  constructor(props: Props<ContractMethod>) {
    super([props], [props])
    this.cref = props.cref
    this.memberName = props.memberName
    this.arc4MethodConfig = props.arc4MethodConfig
  }
  readonly cref: ContractReference
  readonly memberName: string
  readonly arc4MethodConfig: ARC4BareMethodConfig | ARC4ABIMethodConfig | null
  accept<T>(visitor: ContractMemberNodeVisitor<T>): T {
    return visitor.visitContractMethod(this)
  }
}
export enum AppStorageKind {
  appGlobal = 1,
  accountLocal = 2,
  box = 3,
}
export class AppStorageDefinition extends ContractMemberNode {
  constructor(props: Props<AppStorageDefinition>) {
    super(props)
    this.memberName = props.memberName
    this.kind = props.kind
    this.storageWtype = props.storageWtype
    this.keyWtype = props.keyWtype
    this.key = props.key
    this.description = props.description
  }
  readonly memberName: string
  readonly kind: AppStorageKind
  readonly storageWtype: wtypes.WType
  readonly keyWtype: wtypes.WType | null
  readonly key: BytesConstant
  readonly description: string | null
  accept<T>(visitor: ContractMemberNodeVisitor<T>): T {
    return visitor.visitAppStorageDefinition(this)
  }
}
export class LogicSignature extends RootNode {
  constructor(props: Props<LogicSignature>) {
    super(props)
    this.id = props.id
    this.shortName = props.shortName
    this.program = props.program
    this.docstring = props.docstring
    this.reservedScratchSpace = props.reservedScratchSpace
    this.avmVersion = props.avmVersion
  }
  readonly id: LogicSigReference
  readonly shortName: string
  readonly program: Subroutine
  readonly docstring: string | null
  readonly reservedScratchSpace: Set<bigint>
  readonly avmVersion: bigint | null
  accept<T>(visitor: RootNodeVisitor<T>): T {
    return visitor.visitLogicSignature(this)
  }
}
export class CompiledContract extends Expression {
  constructor(props: Props<CompiledContract>) {
    super(props)
    this.contract = props.contract
    this.allocationOverrides = props.allocationOverrides
    this.prefix = props.prefix
    this.templateVariables = props.templateVariables
  }
  readonly contract: ContractReference
  readonly allocationOverrides: Map<TxnField, Expression>
  readonly prefix: string | null
  readonly templateVariables: Map<string, Expression>
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitCompiledContract(this)
  }
}
export class CompiledLogicSig extends Expression {
  constructor(props: Props<CompiledLogicSig>) {
    super(props)
    this.logicSig = props.logicSig
    this.prefix = props.prefix
    this.templateVariables = props.templateVariables
  }
  readonly logicSig: LogicSigReference
  readonly prefix: string | null
  readonly templateVariables: Map<string, Expression>
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitCompiledLogicSig(this)
  }
}
export class StateTotals {
  constructor(props: Props<StateTotals>) {
    this.globalUints = props.globalUints
    this.localUints = props.localUints
    this.globalBytes = props.globalBytes
    this.localBytes = props.localBytes
  }
  readonly globalUints: bigint | null
  readonly localUints: bigint | null
  readonly globalBytes: bigint | null
  readonly localBytes: bigint | null
}
export class ARC4Router extends Expression {
  constructor(props: Props<ARC4Router>) {
    super(props)
    this.wtype = props.wtype
  }
  readonly wtype: wtypes.WType
  accept<T>(visitor: ExpressionVisitor<T>): T {
    return visitor.visitARC4Router(this)
  }
}
export class Contract extends RootNode {
  constructor(props: Props<Contract>) {
    super(props)
    this.id = props.id
    this.name = props.name
    this.description = props.description
    this.methodResolutionOrder = props.methodResolutionOrder
    this.approvalProgram = props.approvalProgram
    this.clearProgram = props.clearProgram
    this.methods = props.methods
    this.appState = props.appState
    this.stateTotals = props.stateTotals
    this.reservedScratchSpace = props.reservedScratchSpace
    this.avmVersion = props.avmVersion
  }
  readonly id: ContractReference
  readonly name: string
  readonly description: string | null
  readonly methodResolutionOrder: Array<ContractReference>
  readonly approvalProgram: ContractMethod
  readonly clearProgram: ContractMethod
  readonly methods: Array<ContractMethod>
  readonly appState: Array<AppStorageDefinition>
  readonly stateTotals: StateTotals | null
  readonly reservedScratchSpace: Set<bigint>
  readonly avmVersion: bigint | null
  accept<T>(visitor: RootNodeVisitor<T>): T {
    return visitor.visitContract(this)
  }
}
export enum ARC4CreateOption {
  allow = 1,
  require = 2,
  disallow = 3,
}
export class ARC4BareMethodConfig {
  constructor(props: Props<ARC4BareMethodConfig>) {
    this.sourceLocation = props.sourceLocation
    this.allowedCompletionTypes = props.allowedCompletionTypes
    this.create = props.create
  }
  readonly sourceLocation: SourceLocation
  readonly allowedCompletionTypes: Array<OnCompletionAction>
  readonly create: ARC4CreateOption
}
export class ABIMethodArgConstantDefault {
  constructor(props: Props<ABIMethodArgConstantDefault>) {
    this.value = props.value
  }
  readonly value: Expression
}
export class ABIMethodArgMemberDefault {
  constructor(props: Props<ABIMethodArgMemberDefault>) {
    this.name = props.name
  }
  readonly name: string
}
export class ARC4ABIMethodConfig {
  constructor(props: Props<ARC4ABIMethodConfig>) {
    this.sourceLocation = props.sourceLocation
    this.allowedCompletionTypes = props.allowedCompletionTypes
    this.create = props.create
    this.name = props.name
    this.readonly = props.readonly
    this.defaultArgs = props.defaultArgs
  }
  readonly sourceLocation: SourceLocation
  readonly allowedCompletionTypes: Array<OnCompletionAction>
  readonly create: ARC4CreateOption
  readonly name: string
  readonly readonly: boolean
  readonly defaultArgs: Map<string, ABIMethodArgMemberDefault | ABIMethodArgConstantDefault>
}
export type LValue = VarExpression | FieldExpression | IndexExpression | TupleExpression | AppStateExpression | AppAccountStateExpression
export type Constant = IntegerConstant | BoolConstant | BytesConstant | StringConstant | DecimalConstant | MethodConstant | AddressConstant
export type AWST = Contract | LogicSignature | Subroutine
export type ARC4MethodConfig = ARC4BareMethodConfig | ARC4ABIMethodConfig
export const concreteNodes = {
  expressionStatement: ExpressionStatement,
  block: Block,
  goto: Goto,
  ifElse: IfElse,
  switch: Switch,
  whileLoop: WhileLoop,
  loopExit: LoopExit,
  loopContinue: LoopContinue,
  returnStatement: ReturnStatement,
  assertExpression: AssertExpression,
  integerConstant: IntegerConstant,
  decimalConstant: DecimalConstant,
  boolConstant: BoolConstant,
  bytesConstant: BytesConstant,
  stringConstant: StringConstant,
  voidConstant: VoidConstant,
  templateVar: TemplateVar,
  methodConstant: MethodConstant,
  addressConstant: AddressConstant,
  aRC4Encode: ARC4Encode,
  copy: Copy,
  arrayConcat: ArrayConcat,
  arrayExtend: ArrayExtend,
  arrayPop: ArrayPop,
  arrayReplace: ArrayReplace,
  aRC4Decode: ARC4Decode,
  intrinsicCall: IntrinsicCall,
  createInnerTransaction: CreateInnerTransaction,
  updateInnerTransaction: UpdateInnerTransaction,
  groupTransactionReference: GroupTransactionReference,
  checkedMaybe: CheckedMaybe,
  tupleExpression: TupleExpression,
  tupleItemExpression: TupleItemExpression,
  varExpression: VarExpression,
  innerTransactionField: InnerTransactionField,
  submitInnerTransaction: SubmitInnerTransaction,
  fieldExpression: FieldExpression,
  indexExpression: IndexExpression,
  sliceExpression: SliceExpression,
  intersectionSliceExpression: IntersectionSliceExpression,
  appStateExpression: AppStateExpression,
  appAccountStateExpression: AppAccountStateExpression,
  boxValueExpression: BoxValueExpression,
  singleEvaluation: SingleEvaluation,
  reinterpretCast: ReinterpretCast,
  newArray: NewArray,
  arrayLength: ArrayLength,
  conditionalExpression: ConditionalExpression,
  assignmentStatement: AssignmentStatement,
  assignmentExpression: AssignmentExpression,
  numericComparisonExpression: NumericComparisonExpression,
  bytesComparisonExpression: BytesComparisonExpression,
  subroutineID: SubroutineID,
  instanceMethodTarget: InstanceMethodTarget,
  instanceSuperMethodTarget: InstanceSuperMethodTarget,
  contractMethodTarget: ContractMethodTarget,
  callArg: CallArg,
  subroutineCallExpression: SubroutineCallExpression,
  puyaLibData: PuyaLibData,
  puyaLibCall: PuyaLibCall,
  uInt64UnaryOperation: UInt64UnaryOperation,
  uInt64PostfixUnaryOperation: UInt64PostfixUnaryOperation,
  bigUIntPostfixUnaryOperation: BigUIntPostfixUnaryOperation,
  bytesUnaryOperation: BytesUnaryOperation,
  uInt64BinaryOperation: UInt64BinaryOperation,
  bigUIntBinaryOperation: BigUIntBinaryOperation,
  bytesBinaryOperation: BytesBinaryOperation,
  booleanBinaryOperation: BooleanBinaryOperation,
  not: Not,
  uInt64AugmentedAssignment: UInt64AugmentedAssignment,
  bigUIntAugmentedAssignment: BigUIntAugmentedAssignment,
  bytesAugmentedAssignment: BytesAugmentedAssignment,
  emit: Emit,
  range: Range,
  enumeration: Enumeration,
  reversed: Reversed,
  forInLoop: ForInLoop,
  stateGet: StateGet,
  stateGetEx: StateGetEx,
  stateExists: StateExists,
  stateDelete: StateDelete,
  newStruct: NewStruct,
  subroutineArgument: SubroutineArgument,
  methodDocumentation: MethodDocumentation,
  subroutine: Subroutine,
  contractMethod: ContractMethod,
  appStorageDefinition: AppStorageDefinition,
  logicSignature: LogicSignature,
  compiledContract: CompiledContract,
  compiledLogicSig: CompiledLogicSig,
  stateTotals: StateTotals,
  aRC4Router: ARC4Router,
  contract: Contract,
  aRC4BareMethodConfig: ARC4BareMethodConfig,
  aBIMethodArgConstantDefault: ABIMethodArgConstantDefault,
  aBIMethodArgMemberDefault: ABIMethodArgMemberDefault,
  aRC4ABIMethodConfig: ARC4ABIMethodConfig,
  uInt64Constant: IntegerConstant,
  bigUIntConstant: IntegerConstant,
} as const
export interface ExpressionVisitor<T> {
  visitAssertExpression(expression: AssertExpression): T
  visitIntegerConstant(expression: IntegerConstant): T
  visitDecimalConstant(expression: DecimalConstant): T
  visitBoolConstant(expression: BoolConstant): T
  visitBytesConstant(expression: BytesConstant): T
  visitStringConstant(expression: StringConstant): T
  visitVoidConstant(expression: VoidConstant): T
  visitTemplateVar(expression: TemplateVar): T
  visitMethodConstant(expression: MethodConstant): T
  visitAddressConstant(expression: AddressConstant): T
  visitARC4Encode(expression: ARC4Encode): T
  visitCopy(expression: Copy): T
  visitArrayConcat(expression: ArrayConcat): T
  visitArrayExtend(expression: ArrayExtend): T
  visitArrayPop(expression: ArrayPop): T
  visitArrayReplace(expression: ArrayReplace): T
  visitARC4Decode(expression: ARC4Decode): T
  visitIntrinsicCall(expression: IntrinsicCall): T
  visitCreateInnerTransaction(expression: CreateInnerTransaction): T
  visitUpdateInnerTransaction(expression: UpdateInnerTransaction): T
  visitGroupTransactionReference(expression: GroupTransactionReference): T
  visitCheckedMaybe(expression: CheckedMaybe): T
  visitTupleExpression(expression: TupleExpression): T
  visitTupleItemExpression(expression: TupleItemExpression): T
  visitVarExpression(expression: VarExpression): T
  visitInnerTransactionField(expression: InnerTransactionField): T
  visitSubmitInnerTransaction(expression: SubmitInnerTransaction): T
  visitFieldExpression(expression: FieldExpression): T
  visitIndexExpression(expression: IndexExpression): T
  visitSliceExpression(expression: SliceExpression): T
  visitIntersectionSliceExpression(expression: IntersectionSliceExpression): T
  visitAppStateExpression(expression: AppStateExpression): T
  visitAppAccountStateExpression(expression: AppAccountStateExpression): T
  visitBoxValueExpression(expression: BoxValueExpression): T
  visitSingleEvaluation(expression: SingleEvaluation): T
  visitReinterpretCast(expression: ReinterpretCast): T
  visitNewArray(expression: NewArray): T
  visitArrayLength(expression: ArrayLength): T
  visitConditionalExpression(expression: ConditionalExpression): T
  visitAssignmentExpression(expression: AssignmentExpression): T
  visitNumericComparisonExpression(expression: NumericComparisonExpression): T
  visitBytesComparisonExpression(expression: BytesComparisonExpression): T
  visitSubroutineCallExpression(expression: SubroutineCallExpression): T
  visitPuyaLibCall(expression: PuyaLibCall): T
  visitUInt64UnaryOperation(expression: UInt64UnaryOperation): T
  visitUInt64PostfixUnaryOperation(expression: UInt64PostfixUnaryOperation): T
  visitBigUIntPostfixUnaryOperation(expression: BigUIntPostfixUnaryOperation): T
  visitBytesUnaryOperation(expression: BytesUnaryOperation): T
  visitUInt64BinaryOperation(expression: UInt64BinaryOperation): T
  visitBigUIntBinaryOperation(expression: BigUIntBinaryOperation): T
  visitBytesBinaryOperation(expression: BytesBinaryOperation): T
  visitBooleanBinaryOperation(expression: BooleanBinaryOperation): T
  visitNot(expression: Not): T
  visitEmit(expression: Emit): T
  visitRange(expression: Range): T
  visitEnumeration(expression: Enumeration): T
  visitReversed(expression: Reversed): T
  visitStateGet(expression: StateGet): T
  visitStateGetEx(expression: StateGetEx): T
  visitStateExists(expression: StateExists): T
  visitStateDelete(expression: StateDelete): T
  visitNewStruct(expression: NewStruct): T
  visitCompiledContract(expression: CompiledContract): T
  visitCompiledLogicSig(expression: CompiledLogicSig): T
  visitARC4Router(expression: ARC4Router): T
}
export interface StatementVisitor<T> {
  visitExpressionStatement(statement: ExpressionStatement): T
  visitBlock(statement: Block): T
  visitGoto(statement: Goto): T
  visitIfElse(statement: IfElse): T
  visitSwitch(statement: Switch): T
  visitWhileLoop(statement: WhileLoop): T
  visitLoopExit(statement: LoopExit): T
  visitLoopContinue(statement: LoopContinue): T
  visitReturnStatement(statement: ReturnStatement): T
  visitAssignmentStatement(statement: AssignmentStatement): T
  visitUInt64AugmentedAssignment(statement: UInt64AugmentedAssignment): T
  visitBigUIntAugmentedAssignment(statement: BigUIntAugmentedAssignment): T
  visitBytesAugmentedAssignment(statement: BytesAugmentedAssignment): T
  visitForInLoop(statement: ForInLoop): T
}
export interface ContractMemberNodeVisitor<T> {
  visitContractMethod(contractMemberNode: ContractMethod): T
  visitAppStorageDefinition(contractMemberNode: AppStorageDefinition): T
}
export interface RootNodeVisitor<T> {
  visitSubroutine(rootNode: Subroutine): T
  visitLogicSignature(rootNode: LogicSignature): T
  visitContract(rootNode: Contract): T
}



================================================
FILE: src/awst/source-location.ts
================================================
import ts from 'typescript'
import { invariant, normalisePath } from '../util'

export class SourceLocation {
  file: string | null
  line: number
  endLine: number
  column: number
  endColumn: number
  scope: 'file' | 'range'

  constructor(props: {
    file?: string | null
    line: number
    endLine: number
    column: number
    endColumn: number
    scope: SourceLocation['scope']
  }) {
    invariant(props.line <= props.endLine, 'Start line must be before end line')
    if (props.line === props.endLine) invariant(props.column <= props.endColumn, 'Start column must be before end column')
    this.file = props.file ?? null
    this.line = props.line
    this.endLine = props.endLine
    this.column = props.column
    this.endColumn = props.endColumn
    this.scope = props.scope

    // Exclude scope from enumerable properties so it doesn't end up being serialized
    Object.defineProperty(this, 'scope', {
      enumerable: false,
    })
  }

  private static getStartAndEnd(node: ts.Node): { start: number; end: number } {
    if (ts.isClassDeclaration(node)) {
      return fromNodeTillStartOfNode(node, node.members.at(0))
    }
    if (ts.isMethodDeclaration(node) || ts.isFunctionDeclaration(node)) {
      return fromNodeTillStartOfNode(node, node.body)
    }
    if (ts.isForStatement(node) || ts.isForInStatement(node) || ts.isForOfStatement(node)) {
      return fromNodeTillStartOfNode(node, node.statement)
    }
    if (ts.isIfStatement(node)) {
      return fromNodeTillStartOfNode(node, node.thenStatement)
    }

    return {
      start: node.getStart(),
      end: node.getEnd(),
    }
  }

  static fromNode(node: ts.Node, programDirectory: string): SourceLocation {
    const sourceFile = node.getSourceFile()

    const { start, end } = SourceLocation.getStartAndEnd(node)

    const startLoc = sourceFile.getLineAndCharacterOfPosition(start)
    const endLoc = sourceFile.getLineAndCharacterOfPosition(end)

    return new SourceLocation({
      file: normalisePath(sourceFile.fileName, programDirectory),
      line: startLoc.line + 1,
      endLine: endLoc.line + 1,
      column: startLoc.character,
      endColumn: endLoc.character,
      scope: 'range',
    })
  }

  static fromFile(sourceFile: ts.SourceFile, programDirectory: string): SourceLocation {
    const endPos = sourceFile.getEnd()
    const endLoc = sourceFile.getLineAndCharacterOfPosition(endPos)
    return new SourceLocation({
      file: normalisePath(sourceFile.fileName, programDirectory),
      line: 1,
      endLine: endLoc.line + 1,
      column: 0,
      endColumn: endLoc.character,
      scope: 'file',
    })
  }

  static fromTextRange(sourceFile: ts.SourceFile, textRange: ts.TextRange, programDirectory: string): SourceLocation {
    const startLoc = sourceFile.getLineAndCharacterOfPosition(textRange.pos)
    const endLoc = sourceFile.getLineAndCharacterOfPosition(textRange.end)

    return new SourceLocation({
      file: normalisePath(sourceFile.fileName, programDirectory),
      line: startLoc.line + 1,
      endLine: endLoc.line + 1,
      column: startLoc.character,
      endColumn: endLoc.character,
      scope: 'range',
    })
  }

  static fromDiagnostic(diagnostic: ts.DiagnosticWithLocation, programDirectory: string): SourceLocation {
    const startLoc = diagnostic.file.getLineAndCharacterOfPosition(diagnostic.start)

    return new SourceLocation({
      file: normalisePath(diagnostic.file.fileName, programDirectory),
      line: startLoc.line + 1,
      endLine: startLoc.line + 1,
      column: startLoc.character,
      endColumn: startLoc.character,
      scope: 'range',
    })
  }

  toString() {
    return `${this.file}:${this.line}:${this.column + 1}`
  }

  static fromLocations(...sourceLocation: SourceLocation[]): SourceLocation {
    const [first, ...rest] = sourceLocation
    invariant(first && rest.every((r) => r.file === first.file), 'All locations must of the same file')
    if (rest.length === 0) return first
    return sourceLocation.reduce((acc, cur) => {
      return new SourceLocation({
        file: acc.file,
        line: Math.min(acc.line, cur.line),
        endLine: Math.max(acc.endLine, cur.endLine),
        column: acc.line === cur.line ? Math.min(acc.column, cur.column) : acc.line < cur.line ? acc.column : cur.column,
        endColumn:
          acc.endLine === cur.endLine ? Math.max(acc.endColumn, cur.endColumn) : acc.endLine > cur.endLine ? acc.endColumn : cur.endColumn,
        scope: 'range',
      })
    })
  }

  static None = new SourceLocation({
    line: 1,
    endLine: 1,
    column: 0,
    endColumn: 1,
    scope: 'file',
  })
}

function fromNodeTillStartOfNode(n1: ts.Node, n2?: ts.Node): { start: number; end: number } {
  return {
    start: n1.getStart(),
    end: n2 ? n2.getStart() - n2.getLeadingTriviaWidth() : n1.getEnd(),
  }
}



================================================
FILE: src/awst/to-code-visitor.ts
================================================
import { Buffer } from 'node:buffer'
import { InternalError } from '../errors'
import { uint8ArrayToBase32, uint8ArrayToUtf8 } from '../util'
import type { ContractReference } from './models'
import type {
  AppStorageDefinition,
  AssertExpression,
  ContractMemberNodeVisitor,
  Emit,
  ExpressionVisitor,
  RootNodeVisitor,
  StatementVisitor,
} from './nodes'
import * as nodes from './nodes'
import { AppStorageKind, BytesEncoding, ContractMethodTarget, InstanceMethodTarget, InstanceSuperMethodTarget, SubroutineID } from './nodes'
import { SymbolToNumber } from './util'
import { wtypes } from './wtypes'

function printBytes(value: Uint8Array, encoding: BytesEncoding) {
  switch (encoding) {
    case BytesEncoding.utf8:
      return `"${uint8ArrayToUtf8(value)}"`
    case BytesEncoding.base64:
      return `b64<${Buffer.from(value).toString('base64')}>`
    case BytesEncoding.base32:
      return `b32<${uint8ArrayToBase32(value)}>`
    default:
      return `0x${Buffer.from(value).toString('hex')}`
  }
}
export class ToCodeVisitor
  implements RootNodeVisitor<string[]>, ContractMemberNodeVisitor<string[]>, StatementVisitor<string[]>, ExpressionVisitor<string>
{
  visitRange(expression: nodes.Range): string {
    return `urange(${expression.start.accept(this)}, ${expression.stop.accept(this)}, ${expression.step.accept(this)})`
  }
  visitVoidConstant(expression: nodes.VoidConstant): string {
    return `void`
  }
  visitGroupTransactionReference(expression: nodes.GroupTransactionReference): string {
    return `group_transaction(index=${expression.index.accept(this)}, type=${expression.wtype})`
  }
  visitPuyaLibCall(expression: nodes.PuyaLibCall): string {
    return `${expression.func}(${expression.args.map((a) => a.value.accept(this)).join(', ')})`
  }
  visitARC4Router(expression: nodes.ARC4Router): string {
    return `arc4Router()`
  }
  visitAppStorageDefinition(contractMemberNode: AppStorageDefinition): string[] {
    throw new Error('Method not implemented.')
  }
  #singleEval = new SymbolToNumber()
  visitUInt64PostfixUnaryOperation(expression: nodes.UInt64PostfixUnaryOperation): string {
    return `${expression.target.accept(this)}${expression.op}`
  }
  visitBigUIntPostfixUnaryOperation(expression: nodes.BigUIntPostfixUnaryOperation): string {
    return `${expression.target.accept(this)}${expression.op}`
  }
  visitCompiledContract(expression: nodes.CompiledContract): string {
    let overrides = Array.from(expression.allocationOverrides.entries())
      .map(([f, v]) => `${f}=${v.accept(this)}`)
      .join(', ')
    if (overrides) {
      overrides = `, ${overrides}`
    }

    let templateVars = Array.from(expression.templateVariables.entries())
      .map(([n, v]) => `${n}=${v.accept(this)}`)
      .join(', ')
    if (templateVars) {
      templateVars = `, ${templateVars}`
    }

    const prefix = expression.prefix ? `, prefix=${expression.prefix}` : ''

    return `compile(${expression.contract.id}${overrides}${prefix}${templateVars}`
  }
  visitCompiledLogicSig(expression: nodes.CompiledLogicSig): string {
    let templateVars = Array.from(expression.templateVariables.entries())
      .map(([n, v]) => `${n}=${v.accept(this)}`)
      .join(', ')
    if (templateVars) {
      templateVars = `, ${templateVars}`
    }

    const prefix = expression.prefix ? `, prefix=${expression.prefix}` : ''

    return `compile(${expression.logicSig.id}${prefix}${templateVars}`
  }
  visitLoopExit(statement: nodes.LoopExit): string[] {
    return ['break']
  }
  visitLoopContinue(statement: nodes.LoopContinue): string[] {
    return ['continue']
  }
  visitGoto(statement: nodes.Goto): string[] {
    return [`goto ${statement.target}`]
  }
  visitIntersectionSliceExpression(expression: nodes.IntersectionSliceExpression): string {
    const args = [expression.beginIndex, expression.endIndex]
      .flatMap((f) => (typeof f === 'bigint' ? f : (f?.accept(this) ?? [])))
      .join(', ')
    return `${expression.base.accept(this)}.slice(${args})`
  }
  visitBoxValueExpression(expression: nodes.BoxValueExpression): string {
    return `Box[${expression.key.accept(this)}].value`
  }
  visitIntegerConstant(expression: nodes.IntegerConstant): string {
    if (expression.tealAlias) return expression.tealAlias
    return `${expression.value}`
  }
  visitDecimalConstant(expression: nodes.DecimalConstant): string {
    return `${expression.value}m`
  }
  visitBoolConstant(expression: nodes.BoolConstant): string {
    return expression.value ? 'True' : 'False'
  }
  visitBytesConstant(expression: nodes.BytesConstant): string {
    return printBytes(expression.value, expression.encoding)
  }
  visitStringConstant(expression: nodes.StringConstant): string {
    return `"${expression.value}"`
  }
  visitTemplateVar(expression: nodes.TemplateVar): string {
    return `TemplateVar[${expression.wtype}](${expression.name})`
  }
  visitMethodConstant(expression: nodes.MethodConstant): string {
    return `Method("${expression.value}")`
  }
  visitAddressConstant(expression: nodes.AddressConstant): string {
    return `Address("${expression.value}")`
  }
  visitARC4Encode(expression: nodes.ARC4Encode): string {
    return `ARC4_ENCODE(${expression.value.accept(this)}, wtype=${expression.wtype})`
  }
  visitCopy(expression: nodes.Copy): string {
    return `copy(${expression.value.accept(this)})`
  }
  visitArrayConcat(expression: nodes.ArrayConcat): string {
    return `${expression.left.accept(this)}.concat(${expression.right.accept(this)})`
  }
  visitArrayPop(expression: nodes.ArrayPop): string {
    return `${expression.base.accept(this)}.pop()`
  }
  visitArrayExtend(expression: nodes.ArrayExtend): string {
    return `${expression.base.accept(this)}.push(...${expression.other.accept(this)}`
  }
  visitArrayLength(expression: nodes.ArrayLength): string {
    return `${expression.array.accept(this)}.length`
  }
  visitArrayReplace(expression: nodes.ArrayReplace): string {
    return `${expression.base.accept(this)}.with(${expression.index.accept(this)}, ${expression.value.accept(this)})`
  }
  visitARC4Decode(expression: nodes.ARC4Decode): string {
    return `ARC4_DECODE(${expression.value.accept(this)})`
  }
  visitIntrinsicCall(expression: nodes.IntrinsicCall): string {
    const immediates = expression.immediates.length ? `<${expression.immediates.map((i) => i).join(', ')}>` : ''
    const stack = expression.stackArgs.map((a) => a.accept(this)).join(', ')
    return `${expression.opCode}${immediates}(${stack})`
  }
  visitCreateInnerTransaction(expression: nodes.CreateInnerTransaction): string {
    const fields = Array.from(expression.fields.entries())
      .map(([f, v]) => `${f}=${v.accept(this)}`)
      .join(', ')
    return `create_inner_transaction(${fields})`
  }
  visitUpdateInnerTransaction(expression: nodes.UpdateInnerTransaction): string {
    const fields = Array.from(expression.fields.entries())
      .map(([f, v]) => `${f}=${v.accept(this)}`)
      .join(', ')
    return `update_inner_transaction(${expression.itxn.accept(this)}, ${fields})`
  }
  visitCheckedMaybe(expression: nodes.CheckedMaybe): string {
    return `checked_maybe(${expression.expr.accept(this)}, comment=${expression.comment})`
  }
  visitTupleExpression(expression: nodes.TupleExpression): string {
    const names = expression.wtype.names
    if (names) {
      return `{ ${expression.items.map((item, i) => `${names[i]}: ${item.accept(this)}`).join(', ')} }`
    }

    return `<tuple>[${expression.items.map((i) => i.accept(this)).join(', ')}]`
  }
  visitTupleItemExpression(expression: nodes.TupleItemExpression): string {
    return `${expression.base.accept(this)}.${expression.index}`
  }
  visitVarExpression(expression: nodes.VarExpression): string {
    return expression.name
  }
  visitInnerTransactionField(expression: nodes.InnerTransactionField): string {
    const indexAccess = expression.arrayIndex ? `[${expression.arrayIndex.accept(this)}]` : ''
    return `${expression.itxn.accept(this)}.${expression.field}${indexAccess}`
  }
  visitSubmitInnerTransaction(expression: nodes.SubmitInnerTransaction): string {
    return `submit_txn(${expression.itxns.map((i) => i.accept(this)).join(', ')})`
  }
  visitFieldExpression(expression: nodes.FieldExpression): string {
    return `${expression.base.accept(this)}.${expression.name}`
  }
  visitIndexExpression(expression: nodes.IndexExpression): string {
    return `${expression.base.accept(this)}[${expression.index.accept(this)}]`
  }
  visitSliceExpression(expression: nodes.SliceExpression): string {
    return `${expression.base.accept(this)}[${expression.beginIndex?.accept(this) ?? ''}:${expression.endIndex?.accept(this) ?? ''}]`
  }
  visitAppStateExpression(expression: nodes.AppStateExpression): string {
    return `GlobalState[${expression.key.accept(this)}]`
  }
  visitAppAccountStateExpression(expression: nodes.AppAccountStateExpression): string {
    return `LocalState[${expression.account.accept(this)}][${expression.key.accept(this)}]`
  }
  visitSingleEvaluation(expression: nodes.SingleEvaluation): string {
    const [id, isNew] = this.#singleEval.forSymbol(expression.id)
    if (!isNew) {
      return `#${id}`
    }
    return `(#${id} = ${expression.source.accept(this)})`
  }
  visitReinterpretCast(expression: nodes.ReinterpretCast): string {
    const target = expression.expr.accept(this)
    if (expression.wtype.equals(wtypes.boolWType)) {
      return `Boolean(${target})`
    }
    return `reinterpret_cast<${expression.wtype}>(${target})`
  }
  visitNewArray(expression: nodes.NewArray): string {
    return `new ${expression.wtype.name}(${expression.values.map((v) => v.accept(this)).join(', ')})`
  }
  visitConditionalExpression(expression: nodes.ConditionalExpression): string {
    return `(${expression.condition.accept(this)} ? ${expression.trueExpr.accept(this)} : ${expression.falseExpr.accept(this)})`
  }
  visitAssignmentExpression(expression: nodes.AssignmentExpression): string {
    const rvalue =
      expression.value instanceof nodes.AssignmentExpression ? `(${expression.value.accept(this)})` : expression.value.accept(this)
    return `(${expression.target.accept(this)} = ${rvalue})`
  }
  visitNumericComparisonExpression(expression: nodes.NumericComparisonExpression): string {
    return `${expression.lhs.accept(this)} ${expression.operator} ${expression.rhs.accept(this)}`
  }
  visitBytesComparisonExpression(expression: nodes.BytesComparisonExpression): string {
    return `${expression.lhs.accept(this)} ${expression.operator} ${expression.rhs.accept(this)}`
  }
  visitSubroutineCallExpression(expression: nodes.SubroutineCallExpression): string {
    const target = this.visitCallTarget(expression.target)
    return `${target}(${expression.args.map((a) => a.value.accept(this)).join(', ')})`
  }
  visitCallTarget(target: nodes.SubroutineCallExpression['target']) {
    if (target instanceof SubroutineID) return target.target
    if (target instanceof ContractMethodTarget) return `${target.cref}.${target.memberName}`
    if (target instanceof InstanceMethodTarget) return `this.${target.memberName}`
    if (target instanceof InstanceSuperMethodTarget) return `super.${target.memberName}`
    throw new InternalError(`Unhandled target: ${target}`)
  }
  visitUInt64UnaryOperation(expression: nodes.UInt64UnaryOperation): string {
    return `${expression.op}${expression.expr.accept(this)}`
  }
  visitBytesUnaryOperation(expression: nodes.BytesUnaryOperation): string {
    return `${expression.op}${expression.expr.accept(this)}`
  }
  visitUInt64BinaryOperation(expression: nodes.UInt64BinaryOperation): string {
    return `${expression.left.accept(this)} ${expression.op} ${expression.right.accept(this)}`
  }
  visitBigUIntBinaryOperation(expression: nodes.BigUIntBinaryOperation): string {
    return `${expression.left.accept(this)} ${expression.op} ${expression.right.accept(this)}`
  }
  visitBytesBinaryOperation(expression: nodes.BytesBinaryOperation): string {
    return `${expression.left.accept(this)} ${expression.op} ${expression.right.accept(this)}`
  }
  visitBooleanBinaryOperation(expression: nodes.BooleanBinaryOperation): string {
    return `${expression.left.accept(this)} ${expression.op} ${expression.right.accept(this)}`
  }
  visitNot(expression: nodes.Not): string {
    return `!${expression.expr.accept(this)}`
  }
  visitEnumeration(expression: nodes.Enumeration): string {
    return `enumerate(${expression.expr.accept(this)})`
  }
  visitReversed(expression: nodes.Reversed): string {
    return `reversed(${expression.expr.accept(this)})`
  }
  visitStateGet(expression: nodes.StateGet): string {
    return `STATE_GET(${expression.field.accept(this)}, default=${expression.default.accept(this)})`
  }

  visitStateDelete(expression: nodes.StateDelete): string {
    return `STATE_DELETE(${expression.field.accept(this)})`
  }
  visitStateGetEx(expression: nodes.StateGetEx): string {
    return `STATE_GET_EX(${expression.field.accept(this)})`
  }
  visitStateExists(expression: nodes.StateExists): string {
    return `STATE_EXISTS(${expression.field.accept(this)})`
  }
  visitNewStruct(expression: nodes.NewStruct): string {
    const props = Array.from(expression.values)
      .map(([k, v]) => `${k}=${v.accept(this)}`)
      .join(', ')
    return `new ${expression.wtype.name}(${props})`
  }
  visitExpressionStatement(statement: nodes.ExpressionStatement): string[] {
    return [statement.expr.accept(this)]
  }
  visitBlock(statement: nodes.Block): string[] {
    return [...(statement.label ? [`${statement.label}:`] : []), ...statement.body.flatMap((b) => b.accept(this))]
  }
  visitIfElse(statement: nodes.IfElse): string[] {
    return [
      `if (${statement.condition.accept(this)}) {`,
      ...indent(statement.ifBranch.accept(this)),
      ...(statement.elseBranch ? ['} else {', ...indent(statement.elseBranch.accept(this)), '}'] : ['}']),
    ]
  }
  visitSwitch(statement: nodes.Switch): string[] {
    return [
      `switch (${statement.value.accept(this)}) {`,
      ...indent(
        Array.from(statement.cases.entries()).flatMap(([clause, block]) => [`case ${clause.accept(this)}:`, ...indent(block.accept(this))]),
      ),
      ...(statement.defaultCase ? indent(['default:', ...indent(statement.defaultCase.accept(this))]) : []),
      '}',
    ]
  }
  visitWhileLoop(statement: nodes.WhileLoop): string[] {
    return [`while (${statement.condition.accept(this)}) {`, ...indent(statement.loopBody.accept(this)), '}']
  }
  visitReturnStatement(statement: nodes.ReturnStatement): string[] {
    return [`return ${statement.value?.accept(this) ?? ''}`]
  }
  visitAssignmentStatement(statement: nodes.AssignmentStatement): string[] {
    return [`${statement.target.accept(this)}: ${statement.target.wtype} = ${statement.value.accept(this)}`]
  }
  visitUInt64AugmentedAssignment(statement: nodes.UInt64AugmentedAssignment): string[] {
    return [`${statement.target.accept(this)} = ${statement.target.accept(this)} ${statement.op} ${statement.value.accept(this)}`]
  }
  visitBigUIntAugmentedAssignment(statement: nodes.BigUIntAugmentedAssignment): string[] {
    return [`${statement.target.accept(this)} = ${statement.target.accept(this)} ${statement.op} ${statement.value.accept(this)}`]
  }
  visitBytesAugmentedAssignment(statement: nodes.BytesAugmentedAssignment): string[] {
    return [`${statement.target.accept(this)} = ${statement.target.accept(this)} ${statement.op} ${statement.value.accept(this)}`]
  }
  visitForInLoop(statement: nodes.ForInLoop): string[] {
    return [
      `for (${statement.items.accept(this)} in ${statement.sequence.accept(this)}) {`,
      ...indent(statement.loopBody.accept(this)),
      '}',
    ]
  }
  visitSubroutine(moduleStatement: nodes.Subroutine): string[] {
    const args = moduleStatement.args.map((a) => `${a.name}: ${a.wtype}`).join(', ')
    return [
      `subroutine ${moduleStatement.name}(${args}): ${moduleStatement.returnType}`,
      '{',
      ...indent(moduleStatement.body.accept(this)),
      '}',
    ]
  }
  visitEmit(expression: Emit): string {
    return `emit("${expression.signature}", ${expression.value.accept(this)})`
  }

  visitContractMethod(statement: nodes.ContractMethod): string[] {
    const args = statement.args.map((a) => `${a.name}: ${a.wtype}`).join(', ')

    const prefix = statement.cref.id === this.currentContract.at(-1)?.id ? '' : `${statement.cref.className}::`
    return [`${prefix}${statement.memberName}(${args}): ${statement.returnType}`, '{', ...indent(statement.body.accept(this)), '}', '']
  }
  visitLogicSignature(moduleStatement: nodes.LogicSignature): string[] {
    return ['', `logicsig ${moduleStatement.id} {`, ...indent(moduleStatement.program.body.accept(this)), '}']
  }
  visitAssertExpression(expression: AssertExpression): string {
    return [
      expression.condition ? 'assert(' : 'err(',
      expression.condition?.accept(this) ?? '',
      expression.errorMessage ? `, comment=${expression.errorMessage}` : '',
      ')',
    ].join('')
  }

  private currentContract: ContractReference[] = []
  visitContract(c: nodes.Contract): string[] {
    this.currentContract.push(c.id)

    using _ = {
      [Symbol.dispose]: () => {
        this.currentContract.pop()
      },
    }
    const body: string[] = []
    if (c.appState.length) {
      const storageByKind = Array.from(c.appState.values()).reduce(
        (acc, cur) => acc.set(cur.kind, [...(acc.get(cur.kind) ?? []), cur]),
        new Map<AppStorageKind, AppStorageDefinition[]>(),
      )
      for (const [name, kind] of [
        ['globals', AppStorageKind.appGlobal],
        ['locals', AppStorageKind.accountLocal],
        ['boxes', AppStorageKind.box],
      ] as const) {
        const items = storageByKind.get(kind)
        if (items?.length) {
          body.push(
            `${name} {`,
            ...indent(
              items.map((g) =>
                g.keyWtype ? `[${g.key.accept(this)}]: ${g.keyWtype} => ${g.storageWtype}` : `[${g.key.accept(this)}]: ${g.storageWtype}`,
              ),
            ),
            '}',
          )
        }
      }
    }
    if (c.reservedScratchSpace.size) {
      body.push(`reservedScratchSpace: [${Array.from(c.reservedScratchSpace).join(', ')}]`)
    }
    if (c.approvalProgram) {
      body.push(...this.visitSpecialMethod(c.approvalProgram, 'approvalProgram'))
    }
    if (c.clearProgram) {
      body.push(...this.visitSpecialMethod(c.clearProgram, 'clearProgram'))
    }
    for (const method of c.methods) {
      body.push(...method.accept(this))
    }

    const header = ['contract', c.name]

    return [header.join(' '), '{', ...indent(body), '}']
  }

  visitSpecialMethod(statement: nodes.ContractMethod, name: string): string[] {
    return [`${name}(): ${statement.returnType}`, '{', ...indent(statement.body.accept(this)), '}', '']
  }
}

function indent(lines: string[], indentSize = '  '): string[] {
  return lines.map((l) => `${indentSize}${l}`)
}



================================================
FILE: src/awst/txn-fields.ts
================================================
import { wtypes } from './wtypes'

export class TxnFieldData {
  readonly immediate: string
  readonly wtype: wtypes.WType
  readonly numValues: number
  readonly isInnerParam: boolean
  /**
   * If field is an array, accept individual arguments and convert to an array
   */
  readonly arrayPromote: boolean
  constructor(data: { field: TxnField; wtype: wtypes.WType; numValues?: number; isInnerParam?: boolean; arrayPromote?: boolean }) {
    this.immediate = data.field
    this.wtype = data.wtype
    this.numValues = data.numValues ?? 1
    this.isInnerParam = data.isInnerParam ?? true
    this.arrayPromote = data.arrayPromote ?? false
  }
}

export enum TxnField {
  Sender = 'Sender',
  Fee = 'Fee',
  FirstValid = 'FirstValid',
  FirstValidTime = 'FirstValidTime',
  LastValid = 'LastValid',
  Note = 'Note',
  Lease = 'Lease',
  Receiver = 'Receiver',
  Amount = 'Amount',
  CloseRemainderTo = 'CloseRemainderTo',
  VotePK = 'VotePK',
  SelectionPK = 'SelectionPK',
  VoteFirst = 'VoteFirst',
  VoteLast = 'VoteLast',
  VoteKeyDilution = 'VoteKeyDilution',
  Type = 'Type',
  TypeEnum = 'TypeEnum',
  XferAsset = 'XferAsset',
  AssetAmount = 'AssetAmount',
  AssetSender = 'AssetSender',
  AssetReceiver = 'AssetReceiver',
  AssetCloseTo = 'AssetCloseTo',
  GroupIndex = 'GroupIndex',
  TxID = 'TxID',
  ApplicationID = 'ApplicationID',
  OnCompletion = 'OnCompletion',
  NumAppArgs = 'NumAppArgs',
  NumAccounts = 'NumAccounts',
  ApprovalProgram = 'ApprovalProgram',
  ClearStateProgram = 'ClearStateProgram',
  RekeyTo = 'RekeyTo',
  ConfigAsset = 'ConfigAsset',
  ConfigAssetTotal = 'ConfigAssetTotal',
  ConfigAssetDecimals = 'ConfigAssetDecimals',
  ConfigAssetDefaultFrozen = 'ConfigAssetDefaultFrozen',
  ConfigAssetUnitName = 'ConfigAssetUnitName',
  ConfigAssetName = 'ConfigAssetName',
  ConfigAssetURL = 'ConfigAssetURL',
  ConfigAssetMetadataHash = 'ConfigAssetMetadataHash',
  ConfigAssetManager = 'ConfigAssetManager',
  ConfigAssetReserve = 'ConfigAssetReserve',
  ConfigAssetFreeze = 'ConfigAssetFreeze',
  ConfigAssetClawback = 'ConfigAssetClawback',
  FreezeAsset = 'FreezeAsset',
  FreezeAssetAccount = 'FreezeAssetAccount',
  FreezeAssetFrozen = 'FreezeAssetFrozen',
  NumAssets = 'NumAssets',
  NumApplications = 'NumApplications',
  GlobalNumUint = 'GlobalNumUint',
  GlobalNumByteSlice = 'GlobalNumByteSlice',
  LocalNumUint = 'LocalNumUint',
  LocalNumByteSlice = 'LocalNumByteSlice',
  ExtraProgramPages = 'ExtraProgramPages',
  Nonparticipation = 'Nonparticipation',
  NumLogs = 'NumLogs',
  CreatedAssetID = 'CreatedAssetID',
  CreatedApplicationID = 'CreatedApplicationID',
  LastLog = 'LastLog',
  StateProofPK = 'StateProofPK',
  NumApprovalProgramPages = 'NumApprovalProgramPages',
  NumClearStateProgramPages = 'NumClearStateProgramPages',
  ApplicationArgs = 'ApplicationArgs',
  Accounts = 'Accounts',
  Assets = 'Assets',
  Applications = 'Applications',
  Logs = 'Logs',
  ApprovalProgramPages = 'ApprovalProgramPages',
  ClearStateProgramPages = 'ClearStateProgramPages',
}

export const TxnFields: Record<TxnField, TxnFieldData> = {
  Sender: new TxnFieldData({ field: TxnField.Sender, wtype: wtypes.accountWType }),
  Fee: new TxnFieldData({ field: TxnField.Fee, wtype: wtypes.uint64WType }),
  FirstValid: new TxnFieldData({ field: TxnField.FirstValid, wtype: wtypes.uint64WType, isInnerParam: false }),
  FirstValidTime: new TxnFieldData({ field: TxnField.FirstValidTime, wtype: wtypes.uint64WType, isInnerParam: false }),
  LastValid: new TxnFieldData({ field: TxnField.LastValid, wtype: wtypes.uint64WType, isInnerParam: false }),
  Note: new TxnFieldData({ field: TxnField.Note, wtype: wtypes.bytesWType }),
  Lease: new TxnFieldData({ field: TxnField.Lease, wtype: wtypes.bytesWType, isInnerParam: false }),
  Receiver: new TxnFieldData({ field: TxnField.Receiver, wtype: wtypes.accountWType }),
  Amount: new TxnFieldData({ field: TxnField.Amount, wtype: wtypes.uint64WType }),
  CloseRemainderTo: new TxnFieldData({ field: TxnField.CloseRemainderTo, wtype: wtypes.accountWType }),
  VotePK: new TxnFieldData({ field: TxnField.VotePK, wtype: wtypes.bytesWType }),
  SelectionPK: new TxnFieldData({ field: TxnField.SelectionPK, wtype: wtypes.bytesWType }),
  VoteFirst: new TxnFieldData({ field: TxnField.VoteFirst, wtype: wtypes.uint64WType }),
  VoteLast: new TxnFieldData({ field: TxnField.VoteLast, wtype: wtypes.uint64WType }),
  VoteKeyDilution: new TxnFieldData({ field: TxnField.VoteKeyDilution, wtype: wtypes.uint64WType }),
  Type: new TxnFieldData({ field: TxnField.Type, wtype: wtypes.bytesWType }),
  TypeEnum: new TxnFieldData({ field: TxnField.TypeEnum, wtype: wtypes.uint64WType }),
  XferAsset: new TxnFieldData({ field: TxnField.XferAsset, wtype: wtypes.assetWType }),
  AssetAmount: new TxnFieldData({ field: TxnField.AssetAmount, wtype: wtypes.uint64WType }),
  AssetSender: new TxnFieldData({ field: TxnField.AssetSender, wtype: wtypes.accountWType }),
  AssetReceiver: new TxnFieldData({ field: TxnField.AssetReceiver, wtype: wtypes.accountWType }),
  AssetCloseTo: new TxnFieldData({ field: TxnField.AssetCloseTo, wtype: wtypes.accountWType }),
  GroupIndex: new TxnFieldData({ field: TxnField.GroupIndex, wtype: wtypes.uint64WType, isInnerParam: false }),
  TxID: new TxnFieldData({ field: TxnField.TxID, wtype: wtypes.bytesWType, isInnerParam: false }),
  // v2
  ApplicationID: new TxnFieldData({ field: TxnField.ApplicationID, wtype: wtypes.applicationWType }),
  OnCompletion: new TxnFieldData({ field: TxnField.OnCompletion, wtype: wtypes.uint64WType }),
  NumAppArgs: new TxnFieldData({ field: TxnField.NumAppArgs, wtype: wtypes.uint64WType, isInnerParam: false }),
  NumAccounts: new TxnFieldData({ field: TxnField.NumAccounts, wtype: wtypes.uint64WType, isInnerParam: false }),
  ApprovalProgram: new TxnFieldData({ field: TxnField.ApprovalProgram, wtype: wtypes.bytesWType }),
  ClearStateProgram: new TxnFieldData({ field: TxnField.ClearStateProgram, wtype: wtypes.bytesWType }),
  RekeyTo: new TxnFieldData({ field: TxnField.RekeyTo, wtype: wtypes.accountWType }),
  ConfigAsset: new TxnFieldData({ field: TxnField.ConfigAsset, wtype: wtypes.assetWType }),
  ConfigAssetTotal: new TxnFieldData({ field: TxnField.ConfigAssetTotal, wtype: wtypes.uint64WType }),
  ConfigAssetDecimals: new TxnFieldData({ field: TxnField.ConfigAssetDecimals, wtype: wtypes.uint64WType }),
  ConfigAssetDefaultFrozen: new TxnFieldData({ field: TxnField.ConfigAssetDefaultFrozen, wtype: wtypes.boolWType }),
  ConfigAssetUnitName: new TxnFieldData({ field: TxnField.ConfigAssetUnitName, wtype: wtypes.bytesWType }),
  ConfigAssetName: new TxnFieldData({ field: TxnField.ConfigAssetName, wtype: wtypes.bytesWType }),
  ConfigAssetURL: new TxnFieldData({ field: TxnField.ConfigAssetURL, wtype: wtypes.bytesWType }),
  ConfigAssetMetadataHash: new TxnFieldData({ field: TxnField.ConfigAssetMetadataHash, wtype: wtypes.bytesWType }),
  ConfigAssetManager: new TxnFieldData({ field: TxnField.ConfigAssetManager, wtype: wtypes.accountWType }),
  ConfigAssetReserve: new TxnFieldData({ field: TxnField.ConfigAssetReserve, wtype: wtypes.accountWType }),
  ConfigAssetFreeze: new TxnFieldData({ field: TxnField.ConfigAssetFreeze, wtype: wtypes.accountWType }),
  ConfigAssetClawback: new TxnFieldData({ field: TxnField.ConfigAssetClawback, wtype: wtypes.accountWType }),
  FreezeAsset: new TxnFieldData({ field: TxnField.FreezeAsset, wtype: wtypes.assetWType }),
  FreezeAssetAccount: new TxnFieldData({ field: TxnField.FreezeAssetAccount, wtype: wtypes.accountWType }),
  FreezeAssetFrozen: new TxnFieldData({ field: TxnField.FreezeAssetFrozen, wtype: wtypes.boolWType }),
  // v3
  NumAssets: new TxnFieldData({ field: TxnField.NumAssets, wtype: wtypes.uint64WType, isInnerParam: false }),
  NumApplications: new TxnFieldData({ field: TxnField.NumApplications, wtype: wtypes.uint64WType, isInnerParam: false }),
  GlobalNumUint: new TxnFieldData({ field: TxnField.GlobalNumUint, wtype: wtypes.uint64WType }),
  GlobalNumByteSlice: new TxnFieldData({ field: TxnField.GlobalNumByteSlice, wtype: wtypes.uint64WType }),
  LocalNumUint: new TxnFieldData({ field: TxnField.LocalNumUint, wtype: wtypes.uint64WType }),
  LocalNumByteSlice: new TxnFieldData({ field: TxnField.LocalNumByteSlice, wtype: wtypes.uint64WType }),
  // v4
  ExtraProgramPages: new TxnFieldData({ field: TxnField.ExtraProgramPages, wtype: wtypes.uint64WType }),
  // v5
  Nonparticipation: new TxnFieldData({ field: TxnField.Nonparticipation, wtype: wtypes.boolWType }),
  NumLogs: new TxnFieldData({ field: TxnField.NumLogs, wtype: wtypes.uint64WType, isInnerParam: false }),
  CreatedAssetID: new TxnFieldData({ field: TxnField.CreatedAssetID, wtype: wtypes.assetWType, isInnerParam: false }),
  CreatedApplicationID: new TxnFieldData({ field: TxnField.CreatedApplicationID, wtype: wtypes.applicationWType, isInnerParam: false }),
  // v6
  LastLog: new TxnFieldData({ field: TxnField.LastLog, wtype: wtypes.bytesWType, isInnerParam: false }),
  StateProofPK: new TxnFieldData({ field: TxnField.StateProofPK, wtype: wtypes.bytesWType }),
  // v7
  NumApprovalProgramPages: new TxnFieldData({ field: TxnField.NumApprovalProgramPages, wtype: wtypes.uint64WType, isInnerParam: false }),
  NumClearStateProgramPages: new TxnFieldData({
    field: TxnField.NumClearStateProgramPages,
    wtype: wtypes.uint64WType,
    isInnerParam: false,
  }),
  // array fields
  // TODO: allow configuring as these are consensus values
  // v2
  ApplicationArgs: new TxnFieldData({ field: TxnField.ApplicationArgs, wtype: wtypes.bytesWType, numValues: 16 }),
  Accounts: new TxnFieldData({ field: TxnField.Accounts, wtype: wtypes.accountWType, numValues: 4 }),
  // v3
  Assets: new TxnFieldData({ field: TxnField.Assets, wtype: wtypes.assetWType, numValues: 8 }),
  Applications: new TxnFieldData({ field: TxnField.Applications, wtype: wtypes.applicationWType, numValues: 8 }),
  // v5
  Logs: new TxnFieldData({ field: TxnField.Logs, wtype: wtypes.bytesWType, numValues: 32, isInnerParam: false }),
  // v7
  ApprovalProgramPages: new TxnFieldData({
    field: TxnField.ApprovalProgramPages,
    wtype: wtypes.bytesWType,
    numValues: 4,
    arrayPromote: true,
  }),
  ClearStateProgramPages: new TxnFieldData({
    field: TxnField.ClearStateProgramPages,
    wtype: wtypes.bytesWType,
    numValues: 4,
    arrayPromote: true,
  }),
}



================================================
FILE: src/awst/util.ts
================================================
import type { Constant, Expression } from './nodes'
import { AddressConstant, BoolConstant, BytesConstant, DecimalConstant, IntegerConstant, MethodConstant, StringConstant } from './nodes'

export function isConstant(expr: Expression): expr is Constant {
  return (
    expr instanceof StringConstant ||
    expr instanceof BytesConstant ||
    expr instanceof IntegerConstant ||
    expr instanceof BoolConstant ||
    expr instanceof AddressConstant ||
    expr instanceof MethodConstant ||
    expr instanceof DecimalConstant
  )
}

export class SymbolToNumber {
  #symbols = new Map<symbol, number>()

  forSymbol(sym: symbol): [number, boolean] {
    let val = this.#symbols.get(sym)
    if (val !== undefined) {
      return [val, false]
    }
    val = this.#symbols.size
    this.#symbols.set(sym, val)
    return [val, true]
  }
}



================================================
FILE: src/awst/wtypes.ts
================================================
import { invariant } from '../util'
import { TransactionKind } from './models'
import type { SourceLocation } from './source-location'

export enum AVMType {
  bytes = 1 << 0,
  uint64 = 1 << 1,
  any = AVMType.bytes | AVMType.uint64,
}

// eslint-disable-next-line @typescript-eslint/no-namespace
export namespace wtypes {
  export class WType {
    constructor(props: { name: string; immutable?: boolean; scalarType: AVMType | null; ephemeral?: boolean }) {
      this.name = props.name
      this.immutable = props.immutable ?? true
      this.scalarType = props.scalarType
      this.ephemeral = props.ephemeral ?? false
    }

    readonly name: string
    readonly immutable: boolean
    /**
     * ephemeral types are not suitable for naive storage / persistence,
     *      even if their underlying type is a simple stack value
     */
    readonly ephemeral: boolean
    /**
     * The AVM stack type of this type (if any)
     */
    readonly scalarType: AVMType | null

    equals(other: WType): boolean {
      return other instanceof this.constructor && other.name === this.name
    }

    toString(): string {
      return this.name
    }

    get id() {
      return this.name
    }
  }

  export const voidWType = new WType({
    name: 'void',
    scalarType: null,
  })
  export const boolWType = new WType({
    name: 'bool',
    scalarType: AVMType.uint64,
  })
  export const uint64WType = new WType({
    name: 'uint64',
    scalarType: AVMType.uint64,
  })
  export const uint64RangeWType = new WType({
    name: 'uint64_range',
    scalarType: null,
    immutable: true,
  })
  export const bytesWType = new WType({
    name: 'bytes',
    scalarType: AVMType.bytes,
  })
  export const stateKeyWType = new WType({
    name: 'state_key',
    scalarType: AVMType.bytes,
  })
  export const boxKeyWType = new WType({
    name: 'box_key',
    scalarType: AVMType.bytes,
  })
  export const stringWType = new WType({
    name: 'string',
    scalarType: AVMType.bytes,
  })
  export const biguintWType = new WType({
    name: 'biguint',
    scalarType: AVMType.bytes,
  })
  export const assetWType = new WType({
    name: 'asset',
    scalarType: AVMType.uint64,
  })

  export const accountWType = new WType({
    name: 'account',
    scalarType: AVMType.bytes,
  })
  export const applicationWType = new WType({
    name: 'application',
    scalarType: AVMType.uint64,
  })

  export class ARC4Type extends WType {
    readonly nativeType: WType | null
    readonly arc4Name: string
    constructor({
      nativeType,
      arc4Name,
      ...rest
    }: {
      nativeType: WType | null
      arc4Name: string
      name: string
      immutable?: boolean
      scalarType?: AVMType | null
      ephemeral?: boolean
    }) {
      super({ ...rest, scalarType: rest.scalarType ?? AVMType.bytes })
      this.arc4Name = arc4Name
      this.nativeType = nativeType
    }
  }

  export class WStructType extends WType {
    fields: Record<string, WType>
    readonly frozen = true

    constructor({ fields, name }: { fields: Record<string, WType>; name: string }) {
      super({
        name,
        scalarType: null,
        immutable: true,
      })
      this.fields = fields
    }
  }

  export class WTuple extends WType {
    types: WType[]
    names: string[] | undefined
    constructor(props: { names?: string[]; types: WType[]; immutable?: boolean; name?: string }) {
      super({
        name: props.name ?? 'tuple',
        scalarType: null,
        immutable: props.immutable ?? true,
      })
      invariant(props.types.length, 'Tuple length cannot be zero')
      this.types = props.types
      if (props.names) {
        invariant(props.names.length === props.types.length, 'If names is provided, length must match types')
        this.names = props.names
      }
    }

    equals(other: WType): boolean {
      if (other instanceof WTuple) {
        return (
          this.name === other.name &&
          this.types.every((t, i) => t.equals(other.types[i])) &&
          (this.names?.every((n, i) => n === other.names?.[i]) ?? this.names === other.names)
        )
      }
      return false
    }

    toString(): string {
      const displayName = this.name.split('::').at(-1) ?? this.name
      if (this.names) {
        return `${displayName}{ ${this.names.map((n, i) => `${n}: ${this.types[i]}`).join(', ')} }`
      }
      return `${this.immutable ? 'readonly' : ''}${displayName}[${this.types.join(', ')}]`
    }
  }
  export abstract class NativeArray extends WType {
    readonly elementType: WType
    readonly sourceLocation: SourceLocation | null
    protected constructor(props: { name: string; itemType: WType; sourceLocation?: SourceLocation; scalarType?: AVMType }) {
      super({
        name: props.name,
        scalarType: props.scalarType ?? null,
      })
      this.elementType = props.itemType
      this.sourceLocation = props.sourceLocation ?? null
    }
  }

  export class StackArray extends NativeArray {
    readonly immutable = true
    constructor(props: { itemType: WType; immutable: boolean; sourceLocation?: SourceLocation }) {
      super({
        name: `stack_array<${props.itemType.name}>`,
        scalarType: AVMType.bytes,
        ...props,
      })
    }
  }
  export class ReferenceArray extends NativeArray {
    readonly immutable = false
    constructor(props: { itemType: WType; immutable: boolean; sourceLocation?: SourceLocation }) {
      super({
        name: `ref_array<${props.itemType.name}>`,
        ...props,
      })
    }
  }

  export class WEnumeration extends WType {
    readonly sequenceType: WType
    constructor(props: { sequenceType: WType }) {
      super({
        name: `enumeration<${props.sequenceType.name}>`,
        scalarType: null,
        immutable: true,
      })
      this.sequenceType = props.sequenceType
    }
  }
  export class WGroupTransaction extends WType {
    transactionType: TransactionKind | null
    arc4Name: string
    constructor({ transactionType }: { transactionType?: TransactionKind }) {
      super({
        scalarType: AVMType.uint64,
        name: transactionType === undefined ? 'group_transaction' : `group_transaction_${TransactionKind[transactionType]}`,
      })
      this.transactionType = transactionType ?? null
      this.arc4Name = transactionType ? TransactionKind[transactionType] : 'txn'
    }
  }
  export class WInnerTransaction extends WType {
    transactionType: TransactionKind | null
    constructor({ transactionType }: { transactionType?: TransactionKind }) {
      super({
        scalarType: null,
        name: transactionType === undefined ? 'inner_transaction' : `inner_transaction_${TransactionKind[transactionType]}`,
      })
      this.transactionType = transactionType ?? null
    }
  }
  export class WInnerTransactionFields extends WType {
    transactionType: TransactionKind | null
    constructor({ transactionType }: { transactionType?: TransactionKind }) {
      super({
        scalarType: null,
        name: transactionType === undefined ? 'inner_transaction_fields' : `inner_transaction_fields_${TransactionKind[transactionType]}`,
      })
      this.transactionType = transactionType ?? null
    }
  }

  export class ARC4UIntN extends ARC4Type {
    readonly n: bigint
    constructor({ n, arc4Name }: { n: bigint; arc4Name?: string }) {
      super({
        name: arc4Name ? `arc4.${arc4Name}` : `arc4.uint${n}`,
        scalarType: AVMType.bytes,
        nativeType: n <= 64 ? uint64WType : biguintWType,
        arc4Name: arc4Name ?? `uint${n}`,
      })
      invariant(n >= 8n && n <= 512n, 'Invalid uint: n must be between 8 and 512')
      invariant(n % 8n === 0n, 'Invalid uint: n must be multiple of 8')
      this.n = n
    }
  }

  export class ARC4UFixedNxM extends ARC4Type {
    readonly n: bigint
    readonly m: bigint
    constructor({ n, m }: { n: bigint; m: bigint }) {
      super({
        name: `arc4.ufixed${n}x${m}`,
        scalarType: AVMType.bytes,
        nativeType: n <= 64 ? uint64WType : biguintWType,
        arc4Name: `ufixed${n}x${m}`,
      })

      invariant(n >= 8n && n <= 512n, 'Invalid ufixed: n must be between 8 and 512')
      invariant(n % 8n === 0n, 'Invalid ufixed: n must be multiple of 8')
      invariant(m >= 0n && m <= 160n, 'Invalid ufixed: m must be between 0 and 160')
      this.n = n
      this.m = m
    }
  }

  export class ARC4Struct extends ARC4Type {
    fields: Record<string, ARC4Type>
    sourceLocation: SourceLocation | null
    frozen: boolean
    desc: string | null

    constructor({
      fields,
      sourceLocation,
      name,
      desc,
      frozen,
    }: {
      frozen: boolean
      name: string
      desc: string | null
      fields: Record<string, ARC4Type>
      sourceLocation?: SourceLocation
    }) {
      super({
        arc4Name: `(${Object.values(fields)
          .map((f) => f.arc4Name)
          .join(',')})`,
        name,
        nativeType: null,
        immutable: frozen && Object.values(fields).every((t) => t.immutable),
      })
      this.sourceLocation = sourceLocation ?? null
      this.fields = fields
      this.frozen = frozen
      this.desc = desc
    }

    toString(): string {
      if (!this.name) return this.arc4Name
      return super.toString()
    }
  }
  export class ARC4Tuple extends ARC4Type {
    readonly types: ARC4Type[]
    readonly sourceLocation: SourceLocation | null

    constructor({ types, sourceLocation }: { types: ARC4Type[]; sourceLocation?: SourceLocation }) {
      const typesStr = types.map((t) => t.arc4Name).join(',')
      super({
        name: `arc4.tuple<${typesStr}>`,
        arc4Name: `(${typesStr})`,
        nativeType: null,
      })
      this.sourceLocation = sourceLocation ?? null
      this.types = types
    }
  }

  export abstract class ARC4Array extends ARC4Type {
    readonly elementType: ARC4Type
    protected constructor(props: {
      arc4Name: string
      otherEncodeableTypes: WType[]
      name: string
      elementType: ARC4Type
      nativeType?: WType
      immutable?: boolean
    }) {
      super({ ...props, scalarType: AVMType.bytes, immutable: props.immutable ?? false, nativeType: props.nativeType ?? null })
      this.elementType = props.elementType
    }
  }

  export class ARC4DynamicArray extends ARC4Array {
    readonly sourceLocation: SourceLocation | null
    constructor({
      elementType,
      sourceLocation,
      arc4Name,
      nativeType,
      immutable,
    }: {
      elementType: ARC4Type
      sourceLocation?: SourceLocation
      arc4Name?: string
      nativeType?: WType
      immutable?: boolean
    }) {
      super({
        elementType,
        name: `arc4.dynamic_array<${elementType.name}>`,
        arc4Name: arc4Name ?? `${elementType.arc4Name}[]`,
        otherEncodeableTypes: [],
        nativeType,
        immutable,
      })
      this.sourceLocation = sourceLocation ?? null
    }
  }
  export class ARC4StaticArray extends ARC4Array {
    readonly sourceLocation: SourceLocation | null
    readonly arraySize: bigint
    constructor({
      elementType,
      sourceLocation,
      arraySize,
      arc4Name,
      nativeType,
      immutable,
    }: {
      arraySize: bigint
      elementType: ARC4Type
      sourceLocation?: SourceLocation
      arc4Name?: string
      nativeType?: WType
      immutable?: boolean
    }) {
      super({
        elementType,
        name: `arc4.static_array<${elementType.name}>`,
        arc4Name: arc4Name ?? `${elementType.arc4Name}[${arraySize}]`,
        nativeType: nativeType,
        otherEncodeableTypes: [],
        immutable,
      })
      this.sourceLocation = sourceLocation ?? null
      this.arraySize = arraySize
    }
  }

  export const arc4ByteAliasWType = new ARC4UIntN({
    n: 8n,
    arc4Name: 'byte',
  })
  export const arc4AddressAliasWType = new ARC4StaticArray({
    arraySize: 32n,
    immutable: true,
    elementType: arc4ByteAliasWType,
    nativeType: accountWType,
    arc4Name: 'address',
  })

  export const arc4BooleanWType = new ARC4Type({
    name: 'arc4.bool',
    arc4Name: 'bool',
    immutable: true,
    nativeType: boolWType,
  })

  export const arc4StringAliasWType = new ARC4DynamicArray({
    arc4Name: 'string',
    elementType: arc4ByteAliasWType,
    nativeType: stringWType,
    immutable: true,
  })
}



================================================
FILE: src/awst/validation/arc4-approval-calls-router.ts
================================================
import { Constants } from '../../constants'
import { logger } from '../../logger'
import type { ARC4Router, AWST, ContractMethod, SubroutineCallExpression } from '../nodes'
import { Contract, InstanceSuperMethodTarget } from '../nodes'
import { FunctionTraverser } from './awst-traverser'

export class Arc4ApprovalCallsRouter extends FunctionTraverser {
  static validate(awst: AWST[]) {
    for (const item of awst) {
      if (item instanceof Contract) {
        if (item.methods.some((m) => m.arc4MethodConfig)) {
          const validator = new Arc4ApprovalCallsRouter()
          validator.validate(item.approvalProgram)
        }
      }
    }
  }

  #superCalled = false
  #routerCalled = false

  validate(approvalProgram: ContractMethod) {
    approvalProgram.body.accept(this)
    if (!this.#superCalled && !this.#routerCalled) {
      logger.warn(
        approvalProgram.sourceLocation,
        'Contract overrides approval program method but does not appear to call super.approvalProgram(). ARC4 routing may not work as expected',
      )
    }
  }

  visitSubroutineCallExpression(expression: SubroutineCallExpression) {
    if (
      expression.target instanceof InstanceSuperMethodTarget &&
      expression.target.memberName === Constants.symbolNames.approvalProgramMethodName
    ) {
      this.#superCalled = true
    }
    super.visitSubroutineCallExpression(expression)
  }

  visitARC4Router(expression: ARC4Router) {
    this.#routerCalled = true
    super.visitARC4Router(expression)
  }
}



================================================
FILE: src/awst/validation/awst-traverser.ts
================================================
import type {
  AddressConstant,
  AppAccountStateExpression,
  AppStateExpression,
  AppStorageDefinition,
  ARC4Decode,
  ARC4Encode,
  ARC4Router,
  ArrayConcat,
  ArrayExtend,
  ArrayLength,
  ArrayPop,
  ArrayReplace,
  AssertExpression,
  AssignmentExpression,
  AssignmentStatement,
  BigUIntAugmentedAssignment,
  BigUIntBinaryOperation,
  BigUIntPostfixUnaryOperation,
  Block,
  BoolConstant,
  BooleanBinaryOperation,
  BoxValueExpression,
  BytesAugmentedAssignment,
  BytesBinaryOperation,
  BytesComparisonExpression,
  BytesConstant,
  BytesUnaryOperation,
  CheckedMaybe,
  CompiledContract,
  CompiledLogicSig,
  ConditionalExpression,
  Contract,
  ContractMemberNodeVisitor,
  ContractMethod,
  Copy,
  CreateInnerTransaction,
  DecimalConstant,
  Emit,
  Enumeration,
  ExpressionStatement,
  ExpressionVisitor,
  FieldExpression,
  ForInLoop,
  Goto,
  GroupTransactionReference,
  IfElse,
  IndexExpression,
  InnerTransactionField,
  IntegerConstant,
  IntersectionSliceExpression,
  IntrinsicCall,
  LogicSignature,
  LoopContinue,
  LoopExit,
  MethodConstant,
  NewArray,
  NewStruct,
  Not,
  NumericComparisonExpression,
  PuyaLibCall,
  Range,
  ReinterpretCast,
  ReturnStatement,
  Reversed,
  RootNodeVisitor,
  SingleEvaluation,
  SliceExpression,
  StateDelete,
  StateExists,
  StateGet,
  StateGetEx,
  StatementVisitor,
  StringConstant,
  SubmitInnerTransaction,
  Subroutine,
  SubroutineCallExpression,
  Switch,
  TemplateVar,
  TupleExpression,
  TupleItemExpression,
  UInt64AugmentedAssignment,
  UInt64BinaryOperation,
  UInt64PostfixUnaryOperation,
  UInt64UnaryOperation,
  UpdateInnerTransaction,
  VarExpression,
  VoidConstant,
  WhileLoop,
} from '../nodes'
import { Expression } from '../nodes'

export class FunctionTraverser implements ExpressionVisitor<void>, StatementVisitor<void> {
  visitExpressionStatement(statement: ExpressionStatement): void {
    statement.expr.accept(this)
  }

  visitBlock(statement: Block): void {
    for (const s of statement.body) {
      s.accept(this)
    }
  }

  visitArrayLength(expression: ArrayLength): void {
    expression.array.accept(this)
  }

  visitArrayReplace(expression: ArrayReplace): void {
    expression.base.accept(this)
    expression.index.accept(this)
    expression.value.accept(this)
  }

  visitGoto(statement: Goto): void {}

  visitIfElse(statement: IfElse): void {
    statement.condition.accept(this)
    statement.ifBranch.accept(this)
    statement.elseBranch?.accept(this)
  }

  visitSwitch(statement: Switch): void {
    statement.value.accept(this)
    for (const [cv, cb] of statement.cases.entries()) {
      cv.accept(this)
      cb.accept(this)
    }
    statement.defaultCase?.accept(this)
  }

  visitWhileLoop(statement: WhileLoop): void {
    statement.condition.accept(this)
    statement.loopBody.accept(this)
  }

  visitLoopExit(statement: LoopExit): void {}

  visitLoopContinue(statement: LoopContinue): void {}

  visitReturnStatement(statement: ReturnStatement): void {
    statement.value?.accept(this)
  }

  visitAssignmentStatement(statement: AssignmentStatement): void {
    statement.target.accept(this)
    statement.value.accept(this)
  }

  visitUInt64AugmentedAssignment(statement: UInt64AugmentedAssignment): void {
    statement.target.accept(this)
    statement.value.accept(this)
  }

  visitBigUIntAugmentedAssignment(statement: BigUIntAugmentedAssignment): void {
    statement.target.accept(this)
    statement.value.accept(this)
  }

  visitBytesAugmentedAssignment(statement: BytesAugmentedAssignment): void {
    statement.target.accept(this)
    statement.value.accept(this)
  }

  visitForInLoop(statement: ForInLoop): void {
    statement.items.accept(this)
    statement.sequence.accept(this)
    statement.loopBody.accept(this)
  }

  visitAssertExpression(expression: AssertExpression): void {
    expression.condition?.accept(this)
  }

  visitIntegerConstant(expression: IntegerConstant): void {}

  visitDecimalConstant(expression: DecimalConstant): void {}

  visitBoolConstant(expression: BoolConstant): void {}

  visitBytesConstant(expression: BytesConstant): void {}

  visitStringConstant(expression: StringConstant): void {}

  visitVoidConstant(expression: VoidConstant): void {}

  visitTemplateVar(expression: TemplateVar): void {}

  visitMethodConstant(expression: MethodConstant): void {}

  visitAddressConstant(expression: AddressConstant): void {}

  visitARC4Encode(expression: ARC4Encode): void {
    expression.value.accept(this)
  }

  visitCopy(expression: Copy): void {
    expression.value.accept(this)
  }

  visitArrayConcat(expression: ArrayConcat): void {
    expression.left.accept(this)
    expression.right.accept(this)
  }

  visitArrayPop(expression: ArrayPop): void {
    expression.base.accept(this)
  }

  visitArrayExtend(expression: ArrayExtend): void {
    expression.base.accept(this)
    expression.other.accept(this)
  }

  visitARC4Decode(expression: ARC4Decode): void {
    expression.value.accept(this)
  }

  visitIntrinsicCall(expression: IntrinsicCall): void {
    for (const a of expression.stackArgs) {
      a.accept(this)
    }
  }

  visitCreateInnerTransaction(expression: CreateInnerTransaction): void {
    for (const v of expression.fields.values()) {
      v.accept(this)
    }
  }

  visitUpdateInnerTransaction(expression: UpdateInnerTransaction): void {
    for (const v of expression.fields.values()) {
      v.accept(this)
    }
  }

  visitGroupTransactionReference(expression: GroupTransactionReference): void {
    expression.index.accept(this)
  }

  visitCheckedMaybe(expression: CheckedMaybe): void {
    expression.expr.accept(this)
  }

  visitTupleExpression(expression: TupleExpression): void {
    for (const v of expression.items) {
      v.accept(this)
    }
  }

  visitTupleItemExpression(expression: TupleItemExpression): void {
    expression.base.accept(this)
  }

  visitVarExpression(expression: VarExpression): void {}

  visitInnerTransactionField(expression: InnerTransactionField): void {
    expression.itxn.accept(this)
    expression.arrayIndex?.accept(this)
  }

  visitSubmitInnerTransaction(expression: SubmitInnerTransaction): void {
    for (const itxn of expression.itxns) {
      itxn.accept(this)
    }
  }

  visitFieldExpression(expression: FieldExpression): void {
    expression.base.accept(this)
  }

  visitIndexExpression(expression: IndexExpression): void {
    expression.base.accept(this)
    expression.index.accept(this)
  }

  visitSliceExpression(expression: SliceExpression): void {
    expression.base.accept(this)
    expression.beginIndex?.accept(this)
    expression.endIndex?.accept(this)
  }

  visitIntersectionSliceExpression(expression: IntersectionSliceExpression): void {
    expression.base.accept(this)
    expression.beginIndex instanceof Expression && expression.beginIndex.accept(this)
    expression.endIndex instanceof Expression && expression.endIndex.accept(this)
  }

  visitAppStateExpression(expression: AppStateExpression): void {
    expression.key.accept(this)
  }

  visitAppAccountStateExpression(expression: AppAccountStateExpression): void {
    expression.key.accept(this)
    expression.account.accept(this)
  }

  visitBoxValueExpression(expression: BoxValueExpression): void {
    expression.key.accept(this)
  }

  visitSingleEvaluation(expression: SingleEvaluation): void {
    expression.source.accept(this)
  }

  visitReinterpretCast(expression: ReinterpretCast): void {
    expression.expr.accept(this)
  }

  visitNewArray(expression: NewArray): void {
    for (const v of expression.values) {
      v.accept(this)
    }
  }

  visitConditionalExpression(expression: ConditionalExpression): void {
    expression.condition.accept(this)
    expression.trueExpr.accept(this)
    expression.falseExpr.accept(this)
  }

  visitAssignmentExpression(expression: AssignmentExpression): void {
    expression.target.accept(this)
    expression.value.accept(this)
  }

  visitNumericComparisonExpression(expression: NumericComparisonExpression): void {
    expression.lhs.accept(this)
    expression.rhs.accept(this)
  }

  visitBytesComparisonExpression(expression: BytesComparisonExpression): void {
    expression.lhs.accept(this)
    expression.rhs.accept(this)
  }

  visitSubroutineCallExpression(expression: SubroutineCallExpression): void {
    for (const a of expression.args) {
      a.value.accept(this)
    }
  }

  visitPuyaLibCall(expression: PuyaLibCall): void {
    for (const a of expression.args) {
      a.value.accept(this)
    }
  }

  visitUInt64UnaryOperation(expression: UInt64UnaryOperation): void {
    expression.expr.accept(this)
  }

  visitUInt64PostfixUnaryOperation(expression: UInt64PostfixUnaryOperation): void {
    expression.target.accept(this)
  }

  visitBigUIntPostfixUnaryOperation(expression: BigUIntPostfixUnaryOperation): void {
    expression.target.accept(this)
  }

  visitBytesUnaryOperation(expression: BytesUnaryOperation): void {
    expression.expr.accept(this)
  }

  visitUInt64BinaryOperation(expression: UInt64BinaryOperation): void {
    expression.left.accept(this)
    expression.right.accept(this)
  }

  visitBigUIntBinaryOperation(expression: BigUIntBinaryOperation): void {
    expression.left.accept(this)
    expression.right.accept(this)
  }

  visitBytesBinaryOperation(expression: BytesBinaryOperation): void {
    expression.left.accept(this)
    expression.right.accept(this)
  }

  visitBooleanBinaryOperation(expression: BooleanBinaryOperation): void {
    expression.left.accept(this)
    expression.right.accept(this)
  }

  visitNot(expression: Not): void {
    expression.expr.accept(this)
  }

  visitEmit(expression: Emit): void {
    expression.value.accept(this)
  }

  visitRange(expression: Range): void {
    expression.start.accept(this)
    expression.stop.accept(this)
    expression.step.accept(this)
  }

  visitEnumeration(expression: Enumeration): void {
    expression.expr.accept(this)
  }

  visitReversed(expression: Reversed): void {
    expression.expr.accept(this)
  }

  visitStateGet(expression: StateGet): void {
    expression.default.accept(this)
    expression.field.accept(this)
  }

  visitStateGetEx(expression: StateGetEx): void {
    expression.field.accept(this)
  }

  visitStateExists(expression: StateExists): void {
    expression.field.accept(this)
  }

  visitStateDelete(expression: StateDelete): void {
    expression.field.accept(this)
  }

  visitNewStruct(expression: NewStruct): void {
    for (const v of expression.values.values()) {
      v.accept(this)
    }
  }

  visitCompiledContract(expression: CompiledContract): void {
    for (const v of expression.templateVariables.values()) {
      v.accept(this)
    }
    for (const v of expression.allocationOverrides.values()) {
      v.accept(this)
    }
  }

  visitCompiledLogicSig(expression: CompiledLogicSig): void {
    for (const v of expression.templateVariables.values()) {
      v.accept(this)
    }
  }

  visitARC4Router(expression: ARC4Router): void {}
}

export class AwstTraverser extends FunctionTraverser implements RootNodeVisitor<void>, ContractMemberNodeVisitor<void> {
  visitContractMethod(contractMemberNode: ContractMethod): void {
    contractMemberNode.body.accept(this)
  }
  visitAppStorageDefinition(contractMemberNode: AppStorageDefinition): void {
    contractMemberNode.key.accept(this)
  }
  visitSubroutine(rootNode: Subroutine): void {
    rootNode.body.accept(this)
  }
  visitLogicSignature(rootNode: LogicSignature): void {
    rootNode.program.accept(this)
  }
  visitContract(rootNode: Contract): void {
    for (const s of rootNode.appState) {
      s.accept(this)
    }
    for (const m of rootNode.methods) {
      m.accept(this)
    }
  }
}



================================================
FILE: src/awst/validation/index.ts
================================================
import type { AWST } from '../nodes'
import { Arc4ApprovalCallsRouter } from './arc4-approval-calls-router'

type ModuleValidator = {
  validate(awst: AWST[]): void
}

const validators: ModuleValidator[] = [Arc4ApprovalCallsRouter]

export function validateAwst(awst: AWST[]): void {
  for (const validator of validators) {
    validator.validate(awst)
  }
}



================================================
FILE: src/awst_build/arc4-util.ts
================================================
import { nodeFactory } from '../awst/node-factory'
import type { ARC4ABIMethodConfig } from '../awst/nodes'
import type { SourceLocation } from '../awst/source-location'
import { wtypes } from '../awst/wtypes'
import { CodeError } from '../errors'
import { codeInvariant } from '../util'
import type { FunctionPType, PType } from './ptypes'
import {
  accountPType,
  applicationPType,
  ArrayPType,
  assetPType,
  biguintPType,
  boolPType,
  bytesPType,
  GroupTransactionPType,
  NativeNumericType,
  numberPType,
  ObjectPType,
  stringPType,
  TuplePType,
  uint64PType,
  voidPType,
} from './ptypes'
import {
  arc4BooleanType,
  ARC4EncodedType,
  arc4StringType,
  ARC4StructType,
  ARC4TupleType,
  DynamicArrayType,
  DynamicBytesType,
  UintNType,
} from './ptypes/arc4-types'

/**
 * For a given ptype, return the equivalent ABI compatible type - or error if there is no compatible type
 * @param ptype The type of the parameter
 * @param direction The direction of the parameter (in for method args, out for method returns)
 * @param sourceLocation The location of the method or parameter, for use in error metadata
 */
export function ptypeToAbiPType(ptype: PType, direction: 'in' | 'out', sourceLocation: SourceLocation): PType {
  if (ptype instanceof ARC4EncodedType) return ptype
  if (ptype instanceof GroupTransactionPType) {
    codeInvariant(direction === 'in', `${ptype.name} cannot be used as an ABI return type`, sourceLocation)
    return ptype
  }
  if (ptype.equals(applicationPType) || ptype.equals(accountPType) || ptype.equals(assetPType)) {
    codeInvariant(direction === 'in', `${ptype.name} cannot be used as an ABI return type`, sourceLocation)
    return ptype
  }
  if (ptype.equals(voidPType)) return voidPType
  if (isArc4EncodableType(ptype)) {
    return ptypeToArc4EncodedType(ptype, sourceLocation)
  }
  throw new CodeError(`${ptype} cannot be used as an ABI ${direction === 'in' ? 'param' : 'return'} type`, { sourceLocation })
}

/**
 * Generate a methodConstant node for the given function, making use of the ARC4ABIMethodConfig
 * @param functionType The function ptype
 * @param arc4Config ARC4 method config
 * @param sourceLocation The source location of the code generating the constant,
 */
export function buildArc4MethodConstant(functionType: FunctionPType, arc4Config: ARC4ABIMethodConfig, sourceLocation: SourceLocation) {
  const params = functionType.parameters.map(([_, ptype]) => getABITypeName(ptype, 'in', sourceLocation)).join(',')
  const returnType = getABITypeName(functionType.returnType, 'out', sourceLocation)
  return nodeFactory.methodConstant({
    value: `${arc4Config.name}(${params})${returnType}`,
    wtype: wtypes.bytesWType,
    sourceLocation,
  })
}

/**
 * Get the ARC4 type name for a ptype, or throw if the ptype is not usable in an ABI method.
 * @param ptype The ptype of the parameter
 * @param direction The direction of the parameter (in for method args, out for method returns)
 * @param sourceLocation The location of the method or parameter, for use in error metadata
 */
export function getABITypeName(ptype: PType, direction: 'in' | 'out', sourceLocation: SourceLocation): string {
  const arc4Type = ptypeToAbiPType(ptype, direction, sourceLocation)
  if (arc4Type.wtype instanceof wtypes.ARC4Type || arc4Type.wtype instanceof wtypes.WGroupTransaction) {
    return arc4Type.wtype.arc4Name
  }
  return arc4Type.wtypeOrThrow.name
}

/**
 * Is the given type an ARC4 encoded type, or can it be encoded to one
 * @param ptype The type to check
 */
export function isArc4EncodableType(ptype: PType): boolean {
  if (ptype instanceof ARC4EncodedType) return true
  if (ptype.equals(boolPType)) return true
  if (ptype.equals(uint64PType)) return true
  if (ptype.equals(biguintPType)) return true
  if (ptype.equals(bytesPType)) return true
  if (ptype.equals(stringPType)) return true
  if (ptype instanceof TuplePType) return ptype.items.every((i) => isArc4EncodableType(i))
  if (ptype instanceof ObjectPType) return ptype.orderedProperties().every(([, pt]) => isArc4EncodableType(pt))
  if (ptype instanceof ArrayPType) return isArc4EncodableType(ptype.elementType)
  return false
}

/**
 * For a given type, return the arc4 encoded version of that type
 * @param ptype The type to be encoded
 * @param sourceLocation The source location triggering the conversion
 */
export function ptypeToArc4EncodedType(ptype: TuplePType, sourceLocation: SourceLocation): ARC4TupleType
export function ptypeToArc4EncodedType(ptype: ObjectPType, sourceLocation: SourceLocation): ARC4StructType
export function ptypeToArc4EncodedType(ptype: ArrayPType, sourceLocation: SourceLocation): DynamicArrayType
export function ptypeToArc4EncodedType<T extends ARC4EncodedType>(ptype: T, sourceLocation: SourceLocation): T
export function ptypeToArc4EncodedType(ptype: PType, sourceLocation: SourceLocation): ARC4EncodedType
export function ptypeToArc4EncodedType(ptype: PType, sourceLocation: SourceLocation): ARC4EncodedType {
  if (ptype instanceof ARC4EncodedType) return ptype
  if (ptype.equals(boolPType)) return arc4BooleanType
  if (ptype.equals(uint64PType)) return new UintNType({ n: 64n })
  if (ptype.equals(biguintPType)) return new UintNType({ n: 512n })
  if (ptype.equals(bytesPType)) return DynamicBytesType
  if (ptype.equals(stringPType)) return arc4StringType
  if (ptype instanceof NativeNumericType) {
    throw new CodeError(numberPType.expressionMessage, { sourceLocation })
  }
  if (ptype instanceof ArrayPType)
    return new DynamicArrayType({
      elementType: ptypeToArc4EncodedType(ptype.elementType, sourceLocation),
      immutable: true,
    })

  if (ptype instanceof TuplePType) return new ARC4TupleType({ types: ptype.items.map((i) => ptypeToArc4EncodedType(i, sourceLocation)) })

  if (ptype instanceof ObjectPType)
    return new ARC4StructType({
      name: ptype.alias?.name ?? ptype.name,
      module: ptype.module,
      description: ptype.description,
      fields: Object.fromEntries(ptype.orderedProperties().map(([p, pt]) => [p, ptypeToArc4EncodedType(pt, sourceLocation)])),
      frozen: true,
    })

  throw new CodeError(`${ptype} cannot be encoded to an ARC4 type`, { sourceLocation })
}



================================================
FILE: src/awst_build/constant-store.ts
================================================
import ts, { SymbolFlags } from 'typescript'
import type { Constant, TemplateVar } from '../awst/nodes'
import type { SourceLocation } from '../awst/source-location'
import { CodeError } from '../errors'
import { logger } from '../logger'
import { hasFlags, invariant } from '../util'

export class ConstantStore {
  #constants = new Map<ts.Symbol, Constant | TemplateVar>()
  #typeChecker: ts.TypeChecker
  constructor(program: ts.Program) {
    this.#typeChecker = program.getTypeChecker()
  }

  tryResolveConstant(node: ts.Identifier) {
    let symbol = this.#typeChecker.resolveName(node.text, node, SymbolFlags.All, true)
    if (!symbol) return undefined
    if (hasFlags(symbol.flags, ts.SymbolFlags.Alias)) {
      symbol = this.#typeChecker.getAliasedSymbol(symbol)
    }
    return this.#constants.get(symbol)
  }

  addConstant(identifier: ts.Identifier, value: Constant | TemplateVar, constantLocation: SourceLocation) {
    const symbol = this.#typeChecker.resolveName(identifier.text, identifier, ts.SymbolFlags.All, false)
    invariant(symbol, 'Constant identifier must resolve to a symbol')

    if (this.#constants.has(symbol)) {
      logger.error(new CodeError(`Duplicate definitions found for constant ${identifier.text}`, { sourceLocation: constantLocation }))
      return
    }
    const exportSymbol = this.#typeChecker.getExportSymbolOfSymbol(symbol)
    this.#constants.set(symbol, value)
    if (exportSymbol !== symbol) this.#constants.set(exportSymbol, value)
  }
}



================================================
FILE: src/awst_build/index.ts
================================================
import { jsonSerializeAwst } from '../awst/json-serialize-awst'
import type { AWST } from '../awst/nodes'
import { ToCodeVisitor } from '../awst/to-code-visitor'
import { logger } from '../logger'
import type { CompileOptions } from '../options'
import type { CreateProgramResult } from '../parser'
import { invariant } from '../util'
import { ArtifactKind, writeArtifact } from '../write-artifact'
import { SourceFileVisitor } from './ast-visitors/source-file-visitor'
import { AwstBuildContext } from './context/awst-build-context'
import { buildLibAwst } from './lib'
import type { CompilationSet } from './models/contract-class-model'

type BuildAwstOptions = Pick<CompileOptions, 'filePaths' | 'outputAwst' | 'outputAwstJson'>

export function buildAwst({ program, sourceFiles }: CreateProgramResult, options: BuildAwstOptions): [AWST[], CompilationSet] {
  return AwstBuildContext.run(program, () => {
    buildLibAwst()
    const moduleAwst: AWST[] = []
    for (const [sourcePath, sourceFile] of Object.entries(sourceFiles)) {
      try {
        AwstBuildContext.current.runInChildContext(() => {
          const visitor = new SourceFileVisitor(sourceFile)
          const algoFile = options.filePaths.find((p) => p.sourceFile === sourcePath)

          const module = visitor.buildModule()

          if (options.outputAwst && algoFile) {
            writeArtifact({
              sourceFile: sourceFile.fileName,
              outDir: algoFile.outDir,
              kind: ArtifactKind.Awst,
              obj: module,
              buildArtifact(module): string {
                const toCode = new ToCodeVisitor()
                return module.flatMap((s) => s.accept(toCode)).join('\n')
              },
            })
          }
          if (options.outputAwstJson && algoFile) {
            writeArtifact({
              sourceFile: sourceFile.fileName,
              outDir: algoFile.outDir,
              kind: ArtifactKind.AwstJson,
              obj: module,
              buildArtifact(module): string {
                return jsonSerializeAwst(module)
              },
            })
          }
          moduleAwst.push(...module)
        })
      } catch (e) {
        invariant(e instanceof Error, 'Only errors should be thrown')
        logger.error(e)
      }
    }
    return [moduleAwst, AwstBuildContext.current.compilationSet]
  })
}



================================================
FILE: src/awst_build/symbol-name.ts
================================================
export class SymbolName {
  public readonly module: string
  public readonly name: string

  constructor(props: { module: string; name: string }) {
    this.module = props.module
    this.name = props.name
  }

  get fullName() {
    return `${this.module}::${this.name}`
  }

  toString() {
    return this.fullName
  }
}



================================================
FILE: src/awst_build/txn-fields.ts
================================================
import { TransactionKind } from '../awst/models'
import { TxnField } from '../awst/txn-fields'
import type { DeliberateAny } from '../typescript-helpers'
import type { PType } from './ptypes'
import {
  accountPType,
  applicationPType,
  assetPType,
  boolPType,
  bytesPType,
  onCompleteActionType,
  transactionTypeType,
  uint64PType,
} from './ptypes'

export type TxnFieldMetaData = {
  /**
   * The awst field enum for this field
   */
  field: TxnField
  /**
   * The ptype for this field, (or one unit of this field if it's an array)
   */
  ptype: PType
  /**
   * Comments for jsdoc
   */
  comment: string | string[]
  /**
   * This field can be read but not set
   */
  computed?: boolean
  /**
   * This field is an indexable collection
   */
  indexable?: boolean
  /**
   * When receiving a value for this field, automatically convert single values into arrays
   */
  arrayPromote?: boolean
}
export type TxnFieldsMetaData = Record<string, TxnFieldMetaData>

const baseTxnFields = {
  sender: { field: TxnField.Sender, ptype: accountPType, comment: '32 byte address' },
  fee: { field: TxnField.Fee, ptype: uint64PType, comment: 'microalgos' },
  firstValid: { field: TxnField.FirstValid, ptype: uint64PType, comment: 'round number' },
  firstValidTime: {
    field: TxnField.FirstValidTime,
    ptype: uint64PType,
    comment: 'UNIX timestamp of block before txn.FirstValid. Fails if negative',
  },
  lastValid: { field: TxnField.LastValid, ptype: uint64PType, comment: 'round number' },
  note: { field: TxnField.Note, ptype: bytesPType, comment: 'Any data up to 1024 bytes' },
  lease: { field: TxnField.Lease, ptype: bytesPType, comment: '32 byte lease value' },
  typeBytes: { field: TxnField.Type, ptype: bytesPType, comment: 'Transaction type as bytes', computed: true },
  type: { field: TxnField.TypeEnum, ptype: transactionTypeType.memberType, comment: 'Transaction type', computed: true },
  groupIndex: {
    field: TxnField.GroupIndex,
    ptype: uint64PType,
    comment: ['Position of this transaction within an atomic group', 'A stand-alone transaction is implicitly element 0 in a group of 1'],
    computed: true,
  },
  txnId: { field: TxnField.TxID, ptype: bytesPType, comment: 'The computed ID for this transaction. 32 bytes.', computed: true },
  rekeyTo: { field: TxnField.RekeyTo, ptype: accountPType, comment: "32 byte Sender's new AuthAddr" },
} satisfies TxnFieldsMetaData

export const paymentTxnFields = {
  ...baseTxnFields,
  receiver: { field: TxnField.Receiver, ptype: accountPType, comment: '32 byte address' },
  amount: { field: TxnField.Amount, ptype: uint64PType, comment: 'microalgos' },
  closeRemainderTo: { field: TxnField.CloseRemainderTo, ptype: accountPType, comment: '32 byte address' },
} satisfies TxnFieldsMetaData

export const keyRegistrationTxnFields = {
  ...baseTxnFields,
  voteKey: { field: TxnField.VotePK, ptype: bytesPType, comment: '32 byte address' },
  selectionKey: { field: TxnField.SelectionPK, ptype: bytesPType, comment: '32 byte address' },
  voteFirst: { field: TxnField.VoteFirst, ptype: uint64PType, comment: 'The first round that the participation key is valid.' },
  voteLast: { field: TxnField.VoteLast, ptype: uint64PType, comment: 'The last round that the participation key is valid.' },
  voteKeyDilution: { field: TxnField.VoteKeyDilution, ptype: uint64PType, comment: 'Dilution for the 2-level participation key' },
  nonparticipation: { field: TxnField.Nonparticipation, ptype: boolPType, comment: 'Marks an account nonparticipating for rewards' },
  stateProofKey: { field: TxnField.StateProofPK, ptype: bytesPType, comment: '64 byte state proof public key' },
} satisfies TxnFieldsMetaData

export const assetConfigTxnFields = {
  ...baseTxnFields,
  configAsset: { field: TxnField.ConfigAsset, ptype: assetPType, comment: 'Asset ID in asset config transaction' },
  createdAsset: { field: TxnField.CreatedAssetID, ptype: assetPType, comment: 'The asset created by this transaction', computed: true },
  total: { field: TxnField.ConfigAssetTotal, ptype: uint64PType, comment: 'Total number of units of this asset created' },
  decimals: {
    field: TxnField.ConfigAssetDecimals,
    ptype: uint64PType,
    comment: 'Number of digits to display after the decimal place when displaying the asset',
  },
  defaultFrozen: {
    field: TxnField.ConfigAssetDefaultFrozen,
    ptype: boolPType,
    comment: "Whether the asset's slots are frozen by default or not, 0 or 1",
  },
  unitName: { field: TxnField.ConfigAssetUnitName, ptype: bytesPType, comment: 'Unit name of the asset' },
  assetName: { field: TxnField.ConfigAssetName, ptype: bytesPType, comment: 'The asset name' },
  url: { field: TxnField.ConfigAssetURL, ptype: bytesPType, comment: 'URL' },
  metadataHash: { field: TxnField.ConfigAssetMetadataHash, ptype: bytesPType, comment: '32 byte commitment to unspecified asset metadata' },
  manager: { field: TxnField.ConfigAssetManager, ptype: accountPType, comment: '32 byte address' },
  reserve: { field: TxnField.ConfigAssetReserve, ptype: accountPType, comment: '32 byte address' },
  freeze: { field: TxnField.ConfigAssetFreeze, ptype: accountPType, comment: '32 byte address' },
  clawback: { field: TxnField.ConfigAssetClawback, ptype: accountPType, comment: '32 byte address' },
} satisfies TxnFieldsMetaData

export const assetTransferTxnFields = {
  ...baseTxnFields,
  xferAsset: { field: TxnField.XferAsset, ptype: assetPType, comment: 'Asset ID' },
  assetAmount: { field: TxnField.AssetAmount, ptype: uint64PType, comment: "value in Asset's units" },
  assetSender: {
    field: TxnField.AssetSender,
    ptype: accountPType,
    comment: "32 byte address. Source of assets if Sender is the Asset's Clawback address.",
  },
  assetReceiver: { field: TxnField.AssetReceiver, ptype: accountPType, comment: '32 byte address' },
  assetCloseTo: { field: TxnField.AssetCloseTo, ptype: accountPType, comment: '32 byte address' },
} satisfies TxnFieldsMetaData

export const assetFreezeTxnFields = {
  ...baseTxnFields,
  freezeAsset: { field: TxnField.FreezeAsset, ptype: assetPType, comment: 'Asset ID being frozen or un-frozen' },
  freezeAccount: {
    field: TxnField.FreezeAssetAccount,
    ptype: accountPType,
    comment: '32 byte address of the account whose asset slot is being frozen or un-frozen',
  },
  frozen: { field: TxnField.FreezeAssetFrozen, ptype: boolPType, comment: 'The new frozen value' },
} satisfies TxnFieldsMetaData

export const applicationCallTxnFields = {
  ...baseTxnFields,
  appId: { field: TxnField.ApplicationID, ptype: applicationPType, comment: 'ApplicationID from ApplicationCall transaction' },
  onCompletion: {
    field: TxnField.OnCompletion,
    ptype: onCompleteActionType.memberType,
    comment: 'ApplicationCall transaction on completion action',
  },
  numAppArgs: { field: TxnField.NumAppArgs, ptype: uint64PType, comment: 'Number of ApplicationArgs', computed: true },
  numAccounts: { field: TxnField.NumAccounts, ptype: uint64PType, comment: 'Number of ApplicationArgs', computed: true },
  approvalProgram: {
    field: TxnField.ApprovalProgramPages,
    ptype: bytesPType,
    comment: 'The first page of the Approval program',
    computed: true,
  },
  clearStateProgram: {
    field: TxnField.ClearStateProgramPages,
    ptype: bytesPType,
    comment: 'The first page of the Clear State program',
    computed: true,
  },
  numAssets: { field: TxnField.NumAssets, ptype: uint64PType, comment: 'Number of Assets', computed: true },
  numApps: { field: TxnField.NumApplications, ptype: uint64PType, comment: 'Number of Applications', computed: true },
  globalNumUint: {
    field: TxnField.GlobalNumUint,
    ptype: uint64PType,
    comment: 'Number of global state integers this application makes use of.',
  },
  globalNumBytes: {
    field: TxnField.GlobalNumByteSlice,
    ptype: uint64PType,
    comment: 'Number of global state byteslices this application makes use of.',
  },
  localNumUint: {
    field: TxnField.LocalNumUint,
    ptype: uint64PType,
    comment: 'Number of local state integers this application makes use of.',
  },
  localNumBytes: {
    field: TxnField.LocalNumByteSlice,
    ptype: uint64PType,
    comment: 'Number of local state byteslices this application makes use of.',
  },
  extraProgramPages: {
    field: TxnField.ExtraProgramPages,
    ptype: uint64PType,
    comment: "Number of additional pages for each of the application's approval and clear state program",
  },
  lastLog: {
    field: TxnField.LastLog,
    ptype: bytesPType,
    comment: 'The last message emitted. Empty bytes if none were emitted. App mode only',
    computed: true,
  },
  logs: {
    field: TxnField.Logs,
    ptype: bytesPType,
    comment: ['Read application logs', '@param index Index of the log to get'],
    indexable: true,
    computed: true,
  },
  numApprovalProgramPages: {
    field: TxnField.NumApprovalProgramPages,
    ptype: uint64PType,
    comment: 'Number of Approval Program pages',
    computed: true,
  },
  approvalProgramPages: {
    field: TxnField.ApprovalProgramPages,
    ptype: bytesPType,
    comment: ['All approval program pages', '@param index Index of the page to get'],
    indexable: true,
    arrayPromote: true,
  },
  numClearStateProgramPages: {
    field: TxnField.NumClearStateProgramPages,
    ptype: uint64PType,
    comment: 'Number of Clear State Program pages',
    computed: true,
  },
  clearStateProgramPages: {
    field: TxnField.ClearStateProgramPages,
    ptype: bytesPType,
    comment: ['All clear state program pages', '@param index Index of the page to get'],
    indexable: true,
    arrayPromote: true,
  },
  appArgs: {
    field: TxnField.ApplicationArgs,
    ptype: bytesPType,
    comment: ['Arguments passed to the application in the ApplicationCall transaction', '@param index Index of the arg to get'],
    indexable: true,
  },
  accounts: {
    field: TxnField.Accounts,
    ptype: accountPType,
    comment: ['Accounts listed in the ApplicationCall transaction', '@param index Index of the account to get'],
    indexable: true,
  },
  assets: {
    field: TxnField.Assets,
    ptype: assetPType,
    comment: ['Foreign Assets listed in the ApplicationCall transaction', '@param index Index of the asset to get'],
    indexable: true,
  },
  apps: {
    field: TxnField.Applications,
    ptype: applicationPType,
    comment: ['Foreign Apps listed in the ApplicationCall transaction', '@param index Index of the application to get'],
    indexable: true,
  },
  createdApp: {
    field: TxnField.CreatedApplicationID,
    ptype: applicationPType,
    comment: 'The id of the created application',
    computed: true,
  },

  /**
   * Number of logs
   */
  numLogs: { field: TxnField.NumLogs, ptype: uint64PType, comment: 'Number of logs', computed: true },
} satisfies TxnFieldsMetaData

export const anyTxnFields = {
  ...paymentTxnFields,
  ...keyRegistrationTxnFields,
  ...assetConfigTxnFields,
  ...assetTransferTxnFields,
  ...assetFreezeTxnFields,
  ...applicationCallTxnFields,
} satisfies TxnFieldsMetaData

export const txnKindToFields = {
  [TransactionKind.pay]: paymentTxnFields,
  [TransactionKind.keyreg]: keyRegistrationTxnFields,
  [TransactionKind.acfg]: assetConfigTxnFields,
  [TransactionKind.axfer]: assetTransferTxnFields,
  [TransactionKind.afrz]: assetFreezeTxnFields,
  [TransactionKind.appl]: applicationCallTxnFields,
}

type TxnFieldName = keyof typeof anyTxnFields
export const txnFieldName = new Proxy<Record<TxnFieldName, TxnFieldName>>({} as DeliberateAny, {
  get(_, prop) {
    if (prop in anyTxnFields) return prop
    return Reflect.get(_, prop)
  },
})



================================================
FILE: src/awst_build/type-registry.ts
================================================
import type { awst } from '../awst'
import type { SourceLocation } from '../awst/source-location'
import { CodeError, InternalError, throwError } from '../errors'
import type { DeliberateAny } from '../typescript-helpers'
import type { InstanceBuilder, InstanceExpressionBuilder, NodeBuilder } from './eb'

import type { GenericPType } from './ptypes'
import { PType } from './ptypes'
import type { SymbolName } from './symbol-name'

type ValueExpressionBuilderCtor<TPType extends PType> = { new (expr: awst.Expression, ptype: PType): InstanceExpressionBuilder<TPType> }
type SingletonExpressionBuilderCtor = { new (sourceLocation: SourceLocation, ptype: PType): NodeBuilder }

type PTypeClass<T extends PType = PType> = { new (...args: DeliberateAny): T }

export class TypeRegistry {
  get hasRegistrations() {
    return this.types.size > 0 || this.genericTypes.size > 0
  }

  private readonly singletonEbs: Map<PType | PTypeClass, SingletonExpressionBuilderCtor> = new Map()
  private readonly instanceEbs: Map<PType | PTypeClass, ValueExpressionBuilderCtor<PType>> = new Map()
  private readonly types: Set<PType | PTypeClass> = new Set()
  private readonly genericTypes: Set<GenericPType<PType>> = new Set()

  register({
    ptype,
    singletonEb,
    instanceEb,
  }:
    | {
        ptype: PType | PTypeClass
        singletonEb: SingletonExpressionBuilderCtor
        instanceEb?: undefined
      }
    | {
        ptype: PType | PTypeClass
        singletonEb?: undefined
        instanceEb: ValueExpressionBuilderCtor<PType>
      }) {
    if (this.types.has(ptype) || this.genericTypes.has(ptype as GenericPType))
      throw new InternalError(`${ptype} has already been registered`)
    this.types.add(ptype)
    if (singletonEb) {
      this.singletonEbs.set(ptype, singletonEb)
    }
    if (instanceEb) {
      this.instanceEbs.set(ptype, instanceEb)
    }
  }
  registerGeneric<T extends PType>({
    generic,
    ptype,
    instanceEb,
  }: {
    generic: GenericPType<T>
    ptype: PTypeClass<T>
    instanceEb: ValueExpressionBuilderCtor<PType>
  }) {
    if (this.genericTypes.has(generic) || this.types.has(ptype)) throw new InternalError(`${ptype} has already been registered`)
    this.genericTypes.add(generic)
    this.instanceEbs.set(ptype, instanceEb)
  }

  /**
   * Try to resolve a symbol name to a singleton ptype
   * @param symbolName The name of the symbol
   */
  tryResolveSingletonName(symbolName: SymbolName): PType | undefined {
    for (const v of this.singletonEbs.keys()) if (v instanceof PType && v.fullName === symbolName.fullName) return v
    return undefined
  }

  /**
   * Try to resolve a symbol name to an instance ptype
   * @param symbolName The name of the symbol
   */
  tryResolveInstancePType(symbolName: SymbolName): PType | undefined {
    for (const v of this.instanceEbs.keys()) {
      if (v instanceof PType && v.fullName === symbolName.fullName) return v
    }
    return undefined
  }

  resolveInstancePType(symbolName: SymbolName, sourceLocation: SourceLocation): PType {
    const ptype = this.tryResolveInstancePType(symbolName)
    if (!ptype) {
      if (symbolName.module.startsWith('typescript/lib')) {
        throw new CodeError(`${symbolName} type is not supported`, { sourceLocation })
      }
      throw new InternalError(`Cannot resolve ptype for symbol ${symbolName}`, {
        sourceLocation,
      })
    }
    return ptype
  }

  tryGetSingletonEb(ptype: PType, sourceLocation: SourceLocation): NodeBuilder | undefined {
    const eb = this.singletonEbs.get(ptype)
    if (eb) {
      return new eb(sourceLocation, ptype)
    }
    for (const [pt, eb] of this.singletonEbs.entries()) {
      if (typeof pt === 'function' && ptype instanceof pt) {
        return new eb(sourceLocation, ptype)
      }
    }

    return undefined
  }

  getSingletonEb(ptype: PType, sourceLocation: SourceLocation): NodeBuilder {
    return (
      this.tryGetSingletonEb(ptype, sourceLocation) ??
      throwError(
        new InternalError(`No singleton eb registered for ${ptype}`, {
          sourceLocation,
        }),
      )
    )
  }
  getInstanceEb(expression: awst.Expression, ptype: PType): InstanceBuilder {
    return (
      this.tryGetInstanceEb(expression, ptype) ??
      throwError(
        new InternalError(`No InstanceBuilder registered for ${ptype}`, {
          sourceLocation: expression.sourceLocation,
        }),
      )
    )
  }
  tryGetInstanceEb(expression: awst.Expression, ptype: PType): InstanceBuilder | undefined {
    const eb = this.instanceEbs.get(ptype)
    if (eb) {
      return new eb(expression, ptype)
    }
    for (const [pt, eb] of this.instanceEbs.entries()) {
      if (typeof pt === 'function' && ptype instanceof pt) {
        return new eb(expression, ptype)
      }
    }
    return undefined
  }

  resolveGenericPType(symbolName: SymbolName, typeArgs: PType[], sourceLocation: SourceLocation) {
    const genericType = this.tryResolveGenericPType(symbolName, typeArgs)
    if (genericType) return genericType
    throw new CodeError(`${symbolName} could not be resolved to a generic type`, { sourceLocation })
  }
  tryResolveGenericPType(symbolName: SymbolName, typeArgs: PType[]): PType | undefined {
    for (const pt of this.genericTypes.values()) {
      if (pt.fullName === symbolName.fullName) {
        return pt.parameterise(typeArgs)
      }
    }
    return undefined
  }
}
export const typeRegistry = new TypeRegistry()

export function instanceEb(expr: awst.Expression, ptype: PType) {
  return typeRegistry.getInstanceEb(expr, ptype)
}



================================================
FILE: src/awst_build/type-resolver.ts
================================================
import ts, { ObjectFlags } from 'typescript'
import { SourceLocation } from '../awst/source-location'
import { Constants } from '../constants'
import { CodeError, InternalError } from '../errors'
import { logger } from '../logger'
import { codeInvariant, hasFlags, intersectsFlags, invariant, isIn, normalisePath } from '../util'
import { getNodeName } from '../visitor/syntax-names'
import type { AppStorageType, PType } from './ptypes'
import {
  anyGtxnType,
  anyPType,
  ApprovalProgram,
  arc4BaseContractType,
  ArrayPType,
  baseContractType,
  BigIntLiteralPType,
  bigIntPType,
  boolPType,
  ClearStateProgram,
  ClusteredContractClassType,
  ClusteredPrototype,
  ContractClassPType,
  FunctionPType,
  gtxnUnion,
  IntersectionPType,
  logicSigBaseType,
  LogicSigPType,
  NamespacePType,
  neverPType,
  nullPType,
  numberPType,
  NumericLiteralPType,
  ObjectPType,
  StorageProxyPType,
  stringPType,
  SuperPrototypeSelector,
  TuplePType,
  TypeParameterType,
  undefinedPType,
  UnionPType,
  unknownPType,
  voidPType,
} from './ptypes'
import { ARC4EncodedType, arc4StructBaseType, ARC4StructClass, ARC4StructType, UintNType } from './ptypes/arc4-types'
import { SymbolName } from './symbol-name'
import { typeRegistry } from './type-registry'

export class TypeResolver {
  constructor(
    private readonly checker: ts.TypeChecker,
    private readonly programDirectory: string,
  ) {}

  private getUnaliasedSymbolForNode(node: ts.Node) {
    const symbol = this.checker.getSymbolAtLocation(node)
    if (symbol) {
      if (hasFlags(symbol.flags, ts.SymbolFlags.Alias)) {
        return this.checker.getAliasedSymbol(symbol)
      }
      return symbol
    }
    return undefined
  }

  resolveTypeParameters(node: ts.CallExpression | ts.NewExpression, sourceLocation: SourceLocation) {
    if (node.typeArguments) {
      // Explicit type arguments
      return node.typeArguments.map((t) => this.resolveTypeNode(t, sourceLocation))
    }
    const sig = this.checker.getResolvedSignature(node)
    invariant(sig, 'CallExpression must resolve to a signature')
    /*
      The method getTypeArgumentsForResolvedSignature has not made it into typescript yet, but it has been
      proposed here: https://github.com/microsoft/TypeScript/issues/59637 and added to the backlog. For now
      the method has been patched into the TypeScript 5.7.2 using patch-package
     */
    const tps = this.checker.getTypeArgumentsForResolvedSignature(sig)
    return tps?.map((t) => this.resolveType(t, sourceLocation)) ?? []
  }

  resolve(node: ts.Node, sourceLocation: SourceLocation): PType {
    const symbol = this.getUnaliasedSymbolForNode(node)
    if (symbol !== undefined && symbol.declarations?.length) {
      const symbolName = symbol && this.getSymbolFullName(symbol, sourceLocation)
      if (symbolName.name === '*') {
        return new NamespacePType(symbolName)
      }
      const ptype = typeRegistry.tryResolveSingletonName(symbolName)
      if (ptype === undefined && symbolName.module.startsWith(Constants.algoTsPackage)) {
        /*
         Most symbols in the algo-ts module should resolve to a singleton instance
         This can probably be removed once we've implemented ptypes for everything in algo-ts

         */
        if (symbolName.fullName !== baseContractType.fullName && symbolName.fullName !== arc4BaseContractType.fullName)
          logger.warn(sourceLocation, `${symbolName} could not be resolved to a singleton ptype`)
      }
      if (ptype) {
        return ptype
      }
    }
    const type = this.checker.getTypeAtLocation(node)
    if (node.kind === ts.SyntaxKind.ThisKeyword || node.kind === ts.SyntaxKind.SuperKeyword) {
      /**
       * This shouldn't be used in any code paths as `visitThisKeyword` and `visitSuperKeyword` have their own way to
       * determine the type.
       */
      logger.debug(sourceLocation, `Attempting to reflect type of ${getNodeName(node)} node which is known to be unreliable`)
    }
    if (ts.isConstructorDeclaration(node)) {
      const signature = this.checker.getSignatureFromDeclaration(node)
      invariant(signature, 'Constructor node must have call signature')
      const parentType = this.getTypeName(this.checker.getTypeAtLocation(node.parent), sourceLocation)
      return this.reflectFunctionType(
        new SymbolName({
          name: Constants.symbolNames.constructorMethodName,
          module: parentType.module,
        }),
        [signature],
        sourceLocation,
      )
    }
    return this.resolveType(type, sourceLocation)
  }

  resolveTypeNode(node: ts.TypeNode, sourceLocation: SourceLocation): PType {
    const type = this.checker.getTypeFromTypeNode(node)
    return this.resolveType(type, sourceLocation)
  }

  resolveType(tsType: ts.Type, sourceLocation: SourceLocation): PType {
    if (tsType.symbol) {
      const symbolType = this.checker.getTypeOfSymbol(tsType.symbol)
      if (symbolType !== tsType && !tsType.isClass() && symbolType.isClass()) {
        tsType = symbolType
      }
    }

    intersect: if (isIntersectionType(tsType)) {
      if (tsType.aliasSymbol) {
        break intersect
      }
      // Special handling of struct base types which are an intersection of `StructBase` and the generic `T` type
      const parts = tsType.types.map((t) => this.resolveType(t, sourceLocation))
      if (parts.some((p) => p.equals(arc4StructBaseType))) {
        return arc4StructBaseType
      } else {
        return IntersectionPType.fromTypes(parts)
      }
    }
    if (isUnionType(tsType)) {
      const ut = UnionPType.fromTypes(tsType.types.map((t) => this.resolveType(t, sourceLocation)))
      if (ut.equals(gtxnUnion)) {
        return anyGtxnType
      }
      return ut
    }
    switch (tsType.flags) {
      case ts.TypeFlags.Undefined:
        return undefinedPType
      case ts.TypeFlags.Null:
        return nullPType
      case ts.TypeFlags.Any:
        return anyPType
      case ts.TypeFlags.Boolean | ts.TypeFlags.Union:
      case ts.TypeFlags.BooleanLiteral:
        return boolPType
      case ts.TypeFlags.Void:
        return voidPType
      case ts.TypeFlags.String:
      case ts.TypeFlags.StringLiteral:
        return stringPType
      case ts.TypeFlags.Never:
        return neverPType
      case ts.TypeFlags.Unknown:
        return unknownPType
      case ts.TypeFlags.NumberLiteral | ts.TypeFlags.EnumLiteral:
      case ts.TypeFlags.NumberLiteral:
        invariant(tsType.isNumberLiteral(), 'type must be literal', sourceLocation)
        return new NumericLiteralPType({ literalValue: BigInt(tsType.value) })
      case ts.TypeFlags.Number:
        return numberPType
      case ts.TypeFlags.BigIntLiteral:
        invariant(tsType.isLiteral() && typeof tsType.value === 'object', 'type must be literal bigint', sourceLocation)
        return new BigIntLiteralPType({ literalValue: BigInt(tsType.value.base10Value) * (tsType.value.negative ? -1n : 1n) })
      case ts.TypeFlags.BigInt:
        return bigIntPType
    }
    if (isTupleReference(tsType)) {
      codeInvariant(
        tsType.target.fixedLength !== undefined && tsType.target.fixedLength !== null,
        'Tuple types should have a fixed length',
        sourceLocation,
      )
      codeInvariant(tsType.typeArguments, 'Tuple items must have types', sourceLocation)

      return new TuplePType({
        items: tsType.typeArguments.map((t) => this.resolveType(t, sourceLocation)),
      })
    }
    if (isInstantiationExpression(tsType)) {
      return this.resolve(tsType.node.expression, sourceLocation)
    }

    const typeName = this.getTypeName(tsType, sourceLocation)
    logger.debug(sourceLocation, `Resolving ptype for ${typeName}`)

    if (typeName.name === '__type' && typeName.module.startsWith(Constants.algoTsPackage)) {
      // We are likely dealing with `typeof X` where X is a singleton exported by algo-ts
      const declarationNode = tsType.symbol.getDeclarations()?.[0]?.parent

      if (declarationNode && ts.isVariableDeclaration(declarationNode)) {
        return this.resolve(declarationNode.name, sourceLocation)
      }
    }

    if (typeName.fullName === arc4StructBaseType.fullName) return arc4StructBaseType
    if (typeName.fullName === ClusteredPrototype.fullName) {
      return this.resolveClusteredPrototype(tsType, sourceLocation)
    }

    if (tsType.flags === ts.TypeFlags.TypeParameter) {
      return new TypeParameterType(typeName)
    }

    if (tsType.aliasTypeArguments?.length) {
      const typeArgs = tsType.aliasTypeArguments.map((a) => this.resolveType(a, sourceLocation))
      const gt = typeRegistry.tryResolveGenericPType(typeName, typeArgs)
      if (gt) return gt
    } else if (isTypeReference(tsType) && tsType.typeArguments?.length) {
      const typeArgs = tsType.typeArguments.map((a) => this.resolveType(a, sourceLocation))
      const gt = typeRegistry.tryResolveGenericPType(typeName, typeArgs)
      if (gt) return gt
    } else {
      const it = typeRegistry.tryResolveInstancePType(typeName)
      if (it) return it
    }

    if (tsType.getConstructSignatures().length) {
      return this.reflectConstructorType(tsType, sourceLocation)
    }

    if (tsType.isClass()) {
      if (typeName.fullName === arc4BaseContractType.fullName) return arc4BaseContractType
      if (typeName.fullName === baseContractType.fullName) return baseContractType
      if (typeName.fullName === logicSigBaseType.fullName) return logicSigBaseType

      const [baseType, ...rest] = tsType.getBaseTypes()?.map((t) => this.resolveType(t, sourceLocation)) ?? []

      invariant(rest.length === 0, 'Class can have at most one base type')

      // Treat sub-types of UintN type as the base type.
      if (baseType instanceof UintNType) return baseType

      if (baseType instanceof ContractClassPType) {
        return this.reflectContractType(typeName, tsType, baseType, sourceLocation)
      }
      if (baseType instanceof ARC4StructType) {
        return this.reflectStructType(typeName, tsType, baseType, sourceLocation)
      }
      if (baseType instanceof LogicSigPType) {
        return new LogicSigPType({
          ...typeName,
          sourceLocation,
          baseType,
        })
      }
      throw new CodeError(
        `${typeName.fullName} cannot be mapped to an algo ts type. Classes must extend "Contract" or "BaseContract" base classes to be considered a contract`,
        { sourceLocation },
      )
    }
    const callSignatures = this.checker.getSignaturesOfType(tsType, ts.SignatureKind.Call)
    if (callSignatures.length) {
      return this.reflectFunctionType(typeName, callSignatures, sourceLocation)
    }
    if (this.checker.isArrayType(tsType)) {
      const itemType = tsType.getNumberIndexType()
      if (!itemType) {
        throw new CodeError('Cannot determine array item type', { sourceLocation })
      } else {
        const itemPType = this.resolveType(itemType, sourceLocation)
        return new ArrayPType({
          elementType: itemPType,
        })
      }
    }
    if (isObjectType(tsType)) {
      return this.reflectObjectType(tsType, sourceLocation)
    }
    throw new InternalError(`Cannot determine type of ${typeName}`, { sourceLocation })
  }

  private reflectObjectType(tsType: ts.Type, sourceLocation: SourceLocation): ObjectPType {
    const typeAlias = tsType.aliasSymbol ? this.getSymbolFullName(tsType.aliasSymbol, sourceLocation) : undefined
    const properties: Record<string, PType> = {}
    for (const prop of tsType.getProperties()) {
      if (prop.name.startsWith('__@')) {
        // Symbol property - ignore
        // TODO: Check AST nodes to confirm?
        continue
      }
      const type = this.checker.getTypeOfSymbol(prop)
      const ptype = this.resolveType(type, sourceLocation)
      if (ptype.singleton) {
        logger.error(sourceLocation, `${ptype} is not a valid object property type`)
      } else {
        properties[prop.name] = ptype
      }
    }
    if (typeAlias) {
      return new ObjectPType({ alias: typeAlias, properties, description: tryGetTypeDescription(tsType) })
    }
    return ObjectPType.anonymous(properties)
  }

  private reflectConstructorType(tsType: ts.Type, sourceLocation: SourceLocation): PType {
    const constructorSignatures = tsType.getConstructSignatures()
    invariant(constructorSignatures.length, 'Must have at least one signature')
    const typeDeclaration = tsType.getSymbol()?.declarations?.[0]
    if (typeDeclaration && ts.isClassDeclaration(typeDeclaration)) {
      const ptype = this.resolve(typeDeclaration, sourceLocation)
      if (ptype instanceof ARC4StructType) {
        return ARC4StructClass.fromStructType(ptype)
      } else if (ptype instanceof ContractClassPType || ptype instanceof LogicSigPType) {
        return ptype
      }
    }
    throw new CodeError('Unable to reflect constructor type', { sourceLocation })
  }

  private reflectFunctionType(
    typeName: SymbolName,
    callSignatures: readonly ts.Signature[],
    sourceLocation: SourceLocation,
  ): FunctionPType {
    if (typeName.fullName === ApprovalProgram.fullName) return ApprovalProgram
    if (typeName.fullName === ClearStateProgram.fullName) return ClearStateProgram

    codeInvariant(callSignatures.length === 1, 'User defined functions must have exactly 1 call signature', sourceLocation)
    const [sig] = callSignatures
    const returnType = this.resolveType(sig.getReturnType(), sourceLocation)
    const parameters = sig.getParameters().map((p) => {
      const paramType = this.checker.getTypeOfSymbol(p)
      return [p.name, this.resolveType(paramType, this.getLocationOfSymbol(p) ?? sourceLocation)] as const
    })
    return new FunctionPType({
      returnType,
      parameters,
      name: typeName.name,
      module: typeName.module,
      sourceLocation,
    })
  }

  private reflectStructType(
    typeName: SymbolName,
    tsType: ts.Type,
    baseType: ARC4StructType,
    sourceLocation: SourceLocation,
  ): ARC4StructType {
    const ignoredProps = ['bytes', 'equals', 'native', 'copy', Constants.symbolNames.constructorMethodName]
    const fields: Record<string, ARC4EncodedType> = {}
    for (const prop of tsType.getProperties()) {
      if (isIn(prop.name, ignoredProps)) continue
      const type = this.checker.getTypeOfSymbol(prop)
      const propLocation = this.getLocationOfSymbol(prop) ?? sourceLocation
      const ptype = this.resolveType(type, propLocation)
      if (ptype instanceof ARC4EncodedType) {
        fields[prop.name] = ptype
      } else {
        // Ignore
      }
    }
    return new ARC4StructType({
      ...typeName,
      fields: fields,
      sourceLocation: sourceLocation,
      description: tryGetTypeDescription(tsType),
      frozen: baseType.frozen,
    })
  }

  private reflectContractType(
    typeName: SymbolName,
    tsType: ts.Type,
    baseType: ContractClassPType,
    sourceLocation: SourceLocation,
  ): ContractClassPType {
    const properties: Record<string, AppStorageType> = {}
    const methods: Record<string, FunctionPType> = {}

    for (const prop of tsType.getProperties()) {
      const type = this.checker.getTypeOfSymbol(prop)
      const ptype = this.resolveType(type, this.getLocationOfSymbol(prop) ?? sourceLocation)
      if (ptype instanceof StorageProxyPType) {
        properties[prop.name] = ptype
      } else if (ptype instanceof FunctionPType) {
        methods[prop.name] = ptype
      }
    }
    return new ContractClassPType({
      properties,
      methods,
      name: typeName.name,
      module: typeName.module,
      baseTypes: [baseType],
      sourceLocation,
    })
  }

  private resolveClusteredPrototype(tsType: ts.Type, sourceLocation: SourceLocation): PType {
    invariant(isIntersectionType(tsType), 'Clustered prototypes must be an intersection type')
    const baseContracts: ContractClassPType[] = []
    for (const t of tsType.types.map((t) => this.resolveType(t, sourceLocation))) {
      if (t instanceof ContractClassPType) {
        baseContracts.push(t)
      } else if (t instanceof SuperPrototypeSelector) {
        // Ignore for now
      } else {
        throw new CodeError(
          `Unexpected type: ${t}. Polytype can only be used to support multiple inheritance in contracts for now. All base types must extend the Contract or BaseContract class.}`,
        )
      }
    }
    return new ClusteredContractClassType({
      methods: {},
      baseTypes: baseContracts,
      sourceLocation,
    })
  }

  private getTypeName(type: ts.Type, sourceLocation: SourceLocation): SymbolName {
    if (type.aliasSymbol) {
      const name = this.getSymbolFullName(type.aliasSymbol, sourceLocation)
      // We only respect type aliases within certain modules, otherwise use the
      // unaliased symbol
      if (name.module.startsWith(Constants.algoTsPackage) || name.module === Constants.moduleNames.polytype) return name
    }
    invariant(type.symbol, 'Type must have a symbol', sourceLocation)
    return this.getSymbolFullName(type.symbol, sourceLocation)
  }

  private getLocationOfSymbol(symbol: ts.Symbol): SourceLocation | undefined {
    const declaration = symbol.getDeclarations()?.[0]

    return declaration && SourceLocation.fromNode(declaration, this.programDirectory)
  }

  private tryGetLocalSymbolName(symbol: ts.Symbol): string | undefined {
    const dec = symbol.getDeclarations()?.[0] as undefined | { localSymbol?: ts.Symbol }
    return dec?.localSymbol?.name
  }

  private getSymbolFullName(symbol: ts.Symbol, sourceLocation: SourceLocation): SymbolName {
    const symbolName = symbol.name === 'default' ? (this.tryGetLocalSymbolName(symbol) ?? symbol.name) : symbol.name

    const declaration = symbol?.declarations?.[0]
    if (declaration) {
      if (
        intersectsFlags(symbol.flags, ts.SymbolFlags.Namespace) &&
        !intersectsFlags(symbol.flags, ts.SymbolFlags.Function | ts.SymbolFlags.RegularEnum)
      ) {
        return new SymbolName({
          module: normalisePath(declaration.getSourceFile().fileName, this.programDirectory),
          name: '*',
        })
      }
      return new SymbolName({ module: normalisePath(declaration.getSourceFile().fileName, this.programDirectory), name: symbolName })
    }
    throw new InternalError(`Symbol does not have a declaration`, { sourceLocation })
  }
}

function isObjectType(tsType: ts.Type): tsType is ts.ObjectType {
  return hasFlags(tsType.flags, ts.TypeFlags.Object)
}
function isTypeReference(tsType: ts.Type): tsType is ts.TypeReference {
  return isObjectType(tsType) && hasFlags(tsType.objectFlags, ts.ObjectFlags.Reference)
}
function isTupleType(tsType: ts.Type): tsType is ts.TupleType {
  return isObjectType(tsType) && hasFlags(tsType.objectFlags, ts.ObjectFlags.Tuple)
}

function isTupleReference(tsType: ts.Type): tsType is ts.TypeReference & { target: ts.TupleType } {
  return isTypeReference(tsType) && isTupleType(tsType.target)
}

function isUnionType(tsType: ts.Type): tsType is ts.UnionType {
  return tsType.flags === ts.TypeFlags.Union
}

function isIntersectionType(tsType: ts.Type): tsType is ts.IntersectionType {
  return tsType.flags === ts.TypeFlags.Intersection
}

function isInstantiationExpression(tsType: ts.Type): tsType is ts.Type & { node: ts.ExpressionWithTypeArguments } {
  return isObjectType(tsType) && hasFlags(tsType.objectFlags, ObjectFlags.InstantiationExpressionType)
}

function tryGetTypeDescription(tsType: ts.Type): string | undefined {
  const dec = tsType.aliasSymbol?.valueDeclaration ?? tsType.symbol.valueDeclaration
  if (!dec) return undefined
  const docs = ts.getJSDocCommentsAndTags(dec)
  for (const doc of docs) {
    if (ts.isJSDoc(doc)) {
      return ts.getTextOfJSDocComment(doc.comment)
    }
  }
  return undefined
}



================================================
FILE: src/awst_build/ast-visitors/base-visitor.ts
================================================
import ts from 'typescript'
import { nodeFactory } from '../../awst/node-factory'
import type { Expression, LValue, MethodDocumentation, Statement } from '../../awst/nodes'
import { SourceLocation } from '../../awst/source-location'
import { CodeError, InternalError, NotSupported } from '../../errors'
import { logger } from '../../logger'
import { codeInvariant, enumerate, invariant, sortBy } from '../../util'
import type { Expressions } from '../../visitor/syntax-names'
import {
  AugmentedAssignmentBinaryOp,
  AugmentedAssignmentLogicalOpSyntaxes,
  BinaryOpSyntaxes,
  ComparisonOpSyntaxes,
  getNodeName,
  getSyntaxName,
  isKeyOf,
  LogicalOpSyntaxes,
  UnaryExpressionUnaryOps,
} from '../../visitor/syntax-names'
import type { Visitor } from '../../visitor/visitor'
import { accept } from '../../visitor/visitor'
import { AwstBuildContext } from '../context/awst-build-context'
import { InstanceBuilder, NodeBuilder } from '../eb'
import { BooleanExpressionBuilder } from '../eb/boolean-expression-builder'
import { ArrayLiteralExpressionBuilder } from '../eb/literal/array-literal-expression-builder'
import { BigIntLiteralExpressionBuilder } from '../eb/literal/big-int-literal-expression-builder'
import { ConditionalExpressionBuilder } from '../eb/literal/conditional-expression-builder'
import type { ObjectLiteralParts } from '../eb/literal/object-literal-expression-builder'
import { ObjectLiteralExpressionBuilder } from '../eb/literal/object-literal-expression-builder'
import { NamespaceBuilder } from '../eb/namespace-builder'
import { OmittedExpressionBuilder } from '../eb/omitted-expression-builder'
import { SpreadExpressionBuilder } from '../eb/spread-expression-builder'
import { StringExpressionBuilder, StringFunctionBuilder } from '../eb/string-expression-builder'
import { StaticIterator } from '../eb/traits/static-iterator'
import { requireExpressionOfType, requireInstanceBuilder } from '../eb/util'
import { concatArrays } from '../eb/util/array/concat'
import type { PType } from '../ptypes'
import {
  ArrayLiteralPType,
  ArrayPType,
  BigIntLiteralPType,
  bigIntPType,
  biguintPType,
  boolPType,
  neverPType,
  numberPType,
  NumericLiteralPType,
  ObjectPType,
  TransientType,
  TuplePType,
  uint64PType,
  UnionPType,
} from '../ptypes'
import { instanceEb, typeRegistry } from '../type-registry'
import { TextVisitor } from './text-visitor'

export abstract class BaseVisitor implements Visitor<Expressions, NodeBuilder> {
  private baseAccept = <TNode extends ts.Node>(node: TNode) => accept<BaseVisitor, TNode>(this, node)
  readonly textVisitor: TextVisitor
  get context() {
    return AwstBuildContext.current
  }

  protected constructor() {
    this.textVisitor = new TextVisitor()
  }

  logNotSupported(node: ts.Node | undefined, message: string) {
    if (!node) return
    logger.error(new NotSupported(message, { sourceLocation: this.sourceLocation(node) }))
  }

  throwNotSupported(node: ts.Node, message: string): never {
    throw new NotSupported(message, { sourceLocation: this.sourceLocation(node) })
  }

  visitBigIntLiteral(node: ts.BigIntLiteral): InstanceBuilder {
    const literalValue = BigInt(node.text.slice(0, -1))
    const ptype = this.context.getPTypeForNode(node)
    invariant(ptype instanceof TransientType, 'Literals should resolve to transient PTypes')
    return new BigIntLiteralExpressionBuilder(literalValue, ptype, this.sourceLocation(node))
  }

  visitRegularExpressionLiteral(node: ts.RegularExpressionLiteral): InstanceBuilder {
    this.throwNotSupported(node, 'Regular expressions')
  }

  visitFalseKeyword(node: ts.FalseLiteral): InstanceBuilder {
    return new BooleanExpressionBuilder(nodeFactory.boolConstant({ value: false, sourceLocation: this.sourceLocation(node) }))
  }

  visitTrueKeyword(node: ts.TrueLiteral): InstanceBuilder {
    return new BooleanExpressionBuilder(nodeFactory.boolConstant({ value: true, sourceLocation: this.sourceLocation(node) }))
  }

  sourceLocation(node: ts.Node): SourceLocation {
    return this.context.getSourceLocation(node)
  }

  visitStringLiteral(node: ts.StringLiteral): InstanceBuilder {
    return new StringExpressionBuilder(nodeFactory.stringConstant({ value: node.text, sourceLocation: this.sourceLocation(node) }))
  }

  visitNoSubstitutionTemplateLiteral(node: ts.NoSubstitutionTemplateLiteral): InstanceBuilder {
    return new StringExpressionBuilder(nodeFactory.stringConstant({ value: node.text, sourceLocation: this.sourceLocation(node) }))
  }

  visitNumericLiteral(node: ts.NumericLiteral): InstanceBuilder {
    const sourceLocation = this.sourceLocation(node)
    codeInvariant(
      !node.text.includes('.'),
      'Literals with decimal points are not supported. Use a string literal to capture decimal values',
      sourceLocation,
    )
    const literalValue = BigInt(node.text)
    if (literalValue > Number.MAX_SAFE_INTEGER || literalValue < Number.MIN_SAFE_INTEGER) {
      logger.error(
        sourceLocation,
        `This number will lose precision at runtime. Use the Uint64 constructor with a bigint or string literal for very large integers.`,
      )
    }
    const ptype = this.context.getPTypeForNode(node)
    invariant(ptype instanceof TransientType, 'Literals should resolve to transient PTypes')
    return new BigIntLiteralExpressionBuilder(literalValue, ptype, this.sourceLocation(node))
  }

  visitIdentifier(node: ts.Identifier): NodeBuilder {
    return this.context.getBuilderForNode(node)
  }

  visitImportKeyword(node: ts.ImportExpression): NodeBuilder {
    this.throwNotSupported(node, 'Dynamic imports')
  }

  visitNullKeyword(node: ts.NullLiteral): NodeBuilder {
    this.throwNotSupported(node, 'Null values')
  }

  visitPrivateIdentifier(node: ts.PrivateIdentifier): NodeBuilder {
    // Private identifiers will be wrapped in a property access expression which makes use of the TextVisitor
    throw InternalError.shouldBeUnreachable()
  }

  visitSuperKeyword(node: ts.SuperExpression): NodeBuilder {
    this.throwNotSupported(node, `'super' keyword outside of a contract type`)
  }

  visitThisKeyword(node: ts.ThisExpression): NodeBuilder {
    this.throwNotSupported(node, `'this' keyword outside of a contract type`)
  }

  visitFunctionExpression(node: ts.FunctionExpression): NodeBuilder {
    this.throwNotSupported(node, 'function expressions. Use a named function instead eg. `function myFunction(...) {...}`')
  }

  visitClassExpression(node: ts.ClassExpression): NodeBuilder {
    this.throwNotSupported(node, 'class expressions')
  }

  visitObjectLiteralExpression(node: ts.ObjectLiteralExpression): NodeBuilder {
    const sourceLocation = this.sourceLocation(node)
    const parts: Array<ObjectLiteralParts> = node.properties.flatMap((p): ObjectLiteralParts[] => {
      const propertySourceLocation = this.sourceLocation(p)
      switch (p.kind) {
        case ts.SyntaxKind.PropertyAssignment:
          return [
            {
              type: 'properties',
              properties: {
                [this.textVisitor.accept(p.name)]: requireInstanceBuilder(this.baseAccept(p.initializer)),
              },
            },
          ]
        case ts.SyntaxKind.ShorthandPropertyAssignment:
          codeInvariant(!p.objectAssignmentInitializer, 'Object assignment initializer not supported', propertySourceLocation)
          this.logNotSupported(p.equalsToken, 'The equals token is not valid here')
          return [
            {
              type: 'properties',
              properties: { [this.textVisitor.accept(p.name)]: requireInstanceBuilder(this.baseAccept(p.name)) },
            },
          ]
        case ts.SyntaxKind.SpreadAssignment:
          return [
            {
              type: 'spread-object',
              obj: requireInstanceBuilder(this.baseAccept(p.expression)),
            },
          ]
        default:
          logger.error(propertySourceLocation, `Unsupported object literal property kind ${getNodeName(p)}`)
          return []
      }
    })
    const ptype = this.context.getPTypeForNode(node)
    invariant(ptype instanceof ObjectPType, 'Object literal ptype should resolve to ObjectPType')
    return new ObjectLiteralExpressionBuilder(sourceLocation, ptype, parts)
  }

  visitArrayLiteralExpression(node: ts.ArrayLiteralExpression): NodeBuilder {
    const sourceLocation = this.sourceLocation(node)

    if (node.elements.length === 0) {
      return new ArrayLiteralExpressionBuilder(sourceLocation, [])
    }

    const toConcat: Array<InstanceBuilder[] | InstanceBuilder> = []
    let itemBuffer: InstanceBuilder[] = []
    for (const element of node.elements) {
      if (ts.isSpreadElement(element)) {
        const spreadExpr = requireInstanceBuilder(this.baseAccept(element.expression))
        if (itemBuffer.length !== 0) {
          toConcat.push(itemBuffer)
          itemBuffer = []
        }
        toConcat.push(spreadExpr)
      } else {
        itemBuffer.push(requireInstanceBuilder(this.baseAccept(element)))
      }
    }
    if (itemBuffer.length !== 0) {
      toConcat.push(itemBuffer)
    }

    return toConcat
      .map((i) =>
        Array.isArray(i) ? new ArrayLiteralExpressionBuilder(SourceLocation.fromLocations(...i.map((li) => li.sourceLocation)), i) : i,
      )
      .reduce((acc, cur) => concatArrays(acc, cur, sourceLocation))
  }

  visitSpreadElement(node: ts.SpreadElement): NodeBuilder {
    const base = requireInstanceBuilder(this.baseAccept(node.expression))
    return new SpreadExpressionBuilder(base, this.sourceLocation(node))
  }

  visitPropertyAccessExpression(node: ts.PropertyAccessExpression): NodeBuilder {
    this.logNotSupported(node.questionDotToken, 'The optional chaining (?.) operator is not supported')
    const target = this.baseAccept(node.expression)
    if (target instanceof NamespaceBuilder) {
      codeInvariant(!ts.isPrivateIdentifier(node.name), 'Private identifiers are not supported here', this.sourceLocation(node.name))
      return this.context.getBuilderForNode(node.name)
    }
    const property = this.textVisitor.accept(node.name)
    return target.memberAccess(property, this.sourceLocation(node.name))
  }

  visitElementAccessExpression(node: ts.ElementAccessExpression): NodeBuilder {
    this.logNotSupported(node.questionDotToken, 'The optional chaining (?.) operator is not supported')

    const sourceLocation = this.sourceLocation(node)
    const target = this.baseAccept(node.expression)
    const argument = this.baseAccept(node.argumentExpression)
    return target.indexAccess(requireInstanceBuilder(argument), sourceLocation)
  }

  visitCallExpression(node: ts.CallExpression): NodeBuilder {
    this.logNotSupported(node.questionDotToken, 'The optional chaining (?.) operator is not supported')
    const sourceLocation = this.sourceLocation(node)
    const eb = this.baseAccept(node.expression)
    const args = node.arguments
      .map((a) => this.baseAccept(a))
      .flatMap((a) => (a instanceof SpreadExpressionBuilder ? a.getSpreadItems() : a))
    const typeArgs = this.context.getTypeParameters(node)
    return eb.call(args, typeArgs, sourceLocation)
  }

  visitNewExpression(node: ts.NewExpression): NodeBuilder {
    const sourceLocation = this.sourceLocation(node)
    const eb = this.baseAccept(node.expression)
    const args =
      node.arguments?.map((a) => this.baseAccept(a)).flatMap((a) => (a instanceof SpreadExpressionBuilder ? a.getSpreadItems() : a)) ?? []
    const typeArgs = this.context.getTypeParameters(node)
    return eb.newCall(args, typeArgs, sourceLocation)
  }

  visitTaggedTemplateExpression(node: ts.TaggedTemplateExpression): NodeBuilder {
    const sourceLocation = this.sourceLocation(node)
    const target = this.baseAccept(node.tag)
    if (ts.isNoSubstitutionTemplateLiteral(node.template)) {
      return target.taggedTemplate(this.textVisitor.accept(node.template), [], sourceLocation)
    } else {
      const head = this.textVisitor.accept(node.template.head)
      const spans = node.template.templateSpans.map(
        (s) => [requireInstanceBuilder(this.baseAccept(s.expression)), this.textVisitor.accept(s.literal)] as const,
      )
      return target.taggedTemplate(head, spans, sourceLocation)
    }
  }

  visitTypeAssertionExpression(node: ts.TypeAssertion): NodeBuilder {
    // Unsure what code this node represents - it may have been superseded by the AsExpression
    this.throwNotSupported(node, 'Type assertions')
  }

  visitParenthesizedExpression(node: ts.ParenthesizedExpression): NodeBuilder {
    return this.baseAccept(node.expression)
  }

  /**
   * `delete obj.prop`
   *
   * Not supported currently as typescript requires 'prop' to be optional and we don't support optional values
   */
  visitDeleteExpression(node: ts.DeleteExpression): NodeBuilder {
    this.throwNotSupported(node, 'Delete expressions')
  }

  visitTypeOfExpression(node: ts.TypeOfExpression): NodeBuilder {
    this.throwNotSupported(node, 'typeof expressions are only supported in type expressions')
  }

  visitVoidExpression(node: ts.VoidExpression): NodeBuilder {
    this.throwNotSupported(node, 'void expression')
  }

  visitAwaitExpression(node: ts.AwaitExpression): NodeBuilder {
    this.throwNotSupported(node, 'await keyword')
  }

  visitPrefixUnaryExpression(node: ts.PrefixUnaryExpression): NodeBuilder {
    const sourceLocation = this.sourceLocation(node)
    const target = requireInstanceBuilder(this.baseAccept(node.operand))
    if (node.operator === ts.SyntaxKind.ExclamationToken) {
      return new BooleanExpressionBuilder(target.boolEval(sourceLocation, true))
    }
    const op = UnaryExpressionUnaryOps[node.operator]
    return target.prefixUnaryOp(op, sourceLocation)
  }

  visitPostfixUnaryExpression(node: ts.PostfixUnaryExpression): NodeBuilder {
    const sourceLocation = this.sourceLocation(node)
    const target = requireInstanceBuilder(this.baseAccept(node.operand))
    const op = UnaryExpressionUnaryOps[node.operator]
    return target.postfixUnaryOp(op, sourceLocation)
  }

  evaluateCondition(nodeOrBuilder: ts.Expression | NodeBuilder, negate = false): Expression {
    using _ = this.context.evaluationCtx.enterBooleanContext()
    if (nodeOrBuilder instanceof NodeBuilder) {
      return requireInstanceBuilder(nodeOrBuilder).boolEval(nodeOrBuilder.sourceLocation, negate)
    } else {
      const sourceLocation = this.sourceLocation(nodeOrBuilder)
      return requireInstanceBuilder(this.baseAccept(nodeOrBuilder)).boolEval(sourceLocation, negate)
    }
  }

  private getBinaryOpKind(token: ts.BinaryOperatorToken): ts.SyntaxKind {
    const sourceLocation = this.sourceLocation(token)
    switch (token.kind) {
      case ts.SyntaxKind.EqualsEqualsToken:
        logger.error(sourceLocation, `Loose equality operator '==' is not supported. Please use strict equality operator '==='`)
        return ts.SyntaxKind.EqualsEqualsEqualsToken
      case ts.SyntaxKind.ExclamationEqualsToken:
        logger.error(sourceLocation, `Loose inequality operator '!=' is not supported. Please use strict inequality operator '!=='`)
        return ts.SyntaxKind.ExclamationEqualsEqualsToken
      default:
        return token.kind
    }
  }

  visitBinaryExpression(node: ts.BinaryExpression): NodeBuilder {
    const sourceLocation = this.sourceLocation(node)
    const binaryOpKind = this.getBinaryOpKind(node.operatorToken)

    if (isKeyOf(binaryOpKind, BinaryOpSyntaxes)) {
      const left = requireInstanceBuilder(this.baseAccept(node.left))
      const right = requireInstanceBuilder(this.baseAccept(node.right))
      return left.binaryOp(right, BinaryOpSyntaxes[binaryOpKind], sourceLocation)
    } else if (isKeyOf(binaryOpKind, AugmentedAssignmentBinaryOp)) {
      using _ = this.context.evaluationCtx.leaveBooleanContext()

      const left = requireInstanceBuilder(this.baseAccept(node.left))
      const right = requireInstanceBuilder(this.baseAccept(node.right))
      return left.augmentedAssignment(right, AugmentedAssignmentBinaryOp[binaryOpKind], sourceLocation)
    } else if (binaryOpKind === ts.SyntaxKind.EqualsToken) {
      using _ = this.context.evaluationCtx.leaveBooleanContext()

      const left = requireInstanceBuilder(this.baseAccept(node.left))
      const right = requireInstanceBuilder(this.baseAccept(node.right))
      return this.handleAssignment(left, right, sourceLocation)
    } else if (isKeyOf(binaryOpKind, ComparisonOpSyntaxes)) {
      const left = requireInstanceBuilder(this.baseAccept(node.left))
      const right = requireInstanceBuilder(this.baseAccept(node.right))
      return left.compare(right, ComparisonOpSyntaxes[binaryOpKind], sourceLocation)
    } else if (isKeyOf(binaryOpKind, LogicalOpSyntaxes)) {
      const ptype = this.context.getPTypeForNode(node)
      if (ptype.equals(boolPType)) {
        const left = requireInstanceBuilder(this.baseAccept(node.left))
        const right = requireInstanceBuilder(this.baseAccept(node.right))

        return new BooleanExpressionBuilder(
          nodeFactory.booleanBinaryOperation({
            left: requireExpressionOfType(left, boolPType),
            right: requireExpressionOfType(right, boolPType),
            sourceLocation,
            op: LogicalOpSyntaxes[binaryOpKind],
          }),
        )
      } else if (this.context.evaluationCtx.isBoolean) {
        const left = requireInstanceBuilder(this.baseAccept(node.left))
        const right = requireInstanceBuilder(this.baseAccept(node.right))
        return new BooleanExpressionBuilder(
          nodeFactory.booleanBinaryOperation({
            left: left.boolEval(sourceLocation),
            right: right.boolEval(sourceLocation),
            sourceLocation,
            op: LogicalOpSyntaxes[binaryOpKind],
          }),
        )
      } else {
        const left = requireInstanceBuilder(this.baseAccept(node.left))
        const right = requireInstanceBuilder(this.baseAccept(node.right))
        const leftSingle = left.singleEvaluation()
        const isOr = binaryOpKind === ts.SyntaxKind.BarBarToken
        return this.createConditionalExpression({
          sourceLocation,
          condition: this.evaluateCondition(leftSingle),
          whenTrue: isOr ? leftSingle : right,
          whenFalse: isOr ? right : leftSingle,
          ptype: ptype,
        })
      }
    } else if (isKeyOf(binaryOpKind, AugmentedAssignmentLogicalOpSyntaxes)) {
      using _ = this.context.evaluationCtx.leaveBooleanContext()
      const left = requireInstanceBuilder(this.baseAccept(node.left))
      const right = requireInstanceBuilder(this.baseAccept(node.right))
      const expr = new BooleanExpressionBuilder(
        nodeFactory.booleanBinaryOperation({
          left: requireExpressionOfType(left, boolPType),
          right: requireExpressionOfType(right, boolPType),
          sourceLocation,
          op: AugmentedAssignmentLogicalOpSyntaxes[binaryOpKind],
        }),
      )
      return this.handleAssignment(left, expr, sourceLocation)
    }
    throw new NotSupported(`Binary expression with op ${getSyntaxName(binaryOpKind)}`)
  }

  visitConditionalExpression(node: ts.ConditionalExpression): NodeBuilder {
    const sourceLocation = this.sourceLocation(node)
    const condition = this.evaluateCondition(node.condition)
    const whenTrue = requireInstanceBuilder(this.baseAccept(node.whenTrue))
    const whenFalse = requireInstanceBuilder(this.baseAccept(node.whenFalse))
    const ptype = this.context.getPTypeForNode(node)
    return this.createConditionalExpression({
      condition,
      sourceLocation,
      whenFalse,
      whenTrue,
      ptype,
    })
  }

  createConditionalExpression({
    condition,
    ptype,
    whenFalse,
    whenTrue,
    sourceLocation,
  }: {
    ptype: PType
    condition: Expression
    whenTrue: InstanceBuilder
    whenFalse: InstanceBuilder
    sourceLocation: SourceLocation
  }): InstanceBuilder {
    // If the expression has a wtype, we can resolve it immediately - if not, we defer the resolution until we have more context
    // (eg. the type of the assignment target)
    if (!(ptype instanceof TransientType) && ptype.wtype) {
      return typeRegistry.getInstanceEb(
        nodeFactory.conditionalExpression({
          sourceLocation: sourceLocation,
          falseExpr: requireExpressionOfType(whenFalse, ptype),
          trueExpr: requireExpressionOfType(whenTrue, ptype),
          condition: condition,
          wtype: ptype.wtypeOrThrow,
        }),
        ptype,
      )
    }
    return new ConditionalExpressionBuilder({ sourceLocation, condition, whenTrue, whenFalse, ptype })
  }

  visitTemplateExpression(node: ts.TemplateExpression): NodeBuilder {
    const sourceLocation = this.sourceLocation(node)
    const target = new StringFunctionBuilder(sourceLocation)

    const head = this.textVisitor.accept(node.head)
    const spans = node.templateSpans.map(
      (s) => [requireInstanceBuilder(this.baseAccept(s.expression)), this.textVisitor.accept(s.literal)] as const,
    )
    return target.taggedTemplate(head, spans, sourceLocation)
  }

  visitYieldExpression(node: ts.YieldExpression): NodeBuilder {
    this.throwNotSupported(node, 'yield expressions')
  }

  visitOmittedExpression(node: ts.OmittedExpression): NodeBuilder {
    return new OmittedExpressionBuilder(this.context.getSourceLocation(node))
  }

  visitExpressionWithTypeArguments(node: ts.ExpressionWithTypeArguments): NodeBuilder {
    // Should be fine to ignore the type parameters as these can be inferred by the type checker
    return this.baseAccept(node.expression)
  }

  visitAsExpression(node: ts.AsExpression): NodeBuilder {
    const sourceLocation = this.sourceLocation(node)
    const outerType = this.context.getPTypeForNode(node)

    if (outerType instanceof TransientType) {
      throw new CodeError(outerType.typeMessage, { sourceLocation })
    }

    const innerExpr = this.baseAccept(node.expression)
    codeInvariant(
      innerExpr instanceof InstanceBuilder,
      `${innerExpr.typeDescription} is not a valid target for an as expression'`,
      sourceLocation,
    )

    codeInvariant(
      innerExpr.resolvableToPType(outerType),
      `${innerExpr.typeDescription} cannot be resolved to type ${outerType}`,
      sourceLocation,
    )

    return innerExpr.resolveToPType(outerType)
  }

  visitNonNullExpression(node: ts.NonNullExpression): NodeBuilder {
    this.throwNotSupported(node, 'non null assertions')
  }

  visitSatisfiesExpression(node: ts.SatisfiesExpression): NodeBuilder {
    return this.baseAccept(node.expression)
  }

  handleAssignmentStatement(target: InstanceBuilder, source: InstanceBuilder, sourceLocation: SourceLocation): Statement {
    return nodeFactory.expressionStatement({ expr: this.handleAssignment(target, source, sourceLocation).resolve() })
  }

  handleAssignment(target: InstanceBuilder, source: InstanceBuilder, sourceLocation: SourceLocation): InstanceBuilder {
    const assignmentType = this.buildAssignmentExpressionType(target.ptype, source.ptype, sourceLocation)
    return instanceEb(
      nodeFactory.assignmentExpression({
        target: this.buildLValue(target, assignmentType, sourceLocation),
        sourceLocation,
        value: source.resolveToPType(assignmentType).resolve(),
      }),
      assignmentType,
    )
  }

  /**
   * Given a target and source type, produce a type that represents the result of an assignment expression.
   *
   * This will largely represent the sourceType verbatim with the exception of numeric literal types which need
   * to be narrowed using the targetType.
   *
   * Eg. a `number` on the rhs should be narrowed to whatever the lhs is for example uint64.
   * @param targetType The type of the assignment target
   * @param sourceType The type of the assignment source
   * @param sourceLocation
   * @private
   */
  private buildAssignmentExpressionType(targetType: PType, sourceType: PType, sourceLocation: SourceLocation): PType {
    if (targetType instanceof ArrayLiteralPType)
      // Puya does not support assigning to array targets, but we can treat array literals as tuples
      return this.buildAssignmentExpressionType(targetType.getTupleType(), sourceType, sourceLocation)

    const errorMessage = `Value of type ${sourceType.name} cannot be assigned to target of type ${targetType.name}`
    if (sourceType.equals(targetType)) {
      return targetType
    }
    if (
      sourceType instanceof NumericLiteralPType ||
      sourceType.equals(numberPType) ||
      (sourceType instanceof UnionPType &&
        sourceType.types.every((t) => t.equals(uint64PType) || t instanceof NumericLiteralPType || sourceType.equals(numberPType)))
    ) {
      // Narrow `uint64 | number` or `number` to target type
      return targetType
    }
    if (
      sourceType.equals(bigIntPType) ||
      sourceType instanceof BigIntLiteralPType ||
      (sourceType instanceof UnionPType &&
        sourceType.types.every((t) => t.equals(biguintPType) || t instanceof BigIntLiteralPType || t.equals(bigIntPType)))
    ) {
      // Narrow `biguint | bigint` or `bigint` to target type
      return targetType
    }
    if (sourceType instanceof ArrayLiteralPType) {
      if (targetType instanceof TuplePType) {
        // Narrow array literal types to tuple item types
        codeInvariant(targetType.items.length <= sourceType.items.length, errorMessage, sourceLocation)
        return new TuplePType({
          items: sourceType.items.map((item, index) =>
            index < targetType.items.length ? this.buildAssignmentExpressionType(targetType.items[index], item, sourceLocation) : item,
          ),
        })
      } else if (targetType instanceof ArrayPType) {
        // Narrow array literal types to array type
        codeInvariant(
          sourceType.items.every((i) =>
            this.buildAssignmentExpressionType(targetType.elementType, i, sourceLocation).equals(targetType.elementType),
          ),
          errorMessage,
          sourceLocation,
        )
        return targetType
      }
    }
    if (sourceType instanceof ObjectPType) {
      // Recursively narrow object properties
      codeInvariant(targetType instanceof ObjectPType, errorMessage)
      const targetPropertyOrder = targetType
        .orderedProperties()
        .reduce((acc, [prop], index) => acc.set(prop, index), new Map<string, number>())
      return new ObjectPType({
        alias: targetType.alias,
        description: targetType.description,
        properties: Object.fromEntries(
          sourceType
            .orderedProperties()
            .map(([prop, propType]): [string, PType] => [
              prop,
              prop in targetType.properties
                ? this.buildAssignmentExpressionType(targetType.getPropertyType(prop), propType, sourceLocation)
                : propType,
            ])
            .toSorted(sortBy(([prop]) => targetPropertyOrder.get(prop) ?? Number.MAX_SAFE_INTEGER)),
        ),
      })
    }
    // Array<never> can be assigned to any target array type
    if (sourceType instanceof ArrayPType && sourceType.elementType.equals(neverPType)) {
      codeInvariant(targetType instanceof ArrayPType, errorMessage)
      return targetType
    }
    return sourceType
  }

  buildLValue(target: InstanceBuilder, assignmentType: PType, sourceLocation: SourceLocation): LValue {
    if (target instanceof ArrayLiteralExpressionBuilder) {
      if (assignmentType instanceof TuplePType) {
        const targetItems = target[StaticIterator]()

        const targets: LValue[] = []
        for (const [index, sourceItemType] of enumerate(assignmentType.items)) {
          const targetItem = targetItems[index]
          if (targetItem && !(targetItem instanceof OmittedExpressionBuilder)) {
            targets.push(this.buildLValue(targetItem, sourceItemType, sourceLocation))
          } else {
            targets.push(
              nodeFactory.varExpression({
                name: this.context.generateDiscardedVarName(),
                sourceLocation,
                wtype: sourceItemType.wtypeOrThrow,
              }),
            )
          }
        }
        return nodeFactory.tupleExpression({ items: targets, sourceLocation })
      }
    }
    if (target instanceof ObjectLiteralExpressionBuilder) {
      if (assignmentType instanceof ObjectPType) {
        const targets: LValue[] = []
        for (const [propName, propType] of assignmentType.orderedProperties()) {
          if (target.hasProperty(propName)) {
            targets.push(this.buildLValue(requireInstanceBuilder(target.memberAccess(propName, sourceLocation)), propType, sourceLocation))
          } else {
            targets.push(
              nodeFactory.varExpression({
                name: this.context.generateDiscardedVarName(),
                sourceLocation,
                wtype: propType.wtypeOrThrow,
              }),
            )
          }
        }
        return nodeFactory.tupleExpression({ items: targets, sourceLocation, wtype: assignmentType.wtype })
      }
    }
    if (target.ptype.equals(assignmentType)) {
      return target.resolveLValue()
    }
    throw new CodeError(
      `The target of an assignment must have the same type as the source. Target: ${target.ptype}, Source: ${assignmentType}`,
      {
        sourceLocation,
      },
    )
  }

  protected parseMemberModifiers(node: { modifiers?: readonly ts.ModifierLike[] }) {
    let isPublic = true
    let isStatic = false
    if (node.modifiers)
      for (const m of node.modifiers) {
        switch (m.kind) {
          case ts.SyntaxKind.StaticKeyword:
            isStatic = true
            continue
          case ts.SyntaxKind.PublicKeyword:
            isPublic = true
            continue
          case ts.SyntaxKind.ProtectedKeyword:
            isPublic = false
            continue
          case ts.SyntaxKind.PrivateKeyword:
            isPublic = false
            continue
          case ts.SyntaxKind.AbstractKeyword:
            continue
          case ts.SyntaxKind.AccessorKeyword:
            logger.error(this.sourceLocation(m), 'properties are not supported')
            continue
          case ts.SyntaxKind.AsyncKeyword:
            logger.error(this.sourceLocation(m), 'async keyword is not supported')
            continue
          case ts.SyntaxKind.DeclareKeyword:
            logger.error(this.sourceLocation(m), 'declare keyword is not supported')
            continue
          case ts.SyntaxKind.ExportKeyword:
          case ts.SyntaxKind.ConstKeyword:
          case ts.SyntaxKind.DefaultKeyword:
          case ts.SyntaxKind.ReadonlyKeyword:
          case ts.SyntaxKind.OverrideKeyword:
          case ts.SyntaxKind.InKeyword:
          case ts.SyntaxKind.OutKeyword:
          case ts.SyntaxKind.Decorator:
            // Ignore for now
            continue
        }
      }
    return {
      isStatic,
      isPublic,
    }
  }

  protected getNodeDescription(node: ts.Node): string | null {
    const docs = ts.getJSDocCommentsAndTags(node)
    for (const doc of docs) {
      if (ts.isJSDoc(doc)) {
        return ts.getTextOfJSDocComment(doc.comment) ?? null
      }
    }
    return null
  }

  protected getMethodDocumentation(node: ts.FunctionDeclaration | ts.MethodDeclaration | ts.ConstructorDeclaration): MethodDocumentation {
    const docs = Array.from(ts.getJSDocCommentsAndTags(node))
    let description: string | null = null
    const args = new Map<string, string>()
    let returns: string | null = null
    for (const doc of docs) {
      if (ts.isJSDoc(doc)) {
        description = ts.getTextOfJSDocComment(doc.comment) ?? null
        if (doc.tags) docs.push(...doc.tags)
      } else if (ts.isJSDocParameterTag(doc)) {
        const paramName = this.textVisitor.accept(doc.name)
        const paramComment = ts.getTextOfJSDocComment(doc.comment)

        args.set(paramName, paramComment ?? '')
      } else if (ts.isJSDocReturnTag(doc)) {
        returns = ts.getTextOfJSDocComment(doc.comment) ?? null
      }
    }
    return nodeFactory.methodDocumentation({
      description,
      args,
      returns,
    })
  }
}



================================================
FILE: src/awst_build/ast-visitors/constructor-visitor.ts
================================================
import ts from 'typescript'
import type { ContractReference } from '../../awst/models'
import { nodeFactory } from '../../awst/node-factory'
import * as awst from '../../awst/nodes'
import { logger } from '../../logger'
import { codeInvariant, invariant } from '../../util'
import type { ContractClassPType } from '../ptypes'
import { voidPType } from '../ptypes'
import { ContractMethodBaseVisitor } from './contract-method-visitor'
import { visitInChildContext } from './util'

export interface ConstructorInfo {
  propertyInitializerStatements: awst.Statement[]
  cref: ContractReference
}

export class ConstructorVisitor extends ContractMethodBaseVisitor {
  private _foundSuperCall = false
  constructor(
    node: ts.ConstructorDeclaration,
    contractType: ContractClassPType,
    private readonly contractInfo: ConstructorInfo,
  ) {
    super(node, contractType)
  }

  get result() {
    const sourceLocation = this.sourceLocation(this.node)
    const { args, body, documentation } = this.buildFunctionAwst()
    return new awst.ContractMethod({
      arc4MethodConfig: null,
      memberName: this._functionType.name,
      sourceLocation,
      args,
      returnType: voidPType.wtype,
      body,
      cref: this.contractInfo.cref,
      documentation,
      inline: null,
    })
  }

  public static buildConstructor(
    node: ts.ConstructorDeclaration,
    contractType: ContractClassPType,
    constructorMethodInfo: ConstructorInfo,
  ) {
    return visitInChildContext(this, node, contractType, constructorMethodInfo)
  }

  visitBlock(node: ts.Block): awst.Block {
    return nodeFactory.block(
      {
        sourceLocation: this.sourceLocation(node),
      },
      node.statements.flatMap((s) => {
        try {
          const statement = this.accept(s)
          if (isSuperCall(s)) {
            // Property initializer statements should be injected immediately after the super() call
            codeInvariant(!this._foundSuperCall, 'A constructor can only contain one call to super()')
            this._foundSuperCall = true
            return nodeFactory.block(
              {
                sourceLocation: this.sourceLocation(s),
              },
              ...(Array.isArray(statement) ? statement : [statement]),
              ...this.contractInfo.propertyInitializerStatements,
            )
          }
          return statement
        } catch (e) {
          invariant(e instanceof Error, 'Only errors should be thrown')
          logger.error(e)
          return []
        }
      }),
    )
  }
}

function isSuperCall(node: ts.Statement) {
  return (
    ts.isExpressionStatement(node) && ts.isCallExpression(node.expression) && node.expression.expression.kind === ts.SyntaxKind.SuperKeyword
  )
}



================================================
FILE: src/awst_build/ast-visitors/contract-method-visitor.ts
================================================
import type ts from 'typescript'
import { ContractReference, OnCompletionAction } from '../../awst/models'
import { nodeFactory } from '../../awst/node-factory'
import type { ABIMethodArgConstantDefault, ABIMethodArgMemberDefault, ARC4MethodConfig } from '../../awst/nodes'
import * as awst from '../../awst/nodes'
import { ARC4ABIMethodConfig, ARC4BareMethodConfig, ARC4CreateOption } from '../../awst/nodes'
import type { SourceLocation } from '../../awst/source-location'
import { Constants } from '../../constants'
import { CodeError } from '../../errors'
import { logger } from '../../logger'
import { codeInvariant, invariant, isIn, sameSets } from '../../util'
import { ptypeToAbiPType } from '../arc4-util'
import type { NodeBuilder } from '../eb'
import { ContractSuperBuilder, ContractThisBuilder } from '../eb/contract-builder'
import { requireExpressionOfType } from '../eb/util'
import type { Arc4AbiDecoratorData, RoutingDecoratorData } from '../models/decorator-data'
import type { ContractClassPType, FunctionPType } from '../ptypes'
import { GlobalStateType, LocalStateType, voidPType } from '../ptypes'
import { DecoratorVisitor } from './decorator-visitor'
import { FunctionVisitor } from './function-visitor'
import { visitInChildContext } from './util'

export class ContractMethodBaseVisitor extends FunctionVisitor {
  protected readonly _contractType: ContractClassPType
  constructor(node: ts.MethodDeclaration | ts.ConstructorDeclaration, contractType: ContractClassPType) {
    super(node)
    this._contractType = contractType
  }
  visitSuperKeyword(node: ts.SuperExpression): NodeBuilder {
    const sourceLocation = this.sourceLocation(node)

    // Only the polytype clustered class should have more than one base type, and it shouldn't have
    // any user code with super calls
    invariant(this._contractType.baseTypes.length === 1, 'Super keyword only valid if contract has a single base type')
    return new ContractSuperBuilder(this._contractType.baseTypes[0], sourceLocation)
  }

  visitThisKeyword(node: ts.ThisExpression): NodeBuilder {
    const sourceLocation = this.sourceLocation(node)
    return new ContractThisBuilder(this._contractType, sourceLocation)
  }
}

type RoutingProps = {
  allowedCompletionTypes?: OnCompletionAction[]
  create?: ARC4CreateOption
}

export class ContractMethodVisitor extends ContractMethodBaseVisitor {
  private readonly metaData: {
    cref: ContractReference
    arc4MethodConfig: ARC4MethodConfig | null
    sourceLocation: SourceLocation
  }

  constructor(node: ts.MethodDeclaration, contractType: ContractClassPType) {
    super(node, contractType)
    const sourceLocation = this.sourceLocation(node)

    const decorator = DecoratorVisitor.buildContractMethodData(node)
    const cref = ContractReference.fromPType(this._contractType)

    const modifiers = this.parseMemberModifiers(node)

    const arc4MethodConfig = this.buildArc4Config({
      functionType: this._functionType,
      decorator,
      modifiers,
      methodLocation: sourceLocation,
    })

    if (arc4MethodConfig)
      this.context.addArc4Config({
        contractReference: cref,
        sourceLocation,
        arc4MethodConfig,
        memberName: this._functionType.name,
      })
    this.metaData = {
      arc4MethodConfig,
      cref,
      sourceLocation,
    }
  }

  get result() {
    const { args, body, documentation } = this.buildFunctionAwst()

    return new awst.ContractMethod({
      arc4MethodConfig: this.metaData.arc4MethodConfig,
      memberName: this._functionType.name,
      sourceLocation: this.metaData.sourceLocation,
      args,
      returnType: this._functionType.returnType.wtypeOrThrow,
      body,
      cref: this.metaData.cref,
      documentation,
      inline: null,
    })
  }

  public static buildContractMethod(node: ts.MethodDeclaration, contractType: ContractClassPType): () => awst.ContractMethod {
    return visitInChildContext(this, node, contractType)
  }

  private buildArc4Config({
    functionType,
    decorator,
    modifiers: { isPublic, isStatic },
    methodLocation,
  }: {
    functionType: FunctionPType
    decorator: RoutingDecoratorData | undefined
    modifiers: { isPublic: boolean; isStatic: boolean }
    methodLocation: SourceLocation
  }): awst.ARC4MethodConfig | null {
    const isProgramMethod = isIn(functionType.name, [
      Constants.symbolNames.approvalProgramMethodName,
      Constants.symbolNames.clearStateProgramMethodName,
    ])

    if (decorator && isIn(decorator.type, [Constants.symbolNames.arc4BareDecoratorName, Constants.symbolNames.arc4AbiDecoratorName])) {
      if (!isPublic) {
        logger.error(methodLocation, 'Private or protected methods cannot be exposed as an abi method')
        return null
      }
      if (isStatic) {
        logger.error(methodLocation, 'Static methods cannot be exposed as an abi method')
        return null
      }
      if (isProgramMethod) {
        logger.error(methodLocation, `${functionType.name} is reserved for program implementations and cannot be used as an abi method`)
        return null
      }
    }
    if (isProgramMethod || !isPublic || isStatic) return null

    const conventionalDefaults = this.getConventionalRoutingConfig(functionType.name)

    this.validateDecoratorRoutingData(functionType, decorator, conventionalDefaults)

    // Default routing properties used when these values aren't specified explicitly.
    const unspecifiedDefaults = {
      allowedCompletionTypes: [OnCompletionAction.NoOp],
      create: ARC4CreateOption.disallow,
    }

    if (decorator?.type === 'arc4.baremethod') {
      this.checkBareMethodTypes(functionType, methodLocation)
      return new ARC4BareMethodConfig({
        sourceLocation: decorator.sourceLocation,
        allowedCompletionTypes:
          decorator.allowedCompletionTypes ?? conventionalDefaults?.allowedCompletionTypes ?? unspecifiedDefaults.allowedCompletionTypes,
        create: decorator.create ?? conventionalDefaults?.create ?? unspecifiedDefaults.create,
      })
    }

    if (decorator?.type === 'arc4.abimethod') {
      this.checkABIMethodTypes(functionType, methodLocation)
      return new ARC4ABIMethodConfig({
        readonly: decorator.readonly,
        sourceLocation: decorator.sourceLocation,
        allowedCompletionTypes:
          decorator.allowedCompletionTypes ?? conventionalDefaults?.allowedCompletionTypes ?? unspecifiedDefaults.allowedCompletionTypes,
        create: decorator.create ?? conventionalDefaults?.create ?? unspecifiedDefaults.create,
        name: decorator.nameOverride ?? functionType.name,
        defaultArgs: new Map(
          Object.entries(decorator.defaultArguments).map(([parameterName, argConfig]) => [
            parameterName,
            this.buildDefaultArgument({
              methodName: functionType.name,
              parameterName,
              config: argConfig,
              decoratorLocation: decorator.sourceLocation,
            }),
          ]),
        ),
      })
    } else if (isPublic && this._contractType.isARC4) {
      this.checkABIMethodTypes(functionType, methodLocation)
      return new ARC4ABIMethodConfig({
        allowedCompletionTypes: conventionalDefaults?.allowedCompletionTypes ?? unspecifiedDefaults.allowedCompletionTypes,
        create: conventionalDefaults?.create ?? unspecifiedDefaults.create,
        sourceLocation: methodLocation,
        name: functionType.name,
        readonly: false,
        defaultArgs: new Map(),
      })
    }
    return null
  }

  private validateDecoratorRoutingData(
    functionType: FunctionPType,
    decorator: RoutingDecoratorData | undefined,
    impliedByConvention: RoutingProps | undefined,
  ) {
    if (!decorator || !impliedByConvention) return

    if (
      decorator.allowedCompletionTypes !== undefined &&
      impliedByConvention.allowedCompletionTypes !== undefined &&
      !sameSets(decorator.allowedCompletionTypes, impliedByConvention.allowedCompletionTypes)
    ) {
      const impliedOcaNames = impliedByConvention.allowedCompletionTypes.map((oca) => OnCompletionAction[oca]).join(', ')
      logger.error(
        decorator.allowedCompletionTypesLocation ?? decorator.sourceLocation,
        `allowActions for conventional routing method '${functionType.name}' must be: ${impliedOcaNames}`,
      )
    }
    if (decorator.create !== undefined && impliedByConvention.create !== undefined && decorator.create !== impliedByConvention.create) {
      const impliedCreateAction = ARC4CreateOption[impliedByConvention.create]
      logger.error(
        decorator.createLocation ?? decorator.sourceLocation,
        `onCreate for conventional routing method '${functionType.name}' must be: ${impliedCreateAction}`,
      )
    }
  }

  /**
   * Get routing properties inferred by conventional naming
   * @param methodName The name of the method
   * @private
   */
  private getConventionalRoutingConfig(methodName: string): RoutingProps | undefined {
    switch (methodName) {
      case Constants.symbolNames.conventionalRouting.closeOutOfApplicationMethodName:
        return {
          allowedCompletionTypes: [OnCompletionAction.CloseOut],
          create: ARC4CreateOption.disallow,
        }
      case Constants.symbolNames.conventionalRouting.createApplicationMethodName:
        return {
          create: ARC4CreateOption.require,
        }
      case Constants.symbolNames.conventionalRouting.deleteApplicationMethodName:
        return {
          allowedCompletionTypes: [OnCompletionAction.DeleteApplication],
        }
      case Constants.symbolNames.conventionalRouting.optInToApplicationMethodName:
        return {
          allowedCompletionTypes: [OnCompletionAction.OptIn],
        }
      case Constants.symbolNames.conventionalRouting.updateApplicationMethodName:
        return {
          allowedCompletionTypes: [OnCompletionAction.UpdateApplication],
          create: ARC4CreateOption.disallow,
        }
      default:
        return undefined
    }
  }

  checkABIMethodTypes(functionType: FunctionPType, sourceLocation: SourceLocation) {
    for (const [, paramType] of functionType.parameters) {
      codeInvariant(
        ptypeToAbiPType(paramType, 'in', sourceLocation),
        'ABI method parameter types must have an ARC4 equivalent',
        sourceLocation,
      )
    }
    codeInvariant(
      ptypeToAbiPType(functionType.returnType, 'out', sourceLocation),
      'ABI method return type must have an ARC4 equivalent',
      sourceLocation,
    )
  }

  checkBareMethodTypes(functionType: FunctionPType, sourceLocation: SourceLocation) {
    codeInvariant(functionType.parameters.length === 0, 'Bare methods cannot have any parameters', sourceLocation)
    codeInvariant(functionType.returnType.equals(voidPType), 'Bare method return type must be void', sourceLocation)
  }

  private buildDefaultArgument({
    methodName,
    parameterName,
    config,
    decoratorLocation,
  }: {
    methodName: string
    parameterName: string
    config: Arc4AbiDecoratorData['defaultArguments'][string]
    decoratorLocation: SourceLocation
  }): ABIMethodArgMemberDefault | ABIMethodArgConstantDefault {
    const [, paramType] = this._contractType.methods[methodName].parameters.find(([p]) => p === parameterName) ?? [undefined, undefined]
    codeInvariant(
      paramType,
      `Default argument specification '${parameterName}' does not match any parameters on the target method`,
      decoratorLocation,
    )
    if (config.type === 'constant') {
      return nodeFactory.aBIMethodArgConstantDefault({
        value: requireExpressionOfType(config.value, paramType),
      })
    }
    const methodType = this._contractType.methods[config.name]
    if (methodType) {
      codeInvariant(
        methodType.returnType.equals(paramType),
        `Default argument specification for '${parameterName}' does not match parameter type`,
        decoratorLocation,
      )
      return nodeFactory.aBIMethodArgMemberDefault({
        name: config.name,
      })
    }
    const propertyType = this._contractType.properties[config.name]
    if (propertyType instanceof GlobalStateType || propertyType instanceof LocalStateType) {
      codeInvariant(
        propertyType.contentType.equals(paramType),
        `Default argument specification for '${parameterName}' does not match parameter type`,
        decoratorLocation,
      )
      return nodeFactory.aBIMethodArgMemberDefault({
        name: config.name,
      })
    }
    throw new CodeError('Unsupported default argument config', { sourceLocation: decoratorLocation })
  }
}



================================================
FILE: src/awst_build/ast-visitors/contract-visitor.ts
================================================
import ts from 'typescript'
import { ContractReference } from '../../awst/models'
import { nodeFactory } from '../../awst/node-factory'
import type * as awst from '../../awst/nodes'
import type { ContractMethod } from '../../awst/nodes'
import type { SourceLocation } from '../../awst/source-location'
import { wtypes } from '../../awst/wtypes'
import { Constants } from '../../constants'
import { logger } from '../../logger'
import { codeInvariant, invariant } from '../../util'
import type { ClassElements } from '../../visitor/syntax-names'
import type { Visitor } from '../../visitor/visitor'
import { accept } from '../../visitor/visitor'
import { ContractSuperBuilder } from '../eb/contract-builder'
import { BoxProxyExpressionBuilder } from '../eb/storage/box'
import { GlobalStateFunctionResultBuilder } from '../eb/storage/global-state'
import { LocalStateFunctionResultBuilder } from '../eb/storage/local-state'
import { requireInstanceBuilder } from '../eb/util'
import { ContractClassModel } from '../models/contract-class-model'
import type { ContractOptionsDecoratorData } from '../models/decorator-data'
import type { ContractClassPType } from '../ptypes'
import { BaseVisitor } from './base-visitor'
import { ConstructorVisitor } from './constructor-visitor'
import { ContractMethodVisitor } from './contract-method-visitor'
import { DecoratorVisitor } from './decorator-visitor'
import { visitInChildContext } from './util'

export class ContractVisitor extends BaseVisitor implements Visitor<ClassElements, void> {
  private _ctor?: () => ContractMethod
  private _methods: Array<() => ContractMethod> = []
  private readonly _contractPType: ContractClassPType
  private readonly _propertyInitialization: awst.Statement[] = []
  public accept = <TNode extends ts.Node>(node: TNode) => accept<ContractVisitor, TNode>(this, node)

  private readonly metaData: {
    isAbstract: boolean
    contractOptions: ContractOptionsDecoratorData | undefined
    sourceLocation: SourceLocation
    description: string | null
  }

  constructor(classDec: ts.ClassDeclaration, ptype: ContractClassPType) {
    super()
    const sourceLocation = this.context.getSourceLocation(classDec)
    codeInvariant(classDec.name, 'Anonymous classes are not supported for contracts', sourceLocation)

    this._contractPType = ptype

    const contractOptions = DecoratorVisitor.buildContractData(classDec)

    const isAbstract = Boolean(classDec.modifiers?.some((m) => m.kind === ts.SyntaxKind.AbstractKeyword))

    for (const property of classDec.members.filter(ts.isPropertyDeclaration)) {
      this.acceptAndIgnoreBuildErrors(property)
    }
    const ctor = classDec.members.find(ts.isConstructorDeclaration)
    if (ctor) this.acceptAndIgnoreBuildErrors(ctor)

    for (const member of classDec.members) {
      if (!ts.isConstructorDeclaration(member) && !ts.isPropertyDeclaration(member)) {
        this.acceptAndIgnoreBuildErrors(member)
      }
    }

    this.metaData = {
      isAbstract,
      sourceLocation,
      contractOptions,
      description: this.getNodeDescription(classDec),
    }
  }

  get result(): [] | [awst.Contract] {
    const { isAbstract, sourceLocation, contractOptions, description } = this.metaData

    let approvalProgram: ContractMethod | null = null
    let clearProgram: ContractMethod | null = null
    const methods: ContractMethod[] = []
    const ctor: ContractMethod | null = this._ctor?.() ?? this.makeDefaultConstructor(sourceLocation)

    for (const deferredMethod of this._methods) {
      const contractMethod = deferredMethod()
      switch (contractMethod.memberName) {
        case Constants.symbolNames.approvalProgramMethodName:
          approvalProgram = contractMethod
          break
        case Constants.symbolNames.clearStateProgramMethodName:
          clearProgram = contractMethod
          break
        default:
          methods.push(contractMethod)
      }
    }

    const contract = new ContractClassModel({
      type: this._contractPType,
      propertyInitialization: this._propertyInitialization,
      isAbstract: isAbstract,
      appState: this.context.getStorageDefinitionsForContract(this._contractPType),
      ctor,
      methods,
      description,
      approvalProgram,
      clearProgram,
      options: contractOptions,
      sourceLocation: sourceLocation,
    })
    this.context.addToCompilationSet(contract.id, contract)
    const contractClass = this.context.compilationSet.getContractClass(ContractReference.fromPType(this._contractPType))
    if (!contractClass.isAbstract) {
      return [contractClass.buildContract(this.context.compilationSet)]
    }
    return []
  }

  private acceptAndIgnoreBuildErrors(node: ts.ClassElement) {
    try {
      this.accept(node)
    } catch (e) {
      invariant(e instanceof Error, 'Only errors should be thrown')
      logger.error(e)
    }
  }

  private makeDefaultConstructor(sourceLocation: SourceLocation) {
    // If there is no property initialization, we don't need an implicit constructor
    if (this._propertyInitialization.length === 0) return null
    invariant(this._contractPType.baseTypes.length === 1, 'Only single base type supported for now')
    return nodeFactory.contractMethod({
      memberName: Constants.symbolNames.constructorMethodName,
      cref: ContractReference.fromPType(this._contractPType),
      args: [],
      arc4MethodConfig: null,
      sourceLocation,
      returnType: wtypes.voidWType,

      documentation: nodeFactory.methodDocumentation(),
      body: nodeFactory.block(
        { sourceLocation },
        nodeFactory.expressionStatement({
          expr: requireInstanceBuilder(
            new ContractSuperBuilder(this._contractPType.baseTypes[0], sourceLocation).call([], [], sourceLocation),
          ).resolve(),
        }),
        ...this._propertyInitialization,
      ),
      inline: null,
    })
  }

  visitClassStaticBlockDeclaration(node: ts.ClassStaticBlockDeclaration): void {
    this.throwNotSupported(node, 'class static blocks')
  }
  visitConstructor(node: ts.ConstructorDeclaration): void {
    this._ctor = ConstructorVisitor.buildConstructor(node, this._contractPType, {
      cref: ContractReference.fromPType(this._contractPType),
      propertyInitializerStatements: this._propertyInitialization,
    })
  }
  visitGetAccessor(node: ts.GetAccessorDeclaration): void {
    this.throwNotSupported(node, 'get accessors')
  }
  visitIndexSignature(node: ts.IndexSignatureDeclaration): void {
    this.throwNotSupported(node, 'index signatures')
  }

  visitMethodDeclaration(node: ts.MethodDeclaration): void {
    this._methods.push(ContractMethodVisitor.buildContractMethod(node, this._contractPType))
  }
  visitPropertyDeclaration(node: ts.PropertyDeclaration): void {
    const sourceLocation = this.sourceLocation(node)
    codeInvariant(!node.questionToken, 'Optional properties are not supported', sourceLocation)
    codeInvariant(!node.exclamationToken, 'Non-null assertion operators on properties are not supported', sourceLocation)
    codeInvariant(!node.modifiers?.some((m) => m.kind === ts.SyntaxKind.StaticKeyword), 'Static properties are not supported')

    const propertyName = this.textVisitor.accept(node.name)
    codeInvariant(node.initializer, 'Properties must have an initializer', sourceLocation)
    if (node.type) {
      logger.info(sourceLocation, 'Type annotations are not required on initialized properties')
    }
    const initializer = this.accept(node.initializer)

    if (initializer instanceof GlobalStateFunctionResultBuilder) {
      const storageDeclaration = initializer.buildStorageDeclaration(
        propertyName,
        this.sourceLocation(node.name),
        this.getNodeDescription(node),
        this._contractPType,
      )
      this.context.addStorageDeclaration(storageDeclaration)
      if (initializer.initialValue) {
        this._propertyInitialization.push(
          nodeFactory.assignmentStatement({
            target: nodeFactory.appStateExpression({
              key: storageDeclaration.key,
              wtype: storageDeclaration.ptype.contentType.wtypeOrThrow,
              sourceLocation: storageDeclaration.sourceLocation,
              existsAssertionMessage: null,
            }),
            value: initializer.initialValue,
            sourceLocation,
          }),
        )
      }
    } else if (initializer instanceof BoxProxyExpressionBuilder || initializer instanceof LocalStateFunctionResultBuilder) {
      this.context.addStorageDeclaration(
        initializer.buildStorageDeclaration(
          propertyName,
          this.sourceLocation(node.name),
          this.getNodeDescription(node),
          this._contractPType,
        ),
      )
    } else {
      logger.error(
        initializer.sourceLocation,
        `Unsupported property type ${initializer.typeDescription}. Only GlobalState, LocalState, and Box proxies can be stored on a contract.`,
      )
    }
  }
  visitSemicolonClassElement(node: ts.SemicolonClassElement): void {
    // Ignore
  }
  visitSetAccessor(node: ts.SetAccessorDeclaration): void {
    this.throwNotSupported(node, 'set accessors')
  }

  public static buildContract(classDec: ts.ClassDeclaration, ptype: ContractClassPType) {
    return visitInChildContext(this, classDec, ptype)
  }
}



================================================
FILE: src/awst_build/ast-visitors/decorator-visitor.ts
================================================
import ts from 'typescript'
import { logger } from '../../logger'
import { invariant, isIn } from '../../util'
import { accept } from '../../visitor/visitor'
import { AwstBuildContext } from '../context/awst-build-context'
import { DecoratorDataBuilder } from '../eb'
import type { DecoratorData, DecoratorDataForType, DecoratorType } from '../models/decorator-data'
import { BaseVisitor } from './base-visitor'

export class DecoratorVisitor extends BaseVisitor {
  private accept = <TNode extends ts.Node>(node: TNode) => accept<DecoratorVisitor, TNode>(this, node)

  public readonly result: DecoratorData

  constructor(node: ts.Decorator) {
    super()

    const expr = this.accept(node.expression)
    invariant(expr instanceof DecoratorDataBuilder, 'expr must be DecoratorDataBuilder')
    this.result = expr.resolveDecoratorData()
  }

  private static buildDecoratorData(node: { modifiers?: ts.NodeArray<ts.ModifierLike> }): DecoratorData[] {
    return (
      node.modifiers?.flatMap((modifier) => {
        if (!ts.isDecorator(modifier)) return []
        try {
          return AwstBuildContext.current.runInChildContext(() => new DecoratorVisitor(modifier).result)
        } catch (e) {
          invariant(e instanceof Error, 'Only errors should be thrown')
          logger.error(e)
          return []
        }
      }) ?? []
    )
  }

  static buildContractData(target: ts.ClassDeclaration) {
    const data = DecoratorVisitor.buildDecoratorData(target)
    return DecoratorVisitor.filterDecoratorData(
      data,
      ['contract'],
      (t) => `${t} is not supported on contracts`,
      'Only one decorator is allowed per contract.',
    )
  }
  static buildLogicSigData(target: ts.ClassDeclaration) {
    const data = DecoratorVisitor.buildDecoratorData(target)
    return DecoratorVisitor.filterDecoratorData(
      data,
      ['logicsig'],
      (t) => `${t} is not supported on logic signatures`,
      'Only one decorator is allowed per logic signature.',
    )
  }
  static buildContractMethodData(target: ts.MethodDeclaration) {
    const data = DecoratorVisitor.buildDecoratorData(target)
    return DecoratorVisitor.filterDecoratorData(
      data,
      ['arc4.abimethod', 'arc4.baremethod'],
      (t) => `${t} is not supported on contract methods`,
      'Only one decorator is allowed per method. Multiple on complete actions can be provided in a single decorator',
    )
  }

  private static filterDecoratorData<TType extends DecoratorType>(
    decoratorData: DecoratorData[],
    types: TType[],
    notSupportedMessage: (type: DecoratorType) => string,
    duplicateMessage: string,
  ): DecoratorDataForType<TType> | undefined {
    let data: DecoratorDataForType<TType> | undefined
    for (const d of decoratorData) {
      if (isIn(d.type, types)) {
        if (data === undefined) {
          data = d as DecoratorDataForType<TType>
        } else {
          logger.error(d.sourceLocation, duplicateMessage)
        }
      } else {
        logger.error(d.sourceLocation, notSupportedMessage(d.type))
      }
    }
    return data
  }
}



================================================
FILE: src/awst_build/ast-visitors/function-visitor.ts
================================================
import ts from 'typescript'
import { isConstant } from '../../awst'
import { nodeFactory } from '../../awst/node-factory'
import type * as awst from '../../awst/nodes'
import type { Block } from '../../awst/nodes'
import { AssignmentExpression, Goto, ReturnStatement } from '../../awst/nodes'
import type { SourceLocation } from '../../awst/source-location'
import { CodeError, InternalError, NotSupported } from '../../errors'
import { logger } from '../../logger'
import { codeInvariant, enumerate, hasFlags, instanceOfAny, invariant } from '../../util'
import type { Statements } from '../../visitor/syntax-names'
import { getNodeName } from '../../visitor/syntax-names'
import type { Visitor } from '../../visitor/visitor'
import { accept } from '../../visitor/visitor'
import type { InstanceBuilder } from '../eb'
import { BuilderComparisonOp } from '../eb'
import { ArrayLiteralExpressionBuilder } from '../eb/literal/array-literal-expression-builder'
import { ObjectLiteralExpressionBuilder } from '../eb/literal/object-literal-expression-builder'
import { NativeArrayExpressionBuilder } from '../eb/native-array-expression-builder'
import { OmittedExpressionBuilder } from '../eb/omitted-expression-builder'
import { TupleExpressionBuilder } from '../eb/tuple-expression-builder'
import { requireExpressionOfType, requireInstanceBuilder } from '../eb/util'
import type { PType } from '../ptypes'
import { FunctionPType, ObjectPType } from '../ptypes'
import { getSequenceItemType } from '../ptypes/util'
import { typeRegistry } from '../type-registry'
import { BaseVisitor } from './base-visitor'
import { maybeNodes } from './util'

// noinspection JSUnusedGlobalSymbols
export abstract class FunctionVisitor
  extends BaseVisitor
  implements
    Visitor<ts.ParameterDeclaration, awst.SubroutineArgument>,
    Visitor<ts.Block, awst.Block>,
    Visitor<Statements, awst.Statement | awst.Statement[]>
{
  protected accept = <TNode extends ts.Node>(node: TNode) => accept<FunctionVisitor, TNode>(this, node)

  protected readonly _functionType: FunctionPType

  constructor(protected readonly node: ts.MethodDeclaration | ts.FunctionDeclaration | ts.ConstructorDeclaration) {
    super()
    const type = this.context.getPTypeForNode(node)
    invariant(type instanceof FunctionPType, 'type of function must be FunctionPType')
    this._functionType = type
  }

  protected buildFunctionAwst(): {
    args: awst.SubroutineArgument[]
    documentation: awst.MethodDocumentation
    body: awst.Block
  } {
    const node = this.node
    const sourceLocation = this.sourceLocation(node)

    const args = node.parameters.map((p) => this.accept(p))
    const assignDestructuredParams = this.evaluateParameterBindingExpressions(node.parameters, sourceLocation)
    codeInvariant(node.body, 'Functions must have a body')
    const body = assignDestructuredParams.length
      ? nodeFactory.block({ sourceLocation }, assignDestructuredParams, this.accept(node.body))
      : this.accept(node.body)

    return {
      args,
      body,
      documentation: this.getMethodDocumentation(node),
    }
  }

  visitBindingName(bindingName: ts.BindingName, sourceLocation: SourceLocation): InstanceBuilder {
    switch (bindingName.kind) {
      case ts.SyntaxKind.ObjectBindingPattern: {
        const props = Array<[string, InstanceBuilder]>()
        for (const element of bindingName.elements) {
          const sourceLocation = this.sourceLocation(element)

          const propertyNameIdentifier = element.propertyName ?? element.name
          invariant(ts.isIdentifier(propertyNameIdentifier), 'propertyName must be an identifier')

          const propertyName = this.textVisitor.accept(propertyNameIdentifier)
          codeInvariant(!element.dotDotDotToken, 'Spread operator is not supported', sourceLocation)
          codeInvariant(!element.initializer, 'Initializer on object binding pattern is not supported', sourceLocation)

          props.push([propertyName, this.visitBindingName(element.name, sourceLocation)])
        }
        const ptype = ObjectPType.anonymous(props.map(([name, builder]): [string, PType] => [name, builder.ptype]))
        return new ObjectLiteralExpressionBuilder(sourceLocation, ptype, [{ type: 'properties', properties: Object.fromEntries(props) }])
      }
      case ts.SyntaxKind.ArrayBindingPattern: {
        const items: InstanceBuilder[] = []
        for (const element of bindingName.elements) {
          const sourceLocation = this.context.getSourceLocation(element)

          if (ts.isOmittedExpression(element)) {
            items.push(new OmittedExpressionBuilder(sourceLocation))
          } else {
            codeInvariant(!element.initializer, 'Initializer on array binding expression is not supported', sourceLocation)
            codeInvariant(!element.propertyName, 'Property name on array binding expression is not supported', sourceLocation)

            if (element.dotDotDotToken) {
              const spreadResult = this.visitBindingName(element.name, sourceLocation)
              if (spreadResult instanceof NativeArrayExpressionBuilder) {
                throw new CodeError(
                  'Spread operator is not supported in assignment expressions where the resulting type is a variadic array',
                  { sourceLocation },
                )
              } else if (spreadResult instanceof TupleExpressionBuilder) {
                throw new CodeError('Spread operator is not currently supported with tuple expressions', { sourceLocation })
              } else {
                throw InternalError.shouldBeUnreachable()
              }
            } else {
              items.push(this.visitBindingName(element.name, sourceLocation))
            }
          }
        }
        return new ArrayLiteralExpressionBuilder(sourceLocation, items)
      }

      case ts.SyntaxKind.Identifier: {
        return requireInstanceBuilder(this.accept(bindingName))
      }
      default:
        throw new InternalError('Unhandled binding name', { sourceLocation })
    }
  }
  evaluateParameterBindingExpressions(parameters: Iterable<ts.ParameterDeclaration>, sourceLocation: SourceLocation): awst.Statement[] {
    const assignments: awst.Statement[] = []
    for (const p of parameters) {
      const sourceLocation = this.sourceLocation(p)
      if (!ts.isIdentifier(p.name)) {
        const paramPType = this.context.getPTypeForNode(p)
        const paramName = this.context.resolveDestructuredParamName(p)
        const paramBuilder = typeRegistry.getInstanceEb(
          nodeFactory.varExpression({
            name: paramName,
            sourceLocation,
            wtype: paramPType.wtypeOrThrow,
          }),
          paramPType,
        )

        assignments.push(this.handleAssignmentStatement(this.visitBindingName(p.name, sourceLocation), paramBuilder, sourceLocation))
      }
    }

    if (assignments.length === 0) return []

    return [
      nodeFactory.block(
        {
          sourceLocation,
          comment: 'Destructured params',
        },
        ...assignments,
      ),
    ]
  }

  visitTypeAliasDeclaration(node: ts.TypeAliasDeclaration): awst.Statement[] {
    return []
  }

  visitClassDeclaration(node: ts.ClassDeclaration): awst.Statement | awst.Statement[] {
    throw new NotSupported('Nested classes', {
      sourceLocation: this.sourceLocation(node),
    })
  }

  visitVariableDeclarationList(node: ts.VariableDeclarationList): awst.Statement[] {
    const isConstDeclaration = hasFlags(node.flags, ts.NodeFlags.Const)
    return node.declarations.flatMap((d) => {
      const sourceLocation = this.sourceLocation(d)
      if (!d.initializer) {
        // Typescript will already error if a destructuring expression is used without an initializer
        if (ts.isIdentifier(d.name)) {
          const ptype = this.context.getPTypeForNode(d.name)
          codeInvariant(ptype.wtype, `${ptype.fullName} is not a valid variable type`)
        }
        return []
      }

      const source = requireInstanceBuilder(this.accept(d.initializer))

      /*
       If we encounter a simple const VAR = %VALUE% declaration, and the value is a compile time constant
       store this value as a constant in the context instead of processing the assignment.

       visitIdentifier will then resolve this constant instead of a VarExpression then the constant is referenced.

       NOTE: This only handles basic expressions for now. Constant values which are destructured from more complex expressions
       are not currently handled. eg. const [myConst] = ["constant value"]
       */
      storeConst: if (isConstDeclaration && ts.isIdentifier(d.name)) {
        const targetType = this.context.getPTypeForNode(d.name)
        if (!targetType.wtype) break storeConst
        const expr = source.resolveToPType(targetType).resolve()
        if (!isConstant(expr)) break storeConst
        this.context.addConstant(d.name, expr)
        return []
      }

      return this.handleAssignmentStatement(this.visitBindingName(d.name, sourceLocation), source, sourceLocation)
    })
  }

  visitVariableStatement(node: ts.VariableStatement): awst.Statement | awst.Statement[] {
    return this.accept(node.declarationList)
  }

  visitForStatement(node: ts.ForStatement): awst.Statement | awst.Statement[] {
    const sourceLocation = this.sourceLocation(node)
    let init: awst.Statement[] = []
    if (node.initializer) {
      if (ts.isExpression(node.initializer)) {
        init = [
          nodeFactory.expressionStatement({
            expr: requireInstanceBuilder(this.accept(node.initializer)).resolve(),
          }),
        ]
      } else {
        init = this.accept(node.initializer)
      }
    }
    let incrementor: awst.Statement[] = []
    if (node.incrementor) {
      incrementor = [
        nodeFactory.expressionStatement({
          expr: requireInstanceBuilder(this.accept(node.incrementor)).resolve(),
        }),
      ]
    }
    using ctx = this.context.switchLoopCtx.enterLoop(node, sourceLocation)
    return [
      ...init,
      nodeFactory.whileLoop({
        sourceLocation,
        condition: node.condition ? this.evaluateCondition(node.condition) : nodeFactory.boolConstant({ value: true, sourceLocation }),
        loopBody: nodeFactory.block(
          {
            sourceLocation,
          },
          this.accept(node.statement),
          ...maybeNodes(ctx.hasContinues, ctx.continueTarget),
          incrementor,
        ),
      }),
      ...maybeNodes(ctx.hasBreaks, ctx.breakTarget),
    ]
  }

  visitForOfStatement(node: ts.ForOfStatement): awst.Statement | awst.Statement[] {
    const sourceLocation = this.sourceLocation(node)
    const sequenceLocation = this.sourceLocation(node.expression)
    const initializerLocation = this.sourceLocation(node.initializer)
    const sequenceType = this.context.getPTypeForNode(node.expression)
    const itemType = getSequenceItemType(sequenceType, sequenceLocation)

    let items: awst.LValue
    if (ts.isExpression(node.initializer)) {
      items = requireInstanceBuilder(this.accept(node.initializer)).resolveLValue()
    } else {
      codeInvariant(node.initializer.declarations.length === 1, 'For of loops can only declare a single loop variable', initializerLocation)
      const [declaration] = node.initializer.declarations
      items = this.buildLValue(this.visitBindingName(declaration.name, initializerLocation), itemType, initializerLocation)
    }
    using ctx = this.context.switchLoopCtx.enterLoop(node, sourceLocation)
    return nodeFactory.block(
      { sourceLocation },
      nodeFactory.forInLoop({
        sourceLocation,
        sequence: requireInstanceBuilder(this.accept(node.expression)).iterate(sourceLocation),
        items,
        loopBody: nodeFactory.block({ sourceLocation }, this.accept(node.statement), ...maybeNodes(ctx.hasContinues, ctx.continueTarget)),
      }),
      ...maybeNodes(ctx.hasBreaks, ctx.breakTarget),
    )
  }
  visitForInStatement(node: ts.ForInStatement): awst.Statement | awst.Statement[] {
    throw new NotSupported('For in statements', {
      sourceLocation: this.sourceLocation(node),
    })
  }
  visitTryStatement(node: ts.TryStatement): awst.Statement | awst.Statement[] {
    throw new NotSupported('Try statements', {
      sourceLocation: this.sourceLocation(node),
    })
  }
  visitEmptyStatement(node: ts.EmptyStatement): awst.Statement | awst.Statement[] {
    return nodeFactory.block({ sourceLocation: this.sourceLocation(node), comment: 'Empty statement' })
  }
  visitExpressionStatement(node: ts.ExpressionStatement): awst.Statement | awst.Statement[] {
    const expr = requireInstanceBuilder(this.accept(node.expression)).resolve()
    if (expr instanceof AssignmentExpression) {
      return nodeFactory.assignmentStatement({
        ...expr,
      })
    }
    return nodeFactory.expressionStatement({
      expr,
    })
  }
  visitIfStatement(node: ts.IfStatement): awst.Statement | awst.Statement[] {
    const sourceLocation = this.sourceLocation(node)
    const condition = this.evaluateCondition(node.expression)

    const ifBranch = nodeFactory.block({ sourceLocation: this.sourceLocation(node.thenStatement) }, this.accept(node.thenStatement))
    const elseBranch =
      node.elseStatement && nodeFactory.block({ sourceLocation: this.sourceLocation(node.elseStatement) }, this.accept(node.elseStatement))

    return nodeFactory.ifElse({
      condition,
      ifBranch,
      elseBranch: elseBranch ?? null,
      sourceLocation,
    })
  }
  visitDoStatement(node: ts.DoStatement): awst.Statement | awst.Statement[] {
    const sourceLocation = this.sourceLocation(node)
    using ctx = this.context.switchLoopCtx.enterLoop(node, sourceLocation)
    invariant(ctx.breakTarget.label, 'Break target must have a label')
    return nodeFactory.block(
      { sourceLocation },
      nodeFactory.whileLoop({
        sourceLocation,
        condition: nodeFactory.boolConstant({ value: true, sourceLocation }),
        loopBody: nodeFactory.block(
          { sourceLocation },
          this.accept(node.statement),
          ...maybeNodes(ctx.hasContinues, ctx.continueTarget),
          nodeFactory.ifElse({
            condition: this.evaluateCondition(node.expression, true),
            sourceLocation,
            ifBranch: nodeFactory.block(
              { sourceLocation },
              nodeFactory.goto({ sourceLocation, target: this.context.switchLoopCtx.getBreakTarget(undefined, sourceLocation) }),
            ),
            elseBranch: null,
          }),
        ),
      }),
      ...maybeNodes(ctx.hasBreaks, ctx.breakTarget),
    )
  }
  visitWhileStatement(node: ts.WhileStatement): awst.Statement | awst.Statement[] {
    const sourceLocation = this.sourceLocation(node)
    using ctx = this.context.switchLoopCtx.enterLoop(node, sourceLocation)

    return nodeFactory.block(
      { sourceLocation },
      nodeFactory.whileLoop({
        sourceLocation,
        condition: this.evaluateCondition(node.expression),
        loopBody: nodeFactory.block({ sourceLocation }, this.accept(node.statement), ...maybeNodes(ctx.hasContinues, ctx.continueTarget)),
      }),
      ...maybeNodes(ctx.hasBreaks, ctx.breakTarget),
    )
  }
  visitContinueStatement(node: ts.ContinueStatement): awst.Statement | awst.Statement[] {
    const sourceLocation = this.sourceLocation(node)

    return nodeFactory.goto({
      sourceLocation,
      target: this.context.switchLoopCtx.getContinueTarget(node.label, sourceLocation),
    })
  }
  visitBreakStatement(node: ts.BreakStatement): awst.Statement | awst.Statement[] {
    const sourceLocation = this.sourceLocation(node)

    return nodeFactory.goto({
      sourceLocation,
      target: this.context.switchLoopCtx.getBreakTarget(node.label, sourceLocation),
    })
  }
  visitReturnStatement(node: ts.ReturnStatement): awst.Statement | awst.Statement[] {
    const sourceLocation = this.sourceLocation(node)
    if (!node.expression) {
      return nodeFactory.returnStatement({
        sourceLocation: sourceLocation,
        value: null,
      })
    }
    const returnValue = this.accept(node.expression)
    return nodeFactory.returnStatement({
      sourceLocation: sourceLocation,
      value: requireExpressionOfType(returnValue, this._functionType.returnType),
    })
  }
  visitWithStatement(node: ts.WithStatement): awst.Statement | awst.Statement[] {
    throw new NotSupported('with statements', { sourceLocation: this.sourceLocation(node) })
  }
  visitSwitchStatement(node: ts.SwitchStatement): awst.Statement | awst.Statement[] {
    const sourceLocation = this.sourceLocation(node)
    using ctx = this.context.switchLoopCtx.enterSwitch(node, sourceLocation)

    const subject = requireInstanceBuilder(this.accept(node.expression)).singleEvaluation()

    let defaultCase: Block | null = null

    const clauses: awst.Statement[] = []
    for (const [index, clause] of enumerate(node.caseBlock.clauses)) {
      const sourceLocation = this.sourceLocation(clause)

      const statements = clause.statements.flatMap((s) => this.accept(s))
      const isNotLastCase = index + 1 < node.caseBlock.clauses.length
      const isObviouslyTerminated = instanceOfAny(statements.at(-1), Goto, ReturnStatement)
      const caseBlock = nodeFactory.block(
        {
          sourceLocation,
        },
        ctx.caseTarget(index, sourceLocation),
        statements,
        ...(isNotLastCase && !isObviouslyTerminated ? [ctx.gotoCase(index + 1, sourceLocation)] : []),
      )
      if (clause.kind === ts.SyntaxKind.DefaultClause) {
        defaultCase = caseBlock
      } else {
        const clauseExpr = requireInstanceBuilder(this.accept(clause.expression))
        clauses.push(
          nodeFactory.ifElse({
            condition: subject.compare(clauseExpr, BuilderComparisonOp.eq, clauseExpr.sourceLocation).boolEval(clauseExpr.sourceLocation),
            ifBranch: caseBlock,
            elseBranch: null,
            sourceLocation,
          }),
        )
      }
    }
    if (defaultCase !== null) clauses.push(defaultCase)

    return nodeFactory.block(
      {
        sourceLocation,
      },
      ...clauses,
      ...maybeNodes(ctx.hasBreaks, ctx.breakTarget),
    )
  }

  visitLabeledStatement(node: ts.LabeledStatement): awst.Statement | awst.Statement[] {
    return this.accept(node.statement)
  }
  visitThrowStatement(node: ts.ThrowStatement): awst.Statement | awst.Statement[] {
    throw new NotSupported('Throw statements', {
      sourceLocation: this.sourceLocation(node),
    })
  }
  visitDebuggerStatement(node: ts.DebuggerStatement): awst.Statement | awst.Statement[] {
    logger.warn(this.sourceLocation(node), 'Ignoring debugger statement')
    return []
  }
  visitImportDeclaration(node: ts.ImportDeclaration): awst.Statement | awst.Statement[] {
    throw new NotSupported('Non-top-level import declarations')
  }

  visitBlock(node: ts.Block): awst.Block {
    return nodeFactory.block(
      {
        sourceLocation: this.sourceLocation(node),
      },
      node.statements.flatMap((s) => {
        try {
          return this.accept(s)
        } catch (e) {
          invariant(e instanceof Error, 'Only errors should be thrown')
          logger.error(e)
          return []
        }
      }),
    )
  }

  visitParameter(node: ts.ParameterDeclaration): awst.SubroutineArgument {
    const sourceLocation = this.sourceLocation(node)
    codeInvariant(node.type, 'Parameters must have type annotation', sourceLocation)
    codeInvariant(!node.dotDotDotToken, 'Rest parameters are not supported', sourceLocation)
    codeInvariant(!node.questionToken, 'Optional parameters are not supported', sourceLocation)
    if (node.initializer) {
      logger.warn(sourceLocation, 'TODO: Default parameter values')
    }
    const paramPType = this.context.getPTypeForNode(node.type)

    if (ts.isIdentifier(node.name)) {
      return nodeFactory.subroutineArgument({
        sourceLocation: sourceLocation,
        name: this.context.resolveVariableName(node.name),
        wtype: paramPType.wtypeOrThrow,
      })
    } else if (ts.isObjectBindingPattern(node.name)) {
      codeInvariant(paramPType instanceof ObjectPType, 'Param type must be object if it is being destructured', sourceLocation)
      return nodeFactory.subroutineArgument({
        sourceLocation,
        name: this.context.resolveDestructuredParamName(node),
        wtype: paramPType.wtype,
      })
    } else {
      throw new CodeError(`Unsupported parameter declaration type ${getNodeName(node)}`, { sourceLocation })
    }
  }
}



================================================
FILE: src/awst_build/ast-visitors/logic-sig-program-visitor.ts
================================================
import type ts from 'typescript'
import * as awst from '../../awst/nodes'
import { FunctionVisitor } from './function-visitor'
import { visitInChildContext } from './util'

export class LogicSigProgramVisitor extends FunctionVisitor {
  constructor(node: ts.MethodDeclaration) {
    super(node)
  }

  get result() {
    const sourceLocation = this.sourceLocation(this.node)
    const { args, body, documentation } = this.buildFunctionAwst()
    return new awst.Subroutine({
      id: this._functionType.fullName,
      name: this._functionType.name,
      sourceLocation,
      args,
      returnType: this._functionType.returnType.wtypeOrThrow,
      body,
      documentation,
      inline: null,
    })
  }

  public static buildLogicSigProgram(node: ts.MethodDeclaration) {
    return visitInChildContext(LogicSigProgramVisitor, node)
  }
}



================================================
FILE: src/awst_build/ast-visitors/logic-sig-visitor.ts
================================================
import type ts from 'typescript'
import type { Subroutine } from '../../awst/nodes'
import type { SourceLocation } from '../../awst/source-location'
import { Constants } from '../../constants'
import { CodeError } from '../../errors'
import { logger } from '../../logger'
import { codeInvariant, invariant } from '../../util'
import type { ClassElements } from '../../visitor/syntax-names'
import type { Visitor } from '../../visitor/visitor'
import { accept } from '../../visitor/visitor'
import type { LogicSigOptionsDecoratorData } from '../models/decorator-data'
import { LogicSigClassModel } from '../models/logic-sig-class-model'
import type { LogicSigPType } from '../ptypes'
import { boolPType, FunctionPType, uint64PType } from '../ptypes'
import { ptypeIn } from '../ptypes/util'
import { BaseVisitor } from './base-visitor'
import { DecoratorVisitor } from './decorator-visitor'
import { LogicSigProgramVisitor } from './logic-sig-program-visitor'
import { visitInChildContext } from './util'

export class LogicSigVisitor extends BaseVisitor implements Visitor<ClassElements, void> {
  public accept = <TNode extends ts.Node>(node: TNode) => accept<LogicSigVisitor, TNode>(this, node)

  static buildLogicSig(classDec: ts.ClassDeclaration, ptype: LogicSigPType) {
    return visitInChildContext(this, classDec, ptype)
  }

  private program?: () => Subroutine
  private readonly metaData: {
    description: string | null
    options: LogicSigOptionsDecoratorData | undefined
    sourceLocation: SourceLocation
  }

  constructor(
    classDec: ts.ClassDeclaration,
    private _logicSigPType: LogicSigPType,
  ) {
    super()
    const sourceLocation = this.sourceLocation(classDec)

    const options = DecoratorVisitor.buildLogicSigData(classDec)

    for (const member of classDec.members) {
      try {
        this.accept(member)
      } catch (e) {
        invariant(e instanceof Error, 'Only errors should be thrown')
        logger.error(e)
      }
    }

    this.metaData = {
      options,
      sourceLocation,
      description: this.getNodeDescription(classDec),
    }
  }

  get result() {
    const { sourceLocation, options, description } = this.metaData

    codeInvariant(this.program, 'Logic signature class must implement a valid program method', sourceLocation)

    const logicSig = new LogicSigClassModel({
      bases: [],
      sourceLocation,
      program: this.program(),
      type: this._logicSigPType,
      description,
      options,
    })

    this.context.addToCompilationSet(logicSig.id, logicSig)
    return logicSig.buildLogicSignature()
  }

  private throwLogicSigNotSupported(node: ts.Node, desc: string): never {
    throw new CodeError(`${desc} are not supported in logic signature definitions`, {
      sourceLocation: this.sourceLocation(node),
    })
  }

  visitClassStaticBlockDeclaration(node: ts.ClassStaticBlockDeclaration) {
    this.throwLogicSigNotSupported(node, 'Class static block declarations')
  }
  visitConstructor(node: ts.ConstructorDeclaration) {
    this.throwLogicSigNotSupported(node, 'Constructor declarations')
  }
  visitGetAccessor(node: ts.GetAccessorDeclaration) {
    this.throwLogicSigNotSupported(node, 'Property declarations')
  }
  visitIndexSignature(node: ts.IndexSignatureDeclaration) {
    this.throwLogicSigNotSupported(node, 'Index signature declarations')
  }
  visitMethodDeclaration(node: ts.MethodDeclaration) {
    const sourceLocation = this.sourceLocation(node)
    const methodType = this.context.getPTypeForNode(node)
    invariant(methodType instanceof FunctionPType, 'type of function must be FunctionPType')
    if (methodType.name !== Constants.symbolNames.logicSigProgramMethodName) {
      logger.error(
        sourceLocation,
        `LogicSig classes may only contain a program implementation method named '${Constants.symbolNames.logicSigProgramMethodName}'. Consider making '${methodType.name}' a free subroutine.`,
      )
      return
    }
    if (!ptypeIn(methodType.returnType, uint64PType, boolPType)) {
      logger.error(
        sourceLocation,
        `LogicSig program method must return \`uint64\` or \`boolean\`, found \`${methodType.returnType.name}\` `,
      )
      return
    }
    this.program = LogicSigProgramVisitor.buildLogicSigProgram(node)
  }
  visitPropertyDeclaration(node: ts.PropertyDeclaration) {
    this.throwLogicSigNotSupported(node, 'Property declarations')
  }
  visitSemicolonClassElement(node: ts.SemicolonClassElement) {
    // Ignore
  }
  visitSetAccessor(node: ts.SetAccessorDeclaration) {
    this.throwLogicSigNotSupported(node, 'Property declarations')
  }
}



================================================
FILE: src/awst_build/ast-visitors/source-file-visitor.ts
================================================
import ts from 'typescript'
import { isConstant } from '../../awst'
import type * as awst from '../../awst/nodes'
import { TemplateVar } from '../../awst/nodes'
import { CodeError } from '../../errors'
import { logger, patchErrorLocation } from '../../logger'
import { codeInvariant, expandMaybeArray, invariant } from '../../util'
import type { ModuleStatements } from '../../visitor/syntax-names'
import type { Visitor } from '../../visitor/visitor'
import { accept } from '../../visitor/visitor'
import { requireExpressionOfType } from '../eb/util'
import { ContractClassPType, LibClassType, LogicSigPType } from '../ptypes'
import { ARC4StructType } from '../ptypes/arc4-types'
import { BaseVisitor } from './base-visitor'
import { ContractVisitor } from './contract-visitor'
import { LogicSigVisitor } from './logic-sig-visitor'
import { StructVisitor } from './struct-visitor'
import { SubroutineVisitor } from './subroutine-visitor'

type NodeOrDeferred = awst.AWST[] | awst.AWST | (() => awst.AWST[] | awst.AWST)

export class SourceFileVisitor extends BaseVisitor implements Visitor<ModuleStatements, NodeOrDeferred> {
  private _moduleStatements: NodeOrDeferred[] = []
  private accept = <TNode extends ts.Node>(node: TNode) => accept<SourceFileVisitor, TNode>(this, node)

  constructor(sourceFile: ts.SourceFile) {
    super()

    for (const statement of sourceFile.statements) {
      try {
        this._moduleStatements.push(this.accept(statement))
      } catch (e) {
        invariant(e instanceof Error, 'Only errors should be thrown')
        logger.error(e)
      }
    }
  }

  visitInterfaceDeclaration(node: ts.InterfaceDeclaration): NodeOrDeferred {
    // Ignore these for now
    return []
  }

  visitTypeAliasDeclaration(_node: ts.TypeAliasDeclaration): NodeOrDeferred {
    // Ignore these for now - but maybe we need to do something with them when it comes to structs
    return []
  }

  visitFunctionDeclaration(node: ts.FunctionDeclaration): NodeOrDeferred {
    const sourceLocation = this.sourceLocation(node)
    return this.context.runInChildContext(() => patchErrorLocation(SubroutineVisitor.buildSubroutine(node), sourceLocation))
  }

  buildModule(): awst.AWST[] {
    return Array.from(this.gatherStatements())
  }

  private *gatherStatements(): Generator<awst.AWST, void, void> {
    for (const statements of this._moduleStatements) {
      try {
        if (typeof statements === 'function') {
          for (const s of expandMaybeArray(statements())) {
            yield s
          }
        } else {
          for (const s of expandMaybeArray(statements)) {
            yield s
          }
        }
      } catch (e) {
        invariant(e instanceof Error, 'Only errors should be thrown')
        logger.error(e)
      }
    }
  }

  visitVariableStatement(node: ts.VariableStatement): NodeOrDeferred {
    const sourceLocation = this.sourceLocation(node)
    if (!(node.declarationList.flags & ts.NodeFlags.Const)) {
      logger.error(new CodeError(`Module level variable declarations must use the 'const' keyword.`, { sourceLocation }))
    }

    return node.declarationList.declarations.flatMap((dec) => {
      if (!dec.initializer) {
        throw new CodeError(`Module level variable declarations must be initialized with a value.`, { sourceLocation })
      }
      if (!ts.isIdentifier(dec.name)) {
        throw new CodeError(`Module level variable declarations must use plain identifiers.`, { sourceLocation })
      }
      const ptype = this.context.getPTypeForNode(dec.name)

      const initializerBuilder = this.accept(dec.initializer)

      if (ptype instanceof LibClassType) {
        invariant(initializerBuilder.ptype?.equals(ptype), 'Initializer type must match target type')
        return []
      }

      const value = requireExpressionOfType(initializerBuilder, ptype)

      codeInvariant(isConstant(value) || value instanceof TemplateVar, 'Module level assignments must be compile time constants')

      this.context.addConstant(dec.name, value)

      return []
    })
  }
  visitImportDeclaration(_node: ts.ImportDeclaration): NodeOrDeferred {
    return []
  }
  visitClassDeclaration(node: ts.ClassDeclaration): NodeOrDeferred {
    const sourceLocation = this.sourceLocation(node)
    const ptype = this.context.getPTypeForNode(node)

    if (ptype instanceof ContractClassPType) {
      return patchErrorLocation(ContractVisitor.buildContract(node, ptype), sourceLocation)
    } else if (ptype instanceof ARC4StructType) {
      return patchErrorLocation(() => StructVisitor.buildStructDef(node, ptype), sourceLocation)()
    } else if (ptype instanceof LogicSigPType) {
      return patchErrorLocation(LogicSigVisitor.buildLogicSig(node, ptype), sourceLocation)
    } else {
      logger.warn(sourceLocation, `Ignoring class declaration ${ptype.fullName}`)
      return []
    }
  }
}



================================================
FILE: src/awst_build/ast-visitors/struct-visitor.ts
================================================
import type ts from 'typescript'
import { CodeError } from '../../errors'
import { logger } from '../../logger'
import { invariant } from '../../util'
import type { ClassElements } from '../../visitor/syntax-names'
import type { Visitor } from '../../visitor/visitor'
import { accept } from '../../visitor/visitor'
import { AwstBuildContext } from '../context/awst-build-context'
import type { ARC4StructType } from '../ptypes/arc4-types'
import { BaseVisitor } from './base-visitor'

export class StructVisitor extends BaseVisitor implements Visitor<ClassElements, void> {
  public accept = <TNode extends ts.Node>(node: TNode) => accept<StructVisitor, TNode>(this, node)

  static buildStructDef(classDec: ts.ClassDeclaration, ptype: ARC4StructType) {
    return AwstBuildContext.current.runInChildContext(() => {
      new StructVisitor(classDec, ptype)
      return []
    })
  }

  constructor(classDec: ts.ClassDeclaration, ptype: ARC4StructType) {
    super()

    for (const member of classDec.members) {
      try {
        this.accept(member)
      } catch (e) {
        invariant(e instanceof Error, 'Only errors should be thrown')
        logger.error(e)
      }
    }
  }

  private throwStructNotSupported(node: ts.Node, desc: string): never {
    throw new CodeError(`${desc} are not supported in ARC4 struct definitions`, {
      sourceLocation: this.sourceLocation(node),
    })
  }

  visitClassStaticBlockDeclaration(node: ts.ClassStaticBlockDeclaration) {
    this.throwStructNotSupported(node, 'Class static block declarations')
  }
  visitConstructor(node: ts.ConstructorDeclaration) {
    this.throwStructNotSupported(node, 'Constructor declarations')
  }
  visitGetAccessor(node: ts.GetAccessorDeclaration) {
    this.throwStructNotSupported(node, 'Property declarations')
  }
  visitIndexSignature(node: ts.IndexSignatureDeclaration) {
    this.throwStructNotSupported(node, 'Index signature declarations')
  }
  visitMethodDeclaration(node: ts.MethodDeclaration) {
    this.throwStructNotSupported(node, 'Method declarations')
  }
  visitPropertyDeclaration(node: ts.PropertyDeclaration) {
    this.throwStructNotSupported(node, 'Property declarations')
  }
  visitSemicolonClassElement(node: ts.SemicolonClassElement) {
    // Ignore
  }
  visitSetAccessor(node: ts.SetAccessorDeclaration) {
    this.throwStructNotSupported(node, 'Property declarations')
  }
}



================================================
FILE: src/awst_build/ast-visitors/subroutine-visitor.ts
================================================
import type ts from 'typescript'
import * as awst from '../../awst/nodes'
import { FunctionVisitor } from './function-visitor'
import { visitInChildContext } from './util'

export class SubroutineVisitor extends FunctionVisitor {
  constructor(node: ts.FunctionDeclaration) {
    super(node)
  }

  get result() {
    const sourceLocation = this.sourceLocation(this.node)

    const { args, body, documentation } = this.buildFunctionAwst()

    return new awst.Subroutine({
      id: this._functionType.fullName,
      name: this._functionType.name,
      sourceLocation,
      args,
      returnType: this._functionType.returnType.wtypeOrThrow,
      body,
      documentation,
      inline: null,
    })
  }

  public static buildSubroutine(node: ts.FunctionDeclaration) {
    return visitInChildContext(SubroutineVisitor, node)
  }
}



================================================
FILE: src/awst_build/ast-visitors/text-visitor.ts
================================================
import type * as ts from 'typescript'
import { NotSupported } from '../../errors'
import type { Visitor } from '../../visitor/visitor'
import { accept } from '../../visitor/visitor'
import { AwstBuildContext } from '../context/awst-build-context'

type ObjectNames = ts.PropertyName | ts.PseudoLiteralToken

export class TextVisitor implements Visitor<ObjectNames, string> {
  get context() {
    return AwstBuildContext.current
  }

  visitBigIntLiteral(node: ts.BigIntLiteral): string {
    return node.text
  }

  visitTemplateHead(node: ts.TemplateHead): string {
    return node.text
  }
  visitTemplateMiddle(node: ts.TemplateMiddle): string {
    return node.text
  }
  visitTemplateTail(node: ts.TemplateTail): string {
    return node.text
  }
  public accept = <TNode extends ts.Node>(node: TNode) => accept<TextVisitor, TNode>(this, node)

  visitIdentifier(node: ts.Identifier): string {
    return node.text
  }
  visitNoSubstitutionTemplateLiteral(node: ts.NoSubstitutionTemplateLiteral): string {
    return node.text
  }
  visitNumericLiteral(node: ts.NumericLiteral): string {
    return node.text
  }
  visitComputedPropertyName(node: ts.ComputedPropertyName): string {
    throw new NotSupported('Computed property names', {
      sourceLocation: this.context.getSourceLocation(node),
    })
  }
  visitPrivateIdentifier(node: ts.PrivateIdentifier): string {
    return node.text
  }
  visitStringLiteral(node: ts.StringLiteral): string {
    return node.text
  }
}



================================================
FILE: src/awst_build/ast-visitors/util.ts
================================================
import { AwstBuildContext } from '../context/awst-build-context'

export function maybeNodes<T>(condition: boolean, ...nodes: T[]): T[] {
  return condition ? nodes : []
}

export function visitInChildContext<TVisitorArgs extends unknown[], TVisitorResult>(
  Visitor: { new (...args: TVisitorArgs): { result: TVisitorResult } },
  ...args: TVisitorArgs
) {
  return AwstBuildContext.current.runInChildContext((deferred) => {
    const visitor = new Visitor(...args)
    return deferred(() => visitor.result)
  })
}



================================================
FILE: src/awst_build/context/awst-build-context.ts
================================================
import { AsyncLocalStorage } from 'node:async_hooks'
import ts from 'typescript'
import type { awst } from '../../awst'
import type { ContractReference, LogicSigReference } from '../../awst/models'
import { nodeFactory } from '../../awst/node-factory'
import type { AppStorageDefinition, ARC4MethodConfig } from '../../awst/nodes'
import { SourceLocation } from '../../awst/source-location'
import { logger } from '../../logger'
import { invariant } from '../../util'
import { ConstantStore } from '../constant-store'
import type { NodeBuilder } from '../eb'
import type { AppStorageDeclaration } from '../models/app-storage-declaration'
import type { ContractClassModel } from '../models/contract-class-model'
import { CompilationSet } from '../models/contract-class-model'
import type { LogicSigClassModel } from '../models/logic-sig-class-model'
import type { ContractClassPType, PType } from '../ptypes'
import { arc4BaseContractType, baseContractType } from '../ptypes'
import { typeRegistry } from '../type-registry'
import { TypeResolver } from '../type-resolver'
import { EvaluationContext } from './evaluation-context'
import { SwitchLoopContext } from './switch-loop-context'
import { UniqueNameResolver } from './unique-name-resolver'

export abstract class AwstBuildContext {
  /**
   * Get the source location of a node in the current source file
   * @param node
   */
  abstract getSourceLocation(node: ts.Node): SourceLocation

  /**
   * Get NodeBuilder instance for the given identifier.
   * @param node
   */
  abstract getBuilderForNode(node: ts.Identifier): NodeBuilder

  /**
   * Reflect the PType of the given node
   * @param node
   */
  abstract getPTypeForNode(node: ts.Node): PType

  /**
   * Reflect generic type parameters for a call expression
   * @param node
   */
  abstract getTypeParameters(node: ts.CallExpression | ts.NewExpression): PType[]

  /**
   * Resolve the given identifier to a unique variable name that accounts
   * for shadowed variable names.
   * @param node
   */
  abstract resolveVariableName(node: ts.Identifier): string

  /**
   * Resolve the given parameter declaration to a unique parameter name to be used
   * in destructuring assignments where no explicit parameter name is available.
   * @param node
   */
  abstract resolveDestructuredParamName(node: ts.ParameterDeclaration): string

  /**
   * Generate a unique variable name for a discarded value.
   */
  abstract generateDiscardedVarName(): string

  /**
   * Add a named constant to the current context
   * @param identifier The identifier of the constant declaration in this source file
   * @param value The compile time constant value
   */
  abstract addConstant(identifier: ts.Identifier, value: awst.Constant | awst.TemplateVar): void

  /**
   * Retrieve the evaluation context
   */
  abstract get evaluationCtx(): EvaluationContext

  /**
   * Retrieve the switch loop context
   */
  abstract get switchLoopCtx(): SwitchLoopContext

  abstract addStorageDeclaration(declaration: AppStorageDeclaration): void
  abstract addArc4Config(methodData: {
    contractReference: ContractReference
    sourceLocation: SourceLocation
    arc4MethodConfig: ARC4MethodConfig
    memberName: string
  }): void
  abstract getArc4Config(contractType: ContractClassPType, memberName: string): ARC4MethodConfig | undefined
  abstract getArc4Config(contractType: ContractClassPType): ARC4MethodConfig[]

  abstract getStorageDeclaration(contractType: ContractClassPType, memberName: string): AppStorageDeclaration | undefined

  abstract getStorageDefinitionsForContract(contractType: ContractClassPType): AppStorageDefinition[]

  abstract addToCompilationSet(compilationTarget: ContractReference, contract: ContractClassModel): void
  abstract addToCompilationSet(compilationTarget: LogicSigReference, logicSig: LogicSigClassModel): void

  abstract get compilationSet(): CompilationSet

  protected abstract createChildContext(): AwstBuildContext

  static get current(): AwstBuildContext {
    const ctx = this.asyncStore.getStore()
    if (!ctx) {
      throw new Error('No context available!')
    }
    return ctx
  }

  private static asyncStore = new AsyncLocalStorage<AwstBuildContext>()

  static run<R>(program: ts.Program, cb: () => R) {
    const ctx = AwstBuildContextImpl.forProgram(program)

    return AwstBuildContext.asyncStore.run(ctx, cb)
  }

  runInChildContext<R>(cb: (deferred: RunDeferred) => R) {
    const childCtx = this.createChildContext()

    const runDeferred: RunDeferred = (action) => () => AwstBuildContext.asyncStore.run(childCtx, action)

    return AwstBuildContext.asyncStore.run(childCtx, () => cb(runDeferred))
  }
}

type RunDeferred = <T>(action: () => T) => () => T

class AwstBuildContextImpl extends AwstBuildContext {
  readonly evaluationCtx = new EvaluationContext()
  readonly switchLoopCtx = new SwitchLoopContext()
  readonly typeResolver: TypeResolver
  readonly typeChecker: ts.TypeChecker
  readonly #compilationSet: CompilationSet
  private constructor(
    public readonly program: ts.Program,
    private readonly constants: ConstantStore,
    private readonly nameResolver: UniqueNameResolver,
    private readonly storageDeclarations: Map<string, Map<string, AppStorageDeclaration>>,
    private readonly arc4MethodConfig: Map<string, Map<string, ARC4MethodConfig>>,
    compilationSet: CompilationSet,
  ) {
    super()
    this.typeChecker = program.getTypeChecker()
    this.typeResolver = new TypeResolver(this.typeChecker, this.program.getCurrentDirectory())
    this.#compilationSet = compilationSet
  }

  addArc4Config({
    memberName,
    sourceLocation,
    contractReference,
    arc4MethodConfig,
  }: {
    contractReference: ContractReference
    sourceLocation: SourceLocation
    arc4MethodConfig: ARC4MethodConfig
    memberName: string
  }): void {
    const contractConfig = this.arc4MethodConfig.get(contractReference.id) ?? new Map<string, ARC4MethodConfig>()
    if (contractConfig.size === 0) {
      // Add to map if new
      this.arc4MethodConfig.set(contractReference.id, contractConfig)
    }
    if (contractConfig.has(memberName)) {
      logger.error(sourceLocation, `Duplicate declaration of member ${memberName} on ${contractReference}`)
    }
    contractConfig.set(memberName, arc4MethodConfig)
  }

  getArc4Config(contractType: ContractClassPType): ARC4MethodConfig[]
  getArc4Config(contractType: ContractClassPType, memberName: string): ARC4MethodConfig | undefined
  getArc4Config(contractType: ContractClassPType, memberName?: string): ARC4MethodConfig | undefined | ARC4MethodConfig[] {
    if (memberName) {
      for (const ct of [contractType, ...contractType.allBases()]) {
        if (ct.equals(baseContractType) || ct.equals(arc4BaseContractType)) continue
        const contractMethods = this.arc4MethodConfig.get(ct.fullName)
        invariant(contractMethods, `${ct} has not been visited`)
        if (contractMethods.has(memberName)) {
          return contractMethods.get(memberName)
        }
      }
      return undefined
    } else {
      return Array.from(
        [contractType, ...contractType.allBases()]
          .toReversed()
          .reduce((acc, ct) => {
            if (ct.equals(baseContractType) || ct.equals(arc4BaseContractType)) return acc

            const contractMethods = this.arc4MethodConfig.get(ct.fullName)
            invariant(contractMethods, `${ct} has not been visited`)

            return new Map([...acc, ...contractMethods])
          }, new Map<string, ARC4MethodConfig>())
          .values(),
      )
    }
  }

  static forProgram(program: ts.Program): AwstBuildContext {
    return new AwstBuildContextImpl(
      program,
      new ConstantStore(program),
      new UniqueNameResolver(),
      new Map(),
      new Map(),
      new CompilationSet(),
    )
  }

  addConstant(identifier: ts.Identifier, value: awst.Constant | awst.TemplateVar) {
    this.constants.addConstant(identifier, value, this.getSourceLocation(identifier))
  }

  createChildContext(): AwstBuildContext {
    return new AwstBuildContextImpl(
      this.program,
      this.constants,
      this.nameResolver.createChild(),
      this.storageDeclarations,
      this.arc4MethodConfig,
      this.#compilationSet,
    )
  }

  resolveDestructuredParamName(node: ts.ParameterDeclaration) {
    const symbol = (node as { symbol?: ts.Symbol }).symbol
    invariant(symbol, 'Param node must have symbol')
    return this.nameResolver.resolveUniqueName('p', symbol)
  }
  generateDiscardedVarName() {
    return this.nameResolver.resolveUniqueName('_', undefined)
  }
  resolveVariableName(node: ts.Identifier) {
    const symbol = this.typeChecker.resolveName(node.text, node, ts.SymbolFlags.All, false)
    invariant(symbol, 'There must be a symbol for an identifier node')
    return this.nameResolver.resolveUniqueName(node.text, symbol)
  }

  getTypeParameters(node: ts.CallExpression | ts.NewExpression): PType[] {
    return this.typeResolver.resolveTypeParameters(node, this.getSourceLocation(node))
  }

  getPTypeForNode(node: ts.Node): PType {
    const sourceLocation = this.getSourceLocation(node)
    if (ts.isTypeNode(node)) {
      return this.typeResolver.resolveTypeNode(node, sourceLocation)
    }
    return this.typeResolver.resolve(node, sourceLocation)
  }

  getBuilderForNode(node: ts.Identifier): NodeBuilder {
    const sourceLocation = this.getSourceLocation(node)
    const ptype = this.typeResolver.resolve(node, sourceLocation)
    if (ptype.singleton) {
      return typeRegistry.getSingletonEb(ptype, sourceLocation)
    }
    const constantValue = this.constants.tryResolveConstant(node)
    if (constantValue) {
      return typeRegistry.getInstanceEb(constantValue, ptype)
    }
    const variableName = this.resolveVariableName(node)
    return typeRegistry.getInstanceEb(
      nodeFactory.varExpression({
        sourceLocation,
        name: variableName,
        wtype: ptype.wtypeOrThrow,
      }),
      ptype,
    )
  }

  getSourceLocation(node: ts.Node) {
    return SourceLocation.fromNode(node, this.program.getCurrentDirectory())
  }

  addStorageDeclaration(declaration: AppStorageDeclaration): void {
    const contractDeclarations = this.storageDeclarations.get(declaration.definedIn.fullName) ?? new Map()
    if (contractDeclarations.size === 0) {
      // Add to map if new
      this.storageDeclarations.set(declaration.definedIn.fullName, contractDeclarations)
    }
    if (contractDeclarations.has(declaration.memberName)) {
      logger.error(declaration.sourceLocation, `Duplicate declaration of member ${declaration.memberName} on ${declaration.definedIn}`)
    }
    contractDeclarations.set(declaration.memberName, declaration)
  }

  getStorageDeclaration(contractType: ContractClassPType, memberName: string): AppStorageDeclaration | undefined {
    const declaration = this.storageDeclarations.get(contractType.fullName)?.get(memberName)
    if (declaration) return declaration
    for (const baseType of contractType.baseTypes) {
      const baseDeclaration = this.getStorageDeclaration(baseType, memberName)
      if (baseDeclaration) return baseDeclaration
    }
    return undefined
  }

  getStorageDefinitionsForContract(contractType: ContractClassPType): AppStorageDefinition[] {
    const result = new Map<string, AppStorageDefinition>()
    const seenContracts = new Set<string>()
    for (const ct of [contractType, ...contractType.allBases()]) {
      if (seenContracts.has(ct.fullName)) continue
      seenContracts.add(ct.fullName)

      for (const [memberName, declaration] of this.storageDeclarations.get(ct.fullName) ?? []) {
        if (result.has(memberName)) {
          logger.error(
            result.get(memberName)?.sourceLocation,
            `Redefinition of app storage member, original declared in ${declaration.sourceLocation}`,
          )
        }
        result.set(memberName, declaration.definition)
      }
    }
    return Array.from(result.values())
  }

  addToCompilationSet(compilationTarget: ContractReference, contract: ContractClassModel): void
  addToCompilationSet(compilationTarget: LogicSigReference, logicSig: LogicSigClassModel): void
  addToCompilationSet(compilationTarget: ContractReference | LogicSigReference, contractOrSig: ContractClassModel | LogicSigClassModel) {
    if (this.#compilationSet.has(compilationTarget)) {
      logger.debug(undefined, `${compilationTarget.id} already exists in compilation set`)
      return
    }
    this.#compilationSet.set(compilationTarget, contractOrSig)
  }

  get compilationSet() {
    return this.#compilationSet
  }
}



================================================
FILE: src/awst_build/context/evaluation-context.ts
================================================
/**
 * Tracks the context in which expressions should be evaluated.
 *
 * A boolean context is more lenient with mixed expression types as it is only concerned with truthy-ness
 */
export class EvaluationContext {
  #isBoolean: boolean = false

  get isBoolean() {
    return this.#isBoolean
  }

  enterBooleanContext(): Disposable {
    const previous = this.#isBoolean
    this.#isBoolean = true
    return {
      [Symbol.dispose]: () => {
        this.#isBoolean = previous
      },
    }
  }
  leaveBooleanContext(): Disposable {
    const previous = this.#isBoolean
    this.#isBoolean = false
    return {
      [Symbol.dispose]: () => {
        this.#isBoolean = previous
      },
    }
  }
}



================================================
FILE: src/awst_build/context/switch-loop-context.ts
================================================
import ts from 'typescript'
import { nodeFactory } from '../../awst/node-factory'
import type { Block, Goto } from '../../awst/nodes'
import type { SourceLocation } from '../../awst/source-location'
import { codeInvariant, invariant, toSubScript } from '../../util'
import { defaultRecord } from '../../util/default-map'

type SwitchOrLoop = 'switch' | 'loop'
type LoopContext = Disposable & { breakTarget: Block; continueTarget: Block; readonly hasBreaks: boolean; readonly hasContinues: boolean }
type SwitchContext = Disposable & {
  breakTarget: Block
  caseTarget(caseIndex: number, sourceLocation: SourceLocation): Block
  gotoCase(caseIndex: number, sourceLocation: SourceLocation): Goto
  readonly hasBreaks: boolean
}
type StackData =
  | { type: 'switch'; uniqueName: string; label?: string; numBreaks: number }
  | { type: 'loop'; uniqueName: string; label?: string; numBreaks: number; numContinues: number }

const breakSuffix = 'ᵇ'
const continueSuffix = 'ᶜ'

/**
 * Tracks parent switches and loops so that break and continue statements
 * can target the correct parent.
 */
export class SwitchLoopContext {
  private labelCount = defaultRecord<string, number>(() => 0)
  private unlabelledCount = defaultRecord<SwitchOrLoop, number>(() => 0)

  constructor() {}

  private switchLoopStack: Array<StackData> = []

  getBreakTarget(label: ts.Identifier | undefined, sourceLocation: SourceLocation): string {
    const labelName = label?.text
    const item = this.switchLoopStack.toReversed().find(({ label }) => labelName === undefined || label === labelName)
    codeInvariant(item, 'Break must exist inside a switch or loop construct', sourceLocation)
    item.numBreaks++
    return `${item.uniqueName}${breakSuffix}`
  }

  getContinueTarget(label: ts.Identifier | undefined, sourceLocation: SourceLocation): string {
    const labelName = label?.text
    const item = this.switchLoopStack.toReversed().find(({ label }) => labelName === undefined || label === labelName)
    codeInvariant(item?.type === 'loop', 'Continue must exist inside a loop construct', sourceLocation)
    item.numContinues++
    return `${item.uniqueName}${continueSuffix}`
  }

  enterLoop(
    node: ts.WhileStatement | ts.ForStatement | ts.ForOfStatement | ts.ForInStatement | ts.DoStatement,
    sourceLocation: SourceLocation,
  ): LoopContext {
    const label = ts.isLabeledStatement(node.parent) ? node?.parent.label : undefined

    const uniqueName = this.uniqueNameForLabel(label, 'loop')
    const stackData: StackData = {
      uniqueName,
      label: label?.text,
      type: 'loop',
      numBreaks: 0,
      numContinues: 0,
    }
    this.switchLoopStack.push(stackData)
    return {
      breakTarget: nodeFactory.block({ sourceLocation, label: `${uniqueName}${breakSuffix}` }),
      continueTarget: nodeFactory.block({ sourceLocation, label: `${uniqueName}${continueSuffix}` }),
      [Symbol.dispose]: () => {
        const popped = this.switchLoopStack.pop()
        invariant(popped?.uniqueName === uniqueName && popped.type === 'loop', 'Switch loop stack is unbalanced')
      },
      get hasBreaks() {
        return stackData.numBreaks > 0
      },
      get hasContinues() {
        return stackData.numContinues > 0
      },
    }
  }

  private uniqueNameForLabel(label: ts.Identifier | undefined, type: 'switch' | 'loop'): string {
    if (label) {
      const count = ++this.labelCount[label.text]
      return `${label.text}${toSubScript(count)}`
    } else {
      const nextCount = ++this.unlabelledCount[type]
      return `#${type}${toSubScript(nextCount)}`
    }
  }

  enterSwitch(node: ts.SwitchStatement, sourceLocation: SourceLocation): SwitchContext {
    const label = ts.isLabeledStatement(node.parent) ? node?.parent.label : undefined
    const uniqueName = this.uniqueNameForLabel(label, 'switch')
    const stackData: StackData = {
      uniqueName,
      label: label?.text,
      type: 'switch',
      numBreaks: 0,
    }
    this.switchLoopStack.push(stackData)
    return {
      breakTarget: nodeFactory.block({ sourceLocation, label: `${uniqueName}${breakSuffix}` }),
      caseTarget(caseIndex: number, sourceLocation: SourceLocation) {
        return nodeFactory.block({ sourceLocation, label: `${uniqueName}ᶜ${toSubScript(caseIndex)}` })
      },
      gotoCase(caseIndex: number, sourceLocation: SourceLocation): Goto {
        return nodeFactory.goto({ sourceLocation, target: `${uniqueName}ᶜ${toSubScript(caseIndex)}` })
      },
      [Symbol.dispose]: () => {
        const popped = this.switchLoopStack.pop()
        invariant(popped?.uniqueName === uniqueName && popped.type === 'switch', 'Switch loop stack is unbalanced')
      },
      get hasBreaks() {
        return stackData.numBreaks > 0
      },
    }
  }
}



================================================
FILE: src/awst_build/context/unique-name-resolver.ts
================================================
import type ts from 'typescript'
import { toSubScript } from '../../util'

export class UniqueNameResolver {
  protected readonly symbolToName: Map<ts.Symbol, string>
  protected readonly nameToCount: Map<string, number>

  constructor(parent?: UniqueNameResolver) {
    if (parent) {
      this.symbolToName = new Map(parent.symbolToName.entries())
      this.nameToCount = new Map(parent.nameToCount.entries())
    } else {
      this.symbolToName = new Map()
      this.nameToCount = new Map()
    }
  }

  /**
   * Resolve a rawName to a unique name within the scope of this resolver. When provided
   * with a symbol which has already been seen, return the same name
   * @param rawName
   * @param symbol
   */
  resolveUniqueName(rawName: string, symbol: ts.Symbol | undefined): string {
    const name = symbol && this.symbolToName.get(symbol)
    if (name) {
      return name
    }
    const nameCount = this.nameToCount.get(rawName) ?? 0
    let uniqueName
    if (nameCount === 0) {
      uniqueName = rawName
    } else {
      uniqueName = `${rawName}${toSubScript(nameCount)}`
    }
    this.nameToCount.set(rawName, nameCount + 1)
    if (symbol) {
      this.symbolToName.set(symbol, uniqueName)
    }
    return uniqueName
  }

  createChild(): UniqueNameResolver {
    return new UniqueNameResolver(this)
  }
}



================================================
FILE: src/awst_build/eb/arc4-bare-method-decorator-builder.ts
================================================
import { OnCompletionAction } from '../../awst/models'
import type { Expression } from '../../awst/nodes'
import { ARC4CreateOption, NewArray, StringConstant, TupleExpression } from '../../awst/nodes'
import type { SourceLocation } from '../../awst/source-location'
import { Constants } from '../../constants'
import { CodeError } from '../../errors'
import { logger } from '../../logger'
import { codeInvariant } from '../../util'
import type { Arc4AbiDecoratorData } from '../models/decorator-data'
import type { PType } from '../ptypes'
import { arc4AbiMethodDecorator, arc4BareMethodDecorator, ArrayPType, boolPType, stringPType } from '../ptypes'
import type { InstanceBuilder } from './index'
import { DecoratorDataBuilder, NodeBuilder } from './index'
import { ObjectLiteralExpressionBuilder } from './literal/object-literal-expression-builder'
import { requireBooleanConstant, requireInstanceBuilder, requireStringConstant } from './util'
import { parseFunctionArgs } from './util/arg-parsing'

const ocaMap: Record<string, OnCompletionAction> = {
  NoOp: OnCompletionAction.NoOp,
  OptIn: OnCompletionAction.OptIn,
  CloseOut: OnCompletionAction.CloseOut,
  ClearState: OnCompletionAction.ClearState,
  UpdateApplication: OnCompletionAction.UpdateApplication,
  DeleteApplication: OnCompletionAction.DeleteApplication,
}

const createMap: Record<string, ARC4CreateOption> = {
  allow: ARC4CreateOption.allow,
  require: ARC4CreateOption.require,
  disallow: ARC4CreateOption.disallow,
}

export class Arc4BareMethodDecoratorBuilder extends NodeBuilder {
  get ptype(): PType {
    return arc4BareMethodDecorator
  }

  call(args: ReadonlyArray<NodeBuilder>, typeArgs: ReadonlyArray<PType>, sourceLocation: SourceLocation): NodeBuilder {
    const {
      args: [{ allowActions, onCreate }],
    } = parseFunctionArgs({
      args,
      typeArgs,
      genericTypeArgs: 1,
      callLocation: sourceLocation,
      funcName: 'arc4.baremethod',
      argSpec: (a) => [
        a.obj({
          allowActions: a.optional(stringPType, new ArrayPType({ elementType: stringPType })),
          onCreate: a.optional(stringPType),
        }),
      ],
    })
    return new DecoratorDataBuilder(sourceLocation, {
      type: Constants.symbolNames.arc4BareDecoratorName,
      allowedCompletionTypes: allowActions && resolveOnCompletionActions(allowActions),
      allowedCompletionTypesLocation: allowActions?.sourceLocation,
      create: onCreate && mapStringConstant(createMap, onCreate?.resolve()),
      createLocation: onCreate?.sourceLocation,
      sourceLocation: sourceLocation,
    })
  }
}

export class Arc4AbiMethodDecoratorBuilder extends NodeBuilder {
  get ptype(): PType {
    return arc4AbiMethodDecorator
  }

  call(args: ReadonlyArray<NodeBuilder>, typeArgs: ReadonlyArray<PType>, sourceLocation: SourceLocation): NodeBuilder {
    const {
      args: [{ allowActions, onCreate, readonly, name, defaultArguments }],
    } = parseFunctionArgs({
      args,
      typeArgs,
      genericTypeArgs: 1,
      callLocation: sourceLocation,
      funcName: 'arc4.abimethod',
      argSpec: (a) => [
        a.obj({
          allowActions: a.optional(stringPType, new ArrayPType({ elementType: stringPType })),
          onCreate: a.optional(stringPType),
          readonly: a.optional(boolPType),
          name: a.optional(stringPType),
          defaultArguments: a.optional(),
        }),
      ],
    })

    return new DecoratorDataBuilder(sourceLocation, {
      type: Constants.symbolNames.arc4AbiDecoratorName,
      allowedCompletionTypes: allowActions && resolveOnCompletionActions(allowActions),
      allowedCompletionTypesLocation: allowActions?.sourceLocation,
      create: onCreate && mapStringConstant(createMap, onCreate?.resolve()),
      createLocation: onCreate?.sourceLocation,
      sourceLocation: sourceLocation,
      nameOverride: name ? requireStringConstant(name).value : undefined,
      readonly: readonly ? requireBooleanConstant(readonly).value : false,
      defaultArguments: resolveDefaultArguments(defaultArguments, sourceLocation),
    })
  }
}

function mapStringConstant<T>(map: Record<string, T>, expr: Expression) {
  codeInvariant(expr instanceof StringConstant, 'Expected string literal', expr.sourceLocation)
  const strValue = expr.value
  if (Object.hasOwn(map, strValue)) return map[strValue]
  throw new CodeError(`${strValue} is not valid at this location`, { sourceLocation: expr.sourceLocation })
}

function resolveOnCompletionActions(oca: InstanceBuilder): OnCompletionAction[] {
  const value = oca.resolve()
  let ocaRawExpr: Expression[]
  if (value instanceof StringConstant) {
    ocaRawExpr = [value]
  } else if (value instanceof TupleExpression) {
    ocaRawExpr = value.items
  } else if (value instanceof NewArray) {
    ocaRawExpr = value.values
  } else {
    throw new CodeError('Unexpected value for onComplete', { sourceLocation: oca.sourceLocation })
  }

  const ocas = ocaRawExpr.map((item) => mapStringConstant(ocaMap, item))
  const distinctOcas = Array.from(new Set(ocas))
  if (distinctOcas.length !== ocas.length) {
    logger.warn(oca.sourceLocation, 'Duplicate on completion actions')
  }
  codeInvariant(distinctOcas.length, 'Method must allow at least one on complete action', oca.sourceLocation)
  return ocas
}

function resolveDefaultArguments(
  defaultArguments: NodeBuilder | undefined,
  sourceLocation: SourceLocation,
): Arc4AbiDecoratorData['defaultArguments'] {
  const result: Arc4AbiDecoratorData['defaultArguments'] = {}
  if (!defaultArguments) return result
  codeInvariant(defaultArguments instanceof ObjectLiteralExpressionBuilder, `Default argument specification should be an object literal`)
  for (const [parameterName] of defaultArguments.ptype.orderedProperties()) {
    const paramConfig = defaultArguments.memberAccess(parameterName, sourceLocation)
    codeInvariant(paramConfig instanceof ObjectLiteralExpressionBuilder, 'Default argument specification should be an object literal')

    if (paramConfig.hasProperty('constant')) {
      result[parameterName] = {
        type: 'constant',
        value: requireInstanceBuilder(paramConfig.memberAccess('constant', sourceLocation)),
      }
    } else if (paramConfig.hasProperty('from')) {
      result[parameterName] = {
        type: 'member',
        name: requireStringConstant(paramConfig.memberAccess('from', sourceLocation)).value,
      }
    } else {
      logger.error(sourceLocation, 'Default argument specifications should specify fromConstant or fromMember')
    }
  }

  return result
}



================================================
FILE: src/awst_build/eb/assert-function-builder.ts
================================================
import { intrinsicFactory } from '../../awst/intrinsic-factory'
import { StringConstant } from '../../awst/nodes'
import type { SourceLocation } from '../../awst/source-location'
import { CodeError } from '../../errors'
import { invariant } from '../../util'
import type { PType } from '../ptypes'
import { stringPType } from '../ptypes'
import type { NodeBuilder } from './index'
import { FunctionBuilder } from './index'
import { requireConstantOfType, requireStringConstant } from './util'
import { parseFunctionArgs } from './util/arg-parsing'
import { VoidExpressionBuilder } from './void-expression-builder'

export class AssertFunctionBuilder extends FunctionBuilder {
  call(args: ReadonlyArray<NodeBuilder>, typeArgs: ReadonlyArray<PType>, sourceLocation: SourceLocation): NodeBuilder {
    const [condition, message, ...rest] = args
    if (rest.length !== 0) {
      throw CodeError.unexpectedUnhandledArgs({ sourceLocation })
    }

    if (condition === undefined) {
      throw new CodeError('Missing required argument: condition', { sourceLocation })
    }
    let messageStr: string | null = null
    if (message) {
      const messageConst = requireConstantOfType(message, stringPType)
      invariant(messageConst instanceof StringConstant, 'messageConst must be StringConst')
      messageStr = messageConst.value
    }

    return new VoidExpressionBuilder(
      intrinsicFactory.assert({
        sourceLocation,
        condition: condition.boolEval(sourceLocation),
        comment: messageStr,
      }),
    )
  }
}

export class ErrFunctionBuilder extends FunctionBuilder {
  call(args: ReadonlyArray<NodeBuilder>, typeArgs: ReadonlyArray<PType>, sourceLocation: SourceLocation): NodeBuilder {
    const {
      args: [message],
    } = parseFunctionArgs({
      args,
      typeArgs,
      genericTypeArgs: 0,
      callLocation: sourceLocation,
      argSpec: (a) => [a.optional(stringPType)],
      funcName: 'err',
    })

    return new VoidExpressionBuilder(
      intrinsicFactory.err({
        sourceLocation,
        comment: message ? requireStringConstant(message).value : null,
      }),
    )
  }
}



================================================
FILE: src/awst_build/eb/assert-match-function-builder.ts
================================================
import { intrinsicFactory } from '../../awst/intrinsic-factory'
import type { SourceLocation } from '../../awst/source-location'
import { codeInvariant } from '../../util'
import type { PType } from '../ptypes'
import { assertMatchFunction, stringPType } from '../ptypes'
import { NodeBuilder } from './index'
import { buildComparisons } from './match-function-builder'
import { requireStringConstant } from './util'
import { parseFunctionArgs } from './util/arg-parsing'
import { VoidExpressionBuilder } from './void-expression-builder'

export class AssertMatchFunctionBuilder extends NodeBuilder {
  readonly ptype = assertMatchFunction

  call(args: ReadonlyArray<NodeBuilder>, typeArgs: ReadonlyArray<PType>, sourceLocation: SourceLocation): NodeBuilder {
    const {
      args: [subject, tests, comment],
    } = parseFunctionArgs({
      args,
      typeArgs,
      callLocation: sourceLocation,
      genericTypeArgs: 1,
      funcName: 'assertMatch',
      argSpec: (a) => [a.passthrough(), a.required(), a.optional(stringPType)],
    })
    codeInvariant(subject, 'subject parameter is missing', sourceLocation)

    const condition = buildComparisons(subject, tests, this.typeDescription, sourceLocation).resolve()

    codeInvariant(condition, 'assertMatch must have at least 1 condition', sourceLocation)
    const commentStr = comment ? requireStringConstant(comment).value : 'assert target is match for conditions'
    return new VoidExpressionBuilder(
      intrinsicFactory.assert({
        condition,
        comment: commentStr,
        sourceLocation,
      }),
    )
  }
}



================================================
FILE: src/awst_build/eb/biguint-expression-builder.ts
================================================
import { awst } from '../../awst'
import { intrinsicFactory } from '../../awst/intrinsic-factory'
import { nodeFactory } from '../../awst/node-factory'
import type { Expression } from '../../awst/nodes'
import { BigUIntBinaryOperator, BigUIntPostfixUnaryOperator, IntegerConstant, NumericComparison } from '../../awst/nodes'
import type { SourceLocation } from '../../awst/source-location'
import { wtypes } from '../../awst/wtypes'

import { NotSupported } from '../../errors'
import { logger } from '../../logger'
import { tryConvertEnum } from '../../util'
import type { InstanceType, PType } from '../ptypes'
import { BigUintFunction, biguintPType, boolPType, bytesPType, stringPType, uint64PType } from '../ptypes'
import { instanceEb } from '../type-registry'
import type { InstanceBuilder, NodeBuilder } from './index'
import { BuilderBinaryOp, BuilderComparisonOp, BuilderUnaryOp, FunctionBuilder, InstanceExpressionBuilder } from './index'
import { UInt64ExpressionBuilder } from './uint64-expression-builder'
import { requireExpressionOfType } from './util'
import { parseFunctionArgs } from './util/arg-parsing'

export class BigUintFunctionBuilder extends FunctionBuilder {
  readonly ptype = BigUintFunction

  call(args: ReadonlyArray<NodeBuilder>, typeArgs: ReadonlyArray<PType>, sourceLocation: SourceLocation): NodeBuilder {
    const {
      args: [initialValue],
    } = parseFunctionArgs({
      args,
      typeArgs,
      genericTypeArgs: 0,
      callLocation: sourceLocation,
      funcName: 'BigUInt',
      argSpec: (a) => [a.optional(boolPType, stringPType, bytesPType, biguintPType, uint64PType)],
    })
    let biguint: Expression

    if (!initialValue) {
      biguint = nodeFactory.bigUIntConstant({
        sourceLocation,
        value: 0n,
      })
    } else if (initialValue.ptype.equals(boolPType)) {
      biguint = nodeFactory.reinterpretCast({
        expr: initialValue.toBytes(sourceLocation),
        sourceLocation,
        wtype: biguintPType.wtype,
      })
    } else if (initialValue.ptype.equals(stringPType)) {
      const expr = initialValue.resolve()
      if (expr instanceof awst.StringConstant) {
        biguint = nodeFactory.bigUIntConstant({
          value: BigInt(expr.value),
          sourceLocation,
        })
      } else {
        logger.error(initialValue.sourceLocation, 'Only compile time constant string values are supported')
        biguint = nodeFactory.bigUIntConstant({ value: 0n, sourceLocation })
      }
    } else if (initialValue.ptype.equals(bytesPType)) {
      biguint = nodeFactory.reinterpretCast({
        expr: initialValue.resolve(),
        sourceLocation,
        wtype: biguintPType.wtype,
      })
    } else if (initialValue.ptype.equals(uint64PType)) {
      const expr = initialValue.resolve()
      if (expr instanceof IntegerConstant) {
        biguint = nodeFactory.bigUIntConstant({
          ...expr,
          sourceLocation,
        })
      } else {
        biguint = nodeFactory.reinterpretCast({
          expr: initialValue.toBytes(sourceLocation),
          sourceLocation,
          wtype: biguintPType.wtype,
        })
      }
    } else {
      return initialValue
    }
    return new BigUintExpressionBuilder(biguint)
  }
}

export class BigUintExpressionBuilder extends InstanceExpressionBuilder<InstanceType> {
  constructor(expr: Expression) {
    super(expr, biguintPType)
  }
  compare(other: InstanceBuilder, op: BuilderComparisonOp, sourceLocation: SourceLocation): InstanceBuilder {
    const otherExpr = requireExpressionOfType(other, biguintPType)
    const numComOp = tryConvertEnum(op, BuilderComparisonOp, NumericComparison)
    if (numComOp === undefined) {
      throw new NotSupported(`Numeric comparison operator ${op}`, {
        sourceLocation,
      })
    }
    return instanceEb(
      nodeFactory.numericComparisonExpression({
        lhs: this._expr,
        rhs: otherExpr,
        operator: numComOp,
        sourceLocation,
      }),
      boolPType,
    )
  }
  boolEval(sourceLocation: SourceLocation, negate: boolean = false): Expression {
    return new UInt64ExpressionBuilder(
      intrinsicFactory.bitLen({
        value: this._expr,
        sourceLocation,
      }),
    ).boolEval(sourceLocation, negate)
  }

  prefixUnaryOp(op: BuilderUnaryOp, sourceLocation: SourceLocation): InstanceBuilder {
    let binaryOp: BigUIntBinaryOperator

    switch (op) {
      case BuilderUnaryOp.inc:
        binaryOp = BigUIntBinaryOperator.add
        break
      case BuilderUnaryOp.dec:
        binaryOp = BigUIntBinaryOperator.sub
        break
      case BuilderUnaryOp.bit_inv:
        logger.error(sourceLocation, `Bitwise inversion of ${this.typeDescription} is not supported as the bit size is indeterminate`)
        return this

      case BuilderUnaryOp.pos:
        return this
      default:
        return super.prefixUnaryOp(op, sourceLocation)
    }
    return new BigUintExpressionBuilder(
      nodeFactory.assignmentExpression({
        target: this.resolveLValue(),
        sourceLocation,
        value: nodeFactory.bigUIntBinaryOperation({
          left: this.resolve(),
          right: nodeFactory.bigUIntConstant({ value: 1n, sourceLocation }),
          op: binaryOp,
          sourceLocation,
        }),
      }),
    )
  }

  postfixUnaryOp(op: BuilderUnaryOp, sourceLocation: SourceLocation): InstanceBuilder {
    let unaryOp: BigUIntPostfixUnaryOperator
    switch (op) {
      case BuilderUnaryOp.inc:
        unaryOp = BigUIntPostfixUnaryOperator.increment
        break
      case BuilderUnaryOp.dec:
        unaryOp = BigUIntPostfixUnaryOperator.decrement
        break
      default:
        return super.postfixUnaryOp(op, sourceLocation)
    }
    return new BigUintExpressionBuilder(
      nodeFactory.bigUIntPostfixUnaryOperation({
        sourceLocation,
        target: this.resolveLValue(),
        wtype: this.ptype.wtype,
        op: unaryOp,
      }),
    )
  }

  binaryOp(other: InstanceBuilder, op: BuilderBinaryOp, sourceLocation: SourceLocation): InstanceBuilder {
    const otherExpr = requireExpressionOfType(other, biguintPType)

    const uintOp = op === BuilderBinaryOp.div ? BigUIntBinaryOperator.floorDiv : tryConvertEnum(op, BuilderBinaryOp, BigUIntBinaryOperator)
    if (uintOp === undefined) {
      throw new NotSupported(`BigUint binary operator '${op}'`, {
        sourceLocation,
      })
    }
    return new BigUintExpressionBuilder(
      nodeFactory.bigUIntBinaryOperation({
        left: this._expr,
        right: otherExpr,
        op: uintOp,
        sourceLocation,
      }),
    )
  }

  augmentedAssignment(other: InstanceBuilder, op: BuilderBinaryOp, sourceLocation: SourceLocation): InstanceBuilder {
    return new BigUintExpressionBuilder(
      nodeFactory.assignmentExpression({
        target: this.resolveLValue(),
        value: this.binaryOp(other, op, sourceLocation).resolve(),
        sourceLocation,
      }),
    )
  }

  toBytes(sourceLocation: SourceLocation): awst.Expression {
    return nodeFactory.reinterpretCast({ expr: this.resolve(), sourceLocation, wtype: wtypes.bytesWType })
  }
}



================================================
FILE: src/awst_build/eb/boolean-expression-builder.ts
================================================
import type { awst } from '../../awst'
import { intrinsicFactory } from '../../awst/intrinsic-factory'
import { nodeFactory } from '../../awst/node-factory'
import type { Expression } from '../../awst/nodes'
import { EqualityComparison, NumericComparison } from '../../awst/nodes'
import type { SourceLocation } from '../../awst/source-location'
import { codeInvariant, tryConvertEnum } from '../../util'
import type { InstanceType, PType } from '../ptypes'
import { boolPType, bytesPType, stringPType } from '../ptypes'
import type { InstanceBuilder, NodeBuilder } from './index'
import { BuilderComparisonOp, FunctionBuilder, InstanceExpressionBuilder } from './index'
import { parseFunctionArgs } from './util/arg-parsing'

export class BooleanFunctionBuilder extends FunctionBuilder {
  call(args: ReadonlyArray<NodeBuilder>, typeArgs: ReadonlyArray<PType>, sourceLocation: SourceLocation): NodeBuilder {
    const {
      args: [value],
    } = parseFunctionArgs({
      args,
      typeArgs,
      genericTypeArgs: 1,
      callLocation: sourceLocation,
      funcName: 'Boolean',
      argSpec: (a) => [a.optional()],
    })
    if (!value) {
      return new BooleanExpressionBuilder(nodeFactory.boolConstant({ value: false, sourceLocation }))
    }

    if (value.ptype.equals(boolPType)) {
      return value
    }
    if (value.ptype.equals(bytesPType)) {
      return new BooleanExpressionBuilder(
        nodeFactory.bytesComparisonExpression({
          sourceLocation,
          operator: EqualityComparison.ne,
          lhs: value.resolve(),
          rhs: nodeFactory.bytesConstant({ value: new Uint8Array(), sourceLocation }),
        }),
      )
    } else if (value.ptype.equals(stringPType)) {
      return new BooleanExpressionBuilder(
        nodeFactory.bytesComparisonExpression({
          sourceLocation,
          operator: EqualityComparison.ne,
          lhs: value.toBytes(sourceLocation),
          rhs: nodeFactory.bytesConstant({ value: new Uint8Array(), sourceLocation }),
        }),
      )
    } else {
      return new BooleanExpressionBuilder(
        nodeFactory.not({
          sourceLocation,
          expr: nodeFactory.not({
            sourceLocation,
            expr: value.boolEval(sourceLocation),
          }),
        }),
      )
    }
  }
}

export class BooleanExpressionBuilder extends InstanceExpressionBuilder<InstanceType> {
  constructor(expr: Expression) {
    super(expr, boolPType)
  }

  boolEval(sourceLocation: SourceLocation, negate: boolean): awst.Expression {
    if (negate) {
      return nodeFactory.not({ sourceLocation, expr: this._expr })
    }
    return this._expr
  }

  toBytes(sourceLocation: SourceLocation): Expression {
    return intrinsicFactory.itob({
      value: this._expr,
      sourceLocation,
    })
  }

  compare(other: InstanceBuilder, op: BuilderComparisonOp, sourceLocation: SourceLocation): InstanceBuilder {
    const operator = tryConvertEnum(op, BuilderComparisonOp, NumericComparison)
    codeInvariant(operator, `${op} is not supported on ${this.typeDescription}`, sourceLocation)
    return new BooleanExpressionBuilder(
      nodeFactory.numericComparisonExpression({
        operator,
        lhs: this.resolve(),
        rhs: other.resolveToPType(boolPType).resolve(),
        sourceLocation,
      }),
    )
  }
}



================================================
FILE: src/awst_build/eb/bytes-expression-builder.ts
================================================
import type { awst } from '../../awst'

import { intrinsicFactory } from '../../awst/intrinsic-factory'
import { nodeFactory } from '../../awst/node-factory'
import type { Expression } from '../../awst/nodes'
import {
  BytesBinaryOperator,
  BytesConstant,
  BytesEncoding,
  BytesUnaryOperator,
  EqualityComparison,
  IntegerConstant,
} from '../../awst/nodes'
import type { SourceLocation } from '../../awst/source-location'
import { wtypes } from '../../awst/wtypes'
import { wrapInCodeError } from '../../errors'
import { logger } from '../../logger'
import { base32ToUint8Array, base64ToUint8Array, enumKeyFromValue, hexToUint8Array, uint8ArrayToUtf8, utf8ToUint8Array } from '../../util'
import type { InstanceType, PType } from '../ptypes'
import {
  ArrayPType,
  bigIntPType,
  biguintPType,
  BytesFunction,
  bytesPType,
  numberPType,
  NumericLiteralPType,
  stringPType,
  uint64PType,
} from '../ptypes'
import { BooleanExpressionBuilder } from './boolean-expression-builder'
import type { BuilderComparisonOp, InstanceBuilder, NodeBuilder } from './index'
import { BuilderUnaryOp, FunctionBuilder, InstanceExpressionBuilder, ParameterlessFunctionBuilder } from './index'
import { BigIntLiteralExpressionBuilder } from './literal/big-int-literal-expression-builder'
import { AtFunctionBuilder } from './shared/at-function-builder'
import { SliceFunctionBuilder } from './shared/slice-function-builder'
import { StringExpressionBuilder } from './string-expression-builder'
import { isStaticallyIterable, StaticIterator } from './traits/static-iterator'
import { UInt64ExpressionBuilder } from './uint64-expression-builder'
import { requireExpressionOfType, requireStringConstant } from './util'
import { parseFunctionArgs } from './util/arg-parsing'
import { compareBytes } from './util/compare-bytes'

export class BytesFunctionBuilder extends FunctionBuilder {
  readonly ptype = BytesFunction

  taggedTemplate(head: string, spans: ReadonlyArray<readonly [InstanceBuilder, string]>, sourceLocation: SourceLocation): InstanceBuilder {
    let result: awst.Expression = nodeFactory.bytesConstant({
      sourceLocation,
      encoding: BytesEncoding.utf8,
      value: utf8ToUint8Array(head),
    })
    for (const [value, joiningText] of spans) {
      const valueBytes = value.ptype?.equals(stringPType) ? value.resolve() : value.toBytes(sourceLocation)
      result = nodeFactory.bytesBinaryOperation({
        left: result,
        right: valueBytes,
        op: BytesBinaryOperator.add,
        sourceLocation,
        wtype: wtypes.bytesWType,
      })
      if (joiningText) {
        result = nodeFactory.bytesBinaryOperation({
          left: result,
          right: nodeFactory.bytesConstant({
            sourceLocation,
            value: utf8ToUint8Array(joiningText),
            encoding: BytesEncoding.utf8,
          }),
          op: BytesBinaryOperator.add,
          sourceLocation,
          wtype: wtypes.bytesWType,
        })
      }
    }

    return new BytesExpressionBuilder(result)
  }

  call(args: ReadonlyArray<NodeBuilder>, typeArgs: ReadonlyArray<PType>, sourceLocation: SourceLocation): NodeBuilder {
    const {
      args: [initialValue],
    } = parseFunctionArgs({
      args,
      typeArgs,
      genericTypeArgs: 0,
      callLocation: sourceLocation,
      funcName: 'Bytes',
      argSpec: (a) => [
        a.optional(
          numberPType,
          bigIntPType,
          uint64PType,
          biguintPType,
          stringPType,
          bytesPType,
          new ArrayPType({ elementType: uint64PType }),
        ),
      ],
    })
    const empty = nodeFactory.bytesConstant({
      sourceLocation,
      value: new Uint8Array(),
    })

    let bytesExpr

    if (!initialValue) {
      bytesExpr = empty
    } else if (initialValue instanceof BigIntLiteralExpressionBuilder) {
      logger.error(initialValue.sourceLocation, initialValue.ptype.expressionMessage)
      bytesExpr = empty
    } else if (initialValue.ptype.equals(uint64PType)) {
      bytesExpr = initialValue.toBytes(sourceLocation)
    } else if (initialValue.ptype.equals(biguintPType)) {
      bytesExpr = initialValue.toBytes(sourceLocation)
    } else if (initialValue.ptype.equals(stringPType)) {
      bytesExpr = initialValue.toBytes(sourceLocation)
    } else if (initialValue.ptype.equals(bytesPType)) {
      return initialValue
    } else {
      if (isStaticallyIterable(initialValue)) {
        const bytes: number[] = []
        for (const item of initialValue[StaticIterator]()) {
          const byte = item.resolve()
          if (byte instanceof IntegerConstant && byte.value < 256n) {
            bytes.push(Number(byte.value))
          } else {
            logger.error(item.sourceLocation, 'A compile time constant value between 0 and 255 is expected here')
            break
          }
        }
        bytesExpr = nodeFactory.bytesConstant({
          value: Uint8Array.from(bytes),
          sourceLocation: initialValue.sourceLocation,
        })
      } else {
        logger.error(initialValue.sourceLocation, 'Only array literals or tuples are supported here')
        bytesExpr = empty
      }
    }
    return new BytesExpressionBuilder(bytesExpr)
  }

  memberAccess(name: string, sourceLocation: SourceLocation): NodeBuilder {
    switch (name) {
      case 'fromHex':
        return new FromEncodingBuilder(sourceLocation, hexToUint8Array, BytesEncoding.base16, 'fromHex')
      case 'fromBase32':
        return new FromEncodingBuilder(sourceLocation, base32ToUint8Array, BytesEncoding.base32, 'fromBase32')
      case 'fromBase64':
        return new FromEncodingBuilder(sourceLocation, base64ToUint8Array, BytesEncoding.base64, 'fromBase64')
    }
    return super.memberAccess(name, sourceLocation)
  }
}

class FromEncodingBuilder extends FunctionBuilder {
  constructor(
    sourceLocation: SourceLocation,
    private decodeLiteral: (value: string) => Uint8Array,
    private encoding: BytesEncoding,
    private functionName: string,
  ) {
    super(sourceLocation)
  }

  call(args: ReadonlyArray<NodeBuilder>, typeArgs: ReadonlyArray<PType>, sourceLocation: SourceLocation): NodeBuilder {
    const {
      args: [valueBuilder],
    } = parseFunctionArgs({
      args,
      typeArgs,
      callLocation: sourceLocation,
      genericTypeArgs: 0,
      funcName: this.functionName,
      argSpec: (a) => [a.required(stringPType)],
    })

    const value = requireStringConstant(valueBuilder)

    return new BytesExpressionBuilder(
      nodeFactory.bytesConstant({
        value: wrapInCodeError(() => this.decodeLiteral(value.value), value.sourceLocation),
        encoding: this.encoding,
        sourceLocation,
      }),
    )
  }
}

export class BytesExpressionBuilder extends InstanceExpressionBuilder<InstanceType> {
  constructor(expr: Expression) {
    super(expr, bytesPType)
  }
  prefixUnaryOp(op: BuilderUnaryOp, sourceLocation: SourceLocation): InstanceBuilder {
    switch (op) {
      case BuilderUnaryOp.bit_inv:
        logger.error(
          sourceLocation,
          `The '~' ${this.typeDescription} operator coerces the target value to a number type. Use {bytes expression}.bitwiseInvert() instead`,
        )
        return new BigIntLiteralExpressionBuilder(0n, new NumericLiteralPType({ literalValue: 0n }), sourceLocation)
    }
    return super.prefixUnaryOp(op, sourceLocation)
  }

  memberAccess(name: string, sourceLocation: SourceLocation): NodeBuilder {
    switch (name) {
      case 'length':
        return new UInt64ExpressionBuilder(
          intrinsicFactory.bytesLen({
            value: this._expr,
            sourceLocation,
          }),
        )
      case 'bitwiseInvert':
        return new BytesInvertBuilder(this._expr)
      case 'bitwiseAnd':
        return new BitwiseOpFunctionBuilder(this._expr, BytesBinaryOperator.bitAnd)
      case 'bitwiseOr':
        return new BitwiseOpFunctionBuilder(this._expr, BytesBinaryOperator.bitOr)
      case 'bitwiseXor':
        return new BitwiseOpFunctionBuilder(this._expr, BytesBinaryOperator.bitXor)
      case 'toString':
        return new ToStringBuilder(this._expr)
      case 'concat':
        return new ConcatExpressionBuilder(this._expr)
      case 'at':
        return new AtFunctionBuilder(
          this._expr,
          bytesPType,
          requireExpressionOfType(this.memberAccess('length', sourceLocation), uint64PType),
        )
      case 'slice':
        return new SliceFunctionBuilder(this._expr, bytesPType)
      case 'equals':
        return new EqualsFunctionBuilder(this._expr)
    }
    return super.memberAccess(name, sourceLocation)
  }
  compare(other: InstanceBuilder, op: BuilderComparisonOp, sourceLocation: SourceLocation): InstanceBuilder {
    return compareBytes(this._expr, requireExpressionOfType(other, bytesPType), op, sourceLocation, this.typeDescription)
  }
  boolEval(sourceLocation: SourceLocation, negate: boolean): awst.Expression {
    return new UInt64ExpressionBuilder(
      intrinsicFactory.bytesLen({
        value: this._expr,
        sourceLocation,
      }),
    ).boolEval(sourceLocation, negate)
  }

  toBytes(): awst.Expression {
    return this.resolve()
  }

  toString(sourceLocation: SourceLocation): Expression {
    if (this._expr instanceof BytesConstant) {
      return nodeFactory.stringConstant({
        value: uint8ArrayToUtf8(this._expr.value),
        sourceLocation: this._expr.sourceLocation,
      })
    }
    return nodeFactory.reinterpretCast({
      expr: this._expr,
      sourceLocation,
      wtype: wtypes.stringWType,
    })
  }
}

export class ConcatExpressionBuilder extends FunctionBuilder {
  constructor(private expr: awst.Expression) {
    super(expr.sourceLocation)
  }

  call(args: ReadonlyArray<NodeBuilder>, typeArgs: ReadonlyArray<PType>, sourceLocation: SourceLocation): NodeBuilder {
    const {
      args: [other],
    } = parseFunctionArgs({
      args,
      typeArgs,
      callLocation: sourceLocation,
      funcName: 'concat',
      genericTypeArgs: 0,
      argSpec: (a) => [a.required(bytesPType)],
    })
    return new BytesExpressionBuilder(
      intrinsicFactory.bytesConcat({
        left: this.expr,
        right: other.resolve(),
        sourceLocation: sourceLocation,
      }),
    )
  }
}

export class BytesInvertBuilder extends ParameterlessFunctionBuilder {
  constructor(private expr: awst.Expression) {
    super(
      expr,
      (expr, sourceLocation) =>
        new BytesExpressionBuilder(
          nodeFactory.bytesUnaryOperation({
            wtype: wtypes.bytesWType,
            expr: this.expr,
            op: BytesUnaryOperator.bitInvert,
            sourceLocation,
          }),
        ),
    )
  }
}

export class BitwiseOpFunctionBuilder extends FunctionBuilder {
  constructor(
    private expr: awst.Expression,
    private op: BytesBinaryOperator,
  ) {
    super(expr.sourceLocation)
  }

  call(args: ReadonlyArray<NodeBuilder>, typeArgs: ReadonlyArray<PType>, sourceLocation: SourceLocation): NodeBuilder {
    const {
      args: [other],
    } = parseFunctionArgs({
      args,
      typeArgs,
      genericTypeArgs: 0,
      callLocation: sourceLocation,
      funcName: enumKeyFromValue(this.op, BytesBinaryOperator),
      argSpec: (a) => [a.required(bytesPType)],
    })
    return new BytesExpressionBuilder(
      nodeFactory.bytesBinaryOperation({
        wtype: wtypes.bytesWType,
        left: this.expr,
        right: other.resolve(),
        op: this.op,
        sourceLocation,
      }),
    )
  }
}

export class ToStringBuilder extends ParameterlessFunctionBuilder {
  constructor(private expr: awst.Expression) {
    super(
      expr,
      (expr, sourceLocation) =>
        new StringExpressionBuilder(
          nodeFactory.reinterpretCast({
            wtype: wtypes.stringWType,
            expr: this.expr,
            sourceLocation,
          }),
        ),
    )
  }
}

class EqualsFunctionBuilder extends FunctionBuilder {
  constructor(private expr: awst.Expression) {
    super(expr.sourceLocation)
  }

  call(args: ReadonlyArray<NodeBuilder>, typeArgs: ReadonlyArray<PType>, sourceLocation: SourceLocation): NodeBuilder {
    const {
      args: [right],
    } = parseFunctionArgs({
      args,
      typeArgs,
      genericTypeArgs: 0,
      callLocation: sourceLocation,
      funcName: 'equals',
      argSpec: (a) => [a.required(bytesPType)],
    })
    return new BooleanExpressionBuilder(
      nodeFactory.bytesComparisonExpression({
        operator: EqualityComparison.eq,
        lhs: this.expr,
        rhs: right.resolve(),
        sourceLocation,
      }),
    )
  }
}



================================================
FILE: src/awst_build/eb/contract-builder.ts
================================================
import { nodeFactory } from '../../awst/node-factory'

import type { Expression, LValue } from '../../awst/nodes'
import type { SourceLocation } from '../../awst/source-location'
import { wtypes } from '../../awst/wtypes'
import { Constants } from '../../constants'
import { CodeError } from '../../errors'
import { codeInvariant, invariant } from '../../util'
import { AwstBuildContext } from '../context/awst-build-context'
import type { ContractOptionsDecoratorData } from '../models/decorator-data'
import type { PType } from '../ptypes'
import {
  ClusteredContractClassType,
  ContractClassPType,
  contractOptionsDecorator,
  numberPType,
  StorageProxyPType,
  stringPType,
} from '../ptypes'

import { instanceEb } from '../type-registry'

import { BaseContractMethodExpressionBuilder, ContractMethodExpressionBuilder } from './free-subroutine-expression-builder'
import { DecoratorDataBuilder, FunctionBuilder, InstanceBuilder, NodeBuilder } from './index'
import { requireLiteralNumber, requireStringConstant } from './util'
import { parseFunctionArgs } from './util/arg-parsing'
import { requireAvmVersion } from './util/avm-version'
import { processScratchRanges } from './util/scratch-slots'
import { VoidExpressionBuilder } from './void-expression-builder'

/**
 * Handles expressions using `this` in the context of a contract
 */
export class ContractThisBuilder extends InstanceBuilder<ContractClassPType> {
  resolve(): Expression {
    throw new CodeError('this keyword is not valid as a value', { sourceLocation: this.sourceLocation })
  }
  resolveLValue(): LValue {
    throw new CodeError('this keyword is not valid as a value', { sourceLocation: this.sourceLocation })
  }
  readonly #ptype: ContractClassPType
  constructor(ptype: ContractClassPType, sourceLocation: SourceLocation) {
    super(sourceLocation)
    this.#ptype = ptype
  }

  get ptype(): ContractClassPType {
    return this.#ptype
  }

  memberAccess(name: string, sourceLocation: SourceLocation): NodeBuilder {
    const property = this.ptype.properties[name]
    if (property) {
      const storageDeclaration = AwstBuildContext.current.getStorageDeclaration(this.ptype, name)
      if (property instanceof StorageProxyPType) {
        codeInvariant(storageDeclaration, `No declaration exists for property ${property}.`, sourceLocation)
        return instanceEb(storageDeclaration.key, property)
      }
    }
    const method = this.ptype.methods[name]
    if (method) {
      return new ContractMethodExpressionBuilder(sourceLocation, method, this.ptype)
    }
    for (const base of this.ptype.allBases()) {
      if (name in base.methods) {
        return new ContractMethodExpressionBuilder(sourceLocation, base.methods[name], base)
      }
    }
    return super.memberAccess(name, sourceLocation)
  }
}

/**
 * Handles expressions using `super` in the context of a contract
 */
export class ContractSuperBuilder extends ContractThisBuilder {
  constructor(ptype: ContractClassPType, sourceLocation: SourceLocation) {
    super(ptype, sourceLocation)
  }

  call(args: ReadonlyArray<NodeBuilder>, typeArgs: ReadonlyArray<PType>, sourceLocation: SourceLocation): NodeBuilder {
    codeInvariant(args.length === 0, 'Constructor arguments are not supported', sourceLocation)
    codeInvariant(typeArgs.length === 0, 'Super calls cannot be generic', sourceLocation)
    return new VoidExpressionBuilder(
      nodeFactory.subroutineCallExpression({
        target: nodeFactory.instanceSuperMethodTarget({
          memberName: Constants.symbolNames.constructorMethodName,
        }),
        args: [],
        sourceLocation,
        wtype: wtypes.voidWType,
      }),
    )
  }

  memberAccess(name: string, sourceLocation: SourceLocation): NodeBuilder {
    if (this.ptype instanceof ClusteredContractClassType && name === 'class') {
      return new PolytypeClassSuperMethodBuilder(this.ptype, sourceLocation)
    }

    const method = this.ptype.methods[name]
    if (method) {
      return new BaseContractMethodExpressionBuilder(sourceLocation, method)
    }
    return super.memberAccess(name, sourceLocation)
  }
}

/**
 * Handles calls of `super.class` from polytype library which is used to access the prototype of a specific base type
 */
class PolytypeClassSuperMethodBuilder extends FunctionBuilder {
  constructor(
    public readonly ptype: ClusteredContractClassType,
    sourceLocation: SourceLocation,
  ) {
    super(sourceLocation)
  }
  call(args: ReadonlyArray<NodeBuilder>, typeArgs: ReadonlyArray<PType>, sourceLocation: SourceLocation): NodeBuilder {
    const {
      args: [contract],
    } = parseFunctionArgs({
      args,
      typeArgs,
      genericTypeArgs: 1,
      callLocation: sourceLocation,
      funcName: 'super.class',
      argSpec: (a) => [a.required(ContractClassPType)],
    })
    const matchedBaseType = this.ptype.baseTypes.find((b) => b.equals(contract.ptype))

    codeInvariant(matchedBaseType, `${contract.ptype} must be a direct base type of this class`)
    return new PolytypeExplicitClassAccessExpressionBuilder(matchedBaseType, sourceLocation)
  }
}

/**
 * Matches polytype's super.class(SomeType) expression
 */
export class PolytypeExplicitClassAccessExpressionBuilder extends InstanceBuilder {
  resolve(): Expression {
    throw new CodeError('Contract class cannot be used as a value')
  }
  resolveLValue(): LValue {
    throw new CodeError('Contract class cannot be used as a value')
  }
  constructor(
    public readonly ptype: ContractClassPType,
    sourceLocation: SourceLocation,
  ) {
    super(sourceLocation)
  }

  memberAccess(name: string, sourceLocation: SourceLocation): NodeBuilder {
    const method = this.ptype.methods[name]
    if (method) {
      return new ContractMethodExpressionBuilder(sourceLocation, method, this.ptype)
    }
    if (name in this.ptype.properties) {
      throw new CodeError(`Not Supported: Accessing properties of a specific base type. Instead just use \`this.${name}\``, {
        sourceLocation,
      })
    }
    return super.memberAccess(name, sourceLocation)
  }
}

export class ContractClassBuilder extends InstanceBuilder {
  resolve(): Expression {
    throw new CodeError('Contract class cannot be used as a value')
  }
  resolveLValue(): LValue {
    throw new CodeError('Contract class cannot be used as a value')
  }
  readonly ptype: ContractClassPType
  constructor(sourceLocation: SourceLocation, ptype: PType) {
    super(sourceLocation)
    invariant(ptype instanceof ContractClassPType, 'ptype must be ContractClassPType')
    this.ptype = ptype
  }

  newCall(args: ReadonlyArray<NodeBuilder>, typeArgs: ReadonlyArray<PType>, sourceLocation: SourceLocation): InstanceBuilder {
    throw new CodeError('Contract class cannot be constructed manually')
  }

  call(args: ReadonlyArray<NodeBuilder>, typeArgs: ReadonlyArray<PType>, sourceLocation: SourceLocation): InstanceBuilder {
    throw new CodeError('Contract class cannot be called manually')
  }

  memberAccess(name: string, sourceLocation: SourceLocation): NodeBuilder {
    switch (name) {
      case 'prototype':
        return new ContractClassPrototypeBuilder(sourceLocation, this.ptype)
    }
    return super.memberAccess(name, sourceLocation)
  }
}

class ContractClassPrototypeBuilder extends NodeBuilder {
  constructor(
    sourceLocation: SourceLocation,
    readonly ptype: ContractClassPType,
  ) {
    super(sourceLocation)
  }

  memberAccess(name: string, sourceLocation: SourceLocation): NodeBuilder {
    const method = this.ptype.methods[name]
    if (method) {
      return new ContractMethodExpressionBuilder(sourceLocation, method, this.ptype)
    }
    return super.memberAccess(name, sourceLocation)
  }
}

export class ContractOptionsDecoratorBuilder extends FunctionBuilder {
  readonly ptype = contractOptionsDecorator
  call(args: ReadonlyArray<NodeBuilder>, typeArgs: ReadonlyArray<PType>, sourceLocation: SourceLocation): NodeBuilder {
    const {
      args: [{ avmVersion, name, stateTotals, scratchSlots }],
    } = parseFunctionArgs({
      args,
      typeArgs,
      genericTypeArgs: 0,
      callLocation: sourceLocation,
      funcName: this.typeDescription,
      argSpec: (a) => [
        a.obj({
          avmVersion: a.optional(numberPType),
          name: a.optional(stringPType),
          scratchSlots: a.optional(),
          stateTotals: a.optional(),
        }),
      ],
    })

    return new DecoratorDataBuilder(sourceLocation, {
      type: 'contract',
      avmVersion: avmVersion && requireAvmVersion(avmVersion),
      name: name && requireStringConstant(name).value,
      stateTotals: stateTotals && buildStateTotals(stateTotals),
      scratchSlots: scratchSlots && processScratchRanges(scratchSlots),
      sourceLocation,
    })
  }
}

function buildStateTotals(builder: NodeBuilder): ContractOptionsDecoratorData['stateTotals'] {
  function tryGetProp(name: string): bigint | undefined {
    if (builder.hasProperty(name)) {
      return requireLiteralNumber(builder.memberAccess(name, builder.sourceLocation))
    }
    return undefined
  }

  return {
    globalBytes: tryGetProp('globalBytes'),
    globalUints: tryGetProp('globalUints'),
    localBytes: tryGetProp('localBytes'),
    localUints: tryGetProp('localUints'),
  }
}



================================================
FILE: src/awst_build/eb/ensure-budget.ts
================================================
import { nodeFactory } from '../../awst/node-factory'
import { PuyaLibFunction } from '../../awst/nodes'
import type { SourceLocation } from '../../awst/source-location'
import { wtypes } from '../../awst/wtypes'
import type { PType } from '../ptypes'
import { ensureBudgetFunction, opUpFeeSourceType, uint64PType } from '../ptypes'
import type { NodeBuilder } from './index'
import { FunctionBuilder } from './index'
import { requireExpressionOfType } from './util'
import { parseFunctionArgs } from './util/arg-parsing'
import { VoidExpressionBuilder } from './void-expression-builder'

export class EnsureBudgetFunctionBuilder extends FunctionBuilder {
  readonly ptype = ensureBudgetFunction

  call(args: ReadonlyArray<NodeBuilder>, typeArgs: ReadonlyArray<PType>, sourceLocation: SourceLocation): NodeBuilder {
    const {
      args: [budget, feeSource],
    } = parseFunctionArgs({
      args,
      typeArgs,
      callLocation: sourceLocation,
      funcName: this.ptype.name,
      genericTypeArgs: 0,
      argSpec: (a) => [a.required(uint64PType), a.optional(opUpFeeSourceType.memberType)],
    })

    return new VoidExpressionBuilder(
      nodeFactory.puyaLibCall({
        func: PuyaLibFunction.ensureBudget,
        args: [
          nodeFactory.callArg({
            name: null,
            value: budget.resolve(),
          }),
          nodeFactory.callArg({
            name: null,
            value: feeSource
              ? requireExpressionOfType(feeSource, opUpFeeSourceType.memberType)
              : nodeFactory.uInt64Constant({ value: 0n, sourceLocation }),
          }),
        ],
        sourceLocation,
        wtype: wtypes.voidWType,
      }),
    )
  }
}



================================================
FILE: src/awst_build/eb/folding.ts
================================================
import { nodeFactory } from '../../awst/node-factory'
import type { Expression } from '../../awst/nodes'
import type { SourceLocation } from '../../awst/source-location'
import { CodeError } from '../../errors'
import { BuilderBinaryOp, BuilderComparisonOp } from './index'

const binaryOpFolding: Record<BuilderBinaryOp, undefined | ((left: bigint, right: bigint) => bigint)> = {
  [BuilderBinaryOp.div]: (l, r) => l / r,
  [BuilderBinaryOp.add]: (l, r) => l + r,
  [BuilderBinaryOp.sub]: (l, r) => l - r,
  [BuilderBinaryOp.mult]: (l, r) => l * r,
  [BuilderBinaryOp.mod]: (l, r) => l % r,
  [BuilderBinaryOp.pow]: (l, r) => l ** r,
  [BuilderBinaryOp.matMult]: undefined,
  [BuilderBinaryOp.lshift]: (l, r) => {
    return l << r
  },
  [BuilderBinaryOp.rshift]: (l, r) => l >> r,
  [BuilderBinaryOp.bitOr]: (l, r) => l | r,
  [BuilderBinaryOp.bitXor]: (l, r) => l ^ r,
  [BuilderBinaryOp.bitAnd]: (l, r) => l & r,
  [BuilderBinaryOp.comma]: (l, r) => r,
}

const comparisonOpFolding: Record<BuilderComparisonOp, undefined | ((left: bigint, right: bigint) => boolean)> = {
  [BuilderComparisonOp.eq]: (l, r) => l === r,
  [BuilderComparisonOp.ne]: (l, r) => l !== r,
  [BuilderComparisonOp.lt]: (l, r) => l < r,
  [BuilderComparisonOp.lte]: (l, r) => l <= r,
  [BuilderComparisonOp.gt]: (l, r) => l > r,
  [BuilderComparisonOp.gte]: (l, r) => l >= r,
}

export function foldBinaryOp(left: bigint, right: bigint, op: BuilderBinaryOp, sourceLocation: SourceLocation): bigint {
  const result = binaryOpFolding[op]?.(left, right)
  switch (typeof result) {
    case 'bigint':
      return result
    default:
      throw new CodeError(`${op} is not supported`, { sourceLocation })
  }
}

export function foldComparisonOp(left: bigint, right: bigint, op: BuilderComparisonOp, sourceLocation: SourceLocation): Expression {
  const result = comparisonOpFolding[op]?.(left, right)
  switch (typeof result) {
    case 'boolean':
      return nodeFactory.boolConstant({
        value: result,
        sourceLocation: sourceLocation,
      })
    default:
      throw new CodeError(`${op} is not supported`, { sourceLocation })
  }
}



================================================
FILE: src/awst_build/eb/free-subroutine-expression-builder.ts
================================================
import { ContractReference } from '../../awst/models'
import { nodeFactory } from '../../awst/node-factory'
import type { ContractMethodTarget, InstanceMethodTarget, InstanceSuperMethodTarget, MethodConstant, SubroutineID } from '../../awst/nodes'
import { ARC4ABIMethodConfig } from '../../awst/nodes'
import type { SourceLocation } from '../../awst/source-location'
import { InternalError } from '../../errors'
import { codeInvariant } from '../../util'
import { buildArc4MethodConstant } from '../arc4-util'
import { AwstBuildContext } from '../context/awst-build-context'
import type { ContractClassPType, PType } from '../ptypes'
import { FunctionPType } from '../ptypes'
import { typeRegistry } from '../type-registry'
import type { NodeBuilder } from './index'
import { FunctionBuilder } from './index'
import { parseFunctionArgs } from './util/arg-parsing'

export abstract class SubroutineExpressionBuilder extends FunctionBuilder {
  protected constructor(
    sourceLocation: SourceLocation,
    public readonly ptype: FunctionPType,
    public readonly target: SubroutineID | InstanceMethodTarget | InstanceSuperMethodTarget | ContractMethodTarget,
  ) {
    super(sourceLocation)
  }

  call(args: ReadonlyArray<NodeBuilder>, typeArgs: ReadonlyArray<PType>, sourceLocation: SourceLocation): NodeBuilder {
    const { args: mappedArgs } = parseFunctionArgs({
      args,
      typeArgs,
      funcName: this.ptype.name,
      callLocation: sourceLocation,
      genericTypeArgs: 0,
      argSpec: (a) => this.ptype.parameters.map(([_, ptype]) => a.required(ptype)),
    })

    return typeRegistry.getInstanceEb(
      nodeFactory.subroutineCallExpression({
        target: this.target,
        args: mappedArgs.map((a) => nodeFactory.callArg({ name: null, value: a.resolve() })),
        sourceLocation: sourceLocation,
        wtype: this.ptype.returnType.wtypeOrThrow,
      }),
      this.ptype.returnType,
    )
  }
}

/**
 * Invoke a contract method on the current contract (ie. this.someMethod())
 */
export class ContractMethodExpressionBuilder extends SubroutineExpressionBuilder {
  declare readonly target: ContractMethodTarget

  constructor(
    sourceLocation: SourceLocation,
    ptype: FunctionPType,
    public readonly contractType: ContractClassPType,
  ) {
    super(
      sourceLocation,
      ptype,
      nodeFactory.contractMethodTarget({
        cref: ContractReference.fromPType(contractType),
        memberName: ptype.name,
      }),
    )
  }

  getMethodSelector(sourceLocation = this.sourceLocation): MethodConstant {
    const methodTarget = this.target
    const arc4Config = AwstBuildContext.current.getArc4Config(this.contractType, methodTarget.memberName)
    codeInvariant(arc4Config instanceof ARC4ABIMethodConfig, `${methodTarget.memberName} is not an ABI method`, this.sourceLocation)
    return buildArc4MethodConstant(this.ptype, arc4Config, sourceLocation)
  }
}

/**
 * Invoke a contract method on the super contract (ie. super.someMethod())
 */
export class BaseContractMethodExpressionBuilder extends SubroutineExpressionBuilder {
  constructor(sourceLocation: SourceLocation, ptype: FunctionPType) {
    super(
      sourceLocation,
      ptype,
      nodeFactory.instanceSuperMethodTarget({
        memberName: ptype.name,
      }),
    )
  }
}

/**
 * Invoke a free subroutine (ie. someMethod())
 */
export class FreeSubroutineExpressionBuilder extends SubroutineExpressionBuilder {
  constructor(sourceLocation: SourceLocation, ptype: PType) {
    if (!(ptype instanceof FunctionPType)) {
      throw new InternalError(`Invalid ptype`)
    }
    super(
      sourceLocation,
      ptype,
      nodeFactory.subroutineID({
        target: ptype.fullName,
      }),
    )
  }
}



================================================
FILE: src/awst_build/eb/index.ts
================================================
import { awst } from '../../awst'
import { nodeFactory } from '../../awst/node-factory'
import type { Expression } from '../../awst/nodes'
import { TupleItemExpression } from '../../awst/nodes'
import type { SourceLocation } from '../../awst/source-location'
import { CodeError, NotSupported } from '../../errors'
import { logger } from '../../logger'
import type { DecoratorData } from '../models/decorator-data'
import type { LibClassType, PType, PTypeOrClass } from '../ptypes'
import { instanceEb } from '../type-registry'

export enum BuilderComparisonOp {
  eq = '===',
  ne = '!==',
  lt = '<',
  lte = '<=',
  gt = '>',
  gte = '>=',
}
export enum BuilderUnaryOp {
  inc = '++',
  dec = '--',
  bit_inv = '~',
  neg = '-',
  pos = '+',
}

export enum BuilderBinaryOp {
  add = '+',
  sub = '-',
  mult = '*',
  div = '/',
  mod = '%',
  pow = '**',
  matMult = '@',
  lshift = '<<',
  rshift = '>>',
  bitOr = '|',
  bitXor = '^',
  bitAnd = '&',
  /**
   * Eval left, return right
   * let y = 2
   * // x == 4
   * const x = (y * 3, y - 2)
   */
  comma = ',',
}

export abstract class NodeBuilder {
  constructor(public readonly sourceLocation: SourceLocation) {}

  abstract readonly ptype: PType | undefined

  public get typeDescription(): string {
    if (this.ptype) {
      return this.ptype.name
    }
    return this.constructor.name
  }

  call(args: ReadonlyArray<NodeBuilder>, typeArgs: ReadonlyArray<PType>, sourceLocation: SourceLocation): NodeBuilder {
    throw new NotSupported(`Calling ${this.typeDescription}`, {
      sourceLocation,
    })
  }

  newCall(args: ReadonlyArray<NodeBuilder>, typeArgs: ReadonlyArray<PType>, sourceLocation: SourceLocation): InstanceBuilder {
    throw new NotSupported(`Calling ${this.typeDescription} with the new keyword`, { sourceLocation })
  }

  taggedTemplate(head: string, spans: ReadonlyArray<readonly [InstanceBuilder, string]>, sourceLocation: SourceLocation): InstanceBuilder {
    throw new NotSupported(`Tagged templates on ${this.typeDescription}`, {
      sourceLocation,
    })
  }

  hasProperty(_name: string): boolean {
    return false
  }

  memberAccess(name: string, sourceLocation: SourceLocation): NodeBuilder {
    throw new NotSupported(`Accessing member ${name} on ${this.typeDescription}`, {
      sourceLocation,
    })
  }

  indexAccess(index: InstanceBuilder, sourceLocation: SourceLocation): NodeBuilder {
    throw new NotSupported(`Indexing ${this.typeDescription}`, {
      sourceLocation,
    })
  }

  boolEval(sourceLocation: SourceLocation, negate = false): awst.Expression {
    throw new NotSupported(`Boolean evaluation of ${this.typeDescription}`, {
      sourceLocation,
    })
  }
}

export abstract class InstanceBuilder<TPType extends PType = PType> extends NodeBuilder {
  constructor(sourceLocation: SourceLocation) {
    super(sourceLocation)
  }
  abstract get ptype(): TPType
  abstract resolve(): awst.Expression
  abstract resolveLValue(): awst.LValue

  /**
   * Returns a boolean indicating if the current builder can be resolved to the target type.
   * Resolvable meaning it may have a different type, but would be assignable to the target type in TypeScript
   * without a cast.
   * @param ptype
   */
  resolvableToPType(ptype: PTypeOrClass): boolean {
    return this.ptype.equalsOrInstanceOf(ptype)
  }

  /**
   * Attempts to resolve the value held by this builder to the target type.
   * @param ptype
   */
  resolveToPType(ptype: PTypeOrClass): InstanceBuilder {
    if (this.ptype.equalsOrInstanceOf(ptype)) {
      return this
    }
    throw CodeError.cannotResolveToType({ sourceType: this.ptype, targetType: ptype, sourceLocation: this.sourceLocation })
  }

  singleEvaluation(): InstanceBuilder {
    const expr = this.resolve()
    if (expr instanceof awst.VarExpression) {
      return this
    }
    return instanceEb(
      nodeFactory.singleEvaluation({
        source: this.resolve(),
      }),
      this.ptype,
    )
  }

  toBytes(sourceLocation: SourceLocation): awst.Expression {
    throw new NotSupported(`Serializing ${this.typeDescription} to bytes`, {
      sourceLocation,
    })
  }

  toString(sourceLocation: SourceLocation): awst.Expression {
    throw new NotSupported(`Converting ${this.typeDescription} to string`, {
      sourceLocation,
    })
  }

  prefixUnaryOp(op: BuilderUnaryOp, sourceLocation: SourceLocation): InstanceBuilder {
    throw new NotSupported(`Prefix Unary ${op} op on ${this.typeDescription}`, {
      sourceLocation,
    })
  }

  postfixUnaryOp(op: BuilderUnaryOp, sourceLocation: SourceLocation): InstanceBuilder {
    throw new NotSupported(`Postfix Unary ${op} op on ${this.typeDescription}`, {
      sourceLocation,
    })
  }

  compare(other: InstanceBuilder, op: BuilderComparisonOp, sourceLocation: SourceLocation): InstanceBuilder {
    throw new NotSupported(`${op} on ${this.typeDescription}`, {
      sourceLocation,
    })
  }

  binaryOp(other: InstanceBuilder, op: BuilderBinaryOp, sourceLocation: SourceLocation): InstanceBuilder {
    throw new NotSupported(`${op} on ${this.typeDescription}`, {
      sourceLocation,
    })
  }

  iterate(sourceLocation: SourceLocation): awst.Expression {
    throw new NotSupported(`Iteration on ${this.typeDescription}`, {
      sourceLocation,
    })
  }

  augmentedAssignment(other: InstanceBuilder, op: BuilderBinaryOp, sourceLocation: SourceLocation): InstanceBuilder {
    throw new NotSupported(`Augmented assignment to ${this.typeDescription} with ${op}`, {
      sourceLocation,
    })
  }

  reinterpretCast(target: PType, sourceLocation?: SourceLocation) {
    return instanceEb(
      nodeFactory.reinterpretCast({
        expr: this.resolve(),
        sourceLocation: sourceLocation ?? this.sourceLocation,
        wtype: target.wtypeOrThrow,
      }),
      target,
    )
  }
}

export abstract class ClassBuilder extends NodeBuilder {
  abstract readonly ptype: LibClassType

  abstract newCall(args: ReadonlyArray<NodeBuilder>, typeArgs: ReadonlyArray<PType>, sourceLocation: SourceLocation): InstanceBuilder

  call(args: ReadonlyArray<NodeBuilder>, typeArgs: ReadonlyArray<PType>, sourceLocation: SourceLocation): NodeBuilder {
    throw new CodeError(`${this.typeDescription} should be called with the \`new\` keyword`, { sourceLocation })
  }
}

export abstract class FunctionBuilder extends NodeBuilder {
  readonly ptype: PType | undefined = undefined

  constructor(location: SourceLocation) {
    super(location)
  }

  abstract call(args: ReadonlyArray<NodeBuilder>, typeArgs: ReadonlyArray<PType>, sourceLocation: SourceLocation): NodeBuilder
}

export abstract class ParameterlessFunctionBuilder extends FunctionBuilder {
  constructor(
    private readonly expression: Expression,
    private readonly definition: (expr: Expression, sourceLocation: SourceLocation) => NodeBuilder,
  ) {
    super(expression.sourceLocation)
  }

  call(args: ReadonlyArray<NodeBuilder>, typeArgs: ReadonlyArray<PType>, sourceLocation: SourceLocation): NodeBuilder {
    if (args.length) logger.error(sourceLocation, 'Function expects no arguments')
    if (typeArgs.length) logger.error(sourceLocation, 'Function expects type arguments')
    return this.definition(this.expression, sourceLocation)
  }
}

export abstract class InstanceExpressionBuilder<TPType extends PType> extends InstanceBuilder<PType> {
  #ptype: TPType

  get ptype(): TPType {
    return this.#ptype
  }

  constructor(
    protected _expr: awst.Expression,
    ptype: TPType,
  ) {
    super(_expr.sourceLocation)
    this.#ptype = ptype
  }

  resolve() {
    return this._expr
  }

  resolveLValue() {
    return requireLValue(this.resolve())
  }
}

export function requireLValue(expr: awst.Expression): awst.LValue {
  const lValueNodes = [
    awst.VarExpression,
    awst.FieldExpression,
    awst.IndexExpression,
    awst.TupleExpression,
    awst.AppStateExpression,
    awst.AppAccountStateExpression,
    awst.BoxValueExpression,
  ]
  if (expr instanceof TupleItemExpression) {
    throw new CodeError('Expression is not a valid assignment target - object is immutable', { sourceLocation: expr.sourceLocation })
  }
  if (!lValueNodes.some((l) => expr instanceof l)) {
    throw new CodeError(`Expression is not a valid assignment target`, {
      sourceLocation: expr.sourceLocation,
    })
  }
  if (expr instanceof awst.IndexExpression || expr instanceof awst.FieldExpression) {
    if (expr.base.wtype.immutable) {
      throw new CodeError(`Expression is not a valid assignment target - object is immutable`, {
        sourceLocation: expr.sourceLocation,
      })
    }
  }
  if (expr instanceof awst.ReinterpretCast) {
    requireLValue(expr.expr)
  }
  if (expr instanceof awst.TupleExpression) {
    for (const item of expr.items) {
      requireLValue(item)
    }
  }
  return expr as awst.LValue
}

export class DecoratorDataBuilder extends NodeBuilder {
  get ptype(): PType | undefined {
    return undefined
  }
  constructor(
    sourceLocation: SourceLocation,
    private readonly data: DecoratorData,
  ) {
    super(sourceLocation)
  }

  resolveDecoratorData(): DecoratorData {
    return this.data
  }
}



================================================
FILE: src/awst_build/eb/intrinsic-enum-builder.ts
================================================
import { nodeFactory } from '../../awst/node-factory'
import type { SourceLocation } from '../../awst/source-location'
import { CodeError } from '../../errors'
import { invariant } from '../../util'
import type { PType } from '../ptypes'
import { IntrinsicEnumType } from '../ptypes'
import { NodeBuilder } from './index'
import { StringExpressionBuilder } from './string-expression-builder'

export class IntrinsicEnumBuilder extends NodeBuilder {
  public readonly ptype: IntrinsicEnumType
  constructor(sourceLocation: SourceLocation, ptype: PType) {
    super(sourceLocation)
    invariant(ptype instanceof IntrinsicEnumType, 'ptype must be instance of IntrinsicEnumType')
    this.ptype = ptype
  }

  memberAccess(name: string, sourceLocation: SourceLocation): NodeBuilder {
    const matchedMember = this.ptype.members.find(([memberName]) => memberName === name)
    if (matchedMember) {
      return new StringExpressionBuilder(
        nodeFactory.stringConstant({
          value: matchedMember[1],
          sourceLocation,
        }),
      )
    }
    throw new CodeError(`Member ${name} does not exist on ${this.typeDescription}`, { sourceLocation })
  }
}



================================================
FILE: src/awst_build/eb/iterable-iterator-expression-builder.ts
================================================
import type { awst } from '../../awst'
import type { Expression } from '../../awst/nodes'
import type { SourceLocation } from '../../awst/source-location'
import { CodeError } from '../../errors'
import { invariant } from '../../util'
import { IterableIteratorType, type PType } from '../ptypes'
import { InstanceExpressionBuilder } from './index'

export class IterableIteratorExpressionBuilder extends InstanceExpressionBuilder<IterableIteratorType> {
  resolve(): awst.Expression {
    throw new CodeError(`${this.typeDescription} can only be used in for loops`, { sourceLocation: this.sourceLocation })
  }

  constructor(expr: Expression, ptype: PType) {
    invariant(ptype instanceof IterableIteratorType, 'ptype must be instance of IterableIteratorType')
    super(expr, ptype)
  }

  iterate(sourceLocation: SourceLocation): Expression {
    return this._expr
  }
}



================================================
FILE: src/awst_build/eb/literal-expression-builder.ts
================================================
import type { awst } from '../../awst'
import type { Expression, LValue } from '../../awst/nodes'
import type { SourceLocation } from '../../awst/source-location'
import { CodeError } from '../../errors'
import type { PType, PTypeOrClass } from '../ptypes'
import { TransientType } from '../ptypes'
import type { BuilderBinaryOp, BuilderComparisonOp, BuilderUnaryOp, NodeBuilder } from './index'
import { InstanceBuilder } from './index'

export abstract class LiteralExpressionBuilder extends InstanceBuilder {
  resolve(): Expression {
    this.throwInvalidExpression()
  }

  resolveLValue(): LValue {
    throw new CodeError('A literal value is not a valid assignment target', { sourceLocation: this.sourceLocation })
  }

  abstract resolvableToPType(ptype: PTypeOrClass): boolean

  abstract resolveToPType(ptype: PTypeOrClass): InstanceBuilder

  private throwInvalidExpression(): never {
    if (this.ptype instanceof TransientType) throw new CodeError(this.ptype.expressionMessage, { sourceLocation: this.sourceLocation })
    throw new CodeError(`Invalid expression type ${this.ptype}`, { sourceLocation: this.sourceLocation })
  }

  compare(other: InstanceBuilder, op: BuilderComparisonOp, sourceLocation: SourceLocation): InstanceBuilder {
    this.throwInvalidExpression()
  }

  binaryOp(other: InstanceBuilder, op: BuilderBinaryOp, sourceLocation: SourceLocation): InstanceBuilder {
    this.throwInvalidExpression()
  }

  memberAccess(name: string, sourceLocation: SourceLocation): NodeBuilder {
    this.throwInvalidExpression()
  }

  call(args: ReadonlyArray<NodeBuilder>, typeArgs: ReadonlyArray<PType>, sourceLocation: SourceLocation): NodeBuilder {
    this.throwInvalidExpression()
  }

  taggedTemplate(head: string, spans: ReadonlyArray<readonly [InstanceBuilder, string]>, sourceLocation: SourceLocation): InstanceBuilder {
    this.throwInvalidExpression()
  }

  indexAccess(index: InstanceBuilder, sourceLocation: SourceLocation): NodeBuilder {
    this.throwInvalidExpression()
  }

  singleEvaluation(): InstanceBuilder {
    this.throwInvalidExpression()
  }

  toBytes(sourceLocation: SourceLocation): awst.Expression {
    this.throwInvalidExpression()
  }

  prefixUnaryOp(op: BuilderUnaryOp, sourceLocation: SourceLocation): InstanceBuilder {
    this.throwInvalidExpression()
  }

  postfixUnaryOp(op: BuilderUnaryOp, sourceLocation: SourceLocation): InstanceBuilder {
    this.throwInvalidExpression()
  }

  iterate(sourceLocation: SourceLocation): awst.Expression {
    this.throwInvalidExpression()
  }

  augmentedAssignment(other: InstanceBuilder, op: BuilderBinaryOp, sourceLocation: SourceLocation): InstanceBuilder {
    this.throwInvalidExpression()
  }

  hasProperty(_name: string): boolean {
    return false
  }
}



================================================
FILE: src/awst_build/eb/log-function-builder.ts
================================================
import type { awst } from '../../awst'

import { intrinsicFactory } from '../../awst/intrinsic-factory'
import { nodeFactory } from '../../awst/node-factory'
import type { Expression } from '../../awst/nodes'
import type { SourceLocation } from '../../awst/source-location'
import { wtypes } from '../../awst/wtypes'
import { CodeError, InternalError, throwError } from '../../errors'
import type { PType } from '../ptypes'
import type { NodeBuilder } from './index'
import { FunctionBuilder } from './index'
import { requireInstanceBuilder } from './util'
import { VoidExpressionBuilder } from './void-expression-builder'

export class LogFunctionBuilder extends FunctionBuilder {
  call(args: ReadonlyArray<NodeBuilder>, typeArgs: ReadonlyArray<PType>, sourceLocation: SourceLocation): NodeBuilder {
    const argsExps = args.map((a) => requireInstanceBuilder(a))

    let logBytes: awst.Expression
    if (argsExps.length === 0) {
      throw new CodeError(`log expects at least 1 argument`, { sourceLocation })
    } else if (argsExps.length === 1) {
      logBytes = argsExps[0].toBytes(sourceLocation)
    } else {
      logBytes =
        argsExps.reduce(
          (a: Expression | undefined, b): Expression | undefined =>
            a === undefined
              ? b.toBytes(sourceLocation)
              : intrinsicFactory.bytesConcat({ left: a, right: b.toBytes(sourceLocation), sourceLocation }),
          undefined,
        ) ?? throwError(new InternalError('Should never get here given previous conditions', { sourceLocation }))
    }

    return new VoidExpressionBuilder(
      nodeFactory.intrinsicCall({
        sourceLocation: sourceLocation,
        immediates: [],
        stackArgs: [logBytes],
        opCode: 'log',
        wtype: wtypes.voidWType,
      }),
    )
  }
}



================================================
FILE: src/awst_build/eb/logic-sig-builder.ts
================================================
import type { Expression, LValue } from '../../awst/nodes'
import type { SourceLocation } from '../../awst/source-location'
import { CodeError } from '../../errors'
import { invariant } from '../../util'
import { logicSigOptionsDecorator, LogicSigPType, numberPType, type PType, stringPType } from '../ptypes'
import { DecoratorDataBuilder, FunctionBuilder, InstanceBuilder, type NodeBuilder } from './index'
import { requireStringConstant } from './util'
import { parseFunctionArgs } from './util/arg-parsing'
import { requireAvmVersion } from './util/avm-version'
import { processScratchRanges } from './util/scratch-slots'

export class LogicSigClassBuilder extends InstanceBuilder {
  resolve(): Expression {
    throw new CodeError('LogicSig class cannot be used as a value')
  }
  resolveLValue(): LValue {
    throw new CodeError('LogicSig class cannot be used as a value')
  }
  readonly ptype: LogicSigPType
  constructor(sourceLocation: SourceLocation, ptype: PType) {
    super(sourceLocation)
    invariant(ptype instanceof LogicSigPType, 'ptype must be LogicSigPType')
    this.ptype = ptype
  }

  newCall(args: ReadonlyArray<NodeBuilder>, typeArgs: ReadonlyArray<PType>, sourceLocation: SourceLocation): InstanceBuilder {
    throw new CodeError('LogicSig class cannot be constructed manually')
  }

  call(args: ReadonlyArray<NodeBuilder>, typeArgs: ReadonlyArray<PType>, sourceLocation: SourceLocation): InstanceBuilder {
    throw new CodeError('LogicSig class cannot be called manually')
  }
}

export class LogicSigOptionsDecoratorBuilder extends FunctionBuilder {
  readonly ptype = logicSigOptionsDecorator

  call(args: ReadonlyArray<NodeBuilder>, typeArgs: ReadonlyArray<PType>, sourceLocation: SourceLocation): NodeBuilder {
    const {
      args: [{ avmVersion, name, scratchSlots }],
    } = parseFunctionArgs({
      args,
      typeArgs,
      genericTypeArgs: 0,
      callLocation: sourceLocation,
      funcName: this.typeDescription,
      argSpec: (a) => [
        a.obj({
          avmVersion: a.optional(numberPType),
          name: a.optional(stringPType),
          scratchSlots: a.optional(),
        }),
      ],
    })

    return new DecoratorDataBuilder(sourceLocation, {
      type: 'logicsig',
      avmVersion: avmVersion ? requireAvmVersion(avmVersion) : undefined,
      name: name ? requireStringConstant(name).value : undefined,
      sourceLocation,
      scratchSlots: scratchSlots && processScratchRanges(scratchSlots),
    })
  }
}



================================================
FILE: src/awst_build/eb/match-function-builder.ts
================================================
import { nodeFactory } from '../../awst/node-factory'
import type { Expression } from '../../awst/nodes'
import { BinaryBooleanOperator } from '../../awst/nodes'
import type { SourceLocation } from '../../awst/source-location'
import { CodeError } from '../../errors'
import { codeInvariant } from '../../util'
import type { PType } from '../ptypes'
import { ArrayPType, boolPType, matchFunction, ObjectPType, TuplePType, uint64PType } from '../ptypes'
import { instanceEb } from '../type-registry'
import type { InstanceBuilder } from './index'
import { BuilderComparisonOp, NodeBuilder } from './index'
import { isStaticallyIterable, StaticIterator } from './traits/static-iterator'
import { requireBuilderOfType, requireInstanceBuilder } from './util'
import { parseFunctionArgs } from './util/arg-parsing'

export class MatchFunctionBuilder extends NodeBuilder {
  readonly ptype = matchFunction

  call(args: ReadonlyArray<NodeBuilder>, typeArgs: ReadonlyArray<PType>, sourceLocation: SourceLocation): NodeBuilder {
    const {
      args: [subject, tests],
    } = parseFunctionArgs({
      args,
      typeArgs,
      callLocation: sourceLocation,
      genericTypeArgs: 1,
      funcName: 'match',
      argSpec: (a) => [a.passthrough(), a.required()],
    })
    codeInvariant(subject, 'subject parameter is missing', sourceLocation)

    return buildComparisons(subject, tests, this.typeDescription, sourceLocation)
  }
}

export function buildComparisons(subject: NodeBuilder, tests: InstanceBuilder, functionName: string, sourceLocation: SourceLocation) {
  if (tests.ptype instanceof ObjectPType) {
    const condition = tests.ptype
      .orderedProperties()
      .reduce((acc: Expression | undefined, [propName, propType]): Expression | undefined => {
        const subjectProperty = requireInstanceBuilder(subject.memberAccess(propName, sourceLocation))
        const testProperty = requireInstanceBuilder(tests.memberAccess(propName, sourceLocation))

        const comparison = buildComparison(subjectProperty, testProperty, functionName, sourceLocation)
        return combineConditions(acc, comparison.resolve(), sourceLocation)
      }, undefined)
    codeInvariant(condition, `${functionName} must have at least 1 condition`, sourceLocation)
    return instanceEb(condition, boolPType)
  } else if (isStaticallyIterable(tests)) {
    const condition = tests[StaticIterator]().reduce<Expression | undefined>(
      (acc, testItem, index) => {
        const indexAsBuilder = instanceEb(nodeFactory.uInt64Constant({ value: BigInt(index), sourceLocation }), uint64PType)
        const subjectItem = requireInstanceBuilder(subject.indexAccess(indexAsBuilder, sourceLocation))
        const comparison = buildComparison(subjectItem, testItem, functionName, sourceLocation)
        return combineConditions(acc, comparison.resolve(), sourceLocation)
      },
      compareLengths(subject, tests, functionName, sourceLocation),
    )
    codeInvariant(condition, `${functionName} must have at least 1 condition`, sourceLocation)
    return instanceEb(condition, boolPType)
  } else if (tests.ptype instanceof ArrayPType) {
    throw new CodeError(`${functionName} doesn't support matching against non literal arrays`, { sourceLocation: tests.sourceLocation })
  } else {
    throw new CodeError(`${functionName} requires either an object, array literal, or tuple`, { sourceLocation: tests.sourceLocation })
  }
}

function compareLengths(subject: NodeBuilder, tests: InstanceBuilder, functionName: string, sourceLocation: SourceLocation) {
  const subjectLength = requireInstanceBuilder(subject.memberAccess('length', sourceLocation))
  const testsLength = requireInstanceBuilder(tests.memberAccess('length', sourceLocation))

  return buildComparison(subjectLength, testsLength, functionName, sourceLocation).resolve()
}

function buildComparison(
  subjectProperty: InstanceBuilder,
  testProperty: InstanceBuilder,
  functionName: string,
  sourceLocation: SourceLocation,
): InstanceBuilder {
  const subjectType = subjectProperty.ptype
  // Recurse comparisons for nested objects
  if (
    subjectProperty.ptype instanceof ObjectPType ||
    subjectProperty.ptype instanceof TuplePType ||
    subjectProperty.ptype instanceof ArrayPType
  ) {
    return buildComparisons(subjectProperty, testProperty, functionName, sourceLocation)
  }

  if (testProperty.resolvableToPType(subjectType)) {
    return subjectProperty.compare(testProperty, BuilderComparisonOp.eq, sourceLocation)
  } else if (testProperty.hasProperty('between')) {
    const range = requireInstanceBuilder(testProperty.memberAccess('between', sourceLocation)).singleEvaluation()
    const rangePType = new TuplePType({ items: [subjectType, subjectType] })
    codeInvariant(range.resolvableToPType(rangePType), 'Between range must be of type $')
    const zeroIndex = instanceEb(nodeFactory.uInt64Constant({ value: 0n, sourceLocation }), uint64PType)
    const gte = subjectProperty
      .compare(requireBuilderOfType(range.indexAccess(zeroIndex, sourceLocation), subjectType), BuilderComparisonOp.gte, sourceLocation)
      .resolve()

    const oneIndex = instanceEb(nodeFactory.uInt64Constant({ value: 1n, sourceLocation }), uint64PType)
    const lte = subjectProperty
      .compare(requireBuilderOfType(range.indexAccess(oneIndex, sourceLocation), subjectType), BuilderComparisonOp.lte, sourceLocation)
      .resolve()

    return instanceEb(combineConditions(lte, gte, sourceLocation), boolPType)
  } else {
    const [op, operand] = getComparisonOpAndOperand(testProperty, subjectType)
    return subjectProperty.compare(operand, op, sourceLocation)
  }
}

function getComparisonOpAndOperand(testProperty: InstanceBuilder, targetType: PType): [BuilderComparisonOp, operand: InstanceBuilder] {
  const ops = {
    lessThan: BuilderComparisonOp.lt,
    lessThanEq: BuilderComparisonOp.lte,
    greaterThan: BuilderComparisonOp.gt,
    greaterThanEq: BuilderComparisonOp.gte,
  }
  for (const [prop, op] of Object.entries(ops)) {
    if (testProperty.hasProperty(prop)) {
      return [op, requireBuilderOfType(testProperty.memberAccess(prop, testProperty.sourceLocation), targetType)]
    }
  }
  throw new CodeError(`Cannot compare values of type ${testProperty.ptype} and ${targetType.name}`, {
    sourceLocation: testProperty.sourceLocation,
  })
}

function combineConditions(left: Expression | undefined, right: Expression, sourceLocation: SourceLocation): Expression {
  if (left) {
    return nodeFactory.booleanBinaryOperation({
      left: left,
      right: right,
      op: BinaryBooleanOperator.and,
      sourceLocation,
    })
  }
  return right
}



================================================
FILE: src/awst_build/eb/mutable-arrays.ts
================================================
import { nodeFactory } from '../../awst/node-factory'
import type { Expression } from '../../awst/nodes'
import type { SourceLocation } from '../../awst/source-location'
import { invariant } from '../../util'
import type { LibClassType, PType } from '../ptypes'
import { MutableArrayConstructor, MutableArrayGeneric, MutableArrayType } from '../ptypes'
import type { InstanceBuilder, NodeBuilder } from './index'
import { ClassBuilder, InstanceExpressionBuilder } from './index'
import { Arc4CopyFunctionBuilder } from './shared/arc4-copy-function-builder'
import { AtFunctionBuilder } from './shared/at-function-builder'
import { ArrayPopFunctionBuilder } from './shared/pop-function-builder'
import { ArrayPushFunctionBuilder } from './shared/push-function-builder'
import { requireExpressionOfType } from './util'
import { parseFunctionArgs } from './util/arg-parsing'
import { indexAccess } from './util/array/index-access'
import { arrayLength } from './util/array/length'

export class MutableArrayClassBuilder extends ClassBuilder {
  ptype: LibClassType = MutableArrayConstructor
  newCall(args: ReadonlyArray<NodeBuilder>, typeArgs: ReadonlyArray<PType>, sourceLocation: SourceLocation): InstanceBuilder {
    const {
      args: [...initialValues],
      ptypes: [itemType],
    } = parseFunctionArgs({
      args,
      typeArgs,
      callLocation: sourceLocation,
      funcName: this.typeDescription,
      genericTypeArgs: 1,
      argSpec: (a) => args.map((_) => a.required()),
    })
    const arrayType = MutableArrayGeneric.parameterise([itemType])
    return new MutableArrayExpressionBuilder(
      nodeFactory.newArray({
        values: initialValues.map((iv) => requireExpressionOfType(iv, itemType)),
        sourceLocation,
        wtype: arrayType.wtype,
      }),
      MutableArrayGeneric.parameterise([itemType]),
    )
  }
}

export class MutableArrayExpressionBuilder extends InstanceExpressionBuilder<MutableArrayType> {
  constructor(expr: Expression, ptype: PType) {
    invariant(ptype instanceof MutableArrayType, 'ptype must be MutableArrayType')
    super(expr, ptype)
  }

  iterate(sourceLocation: SourceLocation): Expression {
    return this.resolve()
  }

  indexAccess(index: InstanceBuilder, sourceLocation: SourceLocation): NodeBuilder {
    return indexAccess(this, index, sourceLocation)
  }

  memberAccess(name: string, sourceLocation: SourceLocation): NodeBuilder {
    switch (name) {
      case 'push':
        return new ArrayPushFunctionBuilder(this)
      case 'pop':
        return new ArrayPopFunctionBuilder(this)
      case 'length':
        return arrayLength(this, sourceLocation)
      case 'copy':
        return new Arc4CopyFunctionBuilder(this)
      case 'at':
        return new AtFunctionBuilder(this._expr, this.ptype.elementType, arrayLength(this, sourceLocation).resolve())
    }
    return super.memberAccess(name, sourceLocation)
  }
}



================================================
FILE: src/awst_build/eb/namespace-builder.ts
================================================
import type { SourceLocation } from '../../awst/source-location'
import { invariant } from '../../util'
import type { PType } from '../ptypes'
import { NamespacePType } from '../ptypes'
import { NodeBuilder } from './index'

export class NamespaceBuilder extends NodeBuilder {
  private readonly _ptype: NamespacePType
  constructor(sourceLocation: SourceLocation, ptype: PType) {
    super(sourceLocation)
    invariant(ptype instanceof NamespacePType, 'NamespaceBuilder must be constructed with NamespacePType')
    this._ptype = ptype
  }

  get ptype(): PType {
    return this._ptype
  }
}



================================================
FILE: src/awst_build/eb/native-array-expression-builder.ts
================================================
import { nodeFactory } from '../../awst/node-factory'
import type { Expression } from '../../awst/nodes'
import type { SourceLocation } from '../../awst/source-location'
import { CodeError } from '../../errors'
import { invariant } from '../../util'
import type { PType } from '../ptypes'
import { ArrayPType, numberPType, TuplePType, uint64PType } from '../ptypes'
import { ARC4ArrayType, ARC4EncodedType } from '../ptypes/arc4-types'
import { instanceEb } from '../type-registry'
import type { InstanceBuilder, NodeBuilder } from './index'
import { FunctionBuilder, InstanceExpressionBuilder } from './index'
import { SliceFunctionBuilder } from './shared/slice-function-builder'
import { parseFunctionArgs } from './util/arg-parsing'
import { concatArrays } from './util/array/concat'
import { indexAccess } from './util/array/index-access'
import { arrayLength } from './util/array/length'
import { translateNegativeIndex } from './util/translate-negative-index'

export class NativeArrayExpressionBuilder extends InstanceExpressionBuilder<ArrayPType> {
  constructor(expr: Expression, ptype: PType) {
    invariant(ptype instanceof ArrayPType, 'ptype must be instance of ArrayPType')
    super(expr, ptype)
  }

  iterate(sourceLocation: SourceLocation): Expression {
    return this.resolve()
  }

  indexAccess(index: InstanceBuilder, sourceLocation: SourceLocation): NodeBuilder {
    return indexAccess(this, index, sourceLocation)
  }

  memberAccess(name: string, sourceLocation: SourceLocation): NodeBuilder {
    switch (name) {
      case 'with':
        return new WithFunctionBuilder(this, sourceLocation)
      case 'length':
        return arrayLength(this, sourceLocation)
      case 'slice':
        return new SliceFunctionBuilder(this.resolve(), this.ptype)
      case 'concat':
        return new ConcatFunctionBuilder(this, sourceLocation)
    }

    return super.memberAccess(name, sourceLocation)
  }
}

class ConcatFunctionBuilder extends FunctionBuilder {
  constructor(
    private arrayBuilder: NativeArrayExpressionBuilder,
    sourceLocation: SourceLocation,
  ) {
    super(sourceLocation)
  }

  call(args: ReadonlyArray<NodeBuilder>, typeArgs: ReadonlyArray<PType>, sourceLocation: SourceLocation): NodeBuilder {
    const {
      args: [...items],
    } = parseFunctionArgs({
      args,
      typeArgs,
      genericTypeArgs: 0,
      argSpec: (a) => args.map(() => a.required()),
      callLocation: sourceLocation,
      funcName: 'Array.concat',
    })
    const elementType = this.arrayBuilder.ptype.elementType

    return new NativeArrayExpressionBuilder(
      items
        .reduce((acc, cur) => {
          if (cur.resolvableToPType(elementType)) {
            return concatArrays(
              acc,
              instanceEb(
                nodeFactory.tupleExpression({
                  items: [cur.resolveToPType(elementType).resolve()],
                  sourceLocation: cur.sourceLocation,
                }),
                new TuplePType({ items: [elementType] }),
              ),
              sourceLocation,
            )
          } else if (cur.resolvableToPType(this.arrayBuilder.ptype)) {
            if (cur.ptype instanceof TuplePType) {
              // Tuple can stay as a tuple, as long as it _is_ resolvable to an array
              return concatArrays(acc, cur, sourceLocation)
            }
            return concatArrays(acc, cur.resolveToPType(this.arrayBuilder.ptype), sourceLocation)
          }
          if (!(elementType instanceof ARC4EncodedType)) {
            throw new CodeError(`${cur.typeDescription} cannot be concatenated to ${this.typeDescription}`, { sourceLocation })
          }
          if (cur.ptype instanceof ARC4ArrayType && cur.ptype.elementType.equals(elementType)) {
            return concatArrays(acc, cur, sourceLocation)
          }
          throw new Error('TODO')
        }, this.arrayBuilder)
        .resolve(),
      this.arrayBuilder.ptype,
    )
  }
}

class WithFunctionBuilder extends FunctionBuilder {
  constructor(
    private arrayBuilder: NativeArrayExpressionBuilder,
    sourceLocation: SourceLocation,
  ) {
    super(sourceLocation)
  }

  call(args: ReadonlyArray<NodeBuilder>, typeArgs: ReadonlyArray<PType>, sourceLocation: SourceLocation): NodeBuilder {
    const {
      args: [index, newValue],
    } = parseFunctionArgs({
      args,
      typeArgs,
      genericTypeArgs: 0,
      argSpec: (a) => [a.required(uint64PType, numberPType), a.required(this.arrayBuilder.ptype.elementType)],
      callLocation: sourceLocation,
      funcName: 'Array.with',
    })

    return new NativeArrayExpressionBuilder(
      nodeFactory.arrayReplace({
        base: this.arrayBuilder.resolve(),
        value: newValue.resolve(),
        index: translateNegativeIndex(arrayLength(this.arrayBuilder, index.sourceLocation).resolve(), index),
        sourceLocation,
      }),
      this.arrayBuilder.ptype,
    )
  }
}



================================================
FILE: src/awst_build/eb/never-expression-builder.ts
================================================
import type { Expression, LValue } from '../../awst/nodes'
import { CodeError } from '../../errors'
import { invariant } from '../../util'
import type { PType } from '../ptypes'
import { InstanceType, neverPType } from '../ptypes'
import { InstanceExpressionBuilder } from './index'

export class NeverExpressionBuilder extends InstanceExpressionBuilder<InstanceType> {
  constructor(expr: Expression, ptype: PType) {
    invariant(ptype instanceof InstanceType && ptype.equals(neverPType), 'ptype must be neverPType')
    super(expr, neverPType)
  }

  resolve(): Expression {
    throw new CodeError('Cannot resolve expression of type never', { sourceLocation: this.sourceLocation })
  }

  resolveLValue(): LValue {
    throw new CodeError('Expression of type never is not a valid assignment target', { sourceLocation: this.sourceLocation })
  }
}



================================================
FILE: src/awst_build/eb/omitted-expression-builder.ts
================================================
import type { Expression, LValue } from '../../awst/nodes'
import { CodeError, InternalError } from '../../errors'
import type { PType, PTypeOrClass } from '../ptypes'
import { anyPType } from '../ptypes'
import { InstanceBuilder } from './index'

export class OmittedExpressionBuilder extends InstanceBuilder {
  get ptype(): PType {
    return anyPType
  }
  resolve(): Expression {
    throw new CodeError('Omitted expression cannot be resolved', { sourceLocation: this.sourceLocation })
  }
  resolveLValue(): LValue {
    throw new InternalError('Omitted expression cannot be resolved to an lvalue', { sourceLocation: this.sourceLocation })
  }

  resolvableToPType(ptype: PTypeOrClass): boolean {
    throw new InternalError('Omitted expression cannot be resolved to any type', { sourceLocation: this.sourceLocation })
  }
}



================================================
FILE: src/awst_build/eb/op-module-builder.ts
================================================
import { intrinsicFactory } from '../../awst/intrinsic-factory'
import { nodeFactory } from '../../awst/node-factory'
import { Expression, IntegerConstant, StringConstant, UInt64BinaryOperator } from '../../awst/nodes'
import type { SourceLocation } from '../../awst/source-location'
import { CodeError, InternalError } from '../../errors'
import { codeInvariant, enumerate, invariant } from '../../util'
import type { IntrinsicOpGrouping, IntrinsicOpMapping } from '../op-metadata'
import { OP_METADATA } from '../op-metadata'
import type { PType } from '../ptypes'
import {
  bytesPType,
  IntrinsicEnumType,
  IntrinsicFunctionGroupType,
  IntrinsicFunctionType,
  stringPType,
  uint64PType,
  voidPType,
} from '../ptypes'
import { instanceEb, typeRegistry } from '../type-registry'
import { FunctionBuilder, InstanceExpressionBuilder, NodeBuilder } from './index'
import { requestConstantOfType, requestExpressionOfType } from './util'
import { parseFunctionArgs } from './util/arg-parsing'

export class IntrinsicOpGroupBuilder extends NodeBuilder {
  private opGrouping: IntrinsicOpGrouping
  public readonly ptype: IntrinsicFunctionGroupType
  constructor(sourceLocation: SourceLocation, ptype: PType) {
    super(sourceLocation)
    invariant(ptype instanceof IntrinsicFunctionGroupType, 'ptype must be IntrinsicFunctionGroupType')
    this.ptype = ptype
    const metaData = OP_METADATA[ptype.name]
    invariant(metaData.type === 'op-grouping', 'ptype must map to op-grouping')
    this.opGrouping = metaData
  }

  hasProperty(name: string): boolean {
    return Object.hasOwn(this.opGrouping.ops, name)
  }

  memberAccess(name: string, sourceLocation: SourceLocation): NodeBuilder {
    if (!Object.hasOwn(this.opGrouping.ops, name)) {
      return super.memberAccess(name, sourceLocation)
    }
    const metaData = this.opGrouping.ops[name]

    if (metaData.signatures.some((s) => s.argNames.length || s.returnType.equals(voidPType))) {
      return new GroupedIntrinsicOpBuilder(sourceLocation, metaData)
    }

    const [sig] = metaData.signatures
    return typeRegistry.getInstanceEb(
      nodeFactory.intrinsicCall({
        wtype: sig.returnType.wtypeOrThrow,
        opCode: metaData.op,
        sourceLocation: sourceLocation,
        stackArgs: sig.stackArgs.map((x) => {
          if (x instanceof Expression) {
            return x
          }
          throw new InternalError('Intrinsic property expression cannot have unresolved arguments', { sourceLocation })
        }),
        immediates: sig.immediateArgs.map((x) => {
          switch (typeof x) {
            case 'string':
            case 'bigint':
              return x
            default:
              throw new InternalError('Intrinsic property expression cannot have unresolved arguments', { sourceLocation })
          }
        }),
      }),
      sig.returnType,
    )
  }
}

abstract class IntrinsicOpBuilderBase extends FunctionBuilder {
  protected constructor(
    sourceLocation: SourceLocation,
    private opMapping: IntrinsicOpMapping,
  ) {
    super(sourceLocation)
  }

  /**
   * Extract with 2 args extracts to the end of the sequence, the exact op code depends on if the start index is a constant value or not
   * @param args
   * @param typeArgs
   * @param sourceLocation
   */
  handleExtract(args: ReadonlyArray<NodeBuilder>, typeArgs: ReadonlyArray<PType>, sourceLocation: SourceLocation): NodeBuilder {
    const {
      args: [target, start, end],
    } = parseFunctionArgs({
      args,
      typeArgs,
      genericTypeArgs: 0,
      funcName: 'extract',
      callLocation: sourceLocation,
      argSpec: (a) => [a.required(bytesPType), a.required(uint64PType), a.optional(uint64PType)],
    })
    if (end) {
      const endExpr = end.resolve()
      codeInvariant(
        !(endExpr instanceof IntegerConstant && endExpr.value === 0n),
        'Extract with length=0 will always return an empty byte array. Omit length parameter to extract to the end of the sequence.',
      )
      return instanceEb(
        nodeFactory.intrinsicCall({
          opCode: 'extract3',
          immediates: [],
          stackArgs: [target.resolve(), start.resolve(), endExpr],
          wtype: bytesPType.wtype,
          sourceLocation,
        }),
        bytesPType,
      )
    }
    const startExpr = start.resolve()
    if (startExpr instanceof IntegerConstant) {
      // Use immediate version of extract
      return instanceEb(
        nodeFactory.intrinsicCall({
          opCode: 'extract',
          immediates: [startExpr.value, 0n],
          stackArgs: [target.resolve()],
          wtype: bytesPType.wtype,
          sourceLocation,
        }),
        bytesPType,
      )
    } else {
      const targetExpr = target.singleEvaluation().resolve()
      const startExpr = start.singleEvaluation().resolve()
      return instanceEb(
        nodeFactory.intrinsicCall({
          opCode: 'extract3',
          immediates: [],
          stackArgs: [
            targetExpr,
            startExpr,
            nodeFactory.uInt64BinaryOperation({
              op: UInt64BinaryOperator.sub,
              sourceLocation,
              left: intrinsicFactory.bytesLen({ value: targetExpr, sourceLocation }),
              right: startExpr,
            }),
          ],
          wtype: bytesPType.wtype,
          sourceLocation,
        }),
        bytesPType,
      )
    }
  }

  call(args: ReadonlyArray<NodeBuilder>, typeArgs: ReadonlyArray<PType>, sourceLocation: SourceLocation): NodeBuilder {
    if (this.opMapping.op === 'extract3') {
      return this.handleExtract(args, typeArgs, sourceLocation)
    }
    signatureLoop: for (const [index, sig] of enumerate(this.opMapping.signatures)) {
      const isLastSig = index + 1 >= this.opMapping.signatures.length
      if (args.length !== sig.argNames.length) {
        if (isLastSig)
          throw new CodeError(`Expected ${sig.argNames.length} args`, {
            sourceLocation,
          })
        else continue
      }

      const immediates: Array<string | bigint> = []
      const stackArgs: Array<Expression> = []

      stackArgLoop: for (const arg of sig.stackArgs) {
        if (arg instanceof Expression) {
          stackArgs.push(arg)
          continue
        }
        const thisArg = args[sig.argNames.indexOf(arg.name)]

        for (const ptype of arg.ptypes) {
          const expr = requestExpressionOfType(thisArg, ptype)
          if (expr) {
            stackArgs.push(expr)
            continue stackArgLoop
          }
        }
        continue signatureLoop
      }

      immediateArgLoop: for (const arg of sig.immediateArgs) {
        if (typeof arg === 'string' || typeof arg === 'bigint') {
          immediates.push(arg)
          continue
        }
        const thisArg = args[sig.argNames.indexOf(arg.name)]

        for (const ptype of arg.ptypes) {
          if (ptype instanceof IntrinsicEnumType) {
            const enumValue = requestConstantOfType(thisArg, stringPType)
            if (enumValue) {
              invariant(enumValue instanceof StringConstant, 'stringPType constant must be StringConstant')
              immediates.push(enumValue.value)
              continue immediateArgLoop
            }
          }
          const constantValue = requestConstantOfType(thisArg, ptype)
          if (constantValue) {
            if (constantValue instanceof IntegerConstant || constantValue instanceof StringConstant) {
              immediates.push(constantValue.value)
              continue immediateArgLoop
            }
            throw new InternalError(`Constant value ${constantValue} cannot be converted to an immediate argument`, { sourceLocation })
          }
        }
        continue signatureLoop
      }

      return typeRegistry.getInstanceEb(
        nodeFactory.intrinsicCall({
          opCode: this.opMapping.op,
          wtype: sig.returnType.wtypeOrThrow,
          sourceLocation: sourceLocation,
          stackArgs,
          immediates,
        }),
        sig.returnType,
      )
    }
    throw new CodeError(`Could not map arguments to any known signature`, { sourceLocation })
  }
}

export class FreeIntrinsicOpBuilder extends IntrinsicOpBuilderBase {
  readonly ptype: IntrinsicFunctionType
  constructor(sourceLocation: SourceLocation, ptype: PType) {
    invariant(ptype instanceof IntrinsicFunctionType, 'ptype must be IntrinsicFunctionType')
    const metaData = OP_METADATA[ptype.name]
    invariant(metaData.type === 'op-mapping', 'ptype must map to op-grouping')
    super(sourceLocation, metaData)
    this.ptype = ptype
  }
}

export class GroupedIntrinsicOpBuilder extends IntrinsicOpBuilderBase {
  constructor(sourceLocation: SourceLocation, opMapping: IntrinsicOpMapping) {
    super(sourceLocation, opMapping)
  }
}

/**
 * Builder for expressions which have the 'type' of an intrinsic function or group but are not the singleton instance
 * imported from @algorandfoundat/algorand-typescript. This is not supported.
 */
export class IntrinsicOpGroupOrFunctionTypeBuilder extends InstanceExpressionBuilder<PType> {
  constructor(expr: Expression, ptype: PType) {
    super(expr, ptype)
    throw new CodeError('Invalid alias of op function or group type', { sourceLocation: expr.sourceLocation })
  }
}



================================================
FILE: src/awst_build/eb/spread-expression-builder.ts
================================================
import type { SourceLocation } from '../../awst/source-location'
import { CodeError } from '../../errors'
import type { PType } from '../ptypes'
import type { InstanceBuilder } from './index'
import { NodeBuilder } from './index'
import { isStaticallyIterable, StaticIterator } from './traits/static-iterator'

export class SpreadExpressionBuilder extends NodeBuilder {
  ptype: PType | undefined = undefined
  constructor(
    private baseExpression: InstanceBuilder,
    sourceLocation: SourceLocation,
  ) {
    super(sourceLocation)
  }

  getSpreadItems(): InstanceBuilder[] {
    if (isStaticallyIterable(this.baseExpression)) {
      return this.baseExpression[StaticIterator]()
    }
    throw new CodeError(`Spread operator is not supported on ${this.baseExpression.typeDescription}`, {
      sourceLocation: this.sourceLocation,
    })
  }
}



================================================
FILE: src/awst_build/eb/string-expression-builder.ts
================================================
import { awst } from '../../awst'
import { intrinsicFactory } from '../../awst/intrinsic-factory'
import { nodeFactory } from '../../awst/node-factory'
import type { Expression } from '../../awst/nodes'
import { BytesBinaryOperator, BytesEncoding, EqualityComparison } from '../../awst/nodes'
import type { SourceLocation } from '../../awst/source-location'
import { wtypes } from '../../awst/wtypes'
import { NotSupported } from '../../errors'
import { tryConvertEnum, utf8ToUint8Array } from '../../util'
import type { InstanceType, PType, PTypeOrClass } from '../ptypes'
import { boolPType, bytesPType, stringPType } from '../ptypes'
import { instanceEb } from '../type-registry'
import type { InstanceBuilder, NodeBuilder } from './index'
import { BuilderBinaryOp, BuilderComparisonOp, FunctionBuilder, InstanceExpressionBuilder } from './index'
import { UInt64ExpressionBuilder } from './uint64-expression-builder'
import { requireExpressionOfType } from './util'
import { parseFunctionArgs } from './util/arg-parsing'

export class StringFunctionBuilder extends FunctionBuilder {
  taggedTemplate(head: string, spans: ReadonlyArray<readonly [InstanceBuilder, string]>, sourceLocation: SourceLocation): InstanceBuilder {
    let result: awst.Expression = nodeFactory.stringConstant({
      sourceLocation,
      value: head,
    })
    for (const [value, joiningText] of spans) {
      const valueStr = value.toString(sourceLocation)
      result = nodeFactory.bytesBinaryOperation({
        left: result,
        right: valueStr,
        op: BytesBinaryOperator.add,
        sourceLocation,
        wtype: wtypes.stringWType,
      })
      if (joiningText) {
        result = nodeFactory.bytesBinaryOperation({
          left: result,
          right: nodeFactory.stringConstant({
            sourceLocation,
            value: joiningText,
          }),
          op: BytesBinaryOperator.add,
          sourceLocation,
          wtype: wtypes.stringWType,
        })
      }
    }
    return new StringExpressionBuilder(result)
  }

  call(args: ReadonlyArray<NodeBuilder>, typeArgs: ReadonlyArray<PType>, sourceLocation: SourceLocation): NodeBuilder {
    const {
      args: [value],
    } = parseFunctionArgs({
      args,
      typeArgs,
      callLocation: sourceLocation,
      funcName: 'String',
      genericTypeArgs: 0,
      argSpec: (a) => [a.optional(bytesPType)],
    })

    if (!value) {
      return new StringExpressionBuilder(
        nodeFactory.stringConstant({
          sourceLocation,
          value: '',
        }),
      )
    }

    return new StringExpressionBuilder(
      nodeFactory.reinterpretCast({
        expr: value.resolve(),
        sourceLocation,
        wtype: wtypes.stringWType,
      }),
    )
  }
}

export class StringExpressionBuilder extends InstanceExpressionBuilder<InstanceType> {
  constructor(expr: Expression) {
    super(expr, stringPType)
  }

  resolvableToPType(ptype: PTypeOrClass): boolean {
    return super.resolvableToPType(ptype)
  }

  resolveToPType(ptype: PTypeOrClass): InstanceBuilder {
    return super.resolveToPType(ptype)
  }

  boolEval(sourceLocation: SourceLocation, negate = false): Expression {
    return new UInt64ExpressionBuilder(
      intrinsicFactory.bytesLen({
        value: this._expr,
        sourceLocation,
      }),
    ).boolEval(sourceLocation, negate)
  }

  memberAccess(name: string, sourceLocation: SourceLocation): NodeBuilder {
    switch (name) {
      case 'concat':
        return new ConcatExpressionBuilder(this._expr)
    }
    return super.memberAccess(name, sourceLocation)
  }

  compare(other: InstanceBuilder, op: BuilderComparisonOp, sourceLocation: SourceLocation): InstanceBuilder {
    const otherExpr = requireExpressionOfType(other, stringPType)
    const numComOp = tryConvertEnum(op, BuilderComparisonOp, EqualityComparison)
    if (numComOp === undefined) {
      throw new NotSupported(`Numeric comparison operator ${op}`, {
        sourceLocation,
      })
    }
    return instanceEb(
      nodeFactory.bytesComparisonExpression({
        lhs: this._expr,
        rhs: otherExpr,
        operator: numComOp,
        sourceLocation,
      }),
      boolPType,
    )
  }

  binaryOp(other: InstanceBuilder, op: BuilderBinaryOp, sourceLocation: SourceLocation): InstanceBuilder {
    switch (op) {
      case BuilderBinaryOp.add:
        return new StringExpressionBuilder(
          intrinsicFactory.bytesConcat({
            left: this.resolve(),
            right: requireExpressionOfType(other, stringPType),
            sourceLocation,
          }),
        )
    }
    return super.binaryOp(other, op, sourceLocation)
  }

  augmentedAssignment(other: InstanceBuilder, op: BuilderBinaryOp, sourceLocation: SourceLocation): InstanceBuilder {
    const newValue = this.binaryOp(other, op, sourceLocation)
    return new StringExpressionBuilder(
      nodeFactory.assignmentExpression({
        target: this.resolveLValue(),
        sourceLocation,
        value: newValue.resolve(),
      }),
    )
  }

  toBytes(sourceLocation: SourceLocation): awst.Expression {
    if (this._expr instanceof awst.StringConstant) {
      return nodeFactory.bytesConstant({
        value: utf8ToUint8Array(this._expr.value),
        encoding: BytesEncoding.utf8,
        sourceLocation: this._expr.sourceLocation,
      })
    }
    return nodeFactory.reinterpretCast({
      expr: this._expr,
      sourceLocation,
      wtype: wtypes.bytesWType,
    })
  }

  toString(): Expression {
    return this.resolve()
  }
}

export class ConcatExpressionBuilder extends FunctionBuilder {
  constructor(private expr: awst.Expression) {
    super(expr.sourceLocation)
  }

  call(args: ReadonlyArray<NodeBuilder>, typeArgs: ReadonlyArray<PType>, sourceLocation: SourceLocation): NodeBuilder {
    const { args: others } = parseFunctionArgs({
      args,
      typeArgs,
      genericTypeArgs: 0,
      callLocation: sourceLocation,
      funcName: 'concat',
      argSpec: (a) => args.map((_) => a.required(stringPType)),
    })

    return new StringExpressionBuilder(
      others.reduce(
        (acc, cur) =>
          intrinsicFactory.bytesConcat({
            left: acc,
            right: cur.resolve(),
            sourceLocation: sourceLocation,
          }),
        this.expr,
      ),
    )
  }
}



================================================
FILE: src/awst_build/eb/template-var.ts
================================================
import { nodeFactory } from '../../awst/node-factory'
import type { SourceLocation } from '../../awst/source-location'
import { logger } from '../../logger'
import { TemplateVarNameRegex } from '../../util/template-var-cli-parser'
import type { PType } from '../ptypes'
import { stringPType, TemplateVarFunction } from '../ptypes'
import { instanceEb } from '../type-registry'
import type { NodeBuilder } from './index'
import { FunctionBuilder } from './index'
import { requireStringConstant } from './util'
import { parseFunctionArgs } from './util/arg-parsing'

export class TemplateVarFunctionBuilder extends FunctionBuilder {
  readonly ptype = TemplateVarFunction

  call(args: ReadonlyArray<NodeBuilder>, typeArgs: ReadonlyArray<PType>, sourceLocation: SourceLocation): NodeBuilder {
    const {
      args: [name, prefix],
      ptypes: [varType],
    } = parseFunctionArgs({
      args,
      typeArgs,
      genericTypeArgs: 1,
      callLocation: sourceLocation,
      funcName: this.typeDescription,
      argSpec: (a) => [a.required(stringPType), a.optional(stringPType)],
    })

    const nameStr = requireStringConstant(name).value
    const validName = TemplateVarNameRegex.exec(nameStr)
    if (validName?.[0] !== nameStr) {
      logger.error(
        name.sourceLocation,
        'Invalid name. Template variable names must only contain capital letters A-Z, numbers 0-9, and underscores',
      )
    }

    const prefixStr = prefix ? requireStringConstant(prefix).value : 'TMPL_'

    return instanceEb(
      nodeFactory.templateVar({
        name: `${prefixStr}${nameStr}`,
        wtype: varType.wtypeOrThrow,
        sourceLocation,
      }),
      varType,
    )
  }
}



================================================
FILE: src/awst_build/eb/tuple-expression-builder.ts
================================================
import { nodeFactory } from '../../awst/node-factory'
import type { Expression } from '../../awst/nodes'
import type { SourceLocation } from '../../awst/source-location'
import { codeInvariant, invariant } from '../../util'
import type { PType, PTypeOrClass } from '../ptypes'
import { ArrayPType, TuplePType, uint64PType } from '../ptypes'
import { instanceEb } from '../type-registry'
import type { InstanceBuilder, NodeBuilder } from './index'
import { InstanceExpressionBuilder } from './index'
import type { StaticallyIterable } from './traits/static-iterator'
import { StaticIterator } from './traits/static-iterator'
import { requireIntegerConstant } from './util'

export class TupleExpressionBuilder extends InstanceExpressionBuilder<TuplePType> implements StaticallyIterable {
  constructor(expression: Expression, ptype: PType) {
    invariant(ptype instanceof TuplePType, 'TupleExpressionBuilder must be built with ptype of type TuplePType')
    super(expression, ptype)
  }

  iterate(): Expression {
    return this.resolve()
  }

  resolvableToPType(ptype: PTypeOrClass): boolean {
    if (ptype instanceof ArrayPType && this.ptype.items.every((i) => i.equals(ptype.elementType))) {
      return true
    }
    return super.resolvableToPType(ptype)
  }

  resolveToPType(ptype: PTypeOrClass): InstanceBuilder {
    if (ptype instanceof ArrayPType && this.ptype.items.every((i) => i.equals(ptype.elementType))) {
      return instanceEb(
        nodeFactory.newArray({
          values: this[StaticIterator]().map((i) => i.resolve()),
          wtype: ptype.wtype,
          sourceLocation: this.sourceLocation,
        }),
        ptype,
      )
    }

    return super.resolveToPType(ptype)
  }

  memberAccess(name: string, sourceLocation: SourceLocation): NodeBuilder {
    switch (name) {
      case 'length':
        return instanceEb(
          nodeFactory.uInt64Constant({
            value: BigInt(this.ptype.items.length),
            sourceLocation,
          }),
          uint64PType,
        )
    }
    return super.memberAccess(name, sourceLocation)
  }

  indexAccess(index: InstanceBuilder, sourceLocation: SourceLocation): NodeBuilder {
    const indexNum = requireIntegerConstant(index).value
    const itemType = this.ptype.items[Number(indexNum)]
    codeInvariant(
      indexNum < this.ptype.items.length && indexNum >= 0,
      "Index arg must be a numeric literal between 0 and the tuple's length",
    )
    return instanceEb(
      nodeFactory.tupleItemExpression({
        index: indexNum,
        sourceLocation,
        base: this._expr,
      }),
      itemType,
    )
  }

  [StaticIterator](): InstanceBuilder[] {
    return this.ptype.items.map((itemType, index) =>
      instanceEb(
        nodeFactory.tupleItemExpression({
          index: BigInt(index),
          sourceLocation: this.sourceLocation,
          base: this._expr,
        }),
        itemType,
      ),
    )
  }
}



================================================
FILE: src/awst_build/eb/uint64-enum-type-builder.ts
================================================
import { nodeFactory } from '../../awst/node-factory'
import type { Expression } from '../../awst/nodes'
import type { SourceLocation } from '../../awst/source-location'
import { wtypes } from '../../awst/wtypes'
import { invariant } from '../../util'
import type { PType, PTypeOrClass } from '../ptypes'
import { Uint64EnumMemberType, Uint64EnumType, uint64PType } from '../ptypes'
import { instanceEb } from '../type-registry'
import type { BuilderComparisonOp, InstanceBuilder } from './index'
import { InstanceExpressionBuilder, NodeBuilder } from './index'
import { requireExpressionOfType } from './util'
import { compareUint64 } from './util/compare-uint64'

export class Uint64EnumTypeBuilder extends NodeBuilder {
  readonly ptype: Uint64EnumType
  constructor(sourceLocation: SourceLocation, ptype: PType) {
    super(sourceLocation)
    invariant(ptype instanceof Uint64EnumType, 'ptype must be Uint64EnumType')
    this.ptype = ptype
  }

  memberAccess(name: string, sourceLocation: SourceLocation): NodeBuilder {
    if (name in this.ptype.members) {
      return new Uint64EnumMemberExpressionBuilder(
        nodeFactory.uInt64Constant({
          value: this.ptype.members[name],
          sourceLocation,
        }),
        this.ptype.memberType,
      )
    }
    return super.memberAccess(name, sourceLocation)
  }
}

export class Uint64EnumMemberExpressionBuilder extends InstanceExpressionBuilder<Uint64EnumMemberType> {
  constructor(expr: Expression, ptype: PType) {
    invariant(ptype instanceof Uint64EnumMemberType, 'ptype must be Uint64EnumType')
    super(expr, ptype)
  }

  compare(other: InstanceBuilder, op: BuilderComparisonOp, sourceLocation: SourceLocation): InstanceBuilder {
    const otherExpr = requireExpressionOfType(other, uint64PType)
    return compareUint64(this._expr, otherExpr, op, sourceLocation, this.typeDescription)
  }

  resolvableToPType(ptype: PTypeOrClass): boolean {
    return ptype.equals(this.ptype) || ptype.equals(uint64PType)
  }
  resolveToPType(ptype: PTypeOrClass): InstanceBuilder {
    if (ptype.equals(uint64PType)) {
      return instanceEb(
        nodeFactory.reinterpretCast({
          expr: this._expr,
          wtype: wtypes.uint64WType,
          sourceLocation: this.sourceLocation,
        }),
        uint64PType,
      )
    }
    return super.resolveToPType(ptype)
  }
}



================================================
FILE: src/awst_build/eb/uint64-expression-builder.ts
================================================
import type { awst } from '../../awst'
import { intrinsicFactory } from '../../awst/intrinsic-factory'
import { nodeFactory } from '../../awst/node-factory'
import type { Expression } from '../../awst/nodes'
import { BoolConstant, UInt64BinaryOperator, UInt64PostfixUnaryOperator, UInt64UnaryOperator } from '../../awst/nodes'
import type { SourceLocation } from '../../awst/source-location'
import { wtypes } from '../../awst/wtypes'

import { NotSupported } from '../../errors'
import { tryConvertEnum } from '../../util'
import type { InstanceType, PType } from '../ptypes'
import { boolPType, stringPType, Uint64Function, uint64PType } from '../ptypes'
import type { BuilderComparisonOp, InstanceBuilder, NodeBuilder } from './index'
import { BuilderBinaryOp, BuilderUnaryOp, FunctionBuilder, InstanceExpressionBuilder } from './index'
import { requireExpressionOfType, requireStringConstant } from './util'
import { parseFunctionArgs } from './util/arg-parsing'
import { compareUint64 } from './util/compare-uint64'
import { stringToBigint } from './util/string-to-bigint'

export class UInt64FunctionBuilder extends FunctionBuilder {
  readonly ptype = Uint64Function

  call(args: ReadonlyArray<NodeBuilder>, typeArgs: ReadonlyArray<PType>, sourceLocation: SourceLocation): NodeBuilder {
    const {
      args: [value],
    } = parseFunctionArgs({
      args,
      typeArgs,
      genericTypeArgs: 0,
      callLocation: sourceLocation,
      funcName: 'Uint64',
      argSpec: (a) => [a.optional(uint64PType, boolPType, stringPType)],
    })

    if (!value) {
      return new UInt64ExpressionBuilder(
        nodeFactory.uInt64Constant({
          sourceLocation,
          value: 0n,
        }),
      )
    }
    if (value.ptype.equals(boolPType)) {
      const expr = value.resolve()
      if (expr instanceof BoolConstant) {
        return new UInt64ExpressionBuilder(
          nodeFactory.uInt64Constant({
            sourceLocation,
            value: expr.value ? 1n : 0n,
          }),
        )
      } else {
        return new UInt64ExpressionBuilder(
          nodeFactory.reinterpretCast({
            expr,
            wtype: wtypes.uint64WType,
            sourceLocation,
          }),
        )
      }
    } else if (value.ptype.equals(stringPType)) {
      const valueStr = requireStringConstant(value)
      return new UInt64ExpressionBuilder(
        nodeFactory.uInt64Constant({
          value: stringToBigint(valueStr),
          sourceLocation,
        }),
      )
    }
    return value
  }
}

export class UInt64ExpressionBuilder extends InstanceExpressionBuilder<InstanceType> {
  constructor(expr: Expression) {
    super(expr, uint64PType)
  }
  boolEval(sourceLocation: SourceLocation, negate: boolean): Expression {
    const asBool = nodeFactory.reinterpretCast({
      sourceLocation,
      expr: this.resolve(),
      wtype: wtypes.boolWType,
    })
    if (negate) {
      return nodeFactory.not({
        expr: asBool,
        sourceLocation,
      })
    }
    return asBool
  }

  compare(other: InstanceBuilder, op: BuilderComparisonOp, sourceLocation: SourceLocation): InstanceBuilder {
    const otherExpr = requireExpressionOfType(other, uint64PType)
    return compareUint64(this._expr, otherExpr, op, sourceLocation, this.typeDescription)
  }

  prefixUnaryOp(op: BuilderUnaryOp, sourceLocation: SourceLocation): InstanceBuilder {
    let binaryOp: UInt64BinaryOperator

    switch (op) {
      case BuilderUnaryOp.inc:
        binaryOp = UInt64BinaryOperator.add
        break
      case BuilderUnaryOp.dec:
        binaryOp = UInt64BinaryOperator.sub
        break
      case BuilderUnaryOp.bit_inv:
        return new UInt64ExpressionBuilder(
          nodeFactory.uInt64UnaryOperation({
            op: UInt64UnaryOperator.bitInvert,
            sourceLocation,
            expr: this.resolve(),
            wtype: this.ptype.wtype,
          }),
        )
      case BuilderUnaryOp.pos:
        return this
      default:
        return super.prefixUnaryOp(op, sourceLocation)
    }
    return new UInt64ExpressionBuilder(
      nodeFactory.assignmentExpression({
        target: this.resolveLValue(),
        sourceLocation,
        value: nodeFactory.uInt64BinaryOperation({
          left: this.resolve(),
          right: nodeFactory.uInt64Constant({ value: 1n, sourceLocation }),
          op: binaryOp,
          sourceLocation,
        }),
      }),
    )
  }

  postfixUnaryOp(op: BuilderUnaryOp, sourceLocation: SourceLocation): InstanceBuilder {
    let unaryOp: UInt64PostfixUnaryOperator
    switch (op) {
      case BuilderUnaryOp.inc:
        unaryOp = UInt64PostfixUnaryOperator.increment
        break
      case BuilderUnaryOp.dec:
        unaryOp = UInt64PostfixUnaryOperator.decrement
        break
      default:
        return super.postfixUnaryOp(op, sourceLocation)
    }
    return new UInt64ExpressionBuilder(
      nodeFactory.uInt64PostfixUnaryOperation({
        sourceLocation,
        target: this.resolveLValue(),
        wtype: this.ptype.wtype,
        op: unaryOp,
      }),
    )
  }

  binaryOp(other: InstanceBuilder, op: BuilderBinaryOp, sourceLocation: SourceLocation): InstanceBuilder {
    const otherExpr = requireExpressionOfType(other, uint64PType)

    const uintOp = op === BuilderBinaryOp.div ? UInt64BinaryOperator.floorDiv : tryConvertEnum(op, BuilderBinaryOp, UInt64BinaryOperator)
    if (uintOp === undefined) {
      throw new NotSupported(`UInt64 binary operator ${op}`, {
        sourceLocation,
      })
    }
    return new UInt64ExpressionBuilder(
      nodeFactory.uInt64BinaryOperation({
        left: this._expr,
        right: otherExpr,
        op: uintOp,
        sourceLocation,
      }),
    )
  }

  augmentedAssignment(other: InstanceBuilder, op: BuilderBinaryOp, sourceLocation: SourceLocation): InstanceBuilder {
    return new UInt64ExpressionBuilder(
      nodeFactory.assignmentExpression({
        target: this.resolveLValue(),
        value: this.binaryOp(other, op, sourceLocation).resolve(),
        sourceLocation,
      }),
    )
  }

  toBytes(sourceLocation: SourceLocation): awst.Expression {
    return intrinsicFactory.itob({ value: this.resolve(), sourceLocation })
  }
}



================================================
FILE: src/awst_build/eb/unresolvable-expression-builder.ts
================================================
import type { Expression, LValue } from '../../awst/nodes'
import { CodeError } from '../../errors'
import type { PType } from '../ptypes'
import { InstanceExpressionBuilder } from './index'

export class UnresolvableExpressionBuilder extends InstanceExpressionBuilder<PType> {
  resolve(): Expression {
    throw new CodeError(`Cannot resolve expression of type ${this.typeDescription}`, { sourceLocation: this.sourceLocation })
  }

  resolveLValue(): LValue {
    throw new CodeError(`Expression of type ${this.typeDescription} is not a valid assignment target`, {
      sourceLocation: this.sourceLocation,
    })
  }
}



================================================
FILE: src/awst_build/eb/urange-function.ts
================================================
import type { awst } from '../../awst'
import { nodeFactory } from '../../awst/node-factory'
import type { SourceLocation } from '../../awst/source-location'
import { wtypes } from '../../awst/wtypes'
import type { PType } from '../ptypes'
import { IterableIteratorGeneric, uint64PType } from '../ptypes'
import type { NodeBuilder } from './index'
import { FunctionBuilder } from './index'
import { IterableIteratorExpressionBuilder } from './iterable-iterator-expression-builder'
import { parseFunctionArgs } from './util/arg-parsing'

export class UrangeFunctionBuilder extends FunctionBuilder {
  call(args: ReadonlyArray<NodeBuilder>, typeArgs: ReadonlyArray<PType>, sourceLocation: SourceLocation): NodeBuilder {
    const { args: uArgs } = parseFunctionArgs({
      args,
      typeArgs,
      genericTypeArgs: 0,
      callLocation: sourceLocation,
      funcName: 'urange',
      argSpec: (a) => [a.required(uint64PType), ...args.slice(1, 3).map((_) => a.required(uint64PType))],
    })
    let expr: awst.Range
    if (uArgs.length === 1) {
      expr = nodeFactory.range({
        start: nodeFactory.uInt64Constant({ value: 0n, sourceLocation }),
        stop: uArgs[0].resolve(),
        step: nodeFactory.uInt64Constant({ value: 1n, sourceLocation }),
        sourceLocation,
        wtype: wtypes.uint64RangeWType,
      })
    } else if (uArgs.length === 2) {
      expr = nodeFactory.range({
        start: uArgs[0].resolve(),
        stop: uArgs[1].resolve(),
        step: nodeFactory.uInt64Constant({ value: 1n, sourceLocation }),
        sourceLocation,
        wtype: wtypes.uint64RangeWType,
      })
    } else {
      expr = nodeFactory.range({
        start: uArgs[0].resolve(),
        stop: uArgs[1].resolve(),
        step: uArgs[2].resolve(),
        sourceLocation,
        wtype: wtypes.uint64RangeWType,
      })
    }
    return new IterableIteratorExpressionBuilder(expr, IterableIteratorGeneric.parameterise([uint64PType]))
  }
}



================================================
FILE: src/awst_build/eb/void-expression-builder.ts
================================================
import type { Expression, LValue } from '../../awst/nodes'
import { CodeError } from '../../errors'
import type { InstanceType } from '../ptypes'
import { voidPType } from '../ptypes'
import { InstanceExpressionBuilder } from './index'

export class VoidExpressionBuilder extends InstanceExpressionBuilder<InstanceType> {
  constructor(expr: Expression) {
    super(expr, voidPType)
  }
  resolveLValue(): LValue {
    throw new CodeError(`${this.typeDescription} is not a valid assignment target`)
  }
}



================================================
FILE: src/awst_build/eb/arc28/arc-28-emit-function-builder.ts
================================================
import { nodeFactory } from '../../../awst/node-factory'
import type { Expression, StringConstant } from '../../../awst/nodes'
import { SourceLocation } from '../../../awst/source-location'
import { CodeError, InternalError } from '../../../errors'
import { logger } from '../../../logger'
import { codeInvariant } from '../../../util'
import { Arc4ParseError, parseArc4Type } from '../../../util/arc4-signature-parser'
import { ptypeToArc4EncodedType } from '../../arc4-util'
import type { PType } from '../../ptypes'
import { arc28EmitFunction, ObjectPType, stringPType, voidPType } from '../../ptypes'
import { ARC4EncodedType, ARC4StructType, ARC4TupleType } from '../../ptypes/arc4-types'
import { instanceEb } from '../../type-registry'
import type { InstanceBuilder, NodeBuilder } from '../index'
import { FunctionBuilder } from '../index'
import { requireStringConstant } from '../util'
import { parseFunctionArgs } from '../util/arg-parsing'

export class Arc28EmitFunctionBuilder extends FunctionBuilder {
  readonly ptype = arc28EmitFunction

  call(args: ReadonlyArray<NodeBuilder>, typeArgs: ReadonlyArray<PType>, sourceLocation: SourceLocation): NodeBuilder {
    const {
      args: [nameOrObj, ...props],
      ptypes: [genericArg],
    } = parseFunctionArgs({
      args,
      typeArgs,
      genericTypeArgs: 1,
      callLocation: sourceLocation,
      funcName: this.typeDescription,
      argSpec: (a) => [a.required(), ...args.slice(1).map(() => a.required())],
    })

    if (nameOrObj.ptype.equals(stringPType)) {
      const thisModule = nameOrObj.sourceLocation.file ?? ''

      const fields: Record<string, ARC4EncodedType> = {}
      const values = new Map<string, Expression>()

      const { name, propTypes } = parseEventName(nameOrObj)

      for (const [index, prop] of props.entries()) {
        const arc4Type = ptypeToArc4EncodedType(prop.ptype, prop.sourceLocation)

        const expectedType = propTypes?.[index]
        if (expectedType) {
          codeInvariant(
            expectedType.wtype.equals(arc4Type.wtype),
            `Expected type ${expectedType} does not match actual type ${arc4Type}`,
            prop.sourceLocation,
          )
        }

        fields[index] = arc4Type
        values.set(
          index.toString(),
          prop.ptype instanceof ARC4EncodedType
            ? prop.resolve()
            : nodeFactory.aRC4Encode({
                value: prop.resolve(),
                wtype: arc4Type.wtype,
                sourceLocation: prop.sourceLocation,
              }),
        )
      }
      if (propTypes && propTypes.length !== values.size) {
        throw new CodeError(`Event signature length (${propTypes.length}) does not match number of provided values (${values.size}).`, {
          sourceLocation: sourceLocation,
        })
      }

      const structType = new ARC4StructType({
        name: name.value,
        module: thisModule,
        fields,
        description: undefined,
        sourceLocation,
        frozen: true,
      })
      const structExpression = nodeFactory.newStruct({
        wtype: structType.wtype,
        values,
        sourceLocation,
      })

      return emitStruct(structType, structExpression, sourceLocation)
    }
    codeInvariant(props.length === 0, 'Unexpected args', props[0]?.sourceLocation)

    const eventBuilder = nameOrObj.resolveToPType(genericArg)

    const eventType = eventBuilder.ptype
    if (eventType instanceof ARC4StructType) {
      return emitStruct(eventType, nameOrObj.resolve(), sourceLocation)
    } else if (eventType instanceof ObjectPType) {
      if (!eventType.alias) {
        logger.error(
          eventBuilder.sourceLocation,
          'Event cannot be an anonymous type. If a named type exists, try specifying it explicitly via the generic parameter. Eg. `emit<YourType>({...})`',
        )
      }
      const arc4Equivalent = ptypeToArc4EncodedType(eventType, sourceLocation)
      return emitStruct(
        arc4Equivalent,
        nodeFactory.aRC4Encode({
          wtype: arc4Equivalent.wtype,
          sourceLocation: nameOrObj.sourceLocation,
          value: nameOrObj.resolve(),
        }),
        sourceLocation,
      )
    }
    throw new InternalError('Unexpected type for arg 0 of emit', { sourceLocation })
  }
}

function emitStruct(ptype: ARC4StructType, expression: Expression, sourceLocation: SourceLocation) {
  return instanceEb(
    nodeFactory.emit({
      signature: ptype.signature,
      value: expression,
      wtype: voidPType.wtype,
      sourceLocation,
    }),
    voidPType,
  )
}

function parseEventName(nameBuilder: InstanceBuilder): {
  name: StringConstant
  propTypes?: ARC4EncodedType[]
} {
  const name = requireStringConstant(nameBuilder)
  const parenthesisIndex = name.value.indexOf('(')
  if (parenthesisIndex === -1) {
    return {
      name,
    }
  }
  const signature = name.value.substring(parenthesisIndex)

  try {
    const signatureType = parseArc4Type(signature)
    codeInvariant(signatureType instanceof ARC4TupleType, 'Event signature must be a tuple type', name.sourceLocation)
    return {
      name: nodeFactory.stringConstant({
        value: name.value.substring(0, parenthesisIndex),
        sourceLocation: name.sourceLocation,
      }),
      propTypes: signatureType.items,
    }
  } catch (e) {
    if (e instanceof Arc4ParseError) {
      // Source location adjustment assumes StringConstant is all on one line
      throw new CodeError(`Invalid signature: ${e.message}`, {
        sourceLocation: new SourceLocation({
          ...name.sourceLocation,
          column: name.sourceLocation.column + parenthesisIndex + e.index,
        }),
      })
    } else {
      throw e
    }
  }
}



================================================
FILE: src/awst_build/eb/arc4/arrays.ts
================================================
import { intrinsicFactory } from '../../../awst/intrinsic-factory'
import { nodeFactory } from '../../../awst/node-factory'
import type { Expression } from '../../../awst/nodes'
import { BytesConstant, StringConstant } from '../../../awst/nodes'
import type { SourceLocation } from '../../../awst/source-location'
import { Constants } from '../../../constants'
import { wrapInCodeError } from '../../../errors'
import { logger } from '../../../logger'

import { base32ToUint8Array, bigIntToUint8Array, codeInvariant, invariant } from '../../../util'
import type { PType } from '../../ptypes'
import { accountPType, bytesPType, IterableIteratorGeneric, NumericLiteralPType, stringPType, TuplePType, uint64PType } from '../../ptypes'
import {
  AddressClass,
  arc4AddressAlias,
  ARC4EncodedType,
  DynamicArrayConstructor,
  DynamicArrayType,
  DynamicBytesConstructor,
  DynamicBytesType,
  StaticArrayConstructor,
  StaticArrayType,
  StaticBytesConstructor,
  StaticBytesGeneric,
} from '../../ptypes/arc4-types'
import { instanceEb } from '../../type-registry'
import type { InstanceBuilder, NodeBuilder } from '../index'
import { ClassBuilder, FunctionBuilder } from '../index'
import { IterableIteratorExpressionBuilder } from '../iterable-iterator-expression-builder'
import { Arc4CopyFunctionBuilder } from '../shared/arc4-copy-function-builder'
import { AtFunctionBuilder } from '../shared/at-function-builder'
import { ArrayPopFunctionBuilder } from '../shared/pop-function-builder'
import { ArrayPushFunctionBuilder } from '../shared/push-function-builder'
import { SliceFunctionBuilder } from '../shared/slice-function-builder'
import { UInt64ExpressionBuilder } from '../uint64-expression-builder'
import { requireExpressionOfType } from '../util'
import { parseFunctionArgs } from '../util/arg-parsing'
import { concatArrays } from '../util/array/concat'
import { indexAccess } from '../util/array/index-access'
import { arrayLength } from '../util/array/length'
import { resolveCompatExpression } from '../util/resolve-compat-builder'
import { Arc4EncodedBaseExpressionBuilder } from './base'

export class DynamicArrayClassBuilder extends ClassBuilder {
  readonly ptype = DynamicArrayConstructor

  newCall(args: ReadonlyArray<NodeBuilder>, typeArgs: ReadonlyArray<PType>, sourceLocation: SourceLocation): InstanceBuilder {
    const {
      args: [...initialItems],
      ptypes: [elementType],
    } = parseFunctionArgs({
      args,
      typeArgs,
      callLocation: sourceLocation,
      funcName: 'DynamicArray constructor',
      genericTypeArgs: 1,
      argSpec: (a) => args.map((_) => a.required()),
    })
    codeInvariant(elementType instanceof ARC4EncodedType, 'Element type must be an ARC4 encoded type', sourceLocation)
    const initialItemExprs = initialItems.map((i) => requireExpressionOfType(i, elementType))
    const ptype = new DynamicArrayType({ elementType, sourceLocation })
    return new DynamicArrayExpressionBuilder(
      nodeFactory.newArray({
        values: initialItemExprs,
        wtype: ptype.wtype,
        sourceLocation,
      }),
      ptype,
    )
  }
}
export class StaticArrayClassBuilder extends ClassBuilder {
  readonly ptype = StaticArrayConstructor

  newCall(args: ReadonlyArray<NodeBuilder>, typeArgs: ReadonlyArray<PType>, sourceLocation: SourceLocation): InstanceBuilder {
    const {
      args: [...initialItems],
      ptypes: [elementType, arraySize],
    } = parseFunctionArgs({
      args,
      typeArgs,
      callLocation: sourceLocation,
      funcName: 'StaticArray constructor',
      genericTypeArgs: 2,
      argSpec: (a) => args.map((_) => a.required()),
    })
    codeInvariant(elementType instanceof ARC4EncodedType, 'Element type must be an ARC4 encoded type', sourceLocation)
    codeInvariant(
      arraySize instanceof NumericLiteralPType,
      `Array size type parameter of ${this.typeDescription} must be a literal number. Inferred type is ${arraySize.name}`,
      sourceLocation,
    )
    const ptype = new StaticArrayType({ elementType, arraySize: arraySize.literalValue, sourceLocation })
    if (initialItems.length === 0) {
      codeInvariant(ptype.fixedByteSize !== null, 'Zero arg constructor can only be used for static arrays with a fixed size encoding.')
      return new StaticArrayExpressionBuilder(
        intrinsicFactory.bzero({ size: ptype.fixedByteSize, wtype: ptype.wtype, sourceLocation }),
        ptype,
      )
    }

    codeInvariant(
      BigInt(initialItems.length) === arraySize.literalValue,
      `Static array of size ${arraySize.literalValue} must be initialized with ${arraySize.literalValue} values`,
      sourceLocation,
    )

    return new StaticArrayExpressionBuilder(
      nodeFactory.newArray({
        values: initialItems.map((i) => requireExpressionOfType(i, elementType)),
        wtype: ptype.wtype,
        sourceLocation,
      }),
      ptype,
    )
  }
}
export class AddressClassBuilder extends ClassBuilder {
  readonly ptype = AddressClass

  newCall(args: ReadonlyArray<NodeBuilder>, typeArgs: ReadonlyArray<PType>, sourceLocation: SourceLocation): InstanceBuilder {
    const {
      args: [accountOrAddressOrBytes],
    } = parseFunctionArgs({
      args,
      typeArgs,
      callLocation: sourceLocation,
      funcName: 'Address constructor',
      genericTypeArgs: 0,
      argSpec: (a) => [a.optional(accountPType, stringPType, bytesPType)],
    })
    if (!accountOrAddressOrBytes) {
      return new AddressExpressionBuilder(
        nodeFactory.addressConstant({
          value: Constants.algo.zeroAddressB32,
          sourceLocation,
          wtype: arc4AddressAlias.wtype,
        }),
        arc4AddressAlias,
      )
    }

    if (accountOrAddressOrBytes.ptype.equals(accountPType)) {
      return new AddressExpressionBuilder(
        nodeFactory.reinterpretCast({
          expr: accountOrAddressOrBytes.resolve(),
          sourceLocation,
          wtype: arc4AddressAlias.wtype,
        }),
        arc4AddressAlias,
      )
    } else if (accountOrAddressOrBytes.ptype.equals(stringPType)) {
      const value = accountOrAddressOrBytes.resolve()
      if (value instanceof StringConstant) {
        wrapInCodeError(() => base32ToUint8Array(value.value), value.sourceLocation)
        return new AddressExpressionBuilder(
          nodeFactory.addressConstant({
            value: value.value,
            sourceLocation,
            wtype: arc4AddressAlias.wtype,
          }),
          arc4AddressAlias,
        )
      }
      logger.error(
        value.sourceLocation,
        `Invalid address literal. Addresses should be ${Constants.algo.encodedAddressLength} characters and not include base32 padding`,
      )
    }
    return new AddressExpressionBuilder(
      nodeFactory.reinterpretCast({
        expr: accountOrAddressOrBytes.resolve(),
        sourceLocation,
        wtype: arc4AddressAlias.wtype,
      }),
      arc4AddressAlias,
    )
  }
}
export class StaticBytesClassBuilder extends ClassBuilder {
  readonly ptype = StaticBytesConstructor

  newCall(args: ReadonlyArray<NodeBuilder>, typeArgs: ReadonlyArray<PType>, sourceLocation: SourceLocation): InstanceBuilder {
    const {
      ptypes: [length],
      args: [initialValue],
    } = parseFunctionArgs({
      args,
      typeArgs,
      callLocation: sourceLocation,
      funcName: `${this.ptype.name} constructor`,
      genericTypeArgs: 1,
      argSpec: (a) => [a.optional(bytesPType, stringPType)],
    })
    const resultPType = StaticBytesGeneric.parameterise([length])

    codeInvariant(length instanceof NumericLiteralPType, 'length must be numeric literal', sourceLocation)
    const byteLength = Number(length.literalValue)
    if (!initialValue) {
      return instanceEb(
        nodeFactory.bytesConstant({
          value: new Uint8Array(byteLength),
          sourceLocation,
          wtype: resultPType.wtype,
        }),
        resultPType,
      )
    }
    const value = resolveCompatExpression(initialValue, bytesPType)
    if (value instanceof BytesConstant) {
      codeInvariant(value.value.length === byteLength, `Value should have byte length of ${byteLength}`, sourceLocation)
      return instanceEb(
        nodeFactory.bytesConstant({
          value: value.value,
          wtype: resultPType.wtype,
          sourceLocation,
        }),
        resultPType,
      )
    } else {
      return instanceEb(
        nodeFactory.aRC4Encode({
          value: initialValue.resolve(),
          sourceLocation,
          wtype: resultPType.wtype,
        }),
        resultPType,
      )
    }
  }
}
export class DynamicBytesClassBuilder extends ClassBuilder {
  readonly ptype = DynamicBytesConstructor

  newCall(args: ReadonlyArray<NodeBuilder>, typeArgs: ReadonlyArray<PType>, sourceLocation: SourceLocation): InstanceBuilder {
    const {
      args: [initialValue],
    } = parseFunctionArgs({
      args,
      typeArgs,
      callLocation: sourceLocation,
      funcName: `${this.ptype.name} constructor`,
      genericTypeArgs: 0,
      argSpec: (a) => [a.optional(bytesPType, stringPType)],
    })
    const resultPType = DynamicBytesType

    if (!initialValue) {
      return instanceEb(
        nodeFactory.bytesConstant({
          value: new Uint8Array([0, 0]),
          sourceLocation,
          wtype: resultPType.wtype,
        }),
        resultPType,
      )
    }

    const value = resolveCompatExpression(initialValue, bytesPType)
    if (value instanceof BytesConstant) {
      return instanceEb(
        nodeFactory.bytesConstant({
          value: new Uint8Array([...bigIntToUint8Array(BigInt(value.value.length), 2), ...value.value]),
          sourceLocation,
          wtype: resultPType.wtype,
        }),
        resultPType,
      )
    } else {
      return instanceEb(
        nodeFactory.aRC4Encode({
          value,
          sourceLocation,
          wtype: resultPType.wtype,
        }),
        resultPType,
      )
    }
  }
}

export abstract class ArrayExpressionBuilder<
  TArrayType extends DynamicArrayType | StaticArrayType,
> extends Arc4EncodedBaseExpressionBuilder<TArrayType> {
  iterate(): Expression {
    return this.resolve()
  }

  indexAccess(index: InstanceBuilder, sourceLocation: SourceLocation): NodeBuilder {
    return indexAccess(this, index, sourceLocation)
  }

  memberAccess(name: string, sourceLocation: SourceLocation): NodeBuilder {
    switch (name) {
      case 'length':
        return arrayLength(this, sourceLocation)
      case 'at':
        return new AtFunctionBuilder(
          this.resolve(),
          this.ptype.elementType,
          this.ptype instanceof StaticArrayType
            ? this.ptype.arraySize
            : requireExpressionOfType(this.memberAccess('length', sourceLocation), uint64PType),
        )
      case 'entries':
        return new EntriesFunctionBuilder(this)
      case 'copy':
        return new Arc4CopyFunctionBuilder(this)
      case 'concat':
        return new ConcatFunctionBuilder(this)
      case 'slice': {
        const sliceResult =
          this.ptype instanceof StaticArrayType ? new DynamicArrayType({ elementType: this.ptype.elementType }) : this.ptype
        return new SliceFunctionBuilder(this.resolve(), sliceResult)
      }
      case 'native':
        return instanceEb(
          nodeFactory.aRC4Decode({
            value: this.resolve(),
            wtype: this.ptype.nativeType.wtypeOrThrow,
            sourceLocation,
          }),
          this.ptype.nativeType,
        )
    }
    return super.memberAccess(name, sourceLocation)
  }
}

class ConcatFunctionBuilder extends FunctionBuilder {
  constructor(private arrayBuilder: ArrayExpressionBuilder<DynamicArrayType | StaticArrayType>) {
    super(arrayBuilder.sourceLocation)
  }

  call(args: ReadonlyArray<NodeBuilder>, typeArgs: ReadonlyArray<PType>, sourceLocation: SourceLocation): NodeBuilder {
    const {
      args: [other],
    } = parseFunctionArgs({
      args,
      typeArgs,
      genericTypeArgs: 0,
      argSpec: (a) => [a.required()],
      funcName: 'concat',
      callLocation: sourceLocation,
    })
    return concatArrays(this.arrayBuilder, other, sourceLocation)
  }
}
class EntriesFunctionBuilder extends FunctionBuilder {
  constructor(private arrayBuilder: ArrayExpressionBuilder<DynamicArrayType | StaticArrayType>) {
    super(arrayBuilder.sourceLocation)
  }

  call(args: ReadonlyArray<NodeBuilder>, typeArgs: ReadonlyArray<PType>, sourceLocation: SourceLocation): NodeBuilder {
    parseFunctionArgs({ args, typeArgs, callLocation: sourceLocation, argSpec: (_) => [], genericTypeArgs: 0, funcName: 'entries' })
    const iteratorType = IterableIteratorGeneric.parameterise([
      new TuplePType({ items: [uint64PType, this.arrayBuilder.ptype.elementType] }),
    ])
    return new IterableIteratorExpressionBuilder(
      nodeFactory.enumeration({
        expr: this.arrayBuilder.iterate(),
        sourceLocation,
        wtype: iteratorType.wtype,
      }),
      iteratorType,
    )
  }
}

export class DynamicArrayExpressionBuilder extends ArrayExpressionBuilder<DynamicArrayType> {
  constructor(expr: Expression, ptype: PType) {
    invariant(ptype instanceof DynamicArrayType, 'ptype must be instance of DynamicArrayType')
    super(expr, ptype)
  }
  memberAccess(name: string, sourceLocation: SourceLocation): NodeBuilder {
    switch (name) {
      case 'push':
        return new ArrayPushFunctionBuilder(this)
      case 'pop':
        return new ArrayPopFunctionBuilder(this)
    }
    return super.memberAccess(name, sourceLocation)
  }
}

export class StaticArrayExpressionBuilder extends ArrayExpressionBuilder<StaticArrayType> {
  constructor(expr: Expression, ptype: PType) {
    invariant(ptype instanceof StaticArrayType, 'ptype must be instance of StaticArrayType')
    super(expr, ptype)
  }

  memberAccess(name: string, sourceLocation: SourceLocation): NodeBuilder {
    switch (name) {
      case 'native':
        return instanceEb(
          nodeFactory.aRC4Decode({
            value: this.resolve(),
            wtype: this.ptype.nativeType.wtypeOrThrow,
            sourceLocation,
          }),
          this.ptype.nativeType,
        )
    }
    return super.memberAccess(name, sourceLocation)
  }
}

export class DynamicBytesExpressionBuilder extends DynamicArrayExpressionBuilder {}
export class StaticBytesExpressionBuilder extends StaticArrayExpressionBuilder {}

export class AddressExpressionBuilder extends ArrayExpressionBuilder<StaticArrayType> {
  constructor(expr: Expression, ptype: PType) {
    invariant(ptype instanceof StaticArrayType, 'ptype must be instance of StaticArrayType')
    invariant(ptype.equals(arc4AddressAlias), 'ptype must be arc4AddressAlias')
    super(expr, ptype)
  }

  memberAccess(name: string, sourceLocation: SourceLocation): NodeBuilder {
    switch (name) {
      case 'length':
        return new UInt64ExpressionBuilder(nodeFactory.uInt64Constant({ value: this.ptype.arraySize, sourceLocation }))
    }
    return super.memberAccess(name, sourceLocation)
  }
}



================================================
FILE: src/awst_build/eb/arc4/base.ts
================================================
import { nodeFactory } from '../../../awst/node-factory'
import type { Expression } from '../../../awst/nodes'
import { EqualityComparison } from '../../../awst/nodes'
import type { SourceLocation } from '../../../awst/source-location'
import { wtypes } from '../../../awst/wtypes'
import { tryConvertEnum } from '../../../util'
import { type PType } from '../../ptypes'
import type { ARC4EncodedType } from '../../ptypes/arc4-types'
import { instanceEb } from '../../type-registry'
import { BooleanExpressionBuilder } from '../boolean-expression-builder'
import { BytesExpressionBuilder } from '../bytes-expression-builder'
import type { InstanceBuilder, NodeBuilder } from '../index'
import { BuilderComparisonOp, FunctionBuilder, InstanceExpressionBuilder } from '../index'
import { requireBuilderOfType } from '../util'
import { parseFunctionArgs } from '../util/arg-parsing'

export class Arc4EncodedBaseExpressionBuilder<T extends ARC4EncodedType> extends InstanceExpressionBuilder<T> {
  constructor(expr: Expression, ptype: T) {
    super(expr, ptype)
  }

  compare(other: InstanceBuilder, op: BuilderComparisonOp, sourceLocation: SourceLocation): InstanceBuilder {
    const equalityOp = tryConvertEnum(op, BuilderComparisonOp, EqualityComparison)

    switch (equalityOp) {
      case EqualityComparison.eq:
      case EqualityComparison.ne:
        return new BooleanExpressionBuilder(
          nodeFactory.bytesComparisonExpression({
            operator: equalityOp,
            lhs: this.toBytes(sourceLocation),
            rhs: requireBuilderOfType(other, this.ptype).toBytes(sourceLocation),
            sourceLocation,
          }),
        )
    }
    return super.compare(other, op, sourceLocation)
  }

  memberAccess(name: string, sourceLocation: SourceLocation): NodeBuilder {
    switch (name) {
      case 'bytes':
        return new BytesExpressionBuilder(this.toBytes(sourceLocation))
      case 'equals':
        return new Arc4EqualsFunctionBuilder(this, sourceLocation)
      case 'native':
        if (this.ptype.nativeType === undefined) break
        return instanceEb(
          nodeFactory.aRC4Decode({
            value: this.resolve(),
            sourceLocation,
            wtype: this.ptype.nativeType.wtypeOrThrow,
          }),
          this.ptype.nativeType,
        )
    }
    return super.memberAccess(name, sourceLocation)
  }

  toBytes(sourceLocation: SourceLocation): Expression {
    return nodeFactory.reinterpretCast({
      expr: this.resolve(),
      wtype: wtypes.bytesWType,
      sourceLocation,
    })
  }
}

class Arc4EqualsFunctionBuilder extends FunctionBuilder {
  constructor(
    private left: Arc4EncodedBaseExpressionBuilder<ARC4EncodedType>,
    sourceLocation: SourceLocation,
  ) {
    super(sourceLocation)
  }

  call(args: ReadonlyArray<NodeBuilder>, typeArgs: ReadonlyArray<PType>, sourceLocation: SourceLocation): NodeBuilder {
    const {
      args: [right],
    } = parseFunctionArgs({
      args,
      typeArgs,
      genericTypeArgs: 0,
      callLocation: sourceLocation,
      funcName: 'equals',
      argSpec: (a) => [a.required(this.left.ptype)],
    })
    return new BooleanExpressionBuilder(
      nodeFactory.bytesComparisonExpression({
        operator: EqualityComparison.eq,
        lhs: this.left.toBytes(sourceLocation),
        rhs: right.toBytes(sourceLocation),
        sourceLocation,
      }),
    )
  }
}



================================================
FILE: src/awst_build/eb/arc4/bool.ts
================================================
import { nodeFactory } from '../../../awst/node-factory'
import type { Expression } from '../../../awst/nodes'
import { BoolConstant } from '../../../awst/nodes'
import type { SourceLocation } from '../../../awst/source-location'
import { wtypes } from '../../../awst/wtypes'
import type { PType } from '../../ptypes'
import { boolPType } from '../../ptypes'
import { ARC4BoolClass, arc4BooleanType, type ARC4EncodedType } from '../../ptypes/arc4-types'
import type { InstanceBuilder, NodeBuilder } from '../index'
import { ClassBuilder } from '../index'
import { parseFunctionArgs } from '../util/arg-parsing'
import { Arc4EncodedBaseExpressionBuilder } from './base'

export class BoolClassBuilder extends ClassBuilder {
  readonly ptype = ARC4BoolClass

  newCall(args: ReadonlyArray<NodeBuilder>, typeArgs: ReadonlyArray<PType>, sourceLocation: SourceLocation): InstanceBuilder {
    const {
      args: [initialValue],
    } = parseFunctionArgs({
      args,
      typeArgs,
      callLocation: sourceLocation,
      funcName: `${this.typeDescription} constructor}`,
      genericTypeArgs: 0,
      argSpec: (a) => [a.optional(boolPType)],
    })
    let expr: Expression
    if (!initialValue) {
      expr = nodeFactory.boolConstant({
        value: false,
        sourceLocation,
        wtype: wtypes.arc4BooleanWType,
      })
    } else {
      const value = initialValue.resolve()
      if (value instanceof BoolConstant) {
        expr = nodeFactory.boolConstant({
          value: value.value,
          sourceLocation,
          wtype: wtypes.arc4BooleanWType,
        })
      } else {
        expr = nodeFactory.aRC4Encode({
          value: value,
          wtype: wtypes.arc4BooleanWType,
          sourceLocation,
        })
      }
    }

    return new BoolExpressionBuilder(expr)
  }
}

export class BoolExpressionBuilder extends Arc4EncodedBaseExpressionBuilder<ARC4EncodedType> {
  constructor(expression: Expression) {
    super(expression, arc4BooleanType)
  }
}



================================================
FILE: src/awst_build/eb/arc4/c2c.ts
================================================
import { OnCompletionAction, TransactionKind } from '../../../awst/models'
import { nodeFactory } from '../../../awst/node-factory'
import type { ARC4MethodConfig, Expression, MethodConstant } from '../../../awst/nodes'
import { ARC4ABIMethodConfig, ARC4BareMethodConfig, ARC4CreateOption, CompiledContract, IntegerConstant } from '../../../awst/nodes'
import { SourceLocation } from '../../../awst/source-location'
import { TxnField } from '../../../awst/txn-fields'
import { wtypes } from '../../../awst/wtypes'
import { Constants } from '../../../constants'
import { logger } from '../../../logger'
import { codeInvariant, enumFromValue, hexToUint8Array, invariant } from '../../../util'
import { buildArc4MethodConstant, ptypeToArc4EncodedType } from '../../arc4-util'
import { AwstBuildContext } from '../../context/awst-build-context'
import type { FunctionPType, PType } from '../../ptypes'
import {
  accountPType,
  applicationCallItxnParamsType,
  applicationItxnType,
  applicationPType,
  assetPType,
  bytesPType,
  compiledContractType,
  GroupTransactionPType,
  ItxnParamsPType,
  voidPType,
} from '../../ptypes'
import {
  abiCallFunction,
  compileArc4Function,
  ContractProxyGeneric,
  ContractProxyType,
  TypedApplicationCallResponseGeneric,
} from '../../ptypes/arc4-types'
import { txnFieldName } from '../../txn-fields'
import { instanceEb } from '../../type-registry'
import { CompileFunctionBuilder } from '../compiled/compile-function'
import { ContractMethodExpressionBuilder } from '../free-subroutine-expression-builder'
import type { InstanceBuilder } from '../index'
import { FunctionBuilder, InstanceExpressionBuilder, NodeBuilder } from '../index'
import { isStaticallyIterable, StaticIterator } from '../traits/static-iterator'
import { mapTransactionFields } from '../transactions/inner-transaction-params'
import { requireExpressionOfType, requireInstanceBuilder } from '../util'
import { parseFunctionArgs } from '../util/arg-parsing'
import { validatePrefix } from './util'

export class AbiCallFunctionBuilder extends FunctionBuilder {
  readonly ptype = abiCallFunction

  call(args: ReadonlyArray<NodeBuilder>, typeArgs: ReadonlyArray<PType>, sourceLocation: SourceLocation): NodeBuilder {
    const {
      args: [functionRef, fields],
    } = parseFunctionArgs({
      args,
      typeArgs,
      genericTypeArgs: 2,
      argSpec: (a) => [a.passthrough(), a.required()],
      callLocation: sourceLocation,
      funcName: this.typeDescription,
    })

    invariant(functionRef instanceof ContractMethodExpressionBuilder, `Arg 0 of ${this.typeDescription} should be an arc4 contract method`)
    const {
      target: { memberName },
      contractType,
      ptype: functionType,
    } = functionRef
    const arc4Config = AwstBuildContext.current.getArc4Config(contractType, memberName)
    codeInvariant(arc4Config instanceof ARC4ABIMethodConfig, `${memberName} is not an ABI method`, functionRef.sourceLocation)
    const methodSelector = buildArc4MethodConstant(functionType, arc4Config, sourceLocation)

    const itxnResult = makeApplicationCall({
      fields,
      methodSelector: methodSelector,
      functionType,
      arc4Config,
      sourceLocation,
    })
    return formatApplicationCallResponse({ itxnResult, functionType, sourceLocation })
  }
}

export class CompileArc4FunctionBuilder extends CompileFunctionBuilder {
  readonly ptype = compileArc4Function

  call(args: ReadonlyArray<NodeBuilder>, typeArgs: ReadonlyArray<PType>, sourceLocation: SourceLocation): NodeBuilder {
    const result = requireInstanceBuilder(super.call(args, [], sourceLocation)).resolve()
    codeInvariant(result instanceof CompiledContract, `${this.typeDescription} expects a contract type`, sourceLocation)
    const proxyType = ContractProxyGeneric.parameterise([...typeArgs])
    return new ContractProxyExpressionBuilder(result, proxyType)
  }
}

export class ContractProxyExpressionBuilder extends InstanceExpressionBuilder<ContractProxyType> {
  constructor(expr: Expression, ptype: PType) {
    invariant(ptype instanceof ContractProxyType, 'ptype must be instance of ContractProxyType')
    super(expr, ptype)
  }

  memberAccess(name: string, sourceLocation: SourceLocation): NodeBuilder {
    switch (name) {
      case 'call':
        return new ContractProxyCallBuilder(this, sourceLocation)
      case 'bareCreate':
        return new ContractProxyBareCreateFunctionBuilder(this, sourceLocation)
    }
    if (name in compiledContractType.properties) {
      return instanceEb(
        nodeFactory.fieldExpression({
          base: this._expr,
          name,
          wtype: compiledContractType.properties[name].wtypeOrThrow,
          sourceLocation,
        }),
        compiledContractType.properties[name],
      )
    }

    return super.memberAccess(name, sourceLocation)
  }
}

export class ContractProxyBareCreateFunctionBuilder extends FunctionBuilder {
  constructor(
    private readonly proxy: ContractProxyExpressionBuilder,
    sourceLocation: SourceLocation,
  ) {
    super(sourceLocation)
  }

  call(args: ReadonlyArray<NodeBuilder>, typeArgs: ReadonlyArray<PType>, sourceLocation: SourceLocation): NodeBuilder {
    const {
      args: [fields],
    } = parseFunctionArgs({
      args,
      typeArgs,
      genericTypeArgs: 0,
      funcName: 'bareCreate',
      argSpec: (a) => [a.optional()],
      callLocation: sourceLocation,
    })
    const arc4Configs = AwstBuildContext.current.getArc4Config(this.proxy.ptype.contractType)
    const createConfigs = arc4Configs.filter((c) => c.create !== ARC4CreateOption.disallow)
    const bareCreate = createConfigs.find((c) => c instanceof ARC4BareMethodConfig)
    if (createConfigs.length && !bareCreate) {
      logger.error(sourceLocation, `${this.proxy.ptype.contractType} has no bare create method`)
    }

    const itxnResult = makeApplicationCall({
      arc4Config:
        bareCreate ??
        new ARC4BareMethodConfig({
          allowedCompletionTypes: [OnCompletionAction.NoOp],
          create: ARC4CreateOption.require,
          sourceLocation: SourceLocation.None,
        }),
      sourceLocation,
      methodSelector: null,
      functionType: null,
      fields,
      proxy: this.proxy,
    })

    return instanceEb(itxnResult, applicationItxnType)
  }
}
export class ContractProxyCallBuilder extends NodeBuilder {
  readonly ptype = undefined

  constructor(
    private readonly proxy: ContractProxyExpressionBuilder,
    sourceLocation: SourceLocation,
  ) {
    super(sourceLocation)
  }
  memberAccess(name: string, sourceLocation: SourceLocation): NodeBuilder {
    const maybeFunction = this.proxy.ptype.contractType.methods[name]
    if (maybeFunction) {
      return new ContractProxyCallFunctionBuilder(this.proxy, maybeFunction, sourceLocation)
    }

    return super.memberAccess(name, sourceLocation)
  }
}

export class ContractProxyCallFunctionBuilder extends FunctionBuilder {
  constructor(
    private readonly proxy: ContractProxyExpressionBuilder,
    private readonly functionType: FunctionPType,
    sourceLocation: SourceLocation,
  ) {
    super(sourceLocation)
  }

  call(args: ReadonlyArray<NodeBuilder>, typeArgs: ReadonlyArray<PType>, sourceLocation: SourceLocation): NodeBuilder {
    const {
      args: [fields],
    } = parseFunctionArgs({
      args,
      typeArgs,
      genericTypeArgs: 0,
      funcName: this.functionType.name,
      argSpec: (a) => [a.optional()],
      callLocation: sourceLocation,
    })

    const arc4Config = AwstBuildContext.current.getArc4Config(this.proxy.ptype.contractType, this.functionType.name)
    codeInvariant(arc4Config, `${this.functionType.name} is not callable`)

    const methodSelector =
      arc4Config instanceof ARC4ABIMethodConfig ? buildArc4MethodConstant(this.functionType, arc4Config, sourceLocation) : null

    return formatApplicationCallResponse({
      itxnResult: makeApplicationCall({
        proxy: this.proxy,
        arc4Config: arc4Config,
        functionType: this.functionType,
        methodSelector,
        fields,
        sourceLocation,
      }),
      functionType: this.functionType,
      sourceLocation,
    })
  }
}
const typedAppCallIgnoredFields = new Set(['args', 'appArgs'])

function makeApplicationCall({
  sourceLocation,
  fields,
  arc4Config,
  proxy,
  methodSelector,
  functionType,
}: {
  proxy?: InstanceBuilder
  fields?: InstanceBuilder
  functionType: FunctionPType | null
  arc4Config: ARC4MethodConfig
  methodSelector: MethodConstant | null
  sourceLocation: SourceLocation
}): Expression {
  const itxnGroup: Expression[] = []
  const mappedFields = new Map<TxnField, Expression>([
    // Set default fee to 0 (transaction will be paid for from transaction group budget, rather than from the application balance)
    [TxnField.Fee, nodeFactory.uInt64Constant({ value: 0n, sourceLocation })],
    [TxnField.TypeEnum, nodeFactory.uInt64Constant({ value: 6n, sourceLocation, tealAlias: 'appl' })],
  ])

  // Map any explicitly provided fields
  if (fields) {
    mapTransactionFields(mappedFields, fields, TransactionKind.appl, sourceLocation, typedAppCallIgnoredFields)
  }
  // Add implicit fields
  if (proxy) {
    // Create a copy of the fields
    const implicitFields = getImplicitFields({ proxy, mappedFields, sourceLocation, methodConfig: arc4Config })
    // Only add fields that aren't explicitly provided
    for (const [key, expr] of implicitFields) {
      if (!mappedFields.has(key)) {
        mappedFields.set(key, expr)
      }
    }
  }
  // Add app args by merging provided args with method selector
  if (arc4Config instanceof ARC4ABIMethodConfig) {
    invariant(methodSelector && functionType, 'methodSelector and functionType both required for abi calls')
    const { itxns, appArgs, foreignApps, foreignAssets, foreignAccounts } = parseAppArgs({
      fields,
      methodSelector,
      sourceLocation,
      functionType,
    })
    mappedFields.set(TxnField.ApplicationArgs, appArgs)
    if (foreignApps) mappedFields.set(TxnField.Applications, foreignApps)
    if (foreignAssets) mappedFields.set(TxnField.Assets, foreignAssets)
    if (foreignAccounts) mappedFields.set(TxnField.Accounts, foreignAccounts)

    itxnGroup.push(...itxns)
  }
  // Build itxn and submit
  itxnGroup.push(
    nodeFactory.createInnerTransaction({
      fields: mappedFields,
      sourceLocation,
      wtype: applicationCallItxnParamsType.wtype,
    }),
  )

  const txnGroup = nodeFactory.submitInnerTransaction({
    itxns: itxnGroup,
    sourceLocation,
  })

  return txnGroup.itxns.length === 1
    ? txnGroup
    : nodeFactory.tupleItemExpression({
        base: txnGroup,
        index: BigInt(txnGroup.itxns.length - 1),
        sourceLocation,
      })
}

function formatApplicationCallResponse({
  itxnResult,
  functionType,
  sourceLocation,
}: {
  itxnResult: Expression
  functionType: FunctionPType
  sourceLocation: SourceLocation
}) {
  if (functionType.returnType.equals(voidPType)) {
    const responseType = TypedApplicationCallResponseGeneric.parameterise([voidPType])
    return instanceEb(
      nodeFactory.tupleExpression({
        items: [itxnResult],
        sourceLocation,
        wtype: responseType.wtype,
      }),
      responseType,
    )
  }

  // Extract return value and return
  const itxnSingle = nodeFactory.singleEvaluation({ source: itxnResult })

  const responseType = TypedApplicationCallResponseGeneric.parameterise([functionType.returnType])
  const returnValue = getReturnValueExpr(itxnSingle, functionType.returnType, sourceLocation)
  return instanceEb(
    nodeFactory.tupleExpression({
      items: [itxnSingle, returnValue],
      sourceLocation,
      wtype: responseType.wtype,
    }),
    responseType,
  )
}

function getImplicitFields({
  proxy,
  methodConfig,
  mappedFields,
  sourceLocation,
}: {
  proxy: InstanceBuilder
  methodConfig: ARC4ABIMethodConfig | ARC4BareMethodConfig
  mappedFields: ReadonlyMap<TxnField, Expression>
  sourceLocation: SourceLocation
}) {
  const implicitFields = new Map<TxnField, Expression>()
  const hasAppId = mappedFields.has(TxnField.ApplicationID)

  const oca = getOca(mappedFields.get(TxnField.OnCompletion), methodConfig.allowedCompletionTypes, sourceLocation)
  implicitFields.set(
    TxnField.OnCompletion,
    nodeFactory.uInt64Constant({
      value: BigInt(oca),
      sourceLocation,
    }),
  )
  if (hasAppId) {
    codeInvariant(
      methodConfig.create !== ARC4CreateOption.require,
      `Cannot specify ${txnFieldName.appId} as target method is only callable in a create scenario`,
      mappedFields.get(TxnField.ApplicationID)?.sourceLocation,
    )
  } else {
    codeInvariant(
      methodConfig.create !== ARC4CreateOption.disallow,
      `${txnFieldName.appId} must be specified to call this method`,
      sourceLocation,
    )
  }
  // Update or possible create
  if (oca === OnCompletionAction.UpdateApplication || !hasAppId) {
    implicitFields.set(
      TxnField.ApprovalProgramPages,
      requireInstanceBuilder(proxy.memberAccess('approvalProgram', sourceLocation)).resolve(),
    )
    implicitFields.set(
      TxnField.ClearStateProgramPages,
      requireInstanceBuilder(proxy.memberAccess('clearStateProgram', sourceLocation)).resolve(),
    )
    if (!hasAppId) {
      implicitFields.set(TxnField.GlobalNumUint, requireInstanceBuilder(proxy.memberAccess('globalUints', sourceLocation)).resolve())
      implicitFields.set(TxnField.GlobalNumByteSlice, requireInstanceBuilder(proxy.memberAccess('globalBytes', sourceLocation)).resolve())
      implicitFields.set(TxnField.LocalNumByteSlice, requireInstanceBuilder(proxy.memberAccess('localBytes', sourceLocation)).resolve())
      implicitFields.set(TxnField.LocalNumUint, requireInstanceBuilder(proxy.memberAccess('localUints', sourceLocation)).resolve())
      implicitFields.set(
        TxnField.ExtraProgramPages,
        requireInstanceBuilder(proxy.memberAccess('extraProgramPages', sourceLocation)).resolve(),
      )
    }
  }
  return implicitFields
}

function getOca(
  ocaField: Expression | undefined,
  allowedCompletionTypes: OnCompletionAction[],
  sourceLocation: SourceLocation,
): OnCompletionAction {
  if (ocaField) {
    codeInvariant(
      ocaField instanceof IntegerConstant,
      `${txnFieldName.onCompletion} should be a compile time constant`,
      ocaField.sourceLocation,
    )
    const oca = enumFromValue(Number(ocaField.value), OnCompletionAction)
    codeInvariant(allowedCompletionTypes.includes(oca), `${txnFieldName.onCompletion} should be one of ${allowedCompletionTypes}`)
    return oca
  } else {
    const oca = allowedCompletionTypes[0]
    if (allowedCompletionTypes.length > 1) {
      logger.warn(sourceLocation, `Method allows multiple on complete actions, defaulting to ${oca}`)
    }
    return oca
  }
}

function parseAppArgs({
  fields,
  methodSelector,
  functionType,
  sourceLocation,
}: {
  fields?: InstanceBuilder
  functionType: FunctionPType
  methodSelector: MethodConstant
  sourceLocation: SourceLocation
}) {
  const results = {
    itxns: new Array<Expression>(),
    foreignApps: new Array<Expression>(),
    foreignAccounts: new Array<Expression>(),
    foreignAssets: new Array<Expression>(),
  }

  const appArgsBuilder = fields && fields.hasProperty('args') && fields.memberAccess('args', sourceLocation)
  const appArgs: Expression[] = [methodSelector]
  if (appArgsBuilder) {
    codeInvariant(isStaticallyIterable(appArgsBuilder), 'Unsupported expression for args', appArgsBuilder.sourceLocation)
    appArgs.push(
      ...appArgsBuilder[StaticIterator]().flatMap((arg, index) => {
        const [paramName, paramType] = functionType.parameters[index]

        if (paramType instanceof GroupTransactionPType) {
          codeInvariant(arg.ptype instanceof ItxnParamsPType, `${paramName} should be an ItxnParams object`)
          if (paramType.kind !== undefined) {
            codeInvariant(
              arg.ptype.kind === paramType.kind,
              `${paramName} should be an ItxnParams object for a ${TransactionKind[paramType.kind]} txn`,
            )
          }
          // Push any itxn params to the itxn array in order
          results.itxns.push(arg.resolve())
          return []
        }
        if (paramType.equals(assetPType)) {
          return handleForeignRef(results.foreignAssets, 0n, paramType, arg)
        }
        if (paramType.equals(applicationPType)) {
          return handleForeignRef(results.foreignApps, 1n, paramType, arg)
        }
        if (paramType.equals(accountPType)) {
          return handleForeignRef(results.foreignAccounts, 1n, paramType, arg)
        }

        const encodedType = ptypeToArc4EncodedType(paramType, sourceLocation)

        const resolvedArg = requireExpressionOfType(arg, paramType)

        if (encodedType.equals(paramType)) {
          return resolvedArg
        }

        return nodeFactory.aRC4Encode({
          value: resolvedArg,
          wtype: encodedType.wtype,
          sourceLocation: arg.sourceLocation,
        })
      }),
    )
  }
  return {
    appArgs: nodeFactory.tupleExpression({
      items: appArgs,
      sourceLocation,
    }),
    itxns: results.itxns,
    foreignApps: results.foreignApps.length
      ? nodeFactory.tupleExpression({
          items: results.foreignApps,
          sourceLocation,
        })
      : null,
    foreignAccounts: results.foreignAccounts.length
      ? nodeFactory.tupleExpression({
          items: results.foreignAccounts,
          sourceLocation,
        })
      : null,
    foreignAssets: results.foreignAssets.length
      ? nodeFactory.tupleExpression({
          items: results.foreignAssets,
          sourceLocation,
        })
      : null,
  }
}

/**
 * Adds the arg expression to the foreign refs array and returns the index of that item
 * @param refsArray The foreign refs array associated with the ref type
 * @param offset The initial offset for the ref type. Account 0 is Txn.sender and App 0 is Global.currentApplication
 * @param paramType The ptype for the parameter
 * @param arg The builder for the arg value
 */
function handleForeignRef(refsArray: Expression[], offset: bigint, paramType: PType, arg: InstanceBuilder) {
  refsArray.push(requireExpressionOfType(arg, paramType))
  return nodeFactory.integerConstant({
    value: BigInt(refsArray.length - 1) + offset,
    wtype: new wtypes.ARC4UIntN({ n: 8n }),
    sourceLocation: SourceLocation.None,
    tealAlias: null,
  })
}

function getReturnValueExpr(itxnResult: Expression, returnType: PType, sourceLocation: SourceLocation) {
  const returnValueLog = nodeFactory.innerTransactionField({
    field: TxnField.LastLog,
    arrayIndex: null,
    itxn: itxnResult,
    wtype: wtypes.bytesWType,
    sourceLocation,
  })
  const logPrefix = nodeFactory.bytesConstant({ value: hexToUint8Array(Constants.algo.arc4.logPrefixHex), sourceLocation })

  const unprefixedLog = validatePrefix(instanceEb(returnValueLog, bytesPType), logPrefix, sourceLocation)

  const arc4Return = ptypeToArc4EncodedType(returnType, sourceLocation)

  const returnValueArc4 = nodeFactory.reinterpretCast({
    expr: unprefixedLog,
    sourceLocation,
    wtype: arc4Return.wtype,
  })

  if (returnType.equals(arc4Return)) return returnValueArc4
  return nodeFactory.aRC4Decode({
    value: returnValueArc4,
    wtype: returnType.wtypeOrThrow,
    sourceLocation,
  })
}



================================================
FILE: src/awst_build/eb/arc4/string.ts
================================================
import { nodeFactory } from '../../../awst/node-factory'
import type { Expression } from '../../../awst/nodes'
import { StringConstant } from '../../../awst/nodes'
import type { SourceLocation } from '../../../awst/source-location'
import { wtypes } from '../../../awst/wtypes'
import type { PType } from '../../ptypes'
import { stringPType } from '../../ptypes'
import type { ARC4EncodedType } from '../../ptypes/arc4-types'
import { ARC4StrClass, arc4StringType } from '../../ptypes/arc4-types'
import type { InstanceBuilder, NodeBuilder } from '../index'
import { ClassBuilder } from '../index'
import { parseFunctionArgs } from '../util/arg-parsing'
import { Arc4EncodedBaseExpressionBuilder } from './base'

export class StrClassBuilder extends ClassBuilder {
  readonly ptype = ARC4StrClass

  newCall(args: ReadonlyArray<NodeBuilder>, typeArgs: ReadonlyArray<PType>, sourceLocation: SourceLocation): InstanceBuilder {
    const {
      args: [initialValue],
    } = parseFunctionArgs({
      args,
      typeArgs,
      genericTypeArgs: 0,
      funcName: this.typeDescription,
      callLocation: sourceLocation,
      argSpec: (a) => [a.optional(stringPType)],
    })

    if (!initialValue) {
      return new StrExpressionBuilder(
        nodeFactory.stringConstant({
          value: '',
          sourceLocation: sourceLocation,
          wtype: wtypes.arc4StringAliasWType,
        }),
      )
    }
    const expr = initialValue.resolve()
    if (expr instanceof StringConstant) {
      return new StrExpressionBuilder(
        nodeFactory.stringConstant({
          value: expr.value,
          sourceLocation: sourceLocation,
          wtype: wtypes.arc4StringAliasWType,
        }),
      )
    } else {
      return new StrExpressionBuilder(
        nodeFactory.aRC4Encode({
          value: expr,
          wtype: wtypes.arc4StringAliasWType,
          sourceLocation,
        }),
      )
    }
  }
}

export class StrExpressionBuilder extends Arc4EncodedBaseExpressionBuilder<ARC4EncodedType> {
  constructor(expression: Expression) {
    super(expression, arc4StringType)
  }
}



================================================
FILE: src/awst_build/eb/arc4/struct.ts
================================================
import { nodeFactory } from '../../../awst/node-factory'
import type { Expression } from '../../../awst/nodes'
import type { SourceLocation } from '../../../awst/source-location'
import { invariant } from '../../../util'
import type { PType, PTypeOrClass } from '../../ptypes'
import { ObjectPType } from '../../ptypes'
import { ARC4StructClass, ARC4StructType } from '../../ptypes/arc4-types'
import { instanceEb } from '../../type-registry'
import type { NodeBuilder } from '../index'
import { ClassBuilder, InstanceBuilder } from '../index'
import { Arc4CopyFunctionBuilder } from '../shared/arc4-copy-function-builder'
import { requireExpressionOfType } from '../util'
import { parseFunctionArgs } from '../util/arg-parsing'
import { Arc4EncodedBaseExpressionBuilder } from './base'

export class StructClassBuilder extends ClassBuilder {
  readonly ptype: ARC4StructClass

  constructor(sourceLocation: SourceLocation, ptype: PType) {
    super(sourceLocation)
    invariant(ptype instanceof ARC4StructClass, 'ptype must be ARC4StructClass')
    this.ptype = ptype
  }

  newCall(args: ReadonlyArray<NodeBuilder>, typeArgs: ReadonlyArray<PType>, sourceLocation: SourceLocation): InstanceBuilder {
    const {
      args: [initialValues],
    } = parseFunctionArgs({
      args,
      typeArgs,
      genericTypeArgs: 1,
      callLocation: sourceLocation,
      funcName: this.typeDescription,
      argSpec: (a) => [a.required(this.ptype.instanceType.nativeType)],
    })
    const initialSingle = initialValues.singleEvaluation()

    const structFields = Object.entries(this.ptype.instanceType.fields).map(
      ([p, t]) => [p, requireExpressionOfType(initialSingle.memberAccess(p, sourceLocation), t)] as const,
    )
    return new StructExpressionBuilder(
      nodeFactory.newStruct({
        wtype: this.ptype.instanceType.wtype,
        values: new Map(structFields),
        sourceLocation,
      }),
      this.ptype.instanceType,
    )
  }
}

export class StructExpressionBuilder extends Arc4EncodedBaseExpressionBuilder<ARC4StructType> {
  constructor(expr: Expression, ptype: PType) {
    invariant(ptype instanceof ARC4StructType, 'ptype must be ARC4StructType')
    super(expr, ptype)
  }

  hasProperty(name: string): boolean {
    return name in this.ptype.fields || super.hasProperty(name)
  }

  memberAccess(name: string, sourceLocation: SourceLocation): NodeBuilder {
    switch (name) {
      case 'copy':
        return new Arc4CopyFunctionBuilder(this)
    }
    if (name in this.ptype.fields) {
      const fieldType = this.ptype.fields[name]
      return instanceEb(
        nodeFactory.fieldExpression({
          name,
          sourceLocation,
          wtype: fieldType.wtype,
          base: this._expr,
        }),
        fieldType,
      )
    }
    return super.memberAccess(name, sourceLocation)
  }

  resolvableToPType(ptype: PTypeOrClass): boolean {
    if (ptype.equals(this.ptype)) return true

    if (ptype instanceof ObjectPType) {
      const native = this.memberAccess('native', this.sourceLocation)
      if (native instanceof InstanceBuilder) {
        return native.resolvableToPType(ptype)
      }
    }
    return false
  }

  resolveToPType(ptype: PTypeOrClass): InstanceBuilder {
    if (ptype.equals(this.ptype)) return this

    if (ptype instanceof ObjectPType) {
      const native = this.memberAccess('native', this.sourceLocation)
      if (native instanceof InstanceBuilder) {
        return native.resolveToPType(ptype)
      }
    }
    return super.resolveToPType(ptype)
  }
}



================================================
FILE: src/awst_build/eb/arc4/tuple.ts
================================================
import { intrinsicFactory } from '../../../awst/intrinsic-factory'
import { nodeFactory } from '../../../awst/node-factory'
import type { Expression } from '../../../awst/nodes'
import type { SourceLocation } from '../../../awst/source-location'
import { logger } from '../../../logger'
import { codeInvariant, invariant } from '../../../util'
import { ptypeToArc4EncodedType } from '../../arc4-util'
import type { PType } from '../../ptypes'
import { numberPType, TuplePType, uint64PType } from '../../ptypes'
import { ARC4EncodedType, Arc4TupleClass, ARC4TupleType } from '../../ptypes/arc4-types'
import { instanceEb } from '../../type-registry'
import type { InstanceBuilder, NodeBuilder } from '../index'
import { ClassBuilder, FunctionBuilder } from '../index'
import { requireIntegerConstant } from '../util'
import { parseFunctionArgs } from '../util/arg-parsing'
import { Arc4EncodedBaseExpressionBuilder } from './base'

export class Arc4TupleClassBuilder extends ClassBuilder {
  readonly ptype = Arc4TupleClass

  newCall(args: ReadonlyArray<NodeBuilder>, typeArgs: ReadonlyArray<PType>, sourceLocation: SourceLocation): InstanceBuilder {
    const {
      args: tupleItems,
      ptypes: [tupleType],
    } = parseFunctionArgs({
      args,
      typeArgs,
      genericTypeArgs: 1,
      funcName: this.typeDescription,
      callLocation: sourceLocation,
      argSpec: (a) => args.map(() => a.required()),
    })
    codeInvariant(tupleType instanceof TuplePType, 'Generic type must be a native tuple type', sourceLocation)

    if (args.length === 0) {
      const arc4Type = ptypeToArc4EncodedType(tupleType, sourceLocation)
      codeInvariant(arc4Type.fixedByteSize !== null, 'Zero arg constructor can only be used for tuples with a fixed size encoding.')
      return new Arc4TupleExpressionBuilder(
        intrinsicFactory.bzero({ size: arc4Type.fixedByteSize, wtype: arc4Type.wtype, sourceLocation }),
        arc4Type,
      )
    }

    const expressions: Expression[] = []
    const types: ARC4EncodedType[] = []
    for (const item of tupleItems) {
      if (item.ptype instanceof ARC4EncodedType) {
        expressions.push(item.resolve())
        types.push(item.ptype)
      } else {
        logger.error(item.sourceLocation, 'ARC4 tuple items must be ARC4 encoded types')
      }
    }
    const arc4TupleType = new ARC4TupleType({
      types,
      sourceLocation,
    })
    return new Arc4TupleExpressionBuilder(
      nodeFactory.aRC4Encode({
        value: nodeFactory.tupleExpression({
          items: expressions,
          wtype: tupleType.wtype,
          sourceLocation,
        }),
        wtype: arc4TupleType.wtype,
        sourceLocation,
      }),
      arc4TupleType,
    )
  }
}

export class Arc4TupleExpressionBuilder extends Arc4EncodedBaseExpressionBuilder<ARC4TupleType> {
  constructor(expr: Expression, ptype: PType) {
    invariant(ptype instanceof ARC4TupleType, 'ptype must be ARC4TupleType')
    super(expr, ptype)
  }

  memberAccess(name: string, sourceLocation: SourceLocation): NodeBuilder {
    switch (name) {
      case 'at':
        return new Arc4TupleAtFunctionBuilder(this, sourceLocation)
      case 'length':
        return instanceEb(
          nodeFactory.uInt64Constant({
            value: BigInt(this.ptype.items.length),
            sourceLocation,
          }),
          uint64PType,
        )
    }
    return super.memberAccess(name, sourceLocation)
  }
}

class Arc4TupleAtFunctionBuilder extends FunctionBuilder {
  constructor(
    private builder: Arc4TupleExpressionBuilder,
    sourceLocation: SourceLocation,
  ) {
    super(sourceLocation)
  }
  call(args: ReadonlyArray<NodeBuilder>, typeArgs: ReadonlyArray<PType>, sourceLocation: SourceLocation): NodeBuilder {
    const {
      args: [index],
    } = parseFunctionArgs({
      args,
      typeArgs,
      genericTypeArgs: 1,
      callLocation: sourceLocation,
      funcName: 'at',
      argSpec: (a) => [a.required(numberPType)],
    })

    const indexNum = requireIntegerConstant(index).value
    codeInvariant(
      indexNum < this.builder.ptype.items.length && indexNum >= 0,
      "Index arg must be a numeric literal between 0 and the tuple's length",
    )

    const itemType = this.builder.ptype.items[Number(indexNum)]

    return instanceEb(
      nodeFactory.tupleItemExpression({
        index: indexNum,
        sourceLocation,
        base: this.builder.resolve(),
      }),
      itemType,
    )
  }
}



================================================
FILE: src/awst_build/eb/arc4/ufixed.ts
================================================
import { nodeFactory } from '../../../awst/node-factory'
import type { Expression, StringConstant } from '../../../awst/nodes'
import type { SourceLocation } from '../../../awst/source-location'
import { CodeError } from '../../../errors'
import { codeInvariant, invariant } from '../../../util'
import type { PType } from '../../ptypes'
import { NumericLiteralPType, stringPType } from '../../ptypes'
import { UFixedNxMClass, UFixedNxMType } from '../../ptypes/arc4-types'
import { ClassBuilder, type InstanceBuilder, type NodeBuilder } from '../index'
import { requireStringConstant } from '../util'
import { parseFunctionArgs } from '../util/arg-parsing'
import { isValidLiteralForPType } from '../util/is-valid-literal-for-ptype'
import { Arc4EncodedBaseExpressionBuilder } from './base'

export class UFixedNxMClassBuilder extends ClassBuilder {
  readonly ptype = UFixedNxMClass

  newCall(args: ReadonlyArray<NodeBuilder>, typeArgs: ReadonlyArray<PType>, sourceLocation: SourceLocation): InstanceBuilder {
    const {
      ptypes: [size, decimals],
      args: [initialValueBuilder],
    } = parseFunctionArgs({
      args,
      typeArgs,
      genericTypeArgs: 2,
      funcName: this.typeDescription,
      argSpec: (a) => [a.optional(stringPType)],
      callLocation: sourceLocation,
    })
    codeInvariant(
      size instanceof NumericLiteralPType,
      `Generic type N of ${this.typeDescription} must be a literal number. Inferred type is ${size.name}`,
      sourceLocation,
    )
    codeInvariant(
      decimals instanceof NumericLiteralPType,
      `Generic type M of ${this.typeDescription} must be a literal number. Inferred type is ${decimals.name}`,
      sourceLocation,
    )
    const ptype = new UFixedNxMType({ n: size.literalValue, m: decimals.literalValue })

    return newUFixedNxM(initialValueBuilder, ptype, sourceLocation)
  }
}

function newUFixedNxM(initialValue: InstanceBuilder | undefined, ptype: UFixedNxMType, sourceLocation: SourceLocation) {
  let expr: Expression
  if (initialValue === undefined) {
    expr = nodeFactory.decimalConstant({
      wtype: ptype.wtype,
      value: '0',
      sourceLocation,
    })
  } else if (initialValue.ptype.equals(stringPType)) {
    const strConstant = requireStringConstant(initialValue)
    expr = fromDecimalString(strConstant, ptype)
  } else {
    throw new CodeError(`Unsupported expression of type ${initialValue.ptype}`, { sourceLocation: initialValue.sourceLocation })
  }

  return new UFixedNxMExpressionBuilder(expr, ptype)
}

function fromDecimalString(strConst: StringConstant, ptype: UFixedNxMType) {
  const [integer, decimal, ...rest] = strConst.value.split('.') as [string, string | undefined, ...string[]]
  codeInvariant(rest.length === 0, 'Decimals should have at most 1 decimal point', strConst.sourceLocation)
  codeInvariant(decimal === undefined || decimal.length <= ptype.m, 'Number of decimal places cannot exceed M', strConst.sourceLocation)

  const d = decimal === undefined ? 0n : BigInt(decimal.padEnd(Number(ptype.m), '0'))
  const i = BigInt(integer)
  const val = i * 10n ** ptype.m + d
  codeInvariant(isValidLiteralForPType(val, ptype), `${strConst} is not a valid literal for ${ptype.name}`, strConst.sourceLocation)
  return nodeFactory.decimalConstant({
    wtype: ptype.wtype,
    value: strConst.value,
    sourceLocation: strConst.sourceLocation,
  })
}

export class UFixedNxMExpressionBuilder extends Arc4EncodedBaseExpressionBuilder<UFixedNxMType> {
  constructor(expr: Expression, ptype: PType) {
    invariant(ptype instanceof UFixedNxMType, 'ptype must be UFixedNxMType')
    super(expr, ptype)
  }
}



================================================
FILE: src/awst_build/eb/arc4/uintn.ts
================================================
import { nodeFactory } from '../../../awst/node-factory'
import type { Expression } from '../../../awst/nodes'
import { IntegerConstant } from '../../../awst/nodes'
import type { SourceLocation } from '../../../awst/source-location'
import { CodeError } from '../../../errors'
import { codeInvariant, invariant } from '../../../util'
import type { LibClassType, PType } from '../../ptypes'
import { biguintPType, NumericLiteralPType, uint64PType } from '../../ptypes'
import { UintNClass, UintNType } from '../../ptypes/arc4-types'
import type { InstanceBuilder, NodeBuilder } from '../index'
import { ClassBuilder } from '../index'
import { parseFunctionArgs } from '../util/arg-parsing'
import { isValidLiteralForPType } from '../util/is-valid-literal-for-ptype'
import { Arc4EncodedBaseExpressionBuilder } from './base'

export class UintNClassBuilder extends ClassBuilder {
  readonly ptype = UintNClass

  newCall(args: ReadonlyArray<NodeBuilder>, typeArgs: ReadonlyArray<PType>, sourceLocation: SourceLocation): InstanceBuilder {
    const {
      ptypes: [size],
      args: [initialValueBuilder],
    } = parseFunctionArgs({
      args,
      typeArgs,
      genericTypeArgs: 1,
      funcName: this.typeDescription,
      argSpec: (a) => [a.optional()],
      callLocation: sourceLocation,
    })
    codeInvariant(
      size instanceof NumericLiteralPType,
      `Generic type of ${this.typeDescription} must be a literal number. Inferred type is ${size.name}`,
      sourceLocation,
    )
    const ptype = new UintNType({ n: size.literalValue })

    return newUintN(initialValueBuilder, ptype, sourceLocation)
  }
}
export const classBuilderForUintNAlias = (aliasClass: LibClassType, aliasInstance: UintNType) => {
  return class extends ClassBuilder {
    readonly ptype = aliasClass

    newCall(args: ReadonlyArray<NodeBuilder>, typeArgs: ReadonlyArray<PType>, sourceLocation: SourceLocation): InstanceBuilder {
      const {
        args: [initialValueBuilder],
      } = parseFunctionArgs({
        args,
        typeArgs,
        genericTypeArgs: 1,
        funcName: `${this.typeDescription} constructor`,
        argSpec: (a) => [a.optional()],
        callLocation: sourceLocation,
      })

      return newUintN(initialValueBuilder, aliasInstance, sourceLocation)
    }
  }
}

function newUintN(initialValueBuilder: InstanceBuilder | undefined, ptype: UintNType, sourceLocation: SourceLocation) {
  if (initialValueBuilder === undefined) {
    return new UintNExpressionBuilder(
      nodeFactory.integerConstant({
        value: 0n,
        tealAlias: null,
        wtype: ptype.wtype,
        sourceLocation: sourceLocation,
      }),
      ptype,
    )
  }
  if (ptype.n <= 64 && initialValueBuilder.resolvableToPType(uint64PType)) {
    const initialValue = initialValueBuilder.resolveToPType(uint64PType).resolve()
    if (initialValue instanceof IntegerConstant) {
      codeInvariant(isValidLiteralForPType(initialValue.value, ptype), `${initialValue.value} cannot be converted to ${ptype}`)
      return new UintNExpressionBuilder(
        nodeFactory.integerConstant({
          value: initialValue.value,
          wtype: ptype.wtype,
          tealAlias: null,
          sourceLocation: sourceLocation,
        }),
        ptype,
      )
    } else {
      return new UintNExpressionBuilder(
        nodeFactory.aRC4Encode({
          wtype: ptype.wtype,
          sourceLocation,
          value: initialValue,
        }),
        ptype,
      )
    }
  }

  if (initialValueBuilder.resolvableToPType(biguintPType)) {
    const initialValue = initialValueBuilder.resolveToPType(biguintPType).resolve()
    if (initialValue instanceof IntegerConstant) {
      codeInvariant(isValidLiteralForPType(initialValue.value, ptype), `${initialValue.value} cannot be converted to ${ptype}`)
      return new UintNExpressionBuilder(
        nodeFactory.integerConstant({
          value: initialValue.value,
          wtype: ptype.wtypeOrThrow,
          sourceLocation: sourceLocation,
          tealAlias: null,
        }),
        ptype,
      )
    } else {
      return new UintNExpressionBuilder(
        nodeFactory.aRC4Encode({
          wtype: ptype.wtype,
          sourceLocation,
          value: initialValue,
        }),
        ptype,
      )
    }
  }
  throw CodeError.unexpectedUnhandledArgs({ sourceLocation })
}

export class UintNExpressionBuilder extends Arc4EncodedBaseExpressionBuilder<UintNType> {
  constructor(expr: Expression, ptype: PType) {
    invariant(ptype instanceof UintNType, 'ptype must be instance of UIntNType')
    super(expr, ptype)
  }
}



================================================
FILE: src/awst_build/eb/arc4/util.ts
================================================
import { nodeFactory } from '../../../awst/node-factory'
import type { BytesConstant, Expression } from '../../../awst/nodes'
import { EqualityComparison } from '../../../awst/nodes'
import type { SourceLocation } from '../../../awst/source-location'
import { wtypes } from '../../../awst/wtypes'
import { Constants } from '../../../constants'
import { CodeError } from '../../../errors'
import { logger } from '../../../logger'
import { codeInvariant, hexToUint8Array } from '../../../util'
import { isArc4EncodableType, ptypeToArc4EncodedType } from '../../arc4-util'
import type { PType } from '../../ptypes'
import { bytesPType, stringPType, uint64PType } from '../../ptypes'
import {
  arc4EncodedLengthFunction,
  ARC4EncodedType,
  decodeArc4Function,
  encodeArc4Function,
  interpretAsArc4Function,
  methodSelectorFunction,
} from '../../ptypes/arc4-types'
import { instanceEb } from '../../type-registry'
import { ContractMethodExpressionBuilder, SubroutineExpressionBuilder } from '../free-subroutine-expression-builder'
import type { InstanceBuilder, NodeBuilder } from '../index'
import { FunctionBuilder } from '../index'
import { requireStringConstant } from '../util'
import { parseFunctionArgs } from '../util/arg-parsing'

export class InterpretAsArc4FunctionBuilder extends FunctionBuilder {
  readonly ptype = interpretAsArc4Function

  call(args: ReadonlyArray<NodeBuilder>, typeArgs: ReadonlyArray<PType>, sourceLocation: SourceLocation): NodeBuilder {
    const {
      ptypes: [ptype],
      args: [theBytes, prefixType],
    } = parseFunctionArgs({
      args,
      typeArgs,
      genericTypeArgs: 1,
      funcName: this.typeDescription,
      argSpec: (a) => [a.required(bytesPType), a.optional(stringPType)],
      callLocation: sourceLocation,
    })
    codeInvariant(ptype instanceof ARC4EncodedType, 'Generic type must be an ARC4 encoded type')

    const prefixBytes = getPrefixValue(prefixType)

    return instanceEb(
      nodeFactory.reinterpretCast({
        expr: validatePrefix(theBytes, prefixBytes, sourceLocation),
        wtype: ptype.wtype,
        sourceLocation,
      }),
      ptype,
    )
  }
}
export class EncodeArc4FunctionBuilder extends FunctionBuilder {
  readonly ptype = encodeArc4Function

  call(args: ReadonlyArray<NodeBuilder>, typeArgs: ReadonlyArray<PType>, sourceLocation: SourceLocation): NodeBuilder {
    const {
      args: [valueToEncode],
      ptypes: [valueType],
    } = parseFunctionArgs({
      args,
      typeArgs,
      genericTypeArgs: 1,
      funcName: this.typeDescription,
      argSpec: (a) => [a.required()],
      callLocation: sourceLocation,
    })
    if (valueType instanceof ARC4EncodedType) {
      // Already encoded, just reinterpret as bytes
      return instanceEb(
        nodeFactory.reinterpretCast({
          expr: valueToEncode.resolve(),
          wtype: wtypes.bytesWType,
          sourceLocation,
        }),
        bytesPType,
      )
    }

    const encodedType = ptypeToArc4EncodedType(valueType, sourceLocation)

    return instanceEb(
      nodeFactory.reinterpretCast({
        expr: nodeFactory.aRC4Encode({
          value: valueToEncode.resolveToPType(valueType).resolve(),
          wtype: encodedType.wtype,
          sourceLocation,
        }),
        sourceLocation,
        wtype: bytesPType.wtype,
      }),
      bytesPType,
    )
  }
}
export class DecodeArc4FunctionBuilder extends FunctionBuilder {
  readonly ptype = decodeArc4Function

  call(args: ReadonlyArray<NodeBuilder>, typeArgs: ReadonlyArray<PType>, sourceLocation: SourceLocation): NodeBuilder {
    const {
      ptypes: [ptype],
      args: [theBytes, prefixType],
    } = parseFunctionArgs({
      args,
      typeArgs,
      genericTypeArgs: 1,
      funcName: this.typeDescription,
      argSpec: (a) => [a.required(bytesPType), a.optional(stringPType)],
      callLocation: sourceLocation,
    })
    codeInvariant(
      !(ptype instanceof ARC4EncodedType),
      `Cannot decode to ${ptype} as it is an ARC4 type. Use \`interpretAsArc4<${ptype}>\` instead`,
      sourceLocation,
    )

    codeInvariant(isArc4EncodableType(ptype), `Cannot determine ARC4 encoding for ${ptype}`, sourceLocation)

    const arc4Encoded = ptypeToArc4EncodedType(ptype, sourceLocation)

    const prefixBytes = getPrefixValue(prefixType)

    return instanceEb(
      nodeFactory.aRC4Decode({
        value: nodeFactory.reinterpretCast({
          expr: validatePrefix(theBytes, prefixBytes, sourceLocation),
          sourceLocation,
          wtype: arc4Encoded.wtype,
        }),
        wtype: ptype.wtypeOrThrow,
        sourceLocation,
      }),
      ptype,
    )
  }
}
export function validatePrefix(
  base: InstanceBuilder,
  expectedPrefix: BytesConstant | undefined,
  sourceLocation: SourceLocation,
): Expression {
  if (expectedPrefix === undefined) return base.resolve()

  const baseSingle = base.singleEvaluation().resolve()

  const baseNoPrefix = nodeFactory.intrinsicCall({
    opCode: 'extract',
    immediates: [4n, 0n],
    wtype: bytesPType.wtype,
    stackArgs: [baseSingle],
    sourceLocation,
  })
  const observedPrefix = nodeFactory.intrinsicCall({
    opCode: 'extract',
    immediates: [0n, 4n],
    wtype: bytesPType.wtype,
    stackArgs: [baseSingle],
    sourceLocation,
  })
  const prefixIsValid = nodeFactory.bytesComparisonExpression({
    operator: EqualityComparison.eq,
    lhs: observedPrefix,
    rhs: expectedPrefix,
    sourceLocation,
  })

  return nodeFactory.checkedMaybe({
    expr: nodeFactory.tupleExpression({ items: [baseNoPrefix, prefixIsValid], sourceLocation }),
    comment: 'Bytes has valid prefix',
  })
}

function getPrefixValue(arg: InstanceBuilder | undefined): BytesConstant | undefined {
  if (arg === undefined) return undefined
  const value = requireStringConstant(arg).value
  switch (value) {
    case 'log':
      return nodeFactory.bytesConstant({ value: hexToUint8Array(Constants.algo.arc4.logPrefixHex), sourceLocation: arg.sourceLocation })
    case 'none':
      return undefined
    default:
      logger.error(arg.sourceLocation, `Expected literal string: 'none' | 'log'`)
  }
}

export class MethodSelectorFunctionBuilder extends FunctionBuilder {
  readonly ptype = methodSelectorFunction

  call(args: ReadonlyArray<NodeBuilder>, typeArgs: ReadonlyArray<PType>, sourceLocation: SourceLocation): NodeBuilder {
    const {
      args: [methodSignature],
    } = parseFunctionArgs({
      args,
      typeArgs,
      genericTypeArgs: 0,
      callLocation: sourceLocation,
      funcName: this.typeDescription,
      argSpec: (a) => [a.passthrough()],
    })

    if (methodSignature instanceof SubroutineExpressionBuilder) {
      codeInvariant(
        methodSignature instanceof ContractMethodExpressionBuilder,
        `Expected contract instance method, found ${methodSignature.typeDescription}`,
      )
      return instanceEb(methodSignature.getMethodSelector(sourceLocation), bytesPType)
    } else {
      if (methodSignature === undefined) {
        throw new CodeError(
          `${this.typeDescription} expects exactly 1 argument that is either a string literal, or a contract function reference`,
          { sourceLocation },
        )
      }
      return instanceEb(
        nodeFactory.methodConstant({
          value: requireStringConstant(methodSignature).value,
          wtype: wtypes.bytesWType,
          sourceLocation,
        }),
        bytesPType,
      )
    }
  }
}

export class Arc4EncodedLengthFunctionBuilder extends FunctionBuilder {
  readonly ptype = arc4EncodedLengthFunction

  call(args: ReadonlyArray<NodeBuilder>, typeArgs: ReadonlyArray<PType>, sourceLocation: SourceLocation): NodeBuilder {
    const {
      ptypes: [typeToEncode],
    } = parseFunctionArgs({
      args,
      typeArgs,
      genericTypeArgs: 1,
      funcName: this.typeDescription,
      argSpec: (a) => [],
      callLocation: sourceLocation,
    })

    const arc4Type = ptypeToArc4EncodedType(typeToEncode, sourceLocation)

    codeInvariant(
      arc4Type.fixedByteSize !== null,
      `Target type must encode to a fixed size. ${typeToEncode} encodes with a variable length`,
      sourceLocation,
    )

    return instanceEb(
      nodeFactory.uInt64Constant({
        value: arc4Type.fixedByteSize,
        sourceLocation,
      }),
      uint64PType,
    )
  }
}



================================================
FILE: src/awst_build/eb/compiled/compile-function.ts
================================================
import { ContractReference, LogicSigReference } from '../../../awst/models'
import { nodeFactory } from '../../../awst/node-factory'
import type { Expression } from '../../../awst/nodes'
import type { SourceLocation } from '../../../awst/source-location'
import { TxnField } from '../../../awst/txn-fields'
import { codeInvariant, invariant } from '../../../util'
import type { PType } from '../../ptypes'
import {
  compiledContractType,
  compiledLogicSigType,
  compileFunctionType,
  ContractClassPType,
  LogicSigPType,
  ObjectPType,
  uint64PType,
} from '../../ptypes'
import { instanceEb } from '../../type-registry'
import type { InstanceBuilder, NodeBuilder } from '../index'
import { FunctionBuilder } from '../index'
import { requireBuilderOfType, requireInstanceBuilder, requireStringConstant } from '../util'
import { parseFunctionArgs } from '../util/arg-parsing'

export class CompileFunctionBuilder extends FunctionBuilder {
  readonly ptype = compileFunctionType

  call(args: ReadonlyArray<NodeBuilder>, typeArgs: ReadonlyArray<PType>, sourceLocation: SourceLocation): NodeBuilder {
    const {
      args: [contractOrSig, options],
    } = parseFunctionArgs({
      args,
      typeArgs,
      genericTypeArgs: 0,
      callLocation: sourceLocation,
      funcName: this.typeDescription,
      argSpec: (a) => [a.required(ContractClassPType, LogicSigPType), a.optional()],
    })

    const templateVarOptions = parseTemplateVars(options)

    if (contractOrSig.ptype instanceof ContractClassPType) {
      return instanceEb(
        nodeFactory.compiledContract({
          contract: ContractReference.fromPType(contractOrSig.ptype),
          allocationOverrides: parseAllocationOverrides(options),
          ...templateVarOptions,
          wtype: compiledContractType.wtype,
          sourceLocation,
        }),
        compiledContractType,
      )
    } else {
      invariant(contractOrSig.ptype instanceof LogicSigPType, 'ptype must be LogicSigPType')
      return instanceEb(
        nodeFactory.compiledLogicSig({
          logicSig: LogicSigReference.fromPType(contractOrSig.ptype),
          ...templateVarOptions,
          wtype: compiledLogicSigType.wtype,
          sourceLocation,
        }),
        compiledLogicSigType,
      )
    }
  }
}
const optionsNames = {
  prefix: 'templateVarsPrefix',
  templateVars: 'templateVars',
}

function parseTemplateVars(options: InstanceBuilder | undefined): { prefix: string | null; templateVariables: Map<string, Expression> } {
  const prefix = options?.hasProperty(optionsNames.prefix)
    ? requireStringConstant(options.memberAccess(optionsNames.prefix, options.sourceLocation)).value
    : null

  const templateVariables = new Map<string, Expression>()

  if (options?.hasProperty(optionsNames.templateVars)) {
    const templateVars = requireInstanceBuilder(options.memberAccess(optionsNames.templateVars, options.sourceLocation))
    codeInvariant(
      templateVars.ptype instanceof ObjectPType,
      `${optionsNames.templateVars} must be an object type`,
      templateVars.sourceLocation,
    )

    for (const [varName] of templateVars.ptype.orderedProperties()) {
      templateVariables.set(varName, requireInstanceBuilder(templateVars.memberAccess(varName, templateVars.sourceLocation)).resolve())
    }
  }

  return {
    prefix,
    templateVariables,
  }
}

const allocationOverrides = {
  extraProgramPages: [TxnField.ExtraProgramPages, uint64PType],
  globalUints: [TxnField.ExtraProgramPages, uint64PType],
  globalBytes: [TxnField.ExtraProgramPages, uint64PType],
  localUints: [TxnField.ExtraProgramPages, uint64PType],
  localBytes: [TxnField.ExtraProgramPages, uint64PType],
} as const

function parseAllocationOverrides(options: InstanceBuilder | undefined): Map<TxnField, Expression> {
  const overrides = new Map<TxnField, Expression>()
  if (options) {
    for (const [property, [field, fieldType]] of Object.entries(allocationOverrides)) {
      if (options.hasProperty(property)) {
        overrides.set(field, requireBuilderOfType(options.memberAccess(property, options.sourceLocation), fieldType).resolve())
      }
    }
  }
  return overrides
}



================================================
FILE: src/awst_build/eb/literal/array-literal-expression-builder.ts
================================================
import { nodeFactory } from '../../../awst/node-factory'
import type { Expression, LValue } from '../../../awst/nodes'
import type { SourceLocation } from '../../../awst/source-location'
import { CodeError } from '../../../errors'
import { codeInvariant } from '../../../util'
import type { PTypeOrClass } from '../../ptypes'
import { ArrayLiteralPType, ArrayPType, TuplePType } from '../../ptypes'
import type { NodeBuilder } from '../index'
import { InstanceBuilder } from '../index'
import type { StaticallyIterable } from '../traits/static-iterator'
import { StaticIterator } from '../traits/static-iterator'
import { TupleExpressionBuilder } from '../tuple-expression-builder'
import { requireIntegerConstant } from '../util'
import { arrayLength } from '../util/array/length'

export class ArrayLiteralExpressionBuilder extends InstanceBuilder implements StaticallyIterable {
  readonly ptype: ArrayLiteralPType | ArrayPType
  constructor(
    sourceLocation: SourceLocation,
    private readonly items: InstanceBuilder[],
    ptype?: ArrayPType | ArrayLiteralPType,
  ) {
    super(sourceLocation)
    this.ptype = ptype ?? new ArrayLiteralPType({ items: items.map((i) => i.ptype) })
  }

  resolve(): Expression {
    const arrayType = this.ptype instanceof ArrayPType ? this.ptype : this.ptype.getArrayType()

    return nodeFactory.newArray({
      sourceLocation: this.sourceLocation,
      values: this.items.map((i) => i.resolve()),
      wtype: arrayType.wtype,
    })
  }

  resolveLValue(): LValue {
    throw new CodeError('Array literal is not a valid lvalue')
  }

  singleEvaluation(): InstanceBuilder {
    return new ArrayLiteralExpressionBuilder(
      this.sourceLocation,
      this.items.map((i) => i.singleEvaluation()),
    )
  }

  indexAccess(index: InstanceBuilder, sourceLocation: SourceLocation): NodeBuilder {
    const indexNum = Number(requireIntegerConstant(index).value)
    codeInvariant(indexNum < this.items.length, `Index ${indexNum} out of bounds of array`, sourceLocation)
    return this.items[indexNum]
  }

  memberAccess(name: string, sourceLocation: SourceLocation): NodeBuilder {
    switch (name) {
      case 'length':
        return arrayLength(this, sourceLocation)
    }
    return super.memberAccess(name, sourceLocation)
  }

  resolveToPType(ptype: PTypeOrClass): InstanceBuilder {
    if (ptype instanceof TuplePType) {
      codeInvariant(
        ptype.items.length <= this.items.length,
        `Value of length ${this.items.length} cannot be resolved to type of length ${ptype.items.length}`,
      )
      return new TupleExpressionBuilder(
        nodeFactory.tupleExpression({
          items: ptype.items.map((itemType, index) => this.items[index].resolveToPType(itemType).resolve()),
          sourceLocation: this.sourceLocation,
        }),
        ptype,
      )
    }
    if (ptype instanceof ArrayPType) {
      return new ArrayLiteralExpressionBuilder(
        this.sourceLocation,
        this.items.map((i) => i.resolveToPType(ptype.elementType)),
        ptype,
      )
    }
    return super.resolveToPType(ptype)
  }

  resolvableToPType(ptype: PTypeOrClass): boolean {
    if (ptype.equals(this.ptype)) return true
    if (ptype instanceof TuplePType) {
      return ptype.items.every((itemType, index) => this.items[index].resolvableToPType(itemType))
    }
    if (ptype instanceof ArrayPType) {
      return this.items.every((i) => i.resolveToPType(ptype.elementType))
    }
    return false
  }

  [StaticIterator](): InstanceBuilder[] {
    return this.items
  }
}



================================================
FILE: src/awst_build/eb/literal/big-int-literal-expression-builder.ts
================================================
import { nodeFactory } from '../../../awst/node-factory'
import type { Expression } from '../../../awst/nodes'
import type { SourceLocation } from '../../../awst/source-location'
import { CodeError } from '../../../errors'
import { codeInvariant } from '../../../util'
import type { PTypeOrClass } from '../../ptypes'
import {
  BigIntLiteralPType,
  bigIntPType,
  biguintPType,
  boolPType,
  numberPType,
  NumericLiteralPType,
  TransientType,
  uint64PType,
} from '../../ptypes'
import { instanceEb, typeRegistry } from '../../type-registry'
import { foldBinaryOp, foldComparisonOp } from '../folding'
import type { BuilderBinaryOp, BuilderComparisonOp, InstanceBuilder } from '../index'
import { BuilderUnaryOp } from '../index'
import { LiteralExpressionBuilder } from '../literal-expression-builder'
import { isValidLiteralForPType } from '../util/is-valid-literal-for-ptype'

export class BigIntLiteralExpressionBuilder extends LiteralExpressionBuilder {
  singleEvaluation(): InstanceBuilder {
    return this
  }

  constructor(
    public readonly value: bigint,
    public readonly ptype: TransientType,
    location: SourceLocation,
  ) {
    super(location)
  }

  resolvableToPType(ptype: PTypeOrClass): boolean {
    const isUnsigned = ptype.equals(biguintPType) || ptype.equals(uint64PType)
    if (this.ptype instanceof NumericLiteralPType || this.ptype.equals(numberPType)) {
      if (isUnsigned) {
        return this.value >= 0n
      }
      return ptype.equals(numberPType) || ptype.equals(this.ptype)
    } else if (this.ptype instanceof BigIntLiteralPType || this.ptype.equals(bigIntPType)) {
      if (isUnsigned) {
        return this.value >= 0n
      }
      return ptype.equals(bigIntPType) || ptype.equals(this.ptype)
    }
    return false
  }
  boolEval(sourceLocation: SourceLocation, negate: boolean = false): Expression {
    const value = negate ? !this.value : Boolean(this.value)

    return nodeFactory.boolConstant({
      value,
      sourceLocation,
    })
  }

  resolveToPType(ptype: PTypeOrClass): InstanceBuilder {
    codeInvariant(this.resolvableToPType(ptype), `${this.value} cannot be converted to type ${ptype.name}`, this.sourceLocation)

    if (ptype.equals(this.ptype)) return this
    if (ptype instanceof TransientType && (ptype.equals(numberPType) || ptype.equals(bigIntPType))) {
      return new BigIntLiteralExpressionBuilder(this.value, ptype, this.sourceLocation)
    }

    codeInvariant(isValidLiteralForPType(this.value, ptype), `${ptype.name} overflow or underflow: ${this.value}`, this.sourceLocation)
    if (ptype.equals(uint64PType)) {
      return instanceEb(nodeFactory.uInt64Constant({ value: this.value, sourceLocation: this.sourceLocation }), uint64PType)
    } else if (ptype.equals(biguintPType)) {
      return instanceEb(nodeFactory.bigUIntConstant({ value: this.value, sourceLocation: this.sourceLocation }), biguintPType)
    }
    throw new CodeError(`${this.value} cannot be converted to type ${ptype.name}`, { sourceLocation: this.sourceLocation })
  }

  binaryOp(other: InstanceBuilder, op: BuilderBinaryOp, sourceLocation: SourceLocation): InstanceBuilder {
    if (other.ptype.wtype) {
      return this.resolveToPType(other.ptype).binaryOp(other, op, sourceLocation)
    }
    if (other instanceof BigIntLiteralExpressionBuilder) {
      const folded = foldBinaryOp(this.value, other.value, op, sourceLocation)
      return new BigIntLiteralExpressionBuilder(folded, this.getUpdatedPType(folded), sourceLocation)
    }
    return super.binaryOp(other, op, sourceLocation)
  }
  compare(other: InstanceBuilder, op: BuilderComparisonOp, sourceLocation: SourceLocation): InstanceBuilder {
    if (other.ptype.wtype) {
      return this.resolveToPType(other.ptype).compare(other, op, sourceLocation)
    }
    if (other instanceof BigIntLiteralExpressionBuilder) {
      return typeRegistry.getInstanceEb(foldComparisonOp(this.value, other.value, op, sourceLocation), boolPType)
    }
    return super.compare(other, op, sourceLocation)
  }
  prefixUnaryOp(op: BuilderUnaryOp, sourceLocation: SourceLocation): InstanceBuilder {
    switch (op) {
      case BuilderUnaryOp.neg:
        return new BigIntLiteralExpressionBuilder(-this.value, this.getUpdatedPType(-this.value), sourceLocation)
      case BuilderUnaryOp.pos:
        return new BigIntLiteralExpressionBuilder(this.value, this.ptype, sourceLocation)
    }
    return super.prefixUnaryOp(op, sourceLocation)
  }

  private getUpdatedPType(value: bigint) {
    if (this.ptype instanceof BigIntLiteralPType) {
      return new BigIntLiteralPType({ literalValue: value })
    }
    if (this.ptype instanceof NumericLiteralPType) {
      return new NumericLiteralPType({ literalValue: value })
    }
    return this.ptype
  }
}



================================================
FILE: src/awst_build/eb/literal/conditional-expression-builder.ts
================================================
import { nodeFactory } from '../../../awst/node-factory'
import type { Expression } from '../../../awst/nodes'
import type { SourceLocation } from '../../../awst/source-location'
import { wtypes } from '../../../awst/wtypes'

import type { PType, PTypeOrClass } from '../../ptypes'
import { typeRegistry } from '../../type-registry'
import type { InstanceBuilder } from '../index'
import { LiteralExpressionBuilder } from '../literal-expression-builder'
import { requireBuilderOfType, resolvableToType } from '../util'

export class ConditionalExpressionBuilder extends LiteralExpressionBuilder {
  private readonly _ptype: PType
  private readonly whenTrue: InstanceBuilder
  private readonly whenFalse: InstanceBuilder
  private readonly condition: Expression

  get ptype(): PType {
    return this._ptype
  }

  boolEval(sourceLocation: SourceLocation, negate: boolean = false): Expression {
    return nodeFactory.conditionalExpression({
      sourceLocation: this.sourceLocation,
      falseExpr: this.whenFalse.boolEval(sourceLocation, negate),
      trueExpr: this.whenTrue.boolEval(sourceLocation, negate),
      condition: this.condition,
      wtype: wtypes.boolWType,
    })
  }

  constructor({
    condition,
    ptype,
    whenFalse,
    whenTrue,
    sourceLocation,
  }: {
    ptype: PType
    condition: Expression
    whenTrue: InstanceBuilder
    whenFalse: InstanceBuilder
    sourceLocation: SourceLocation
  }) {
    super(sourceLocation)
    this._ptype = ptype
    this.whenTrue = whenTrue
    this.whenFalse = whenFalse
    this.condition = condition
  }

  resolvableToPType(ptype: PTypeOrClass): boolean {
    return resolvableToType(this.whenTrue, ptype) && resolvableToType(this.whenFalse, ptype)
  }

  resolveToPType(ptype: PTypeOrClass): InstanceBuilder {
    const falseBuilder = requireBuilderOfType(this.whenFalse, ptype)
    const trueBuilder = requireBuilderOfType(this.whenTrue, ptype)

    return typeRegistry.getInstanceEb(
      nodeFactory.conditionalExpression({
        sourceLocation: this.sourceLocation,
        falseExpr: falseBuilder.resolve(),
        trueExpr: trueBuilder.resolve(),
        condition: this.condition,
        wtype: falseBuilder.ptype.wtypeOrThrow,
      }),
      falseBuilder.ptype,
    )
  }
}



================================================
FILE: src/awst_build/eb/literal/object-expression-builder.ts
================================================
import { nodeFactory } from '../../../awst/node-factory'
import type { Expression } from '../../../awst/nodes'
import type { SourceLocation } from '../../../awst/source-location'
import { CodeError } from '../../../errors'
import { invariant } from '../../../util'
import type { PTypeOrClass } from '../../ptypes'
import { ObjectPType, type PType } from '../../ptypes'
import { instanceEb } from '../../type-registry'
import type { InstanceBuilder } from '../index'
import { InstanceExpressionBuilder, type NodeBuilder } from '../index'
import { requireExpressionOfType } from '../util'

export class ObjectExpressionBuilder extends InstanceExpressionBuilder<ObjectPType> {
  constructor(expr: Expression, ptype: PType) {
    invariant(ptype instanceof ObjectPType, `ObjectExpressionBuilder must be instantiated with ptype of ObjectPType`)
    super(expr, ptype)
  }

  memberAccess(name: string, sourceLocation: SourceLocation): NodeBuilder {
    const propertyIndex = this.ptype.orderedProperties().findIndex(([prop]) => prop === name)
    if (propertyIndex === -1) {
      return super.memberAccess(name, sourceLocation)
    }
    const propertyPtype = this.ptype.getPropertyType(name)
    return instanceEb(
      nodeFactory.fieldExpression({
        name,
        sourceLocation,
        base: this._expr,
        wtype: propertyPtype.wtypeOrThrow,
      }),
      propertyPtype,
    )
  }

  hasProperty(name: string): boolean {
    return this.ptype.orderedProperties().some(([prop]) => prop === name)
  }

  resolvableToPType(ptype: PTypeOrClass): ptype is ObjectPType {
    if (ptype instanceof ObjectPType) {
      return ptype.orderedProperties().every(([prop, propType]) => this.ptype.hasPropertyOfType(prop, propType))
    }
    return false
  }

  resolveToPType(ptype: PTypeOrClass): InstanceBuilder {
    if (ptype.equals(this.ptype)) {
      return this
    }
    if (this.resolvableToPType(ptype)) {
      const base = this.singleEvaluation()
      return instanceEb(
        nodeFactory.tupleExpression({
          sourceLocation: this.sourceLocation,
          items: ptype
            .orderedProperties()
            .map(([prop, propType]) => requireExpressionOfType(base.memberAccess(prop, this.sourceLocation), propType)),
          wtype: ptype.wtype,
        }),
        ptype,
      )
    }
    throw CodeError.cannotResolveToType({ sourceType: this.ptype, targetType: ptype, sourceLocation: this.sourceLocation })
  }
}



================================================
FILE: src/awst_build/eb/literal/object-literal-expression-builder.ts
================================================
import { nodeFactory } from '../../../awst/node-factory'
import type { Expression, LValue } from '../../../awst/nodes'
import type { SourceLocation } from '../../../awst/source-location'
import { CodeError } from '../../../errors'
import type { PTypeOrClass } from '../../ptypes'
import { ObjectPType } from '../../ptypes'
import type { InstanceBuilder, NodeBuilder } from '../index'
import { LiteralExpressionBuilder } from '../literal-expression-builder'
import { requestExpressionOfType, requireExpressionOfType, requireInstanceBuilder } from '../util'
import { ObjectExpressionBuilder } from './object-expression-builder'

export type ObjectLiteralParts =
  | {
      type: 'properties'
      properties: Record<string, InstanceBuilder>
    }
  | {
      type: 'spread-object'
      obj: InstanceBuilder
    }

export class ObjectLiteralExpressionBuilder extends LiteralExpressionBuilder {
  readonly _ptype: ObjectPType
  get ptype(): ObjectPType {
    return this._ptype
  }

  constructor(
    sourceLocation: SourceLocation,
    ptype: ObjectPType,
    private readonly parts: ObjectLiteralParts[],
  ) {
    super(sourceLocation)
    this._ptype = ptype
  }

  resolve(): Expression {
    // Resolve object to a tuple using its own inferred types
    return this.toTuple(this.ptype)
  }
  resolveLValue(): LValue {
    return nodeFactory.tupleExpression({
      items: this.ptype
        .orderedProperties()
        .map(([p, propPType]) => requireInstanceBuilder(this.memberAccess(p, this.sourceLocation)).resolveLValue()),
      sourceLocation: this.sourceLocation,
      wtype: this.ptype.wtype,
    })
  }
  memberAccess(name: string, sourceLocation: SourceLocation): NodeBuilder {
    for (const part of this.parts.toReversed()) {
      if (part.type === 'properties') {
        if (Object.hasOwn(part.properties, name)) {
          return part.properties[name]
        }
      } else {
        if (part.obj.hasProperty(name)) {
          return part.obj.memberAccess(name, sourceLocation)
        }
      }
    }
    throw new CodeError(`${name} does not exist on ${this.typeDescription}`, { sourceLocation })
  }

  hasProperty(name: string): boolean {
    return this.parts.some((part) => (part.type === 'properties' ? Object.hasOwn(part.properties, name) : part.obj.hasProperty(name)))
  }

  private toTuple(ptype: ObjectPType): Expression {
    let base: InstanceBuilder
    if (this.ptype.equals(ptype)) {
      // eslint-disable-next-line @typescript-eslint/no-this-alias
      base = this
    } else {
      // Resolve this object to a tuple using declared order but using the target property types.
      // This will resolve numeric literals to algo-ts types if available
      const tempType = new ObjectPType({
        properties: Object.fromEntries(this.ptype.orderedProperties().map(([p]) => [p, ptype.getPropertyType(p)] as const)),
      })

      base = new ObjectExpressionBuilder(
        nodeFactory.tupleExpression({
          items: tempType
            .orderedProperties()
            .map(([p, propType]) => requireExpressionOfType(this.memberAccess(p, this.sourceLocation), propType)),
          sourceLocation: this.sourceLocation,
          wtype: tempType.wtype,
        }),
        tempType,
      ).singleEvaluation()
    }
    // Reorder properties to the target type
    return nodeFactory.tupleExpression({
      items: ptype
        .orderedProperties()
        .map(([p, propPType]) => requireExpressionOfType(base.memberAccess(p, this.sourceLocation), propPType)),
      sourceLocation: this.sourceLocation,
      wtype: ptype.wtype,
    })
  }

  resolvableToPType(ptype: PTypeOrClass): ptype is ObjectPType {
    if (!(ptype instanceof ObjectPType)) return false
    for (const [prop, propPType] of ptype.orderedProperties()) {
      if (!this.hasProperty(prop)) return false
      const propValue = requestExpressionOfType(this.memberAccess(prop, this.sourceLocation), propPType)
      if (propValue === undefined) return false
    }
    return true
  }

  resolveToPType(ptype: PTypeOrClass): InstanceBuilder {
    if (!this.resolvableToPType(ptype))
      throw new CodeError(`${this.typeDescription} cannot be resolved to ${ptype}`, { sourceLocation: this.sourceLocation })
    return new ObjectExpressionBuilder(this.toTuple(ptype), ptype)
  }
}



================================================
FILE: src/awst_build/eb/reference/account.ts
================================================
import { nodeFactory } from '../../../awst/node-factory'
import type { Expression } from '../../../awst/nodes'
import type { SourceLocation } from '../../../awst/source-location'
import { wtypes } from '../../../awst/wtypes'
import type { PType } from '../../ptypes'
import { accountPType, applicationPType, assetPType, bytesPType, stringPType, uint64PType } from '../../ptypes'
import { BooleanExpressionBuilder } from '../boolean-expression-builder'
import type { BuilderComparisonOp, InstanceBuilder, NodeBuilder } from '../index'
import { FunctionBuilder } from '../index'
import { requireExpressionOfType, requireStringConstant } from '../util'
import { parseFunctionArgs } from '../util/arg-parsing'
import { compareBytes } from '../util/compare-bytes'
import { ReferenceTypeExpressionBuilder } from './base'

export class AccountFunctionBuilder extends FunctionBuilder {
  call(args: ReadonlyArray<NodeBuilder>, typeArgs: ReadonlyArray<PType>, sourceLocation: SourceLocation): NodeBuilder {
    const {
      args: [addressOrKey],
    } = parseFunctionArgs({
      args,
      typeArgs,
      callLocation: sourceLocation,
      funcName: 'Account function',
      genericTypeArgs: 0,
      argSpec: (a) => [a.optional(stringPType, bytesPType)],
    })

    if (!addressOrKey) {
      return new AccountExpressionBuilder(
        nodeFactory.intrinsicCall({
          opCode: 'global',
          immediates: ['ZeroAddress'],
          stackArgs: [],
          sourceLocation,
          wtype: accountPType.wtype,
        }),
      )
    }
    if (addressOrKey.ptype.equals(stringPType)) {
      const address = requireStringConstant(addressOrKey)
      return new AccountExpressionBuilder(
        nodeFactory.addressConstant({
          value: address.value,
          sourceLocation: address.sourceLocation,
          wtype: accountPType.wtype,
        }),
      )
    }

    return new AccountExpressionBuilder(
      nodeFactory.reinterpretCast({
        expr: requireExpressionOfType(addressOrKey, bytesPType),
        wtype: accountPType.wtype,
        sourceLocation,
      }),
    )
  }
}
export class AccountExpressionBuilder extends ReferenceTypeExpressionBuilder {
  constructor(expr: Expression) {
    super(expr, {
      backingType: bytesPType,
      backingMember: 'bytes',
      fieldMapping: {
        balance: ['AcctBalance', uint64PType],
        minBalance: ['AcctMinBalance', uint64PType],
        authAddress: ['AcctAuthAddr', accountPType],
        totalNumUint: ['AcctTotalNumUint', uint64PType],
        totalNumByteSlice: ['AcctTotalNumByteSlice', uint64PType],
        totalExtraAppPages: ['AcctTotalExtraAppPages', uint64PType],
        totalAppsCreated: ['AcctTotalAppsCreated', uint64PType],
        totalAppsOptedIn: ['AcctTotalAppsOptedIn', uint64PType],
        totalAssetsCreated: ['AcctTotalAssetsCreated', uint64PType],
        totalAssets: ['AcctTotalAssets', uint64PType],
        totalBoxes: ['AcctTotalBoxes', uint64PType],
        totalBoxBytes: ['AcctTotalBoxBytes', uint64PType],
      },
      fieldOpCode: 'acct_params_get',
      ptype: accountPType,
      fieldBoolComment: 'account funded',
    })
  }

  compare(other: InstanceBuilder, op: BuilderComparisonOp, sourceLocation: SourceLocation): InstanceBuilder {
    return compareBytes(this._expr, requireExpressionOfType(other, accountPType), op, sourceLocation, this.typeDescription)
  }

  memberAccess(name: string, sourceLocation: SourceLocation): NodeBuilder {
    switch (name) {
      case 'isOptedIn':
        return new IsOptedInFunctionBuilder(this._expr, sourceLocation)
    }
    return super.memberAccess(name, sourceLocation)
  }

  toBytes(sourceLocation: SourceLocation): Expression {
    return nodeFactory.reinterpretCast({
      expr: this._expr,
      wtype: wtypes.bytesWType,
      sourceLocation,
    })
  }
}

class IsOptedInFunctionBuilder extends FunctionBuilder {
  constructor(
    private expr: Expression,
    sourceLocation: SourceLocation,
  ) {
    super(sourceLocation)
  }

  call(args: ReadonlyArray<NodeBuilder>, typeArgs: ReadonlyArray<PType>, sourceLocation: SourceLocation): NodeBuilder {
    const {
      args: [applicationOrAsset],
    } = parseFunctionArgs({
      args,
      typeArgs,
      genericTypeArgs: 0,
      callLocation: sourceLocation,
      funcName: 'isOptedIn',
      argSpec: (a) => [a.required(applicationPType, assetPType)],
    })

    if (applicationOrAsset.ptype.equals(assetPType)) {
      return new BooleanExpressionBuilder(
        nodeFactory.tupleItemExpression({
          base: nodeFactory.intrinsicCall({
            opCode: 'asset_holding_get',
            immediates: ['AssetBalance'],
            stackArgs: [this.expr, applicationOrAsset.resolve()],
            wtype: new wtypes.WTuple({ types: [wtypes.uint64WType, wtypes.boolWType], immutable: true }),
            sourceLocation,
          }),
          index: 1n,
          sourceLocation,
        }),
      )
    } else {
      return new BooleanExpressionBuilder(
        nodeFactory.intrinsicCall({
          opCode: 'app_opted_in',
          stackArgs: [this.expr, applicationOrAsset.resolve()],
          sourceLocation,
          wtype: wtypes.boolWType,
          immediates: [],
        }),
      )
    }
  }
}



================================================
FILE: src/awst_build/eb/reference/application.ts
================================================
import { nodeFactory } from '../../../awst/node-factory'
import type { Expression } from '../../../awst/nodes'
import type { SourceLocation } from '../../../awst/source-location'
import type { PType } from '../../ptypes'
import { accountPType, applicationPType, bytesPType, uint64PType } from '../../ptypes'
import type { NodeBuilder } from '../index'
import { FunctionBuilder } from '../index'
import { parseFunctionArgs } from '../util/arg-parsing'
import { Uint64BackedReferenceTypeExpressionBuilder } from './base'

export class ApplicationFunctionBuilder extends FunctionBuilder {
  call(args: ReadonlyArray<NodeBuilder>, typeArgs: ReadonlyArray<PType>, sourceLocation: SourceLocation): NodeBuilder {
    const {
      args: [applicationId],
    } = parseFunctionArgs({
      argSpec: (a) => [a.optional(uint64PType)],
      args,
      typeArgs,
      genericTypeArgs: 0,
      funcName: 'Application',
      callLocation: sourceLocation,
    })

    return new ApplicationExpressionBuilder(
      nodeFactory.reinterpretCast({
        expr: applicationId?.resolve() ?? nodeFactory.uInt64Constant({ value: 0n, sourceLocation }),
        sourceLocation,
        wtype: applicationPType.wtypeOrThrow,
      }),
    )
  }
}

export class ApplicationExpressionBuilder extends Uint64BackedReferenceTypeExpressionBuilder {
  constructor(expr: Expression) {
    super(expr, {
      ptype: applicationPType,
      backingMember: 'id',
      fieldOpCode: 'app_params_get',
      fieldMapping: {
        approvalProgram: ['AppApprovalProgram', bytesPType],
        clearStateProgram: ['AppClearStateProgram', bytesPType],
        globalNumUint: ['AppGlobalNumUint', uint64PType],
        globalNumBytes: ['AppGlobalNumByteSlice', uint64PType],
        localNumUint: ['AppLocalNumUint', uint64PType],
        localNumBytes: ['AppLocalNumByteSlice', uint64PType],
        extraProgramPages: ['AppExtraProgramPages', uint64PType],
        creator: ['AppCreator', accountPType],
        address: ['AppAddress', accountPType],
      },
      fieldBoolComment: 'application exists',
    })
  }
}



================================================
FILE: src/awst_build/eb/reference/asset.ts
================================================
import { nodeFactory } from '../../../awst/node-factory'
import type { Expression } from '../../../awst/nodes'
import type { SourceLocation } from '../../../awst/source-location'
import { wtypes } from '../../../awst/wtypes'
import type { PType } from '../../ptypes'
import { accountPType, assetPType, boolPType, bytesPType, uint64PType } from '../../ptypes'
import { instanceEb } from '../../type-registry'
import type { NodeBuilder } from '../index'
import { FunctionBuilder } from '../index'
import { parseFunctionArgs } from '../util/arg-parsing'
import type { FieldMapping } from './base'
import { Uint64BackedReferenceTypeExpressionBuilder } from './base'

export class AssetFunctionBuilder extends FunctionBuilder {
  call(args: ReadonlyArray<NodeBuilder>, typeArgs: ReadonlyArray<PType>, sourceLocation: SourceLocation): NodeBuilder {
    const {
      args: [assetId],
    } = parseFunctionArgs({
      argSpec: (a) => [a.optional(uint64PType)],
      args,
      typeArgs,
      genericTypeArgs: 0,
      funcName: 'Asset function',
      callLocation: sourceLocation,
    })

    return new AssetExpressionBuilder(
      nodeFactory.reinterpretCast({
        expr: assetId?.resolve() ?? nodeFactory.uInt64Constant({ value: 0n, sourceLocation }),
        sourceLocation,
        wtype: assetPType.wtypeOrThrow,
      }),
    )
  }
}

class AssetHoldingExpressionBuilder extends FunctionBuilder {
  static fieldMapping = {
    balance: ['AssetBalance', uint64PType],
    frozen: ['AssetFrozen', boolPType],
  } satisfies FieldMapping
  constructor(
    private asset: Expression,
    private holdingField: keyof typeof AssetHoldingExpressionBuilder.fieldMapping,
    sourceLocation: SourceLocation,
  ) {
    super(sourceLocation)
  }

  call(args: ReadonlyArray<NodeBuilder>, typeArgs: ReadonlyArray<PType>, sourceLocation: SourceLocation): NodeBuilder {
    const {
      args: [holder],
    } = parseFunctionArgs({
      args,
      typeArgs,
      callLocation: sourceLocation,
      genericTypeArgs: 0,
      funcName: this.holdingField,
      argSpec: (a) => [a.required(accountPType)],
    })
    const [immediate, resultType] = AssetHoldingExpressionBuilder.fieldMapping[this.holdingField]
    const op = nodeFactory.intrinsicCall({
      opCode: 'asset_holding_get',
      immediates: [immediate],
      stackArgs: [holder.resolve(), this.asset],
      wtype: new wtypes.WTuple({ types: [resultType.wtypeOrThrow, wtypes.boolWType], immutable: true }),
      sourceLocation,
    })
    return instanceEb(nodeFactory.checkedMaybe({ expr: op, comment: `account opted into asset` }), resultType)
  }
}
export class AssetExpressionBuilder extends Uint64BackedReferenceTypeExpressionBuilder {
  constructor(expr: Expression) {
    super(expr, {
      ptype: assetPType,
      backingMember: 'id',
      fieldOpCode: 'asset_params_get',
      fieldMapping: {
        total: ['AssetTotal', uint64PType],
        decimals: ['AssetDecimals', uint64PType],
        defaultFrozen: ['AssetDefaultFrozen', boolPType],
        unitName: ['AssetUnitName', bytesPType],
        name: ['AssetName', bytesPType],
        url: ['AssetURL', bytesPType],
        metadataHash: ['AssetMetadataHash', bytesPType],
        manager: ['AssetManager', accountPType],
        reserve: ['AssetReserve', accountPType],
        freeze: ['AssetFreeze', accountPType],
        clawback: ['AssetClawback', accountPType],
        creator: ['AssetCreator', accountPType],
      },
      fieldBoolComment: 'asset exists',
    })
  }
  memberAccess(name: string, sourceLocation: SourceLocation): NodeBuilder {
    if (name in AssetHoldingExpressionBuilder.fieldMapping) {
      return new AssetHoldingExpressionBuilder(
        this.resolve(),
        name as keyof typeof AssetHoldingExpressionBuilder.fieldMapping,
        sourceLocation,
      )
    }
    return super.memberAccess(name, sourceLocation)
  }
}



================================================
FILE: src/awst_build/eb/reference/base.ts
================================================
import { intrinsicFactory } from '../../../awst/intrinsic-factory'
import { nodeFactory } from '../../../awst/node-factory'
import type { Expression } from '../../../awst/nodes'
import type { SourceLocation } from '../../../awst/source-location'
import { wtypes } from '../../../awst/wtypes'
import type { PType } from '../../ptypes'
import { uint64PType } from '../../ptypes'
import { instanceEb } from '../../type-registry'
import type { BuilderComparisonOp, InstanceBuilder, NodeBuilder } from '../index'
import { InstanceExpressionBuilder } from '../index'
import { requireExpressionOfType } from '../util'
import { compareUint64 } from '../util/compare-uint64'

export type FieldMapping = Record<string, [string, PType]>

export abstract class ReferenceTypeExpressionBuilder extends InstanceExpressionBuilder<PType> {
  constructor(
    expr: Expression,
    protected options: {
      ptype: PType
      backingType: PType
      backingMember: string
      fieldMapping: FieldMapping
      fieldOpCode: string
      fieldBoolComment: string
    },
  ) {
    super(expr, options.ptype)
  }

  memberAccess(name: string, sourceLocation: SourceLocation): NodeBuilder {
    if (name === this.options.backingMember) {
      return instanceEb(
        nodeFactory.reinterpretCast({
          expr: this.resolve(),
          wtype: this.options.backingType.wtypeOrThrow,
          sourceLocation,
        }),
        this.options.backingType,
      )
    }
    if (name in this.options.fieldMapping) {
      const [immediate, resultType] = this.options.fieldMapping[name]
      const op = nodeFactory.intrinsicCall({
        opCode: this.options.fieldOpCode,
        immediates: [immediate],
        stackArgs: [this.resolve()],
        wtype: new wtypes.WTuple({ types: [resultType.wtypeOrThrow, wtypes.boolWType], immutable: true }),
        sourceLocation,
      })
      return instanceEb(nodeFactory.checkedMaybe({ expr: op, comment: this.options.fieldBoolComment }), resultType)
    }
    return super.memberAccess(name, sourceLocation)
  }
}

export abstract class Uint64BackedReferenceTypeExpressionBuilder extends ReferenceTypeExpressionBuilder {
  constructor(
    expr: Expression,
    options: {
      ptype: PType
      backingMember: string
      fieldMapping: FieldMapping
      fieldOpCode: string
      fieldBoolComment: string
    },
  ) {
    super(expr, {
      backingType: uint64PType,
      ...options,
    })
  }

  toBytes(sourceLocation: SourceLocation): Expression {
    return intrinsicFactory.itob({ value: this.resolve(), sourceLocation })
  }
  boolEval(sourceLocation: SourceLocation, negate: boolean = false): Expression {
    if (negate) {
      return nodeFactory.not({
        expr: this.resolve(),
        sourceLocation,
      })
    }
    return nodeFactory.reinterpretCast({
      sourceLocation,
      expr: this.resolve(),
      wtype: wtypes.boolWType,
    })
  }

  compare(other: InstanceBuilder, op: BuilderComparisonOp, sourceLocation: SourceLocation): InstanceBuilder {
    const otherExpr = requireExpressionOfType(other, this.ptype)
    return compareUint64(this.resolve(), otherExpr, op, sourceLocation, this.typeDescription)
  }
}



================================================
FILE: src/awst_build/eb/shared/arc4-copy-function-builder.ts
================================================
import { nodeFactory } from '../../../awst/node-factory'
import type { SourceLocation } from '../../../awst/source-location'
import type { PType } from '../../ptypes'
import { instanceEb } from '../../type-registry'
import type { InstanceBuilder } from '../index'
import { FunctionBuilder, type NodeBuilder } from '../index'
import { parseFunctionArgs } from '../util/arg-parsing'

export class Arc4CopyFunctionBuilder extends FunctionBuilder {
  constructor(private baseBuilder: InstanceBuilder) {
    super(baseBuilder.sourceLocation)
  }

  call(args: ReadonlyArray<NodeBuilder>, typeArgs: ReadonlyArray<PType>, sourceLocation: SourceLocation): NodeBuilder {
    parseFunctionArgs({ args, typeArgs, genericTypeArgs: 0, argSpec: (a) => [], funcName: 'copy', callLocation: sourceLocation })
    return instanceEb(
      nodeFactory.copy({
        value: this.baseBuilder.resolve(),
        sourceLocation,
      }),
      this.baseBuilder.ptype,
    )
  }
}



================================================
FILE: src/awst_build/eb/shared/at-function-builder.ts
================================================
import { nodeFactory } from '../../../awst/node-factory'
import type { Expression } from '../../../awst/nodes'
import type { SourceLocation } from '../../../awst/source-location'
import type { PType } from '../../ptypes'
import { numberPType, uint64PType } from '../../ptypes'
import { instanceEb } from '../../type-registry'
import type { NodeBuilder } from '../index'
import { FunctionBuilder } from '../index'
import { parseFunctionArgs } from '../util/arg-parsing'
import { translateNegativeIndex } from '../util/translate-negative-index'

export class AtFunctionBuilder extends FunctionBuilder {
  constructor(
    private expr: Expression,
    private itemPType: PType,
    private exprLength: Expression | bigint,
  ) {
    super(expr.sourceLocation)
  }

  call(args: ReadonlyArray<NodeBuilder>, typeArgs: ReadonlyArray<PType>, sourceLocation: SourceLocation): NodeBuilder {
    const {
      args: [index],
    } = parseFunctionArgs({
      args,
      typeArgs,
      genericTypeArgs: 0,
      callLocation: sourceLocation,
      funcName: 'at',
      argSpec: (a) => [a.required(uint64PType, numberPType)],
    })

    return instanceEb(
      nodeFactory.indexExpression({
        base: this.expr,
        sourceLocation: sourceLocation,
        index: translateNegativeIndex(this.exprLength, index),
        wtype: this.itemPType.wtypeOrThrow,
      }),
      this.itemPType,
    )
  }
}



================================================
FILE: src/awst_build/eb/shared/pop-function-builder.ts
================================================
import { nodeFactory } from '../../../awst/node-factory'
import type { SourceLocation } from '../../../awst/source-location'
import type { PType } from '../../ptypes'
import { instanceEb } from '../../type-registry'
import type { InstanceBuilder } from '../index'
import { FunctionBuilder, type NodeBuilder } from '../index'
import { parseFunctionArgs } from '../util/arg-parsing'

export class ArrayPopFunctionBuilder extends FunctionBuilder {
  constructor(private arrayBuilder: InstanceBuilder<{ elementType: PType } & PType>) {
    super(arrayBuilder.sourceLocation)
  }

  call(args: ReadonlyArray<NodeBuilder>, typeArgs: ReadonlyArray<PType>, sourceLocation: SourceLocation): NodeBuilder {
    const elementType = this.arrayBuilder.ptype.elementType
    parseFunctionArgs({
      args,
      typeArgs,
      funcName: 'pop',
      callLocation: sourceLocation,
      genericTypeArgs: 0,
      argSpec: () => [],
    })

    return instanceEb(
      nodeFactory.arrayPop({
        base: this.arrayBuilder.resolve(),
        sourceLocation,
        wtype: elementType.wtypeOrThrow,
      }),
      elementType,
    )
  }
}



================================================
FILE: src/awst_build/eb/shared/push-function-builder.ts
================================================
import { nodeFactory } from '../../../awst/node-factory'
import type { SourceLocation } from '../../../awst/source-location'
import { wtypes } from '../../../awst/wtypes'
import type { PType } from '../../ptypes'
import { voidPType } from '../../ptypes'
import { instanceEb } from '../../type-registry'
import type { InstanceBuilder } from '../index'
import { FunctionBuilder, type NodeBuilder } from '../index'
import { parseFunctionArgs } from '../util/arg-parsing'

export class ArrayPushFunctionBuilder extends FunctionBuilder {
  constructor(private arrayBuilder: InstanceBuilder<{ elementType: PType } & PType>) {
    super(arrayBuilder.sourceLocation)
  }

  call(args: ReadonlyArray<NodeBuilder>, typeArgs: ReadonlyArray<PType>, sourceLocation: SourceLocation): NodeBuilder {
    const elementType = this.arrayBuilder.ptype.elementType
    const {
      args: [...items],
    } = parseFunctionArgs({
      args,
      typeArgs,
      funcName: 'push',
      callLocation: sourceLocation,
      genericTypeArgs: 0,
      argSpec: (a) => [a.required(elementType), ...args.slice(1).map(() => a.required(elementType))],
    })

    return instanceEb(
      nodeFactory.arrayExtend({
        base: this.arrayBuilder.resolve(),
        other: nodeFactory.tupleExpression({
          items: items.map((i) => i.resolve()),
          sourceLocation,
        }),
        sourceLocation,
        wtype: wtypes.voidWType,
      }),
      voidPType,
    )
  }
}



================================================
FILE: src/awst_build/eb/shared/slice-function-builder.ts
================================================
import { nodeFactory } from '../../../awst/node-factory'
import type { Expression } from '../../../awst/nodes'
import type { SourceLocation } from '../../../awst/source-location'
import type { wtypes } from '../../../awst/wtypes'

import type { PType } from '../../ptypes'
import { numberPType, uint64PType } from '../../ptypes'
import { instanceEb } from '../../type-registry'
import type { NodeBuilder } from '../index'
import { FunctionBuilder } from '../index'
import { parseFunctionArgs } from '../util/arg-parsing'
import { getBigIntOrUint64Expr } from '../util/get-bigint-or-uint64-expr'

export class SliceFunctionBuilder extends FunctionBuilder {
  constructor(
    private base: Expression,
    private resultPType: PType & { wtype: wtypes.WType },
  ) {
    super(base.sourceLocation)
  }

  call(args: ReadonlyArray<NodeBuilder>, typeArgs: ReadonlyArray<PType>, sourceLocation: SourceLocation): NodeBuilder {
    const {
      args: [start, stop],
    } = parseFunctionArgs({
      args,
      typeArgs,
      genericTypeArgs: 0,
      callLocation: sourceLocation,
      funcName: 'slice',
      argSpec: (a) => [a.optional(uint64PType, numberPType), a.optional(uint64PType, numberPType)],
    })
    return instanceEb(
      nodeFactory.intersectionSliceExpression({
        base: this.base,
        sourceLocation: sourceLocation,
        beginIndex: start ? getBigIntOrUint64Expr(start) : null,
        endIndex: stop ? getBigIntOrUint64Expr(stop) : null,
        wtype: this.resultPType.wtype,
      }),
      this.resultPType,
    )
  }
}



================================================
FILE: src/awst_build/eb/storage/global-state.ts
================================================
import { nodeFactory } from '../../../awst/node-factory'
import type { AppStateExpression, Expression } from '../../../awst/nodes'
import { BytesConstant } from '../../../awst/nodes'
import type { SourceLocation } from '../../../awst/source-location'
import { wtypes } from '../../../awst/wtypes'
import { codeInvariant, invariant } from '../../../util'
import { AppStorageDeclaration } from '../../models/app-storage-declaration'
import type { ContractClassPType, PType } from '../../ptypes'
import { boolPType, bytesPType, GlobalStateType, stringPType } from '../../ptypes'
import { typeRegistry } from '../../type-registry'
import { BooleanExpressionBuilder } from '../boolean-expression-builder'
import type { NodeBuilder } from '../index'
import { FunctionBuilder, InstanceExpressionBuilder } from '../index'
import { parseFunctionArgs } from '../util/arg-parsing'
import { VoidExpressionBuilder } from '../void-expression-builder'
import { extractKey } from './util'

export class GlobalStateFunctionBuilder extends FunctionBuilder {
  constructor(sourceLocation: SourceLocation) {
    super(sourceLocation)
  }

  call(args: ReadonlyArray<NodeBuilder>, typeArgs: ReadonlyArray<PType>, sourceLocation: SourceLocation): NodeBuilder {
    const [contentPType] = typeArgs
    const {
      args: [{ initialValue, key }],
    } = parseFunctionArgs({
      args,
      typeArgs,
      genericTypeArgs: 1,
      argSpec: (a) => [
        a.obj({
          initialValue: a.optional(contentPType),
          key: a.optional(stringPType, bytesPType),
        }),
      ],
      funcName: this.typeDescription,
      callLocation: sourceLocation,
    })
    const ptype = new GlobalStateType({ content: contentPType })

    return new GlobalStateFunctionResultBuilder(extractKey(key, wtypes.stateKeyWType), ptype, {
      initialValue: initialValue?.resolve(),
      sourceLocation,
    })
  }
}

class GlobalStateDeleteFunctionBuilder extends FunctionBuilder {
  constructor(
    private key: AppStateExpression,
    sourceLocation: SourceLocation,
  ) {
    super(sourceLocation)
  }

  call(args: ReadonlyArray<NodeBuilder>, typeArgs: ReadonlyArray<PType>, sourceLocation: SourceLocation): NodeBuilder {
    parseFunctionArgs({
      args,
      typeArgs,
      genericTypeArgs: 0,
      callLocation: sourceLocation,
      funcName: 'GlobalState.delete',
      argSpec: () => [],
    })
    return new VoidExpressionBuilder(
      nodeFactory.stateDelete({
        field: this.key,
        sourceLocation,
        wtype: wtypes.voidWType,
      }),
    )
  }
}

export class GlobalStateExpressionBuilder extends InstanceExpressionBuilder<GlobalStateType> {
  constructor(expr: Expression, ptype: PType) {
    invariant(ptype instanceof GlobalStateType, 'ptype must be instance of GlobalStateType')
    super(expr, ptype)
  }

  memberAccess(name: string, sourceLocation: SourceLocation): NodeBuilder {
    switch (name) {
      case 'delete':
        return new GlobalStateDeleteFunctionBuilder(this.buildField(), sourceLocation)
      case 'value':
        return typeRegistry.getInstanceEb(this.buildField(), this.ptype.contentType)
      case 'hasValue':
        return new BooleanExpressionBuilder(
          nodeFactory.stateExists({
            field: this.buildField(),
            wtype: boolPType.wtype,
            sourceLocation,
          }),
        )
    }
    return super.memberAccess(name, sourceLocation)
  }

  protected buildField(): AppStateExpression {
    return nodeFactory.appStateExpression({
      key: this._expr,
      wtype: this.ptype.contentType.wtypeOrThrow,
      existsAssertionMessage: 'check GlobalState exists',
      sourceLocation: this.sourceLocation,
    })
  }
}

export class GlobalStateFunctionResultBuilder extends GlobalStateExpressionBuilder {
  resolve(): Expression {
    codeInvariant(
      this._keyExpr,
      'Global state must have explicit key provided if not being assigned to a contract property',
      this.sourceLocation,
    )
    codeInvariant(!this.initialValue, 'Global state can only have an initial value specified if being assigned to a contract property')
    return this._expr
  }
  public readonly initialValue: Expression | undefined

  private readonly _keyExpr: Expression | undefined

  constructor(expr: Expression | undefined, ptype: PType, config: { initialValue?: Expression; sourceLocation: SourceLocation }) {
    const sourceLocation = expr?.sourceLocation ?? config?.sourceLocation
    invariant(sourceLocation, 'Must have expression or config')
    super(expr ?? nodeFactory.voidConstant({ sourceLocation }), ptype)
    this.initialValue = config.initialValue
    this._keyExpr = expr
  }

  protected buildField(): AppStateExpression {
    codeInvariant(
      this._keyExpr,
      'Global state must have explicit key provided if not being assigned to a contract property',
      this.sourceLocation,
    )
    return super.buildField()
  }

  buildStorageDeclaration(
    memberName: string,
    memberLocation: SourceLocation,
    memberDescription: string | null,
    contractType: ContractClassPType,
  ): AppStorageDeclaration {
    if (this._keyExpr)
      codeInvariant(
        this._keyExpr instanceof BytesConstant,
        `key must be a compile time constant value if ${this.typeDescription} is assigned to a contract member`,
      )
    return new AppStorageDeclaration({
      sourceLocation: memberLocation,
      ptype: this.ptype,
      memberName: memberName,
      keyOverride: this._keyExpr ?? null,
      description: memberDescription,
      definedIn: contractType,
    })
  }
}



================================================
FILE: src/awst_build/eb/storage/local-state.ts
================================================
import { nodeFactory } from '../../../awst/node-factory'
import type { AppAccountStateExpression, AppStateExpression, Expression, LValue } from '../../../awst/nodes'
import { BytesConstant } from '../../../awst/nodes'
import type { SourceLocation } from '../../../awst/source-location'
import { wtypes } from '../../../awst/wtypes'
import { CodeError } from '../../../errors'
import { codeInvariant, invariant } from '../../../util'
import { AppStorageDeclaration } from '../../models/app-storage-declaration'

import type { ContractClassPType, PType } from '../../ptypes'
import { accountPType, boolPType, bytesPType, LocalStateType, stringPType } from '../../ptypes'
import { instanceEb } from '../../type-registry'
import { FunctionBuilder, InstanceBuilder, InstanceExpressionBuilder, NodeBuilder } from '../index'
import { parseFunctionArgs } from '../util/arg-parsing'
import { VoidExpressionBuilder } from '../void-expression-builder'
import { extractKey } from './util'

export class LocalStateFunctionBuilder extends FunctionBuilder {
  constructor(sourceLocation: SourceLocation) {
    super(sourceLocation)
  }

  call(args: ReadonlyArray<NodeBuilder>, typeArgs: ReadonlyArray<PType>, sourceLocation: SourceLocation): NodeBuilder {
    const [contentPType] = typeArgs
    const {
      args: [{ key }],
    } = parseFunctionArgs({
      args,
      typeArgs,
      genericTypeArgs: 1,
      argSpec: (a) => [
        a.obj({
          key: a.optional(stringPType, bytesPType),
        }),
      ],
      funcName: this.typeDescription,
      callLocation: sourceLocation,
    })
    const ptype = new LocalStateType({ content: contentPType })
    return new LocalStateFunctionResultBuilder(extractKey(key, wtypes.stateKeyWType), ptype, { sourceLocation })
  }
}

export class LocalStateExpressionBuilder extends InstanceExpressionBuilder<LocalStateType> {
  constructor(expr: Expression, ptype: PType) {
    invariant(ptype instanceof LocalStateType, 'ptype must be instance of LocalStateType')
    super(expr, ptype)
  }

  call(args: ReadonlyArray<NodeBuilder>, typeArgs: ReadonlyArray<PType>, sourceLocation: SourceLocation): NodeBuilder {
    const {
      args: [account],
    } = parseFunctionArgs({
      args,
      typeArgs,
      genericTypeArgs: 0,
      callLocation: sourceLocation,
      funcName: 'LocalState',
      argSpec: (a) => [a.required(accountPType)],
    })

    return new LocalStateForAccountExpressionBuilder(this.buildField(account.resolve(), sourceLocation), this.ptype.contentType)
  }

  private buildField(account: Expression, sourceLocation: SourceLocation): AppAccountStateExpression {
    return nodeFactory.appAccountStateExpression({
      key: this._expr,
      account,
      wtype: this.ptype.contentType.wtypeOrThrow,
      existsAssertionMessage: 'check LocalState exists',
      sourceLocation,
    })
  }
}

export class LocalStateForAccountExpressionBuilder extends NodeBuilder {
  ptype: undefined

  constructor(
    private key: AppAccountStateExpression,
    private contentType: PType,
  ) {
    super(key.sourceLocation)
  }

  memberAccess(name: string, sourceLocation: SourceLocation): NodeBuilder {
    switch (name) {
      case 'value':
        return instanceEb(
          nodeFactory.appAccountStateExpression({
            ...this.key,
            sourceLocation,
          }),
          this.contentType,
        )
      case 'hasValue':
        return instanceEb(
          nodeFactory.stateExists({
            field: this.key,
            sourceLocation,
            wtype: wtypes.boolWType,
          }),
          boolPType,
        )
      case 'delete':
        return new LocalStateDeleteFunctionBuilder(this.key, sourceLocation)
    }
    return super.memberAccess(name, sourceLocation)
  }
}

class LocalStateDeleteFunctionBuilder extends FunctionBuilder {
  constructor(
    private key: AppStateExpression,
    sourceLocation: SourceLocation,
  ) {
    super(sourceLocation)
  }

  call(args: ReadonlyArray<NodeBuilder>, typeArgs: ReadonlyArray<PType>, sourceLocation: SourceLocation): NodeBuilder {
    parseFunctionArgs({
      args,
      typeArgs,
      genericTypeArgs: 0,
      callLocation: sourceLocation,
      funcName: 'LocalState.delete',
      argSpec: () => [],
    })
    return new VoidExpressionBuilder(
      nodeFactory.stateDelete({
        field: this.key,
        sourceLocation,
        wtype: wtypes.voidWType,
      }),
    )
  }
}

export class LocalStateFunctionResultBuilder extends InstanceBuilder<LocalStateType> {
  resolve(): Expression {
    codeInvariant(
      this._expr,
      'Local state must have explicit key provided if not being assigned to a contract property',
      this.sourceLocation,
    )
    return this._expr
  }
  resolveLValue(): LValue {
    throw CodeError.invalidAssignmentTarget({ name: this.typeDescription, sourceLocation: this.sourceLocation })
  }

  private _expr: Expression | undefined
  constructor(expr: Expression | undefined, ptype: PType, config: { sourceLocation: SourceLocation }) {
    const sourceLocation = expr?.sourceLocation ?? config?.sourceLocation
    invariant(sourceLocation, 'Must have expression or config')
    super(sourceLocation)
    invariant(ptype instanceof LocalStateType, 'ptype must be LocalStateType')
    this._expr = expr
    this.ptype = ptype
  }
  readonly ptype: LocalStateType

  buildStorageDeclaration(
    memberName: string,
    memberLocation: SourceLocation,
    memberDescription: string | null,
    contractType: ContractClassPType,
  ): AppStorageDeclaration {
    if (this._expr)
      codeInvariant(
        this._expr instanceof BytesConstant,
        `key is must be a compile time constant value if ${this.typeDescription} is assigned to a contract member`,
      )
    return new AppStorageDeclaration({
      sourceLocation: memberLocation,
      ptype: this.ptype,
      memberName: memberName,
      keyOverride: this._expr ?? null,
      description: memberDescription,
      definedIn: contractType,
    })
  }
}



================================================
FILE: src/awst_build/eb/storage/util.ts
================================================
import { nodeFactory } from '../../../awst/node-factory'
import type { Expression } from '../../../awst/nodes'
import { BytesConstant } from '../../../awst/nodes'
import type { wtypes } from '../../../awst/wtypes'
import type { InstanceBuilder } from '../index'

export function extractKey(key: InstanceBuilder, keyWType: wtypes.WType): Expression
export function extractKey(key: InstanceBuilder | undefined, keyWType: wtypes.WType): Expression | undefined
export function extractKey(key: InstanceBuilder | undefined, keyWType: wtypes.WType): Expression | undefined {
  if (!key) return undefined

  const keyBytes = key.toBytes(key.sourceLocation)
  if (keyBytes instanceof BytesConstant) {
    return nodeFactory.bytesConstant({
      ...keyBytes,
      wtype: keyWType,
    })
  } else {
    return nodeFactory.reinterpretCast({
      expr: keyBytes,
      wtype: keyWType,
      sourceLocation: key.sourceLocation,
    })
  }
}



================================================
FILE: src/awst_build/eb/storage/value-proxy.ts
================================================
import type {
  AppAccountStateExpression,
  AppStateExpression,
  Expression,
  FieldExpression,
  IndexExpression,
  TupleExpression,
  VarExpression,
} from '../../../awst/nodes'
import type { SourceLocation } from '../../../awst/source-location'
import type { PType, PTypeOrClass } from '../../ptypes'
import { typeRegistry } from '../../type-registry'
import type { BuilderBinaryOp, BuilderComparisonOp, BuilderUnaryOp, InstanceBuilder, NodeBuilder } from '../index'
import { InstanceExpressionBuilder } from '../index'

export abstract class ValueProxy<TPType extends PType> extends InstanceExpressionBuilder<TPType> {
  private get proxied(): InstanceBuilder {
    return typeRegistry.getInstanceEb(this._expr, this.ptype)
  }

  resolve(): Expression {
    return this.proxied.resolve()
  }
  resolveLValue(): VarExpression | FieldExpression | IndexExpression | TupleExpression | AppStateExpression | AppAccountStateExpression {
    return this.proxied.resolveLValue()
  }
  memberAccess(name: string, sourceLocation: SourceLocation): NodeBuilder {
    return this.proxied.memberAccess(name, sourceLocation)
  }
  augmentedAssignment(other: InstanceBuilder, op: BuilderBinaryOp, sourceLocation: SourceLocation): InstanceBuilder {
    return this.proxied.augmentedAssignment(other, op, sourceLocation)
  }
  iterate(sourceLocation: SourceLocation): Expression {
    return this.proxied.iterate(sourceLocation)
  }
  indexAccess(index: InstanceBuilder, sourceLocation: SourceLocation): NodeBuilder {
    return this.proxied.indexAccess(index, sourceLocation)
  }
  boolEval(sourceLocation: SourceLocation, negate: boolean = false): Expression {
    return this.proxied.boolEval(sourceLocation, negate)
  }
  binaryOp(other: InstanceBuilder, op: BuilderBinaryOp, sourceLocation: SourceLocation): InstanceBuilder {
    return this.proxied.binaryOp(other, op, sourceLocation)
  }
  prefixUnaryOp(op: BuilderUnaryOp, sourceLocation: SourceLocation): InstanceBuilder {
    return this.proxied.prefixUnaryOp(op, sourceLocation)
  }
  postfixUnaryOp(op: BuilderUnaryOp, sourceLocation: SourceLocation): InstanceBuilder {
    return this.proxied.postfixUnaryOp(op, sourceLocation)
  }
  call(args: ReadonlyArray<NodeBuilder>, typeArgs: ReadonlyArray<PType>, sourceLocation: SourceLocation): NodeBuilder {
    return this.proxied.call(args, typeArgs, sourceLocation)
  }
  compare(other: InstanceBuilder, op: BuilderComparisonOp, sourceLocation: SourceLocation): InstanceBuilder {
    return this.proxied.compare(other, op, sourceLocation)
  }
  taggedTemplate(head: string, spans: ReadonlyArray<readonly [InstanceBuilder, string]>, sourceLocation: SourceLocation): InstanceBuilder {
    return this.proxied.taggedTemplate(head, spans, sourceLocation)
  }
  singleEvaluation(): InstanceBuilder {
    return this.proxied.singleEvaluation()
  }
  hasProperty(_name: string): boolean {
    return this.proxied.hasProperty(_name)
  }
  toBytes(sourceLocation: SourceLocation): Expression {
    return this.proxied.toBytes(sourceLocation)
  }
  resolvableToPType(ptype: PTypeOrClass): boolean {
    return this.proxied.resolvableToPType(ptype)
  }
  resolveToPType(ptype: PTypeOrClass): InstanceBuilder {
    return this.proxied.resolveToPType(ptype)
  }
}



================================================
FILE: src/awst_build/eb/storage/box/base.ts
================================================
import { nodeFactory } from '../../../../awst/node-factory'
import { type BoxValueExpression, BytesConstant, type Expression } from '../../../../awst/nodes'
import type { SourceLocation } from '../../../../awst/source-location'
import { wtypes } from '../../../../awst/wtypes'
import { codeInvariant } from '../../../../util'
import { AppStorageDeclaration } from '../../../models/app-storage-declaration'
import type { BoxPType, BoxRefPType } from '../../../ptypes'
import { boolPType, BoxMapPType, type ContractClassPType, type PType, uint64PType } from '../../../ptypes'
import { instanceEb } from '../../../type-registry'
import { InstanceExpressionBuilder } from '../../index'
import { ValueProxy } from '../value-proxy'

export abstract class BoxProxyExpressionBuilder<
  TProxyType extends BoxMapPType | BoxRefPType | BoxPType,
> extends InstanceExpressionBuilder<TProxyType> {
  buildStorageDeclaration(
    memberName: string,
    memberLocation: SourceLocation,
    memberDescription: string | null,
    contractType: ContractClassPType,
  ): AppStorageDeclaration {
    codeInvariant(
      this._expr instanceof BytesConstant,
      `key${this.ptype instanceof BoxMapPType ? ' prefix' : ''} must be a compile time constant value if ${this.typeDescription} is assigned to a contract member`,
    )
    return new AppStorageDeclaration({
      sourceLocation: memberLocation,
      ptype: this.ptype,
      memberName: memberName,
      keyOverride: this._expr ?? null,
      description: memberDescription,
      definedIn: contractType,
    })
  }

  toBytes(sourceLocation: SourceLocation): Expression {
    return nodeFactory.reinterpretCast({
      expr: this.resolve(),
      wtype: wtypes.bytesWType,
      sourceLocation,
    })
  }
}

/**
 * Wraps the box value expression and watches for certain expressions which can be optimized.
 *
 * For example box.value.bytes.slice(...) can be optimized to use box_extract directly rather
 * than reading the entire box into memory and then slicing it. All unhandled scenarios are proxied
 * through to the underlying builder for the given type.
 */
export class BoxValueExpressionBuilder extends ValueProxy<PType> {
  constructor(boxValue: BoxValueExpression, ptype: PType) {
    super(boxValue, ptype)
  }
}

export function boxValue({
  key,
  sourceLocation,
  contentType,
}: {
  key: Expression
  sourceLocation: SourceLocation
  contentType: PType
}): BoxValueExpression {
  return nodeFactory.boxValueExpression({
    key,
    sourceLocation,
    wtype: contentType.wtypeOrThrow,
    existsAssertionMessage: 'Box must have value',
  })
}

export function boxLength(box: BoxValueExpression, sourceLocation: SourceLocation) {
  return instanceEb(
    nodeFactory.checkedMaybe({
      expr: nodeFactory.intrinsicCall({
        opCode: 'box_len',
        stackArgs: [box.key],
        wtype: new wtypes.WTuple({ types: [wtypes.uint64WType, wtypes.boolWType], immutable: true }),
        immediates: [],
        sourceLocation,
      }),
      comment: box.existsAssertionMessage ?? 'Box exists',
    }),
    uint64PType,
  )
}

export function boxExists(box: BoxValueExpression, sourceLocation: SourceLocation) {
  return instanceEb(
    nodeFactory.stateExists({
      field: box,
      sourceLocation,
      wtype: wtypes.boolWType,
    }),

    boolPType,
  )
}



================================================
FILE: src/awst_build/eb/storage/box/box-map.ts
================================================
import { intrinsicFactory } from '../../../../awst/intrinsic-factory'
import type { Expression } from '../../../../awst/nodes'
import type { SourceLocation } from '../../../../awst/source-location'
import { wtypes } from '../../../../awst/wtypes'

import { invariant } from '../../../../util'
import type { PType } from '../../../ptypes'
import { BoxMapPType, BoxPType, bytesPType, stringPType } from '../../../ptypes'
import { instanceEb } from '../../../type-registry'
import { FunctionBuilder, type NodeBuilder } from '../../index'
import { parseFunctionArgs } from '../../util/arg-parsing'
import { extractKey } from '../util'
import { BoxProxyExpressionBuilder } from './base'
import { BoxExpressionBuilder } from './box'
import { checkBoxType } from './util'

export class BoxMapFunctionBuilder extends FunctionBuilder {
  call(args: ReadonlyArray<NodeBuilder>, typeArgs: ReadonlyArray<PType>, sourceLocation: SourceLocation): NodeBuilder {
    const {
      ptypes: [keySuffixType, contentPType],
      args: [{ keyPrefix }],
    } = parseFunctionArgs({
      args,
      typeArgs,
      funcName: `BoxMap`,
      callLocation: sourceLocation,
      genericTypeArgs: 2,
      argSpec: (a) => [a.obj({ keyPrefix: a.required(bytesPType, stringPType) })],
    })
    checkBoxType(contentPType, sourceLocation)

    const ptype = new BoxMapPType({ content: contentPType, keyType: keySuffixType })
    return new BoxMapExpressionBuilder(extractKey(keyPrefix, wtypes.boxKeyWType), ptype)
  }
}

export class BoxMapExpressionBuilder extends BoxProxyExpressionBuilder<BoxMapPType> {
  constructor(expr: Expression, ptype: PType) {
    invariant(ptype instanceof BoxMapPType, 'BoxMapExpressionBuilder must be constructed with ptype of BoxMapPType')
    super(expr, ptype)
  }
  call(args: ReadonlyArray<NodeBuilder>, typeArgs: ReadonlyArray<PType>, sourceLocation: SourceLocation): NodeBuilder {
    const {
      args: [key],
    } = parseFunctionArgs({
      args,
      typeArgs,
      genericTypeArgs: 0,
      callLocation: sourceLocation,
      argSpec: (a) => [a.required(this.ptype.keyType)],
      funcName: 'BoxMap',
    })

    return new BoxExpressionBuilder(
      intrinsicFactory.bytesConcat({
        left: this._expr,
        right: key.toBytes(sourceLocation),
        sourceLocation: this.sourceLocation,
      }),
      new BoxPType({
        content: this.ptype.contentType,
      }),
    )
  }

  memberAccess(name: string, sourceLocation: SourceLocation): NodeBuilder {
    switch (name) {
      case 'keyPrefix':
        return instanceEb(this.toBytes(sourceLocation), bytesPType)
    }
    return super.memberAccess(name, sourceLocation)
  }
}



================================================
FILE: src/awst_build/eb/storage/box/box-ref.ts
================================================
import { nodeFactory } from '../../../../awst/node-factory'
import type { BoxValueExpression, Expression } from '../../../../awst/nodes'
import type { SourceLocation } from '../../../../awst/source-location'
import { wtypes } from '../../../../awst/wtypes'

import { invariant } from '../../../../util'
import type { PType } from '../../../ptypes'
import { boolPType, BoxRefPType, boxRefType, bytesPType, stringPType, TuplePType, uint64PType, voidPType } from '../../../ptypes'
import { instanceEb } from '../../../type-registry'
import { FunctionBuilder, type NodeBuilder } from '../../index'
import { parseFunctionArgs } from '../../util/arg-parsing'
import { extractKey } from '../util'
import { boxExists, boxLength, BoxProxyExpressionBuilder, boxValue, BoxValueExpressionBuilder } from './base'

export class BoxRefFunctionBuilder extends FunctionBuilder {
  call(args: ReadonlyArray<NodeBuilder>, typeArgs: ReadonlyArray<PType>, sourceLocation: SourceLocation): NodeBuilder {
    const {
      args: [{ key }],
    } = parseFunctionArgs({
      args,
      typeArgs,
      funcName: `BoxRef`,
      callLocation: sourceLocation,
      genericTypeArgs: 0,
      argSpec: (a) => [a.obj({ key: a.required(bytesPType, stringPType) })],
    })

    return new BoxRefExpressionBuilder(extractKey(key, wtypes.boxKeyWType), boxRefType)
  }
}

export class BoxRefExpressionBuilder extends BoxProxyExpressionBuilder<BoxRefPType> {
  constructor(expr: Expression, ptype: PType) {
    invariant(ptype instanceof BoxRefPType, 'BoxRefExpressionBuilder must be constructed with ptype of BoxRefPType')
    super(expr, ptype)
  }

  memberAccess(name: string, sourceLocation: SourceLocation): NodeBuilder {
    const boxValueExpr = boxValue({
      key: this._expr,
      sourceLocation,
      contentType: this.ptype.contentType,
    })
    switch (name) {
      case 'key':
        return instanceEb(this.toBytes(sourceLocation), bytesPType)
      case 'get':
        return new BoxRefGetFunctionBuilder(boxValueExpr)
      case 'delete':
        return new BoxRefDeleteFunctionBuilder(boxValueExpr)
      case 'put':
        return new BoxRefPutFunctionBuilder(boxValueExpr)
      case 'splice':
        return new BoxRefSpliceFunctionBuilder(boxValueExpr)
      case 'create':
        return new BoxRefCreateFunctionBuilder(boxValueExpr)
      case 'resize':
        return new BoxRefResizeFunctionBuilder(boxValueExpr)
      case 'extract':
        return new BoxRefExtractFunctionBuilder(boxValueExpr)
      case 'replace':
        return new BoxRefReplaceFunctionBuilder(boxValueExpr)
      case 'exists':
        return boxExists(boxValueExpr, sourceLocation)
      case 'maybe':
        return new BoxRefMaybeFunctionBuilder(boxValueExpr)
      case 'length':
        return boxLength(boxValueExpr, sourceLocation)
      case 'value':
        return new BoxValueExpressionBuilder(boxValueExpr, this.ptype.contentType)
    }
    return super.memberAccess(name, sourceLocation)
  }
}

abstract class BoxRefBaseFunctionBuilder extends FunctionBuilder {
  constructor(protected readonly boxValue: BoxValueExpression) {
    super(boxValue.sourceLocation)
  }
}

class BoxRefCreateFunctionBuilder extends BoxRefBaseFunctionBuilder {
  call(args: ReadonlyArray<NodeBuilder>, typeArgs: ReadonlyArray<PType>, sourceLocation: SourceLocation): NodeBuilder {
    const {
      args: [{ size }],
    } = parseFunctionArgs({
      args,
      typeArgs,
      genericTypeArgs: 0,
      funcName: 'BoxRef.create',
      callLocation: sourceLocation,
      argSpec: (a) => [a.obj({ size: a.required(uint64PType) })],
    })
    return instanceEb(
      nodeFactory.intrinsicCall({
        opCode: 'box_create',
        stackArgs: [this.boxValue.key, size.resolve()],
        wtype: wtypes.boolWType,
        immediates: [],
        sourceLocation,
      }),
      boolPType,
    )
  }
}
class BoxRefResizeFunctionBuilder extends BoxRefBaseFunctionBuilder {
  call(args: ReadonlyArray<NodeBuilder>, typeArgs: ReadonlyArray<PType>, sourceLocation: SourceLocation): NodeBuilder {
    const {
      args: [size],
    } = parseFunctionArgs({
      args,
      typeArgs,
      genericTypeArgs: 0,
      funcName: 'BoxRef.resize',
      callLocation: sourceLocation,
      argSpec: (a) => [a.required(uint64PType)],
    })
    return instanceEb(
      nodeFactory.intrinsicCall({
        opCode: 'box_resize',
        stackArgs: [this.boxValue.key, size.resolve()],
        wtype: wtypes.voidWType,
        immediates: [],
        sourceLocation,
      }),
      voidPType,
    )
  }
}
class BoxRefExtractFunctionBuilder extends BoxRefBaseFunctionBuilder {
  call(args: ReadonlyArray<NodeBuilder>, typeArgs: ReadonlyArray<PType>, sourceLocation: SourceLocation): NodeBuilder {
    const {
      args: [start, length],
    } = parseFunctionArgs({
      args,
      typeArgs,
      genericTypeArgs: 0,
      funcName: 'BoxRef.extract',
      callLocation: sourceLocation,
      argSpec: (a) => [a.required(uint64PType), a.required(uint64PType)],
    })
    return instanceEb(
      nodeFactory.intrinsicCall({
        opCode: 'box_extract',
        stackArgs: [this.boxValue.key, start.resolve(), length.resolve()],
        wtype: wtypes.bytesWType,
        immediates: [],
        sourceLocation,
      }),
      bytesPType,
    )
  }
}
class BoxRefReplaceFunctionBuilder extends BoxRefBaseFunctionBuilder {
  call(args: ReadonlyArray<NodeBuilder>, typeArgs: ReadonlyArray<PType>, sourceLocation: SourceLocation): NodeBuilder {
    const {
      args: [start, value],
    } = parseFunctionArgs({
      args,
      typeArgs,
      genericTypeArgs: 0,
      funcName: 'BoxRef.replace',
      callLocation: sourceLocation,
      argSpec: (a) => [a.required(uint64PType), a.required(bytesPType)],
    })
    return instanceEb(
      nodeFactory.intrinsicCall({
        opCode: 'box_replace',
        stackArgs: [this.boxValue.key, start.resolve(), value.resolve()],
        wtype: wtypes.voidWType,
        immediates: [],
        sourceLocation,
      }),
      voidPType,
    )
  }
}
class BoxRefGetFunctionBuilder extends BoxRefBaseFunctionBuilder {
  call(args: ReadonlyArray<NodeBuilder>, typeArgs: ReadonlyArray<PType>, sourceLocation: SourceLocation): NodeBuilder {
    const {
      args: [{ default: defaultValue }],
    } = parseFunctionArgs({
      args,
      typeArgs,
      funcName: 'BoxRef.get',
      callLocation: sourceLocation,
      genericTypeArgs: 0,
      argSpec: (a) => [a.obj({ default: a.optional(bytesPType) })],
    })

    if (defaultValue) {
      return instanceEb(
        nodeFactory.stateGet({
          sourceLocation,
          default: defaultValue.resolve(),
          wtype: wtypes.bytesWType,
          field: this.boxValue,
        }),
        bytesPType,
      )
    } else {
      return new BoxValueExpressionBuilder(this.boxValue, bytesPType)
    }
  }
}

class BoxRefPutFunctionBuilder extends BoxRefBaseFunctionBuilder {
  call(args: ReadonlyArray<NodeBuilder>, typeArgs: ReadonlyArray<PType>, sourceLocation: SourceLocation): NodeBuilder {
    const {
      args: [value],
    } = parseFunctionArgs({
      args,
      typeArgs,
      genericTypeArgs: 0,
      funcName: 'BoxRef.put',
      callLocation: sourceLocation,
      argSpec: (a) => [a.required(bytesPType)],
    })
    return instanceEb(
      nodeFactory.intrinsicCall({
        opCode: 'box_put',
        stackArgs: [this.boxValue.key, value.resolve()],
        wtype: wtypes.voidWType,
        immediates: [],
        sourceLocation,
      }),
      voidPType,
    )
  }
}
class BoxRefSpliceFunctionBuilder extends BoxRefBaseFunctionBuilder {
  call(args: ReadonlyArray<NodeBuilder>, typeArgs: ReadonlyArray<PType>, sourceLocation: SourceLocation): NodeBuilder {
    const {
      args: [start, stop, value],
    } = parseFunctionArgs({
      args,
      typeArgs,
      genericTypeArgs: 0,
      funcName: 'BoxRef.splice',
      callLocation: sourceLocation,
      argSpec: (a) => [a.required(uint64PType), a.required(uint64PType), a.required(bytesPType)],
    })
    return instanceEb(
      nodeFactory.intrinsicCall({
        opCode: 'box_splice',
        stackArgs: [this.boxValue.key, start.resolve(), stop.resolve(), value.resolve()],
        wtype: wtypes.voidWType,
        immediates: [],
        sourceLocation,
      }),
      voidPType,
    )
  }
}

class BoxRefMaybeFunctionBuilder extends BoxRefBaseFunctionBuilder {
  call(args: ReadonlyArray<NodeBuilder>, typeArgs: ReadonlyArray<PType>, sourceLocation: SourceLocation): NodeBuilder {
    parseFunctionArgs({
      args,
      typeArgs,
      funcName: 'BoxRef.maybe',
      callLocation: sourceLocation,
      genericTypeArgs: 0,
      argSpec: () => [],
    })
    const type = new TuplePType({ items: [bytesPType, boolPType] })

    return instanceEb(
      nodeFactory.stateGetEx({
        sourceLocation,
        wtype: type.wtype,
        field: this.boxValue,
      }),
      type,
    )
  }
}

class BoxRefDeleteFunctionBuilder extends BoxRefBaseFunctionBuilder {
  call(args: ReadonlyArray<NodeBuilder>, typeArgs: ReadonlyArray<PType>, sourceLocation: SourceLocation): NodeBuilder {
    parseFunctionArgs({
      args,
      typeArgs,
      funcName: 'BoxRef.delete',
      callLocation: sourceLocation,
      genericTypeArgs: 0,
      argSpec: () => [],
    })

    return instanceEb(
      nodeFactory.stateDelete({
        field: this.boxValue,
        sourceLocation,
        wtype: wtypes.boolWType,
      }),
      boolPType,
    )
  }
}



================================================
FILE: src/awst_build/eb/storage/box/box.ts
================================================
import { nodeFactory } from '../../../../awst/node-factory'
import type { BoxValueExpression, Expression } from '../../../../awst/nodes'
import type { SourceLocation } from '../../../../awst/source-location'
import { wtypes } from '../../../../awst/wtypes'
import { logger } from '../../../../logger'
import { invariant } from '../../../../util'
import type { PType } from '../../../ptypes'
import { boolPType, BoxPType, bytesPType, stringPType, TuplePType, uint64PType } from '../../../ptypes'
import { instanceEb } from '../../../type-registry'
import { FunctionBuilder, type NodeBuilder, ParameterlessFunctionBuilder } from '../../index'
import { parseFunctionArgs } from '../../util/arg-parsing'
import { extractKey } from '../util'
import { boxExists, boxLength, BoxProxyExpressionBuilder, boxValue, BoxValueExpressionBuilder } from './base'
import { checkBoxType, getBoxSize } from './util'

export class BoxFunctionBuilder extends FunctionBuilder {
  call(args: ReadonlyArray<NodeBuilder>, typeArgs: ReadonlyArray<PType>, sourceLocation: SourceLocation): NodeBuilder {
    const {
      ptypes: [contentPType],
      args: [{ key }],
    } = parseFunctionArgs({
      args,
      typeArgs,
      funcName: `Box`,
      callLocation: sourceLocation,
      genericTypeArgs: 1,
      argSpec: (a) => [a.obj({ key: a.required(bytesPType, stringPType) })],
    })
    checkBoxType(contentPType, sourceLocation)

    const ptype = new BoxPType({ content: contentPType })
    return new BoxExpressionBuilder(extractKey(key, wtypes.boxKeyWType), ptype)
  }
}

export class BoxExpressionBuilder extends BoxProxyExpressionBuilder<BoxPType> {
  constructor(expr: Expression, ptype: PType) {
    invariant(ptype instanceof BoxPType, 'BoxExpressionBuilder must be constructed with ptype of BoxPType')
    super(expr, ptype)
  }

  memberAccess(name: string, sourceLocation: SourceLocation): NodeBuilder {
    const boxValueExpr = boxValue({
      key: this._expr,
      sourceLocation,
      contentType: this.ptype.contentType,
    })
    switch (name) {
      case 'create':
        return new BoxCreateFunctionBuilder(boxValueExpr, this.ptype.contentType, sourceLocation)
      case 'key':
        return instanceEb(this.toBytes(sourceLocation), bytesPType)
      case 'value':
        return new BoxValueExpressionBuilder(boxValueExpr, this.ptype.contentType)
      case 'exists':
        return boxExists(boxValueExpr, sourceLocation)
      case 'length':
        return boxLength(boxValueExpr, sourceLocation)
      case 'delete':
        return new BoxDeleteFunctionBuilder(boxValueExpr, sourceLocation)
      case 'get':
        return new BoxGetFunctionBuilder(boxValueExpr, this.ptype.contentType, sourceLocation)
      case 'maybe':
        return new BoxMaybeFunctionBuilder(boxValueExpr, this.ptype.contentType, sourceLocation)
    }
    return super.memberAccess(name, sourceLocation)
  }
}

class BoxCreateFunctionBuilder extends FunctionBuilder {
  constructor(
    private boxValue: BoxValueExpression,
    private contentType: PType,
    sourceLocation: SourceLocation,
  ) {
    super(sourceLocation)
  }

  call(args: ReadonlyArray<NodeBuilder>, typeArgs: ReadonlyArray<PType>, sourceLocation: SourceLocation): NodeBuilder {
    const {
      args: [{ size }],
    } = parseFunctionArgs({
      args,
      typeArgs,
      genericTypeArgs: 0,
      callLocation: sourceLocation,
      funcName: 'Box.create',
      argSpec: (a) => [a.obj({ size: a.optional(uint64PType) })],
    })
    if (size) {
      return instanceEb(
        nodeFactory.intrinsicCall({
          opCode: 'box_create',
          stackArgs: [this.boxValue.key, size.resolve()],
          wtype: wtypes.boolWType,
          immediates: [],
          sourceLocation,
        }),
        boolPType,
      )
    }
    const boxSize = getBoxSize(this.contentType)
    if (boxSize === null) {
      logger.error(sourceLocation, `${this.contentType} does not have a fixed byte size. Please specify a size argument.`)
    }
    return instanceEb(
      nodeFactory.intrinsicCall({
        opCode: 'box_create',
        stackArgs: [this.boxValue.key, nodeFactory.uInt64Constant({ value: boxSize ?? 0n, sourceLocation })],
        wtype: wtypes.boolWType,
        immediates: [],
        sourceLocation,
      }),
      boolPType,
    )
  }
}

class BoxDeleteFunctionBuilder extends ParameterlessFunctionBuilder {
  constructor(boxValue: BoxValueExpression, sourceLocation: SourceLocation) {
    super(boxValue, (expr) =>
      instanceEb(
        nodeFactory.stateDelete({
          sourceLocation,
          field: boxValue,
          wtype: wtypes.boolWType,
        }),
        boolPType,
      ),
    )
  }
}

class BoxGetFunctionBuilder extends FunctionBuilder {
  constructor(
    private readonly boxValue: BoxValueExpression,
    private readonly contentType: PType,
    sourceLocation: SourceLocation,
  ) {
    super(sourceLocation)
  }

  call(args: ReadonlyArray<NodeBuilder>, typeArgs: ReadonlyArray<PType>, sourceLocation: SourceLocation): NodeBuilder {
    const {
      args: [{ default: defaultValue }],
    } = parseFunctionArgs({
      args,
      typeArgs,
      funcName: 'Box.get',
      callLocation: sourceLocation,
      genericTypeArgs: 0,
      argSpec: (a) => [a.obj({ default: a.optional(this.contentType) })],
    })

    if (defaultValue) {
      return instanceEb(
        nodeFactory.stateGet({
          sourceLocation,
          default: defaultValue.resolve(),
          wtype: this.contentType.wtypeOrThrow,
          field: this.boxValue,
        }),
        this.contentType,
      )
    } else {
      return new BoxValueExpressionBuilder(this.boxValue, this.contentType)
    }
  }
}
class BoxMaybeFunctionBuilder extends FunctionBuilder {
  constructor(
    private readonly boxValue: BoxValueExpression,
    private readonly contentType: PType,
    sourceLocation: SourceLocation,
  ) {
    super(sourceLocation)
  }

  call(args: ReadonlyArray<NodeBuilder>, typeArgs: ReadonlyArray<PType>, sourceLocation: SourceLocation): NodeBuilder {
    parseFunctionArgs({
      args,
      typeArgs,
      funcName: 'Box.maybe',
      callLocation: sourceLocation,
      genericTypeArgs: 0,
      argSpec: () => [],
    })
    const type = new TuplePType({ items: [this.contentType, boolPType] })

    return instanceEb(
      nodeFactory.stateGetEx({
        sourceLocation,
        wtype: type.wtype,
        field: this.boxValue,
      }),
      type,
    )
  }
}



================================================
FILE: src/awst_build/eb/storage/box/index.ts
================================================
export { BoxFunctionBuilder, BoxExpressionBuilder } from './box'
export { BoxMapFunctionBuilder, BoxMapExpressionBuilder } from './box-map'
export { BoxRefFunctionBuilder, BoxRefExpressionBuilder } from './box-ref'
export { BoxProxyExpressionBuilder } from './base'



================================================
FILE: src/awst_build/eb/storage/box/util.ts
================================================
import type { SourceLocation } from '../../../../awst/source-location'
import { AVMType } from '../../../../awst/wtypes'
import { logger } from '../../../../logger'
import type { PType } from '../../../ptypes'
import { accountPType } from '../../../ptypes'
import { ARC4EncodedType } from '../../../ptypes/arc4-types'

/**
 * Verifies contentType is able to be stored in a box.
 * @param contentType The content type of the box
 * @param sourceLocation The source location of the box proxy declaration
 */
export function checkBoxType(contentType: PType, sourceLocation: SourceLocation) {
  if (contentType instanceof ARC4EncodedType) {
    return
  } else if (contentType.wtype && contentType.wtype.scalarType !== null) {
    return
  } else {
    logger.error(sourceLocation, `Objects of type ${contentType} cannot be stored in a box`)
  }
}

/**
 * Returns the fixed size requirement for a box of a given ptype or null if the contentType is dynamically sized.
 * @param contentType The content type of the box
 */
export function getBoxSize(contentType: PType): bigint | null {
  if (contentType instanceof ARC4EncodedType) {
    return contentType.fixedByteSize
  } else if (contentType.wtype?.scalarType === AVMType.uint64) {
    return 8n
  } else if (contentType.equals(accountPType)) {
    return 32n
  } else {
    return null
  }
}



================================================
FILE: src/awst_build/eb/traits/static-iterator.ts
================================================
import type { InstanceBuilder, NodeBuilder } from '../index'

export const StaticIterator = Symbol('StaticIterator')

export interface StaticallyIterable {
  [StaticIterator](): InstanceBuilder[]
}

export function isStaticallyIterable<T extends NodeBuilder>(builder: T): builder is T & StaticallyIterable {
  return StaticIterator in builder
}



================================================
FILE: src/awst_build/eb/transactions/group-transactions.ts
================================================
import { nodeFactory } from '../../../awst/node-factory'
import type { Expression } from '../../../awst/nodes'
import { IntegerConstant } from '../../../awst/nodes'
import type { SourceLocation } from '../../../awst/source-location'
import type { TxnFieldData } from '../../../awst/txn-fields'
import { TxnFields } from '../../../awst/txn-fields'
import { Constants } from '../../../constants'
import { logger } from '../../../logger'
import { invariant } from '../../../util'
import type { PType } from '../../ptypes'
import { GroupTransactionPType, TransactionFunctionType, uint64PType } from '../../ptypes'
import { anyTxnFields, txnKindToFields } from '../../txn-fields'
import { instanceEb } from '../../type-registry'
import type { NodeBuilder } from '../index'
import { FunctionBuilder, InstanceExpressionBuilder } from '../index'
import { parseFunctionArgs } from '../util/arg-parsing'
import { getGroupTransactionType } from './util'

export class GroupTransactionExpressionBuilder extends InstanceExpressionBuilder<GroupTransactionPType> {
  constructor(expr: Expression, ptype: PType) {
    invariant(ptype instanceof GroupTransactionPType, 'ptype must be GroupTransactionPType')
    super(expr, ptype)
  }

  hasProperty(name: string): boolean {
    const txnKind = this.ptype.kind
    const fields = txnKind === undefined ? anyTxnFields : txnKindToFields[txnKind]
    return name in fields
  }

  memberAccess(name: string, sourceLocation: SourceLocation): NodeBuilder {
    const txnKind = this.ptype.kind
    const fields = txnKind === undefined ? anyTxnFields : txnKindToFields[txnKind]
    if (name in fields) {
      const { field, ptype: returnType } = fields[name as keyof typeof fields]
      const data = TxnFields[field]

      if (data.numValues === 1) {
        return instanceEb(
          nodeFactory.intrinsicCall({
            sourceLocation,
            stackArgs: [this._expr],
            immediates: [data.immediate],
            wtype: data.wtype,
            opCode: 'gtxns',
          }),
          returnType,
        )
      } else {
        return new IndexedTransactionFieldFunctionBuilder(this._expr, {
          txnData: data,
          returnType,
          memberName: name,
        })
      }
    }
    return super.memberAccess(name, sourceLocation)
  }
}

export class GroupTransactionFunctionBuilder extends FunctionBuilder {
  readonly ptype: TransactionFunctionType

  constructor(sourceLocation: SourceLocation, ptype: PType) {
    super(sourceLocation)
    invariant(ptype instanceof TransactionFunctionType, 'ptype must be instance of TransactionFunctionType')
    this.ptype = ptype
  }

  call(args: ReadonlyArray<NodeBuilder>, typeArgs: ReadonlyArray<PType>, sourceLocation: SourceLocation): NodeBuilder {
    const {
      args: [groupIndexBuilder],
    } = parseFunctionArgs({
      args,
      typeArgs,
      genericTypeArgs: 0,
      callLocation: sourceLocation,
      funcName: this.ptype.name,
      argSpec: (a) => [a.required(uint64PType)],
    })
    const txnPType = getGroupTransactionType(this.ptype.kind)
    const groupIndex = groupIndexBuilder.resolve()
    if (groupIndex instanceof IntegerConstant && groupIndex.value >= Constants.algo.maxTransactionGroupSize) {
      logger.error(groupIndex.sourceLocation, `transaction group index should be less than ${Constants.algo.maxTransactionGroupSize}`)
    }

    return new GroupTransactionExpressionBuilder(
      nodeFactory.groupTransactionReference({
        index: groupIndex,
        wtype: txnPType.wtype,
        sourceLocation,
      }),
      txnPType,
    )
  }
}

class IndexedTransactionFieldFunctionBuilder extends FunctionBuilder {
  constructor(
    private gtxn: Expression,
    private config: { txnData: TxnFieldData; returnType: PType; memberName: string },
  ) {
    super(gtxn.sourceLocation)
  }

  call(args: ReadonlyArray<NodeBuilder>, typeArgs: ReadonlyArray<PType>, sourceLocation: SourceLocation): NodeBuilder {
    const {
      args: [index],
    } = parseFunctionArgs({
      args,
      typeArgs,
      genericTypeArgs: 0,
      callLocation: sourceLocation,
      funcName: this.config.memberName,
      argSpec: (a) => [a.required(uint64PType)],
    })

    return instanceEb(
      nodeFactory.intrinsicCall({
        sourceLocation,
        stackArgs: [this.gtxn, index.resolve()],
        immediates: [this.config.txnData.immediate],
        wtype: this.config.txnData.wtype,
        opCode: 'gtxnsas',
      }),
      this.config.returnType,
    )
  }
}



================================================
FILE: src/awst_build/eb/transactions/inner-transaction-params.ts
================================================
import type { TransactionKind } from '../../../awst/models'
import { nodeFactory } from '../../../awst/node-factory'
import type { Expression } from '../../../awst/nodes'
import type { SourceLocation } from '../../../awst/source-location'
import { TxnField, TxnFields } from '../../../awst/txn-fields'
import { logger } from '../../../logger'
import { codeInvariant, invariant } from '../../../util'
import type { PType } from '../../ptypes'
import { ItxnParamsPType, ObjectPType, submitGroupItxnFunction, TransactionFunctionType, TuplePType } from '../../ptypes'
import type { TxnFieldsMetaData } from '../../txn-fields'
import { anyTxnFields, txnKindToFields } from '../../txn-fields'
import { instanceEb } from '../../type-registry'
import type { InstanceBuilder, NodeBuilder } from '../index'
import { FunctionBuilder, InstanceExpressionBuilder } from '../index'
import { isStaticallyIterable, StaticIterator } from '../traits/static-iterator'
import { parseFunctionArgs } from '../util/arg-parsing'
import { resolveCompatExpression } from '../util/resolve-compat-builder'
import { InnerTransactionExpressionBuilder } from './inner-transactions'
import { getInnerTransactionType, getItxnParamsType } from './util'

export class ItxnParamsFactoryFunctionBuilder extends FunctionBuilder {
  readonly ptype: TransactionFunctionType

  constructor(sourceLocation: SourceLocation, ptype: PType) {
    super(sourceLocation)
    invariant(ptype instanceof TransactionFunctionType, 'ptype must be TransactionFunctionType')
    this.ptype = ptype
  }

  call(args: ReadonlyArray<NodeBuilder>, typeArgs: ReadonlyArray<PType>, sourceLocation: SourceLocation): NodeBuilder {
    const {
      args: [initialFields],
    } = parseFunctionArgs({
      args,
      typeArgs,
      callLocation: sourceLocation,
      genericTypeArgs: 0,
      funcName: this.ptype.name,
      argSpec: (a) => [a.required()],
    })
    const mappedFields = new Map<TxnField, Expression>()
    // Set default fee to 0 (transaction will be paid for from transaction group budget, rather than from the application balance)
    mappedFields.set(TxnField.Fee, nodeFactory.uInt64Constant({ value: 0n, sourceLocation }))
    if (this.ptype.kind) mappedFields.set(TxnField.TypeEnum, nodeFactory.uInt64Constant({ value: BigInt(this.ptype.kind), sourceLocation }))
    mapTransactionFields(mappedFields, initialFields, this.ptype.kind, sourceLocation)
    invariant(this.ptype.kind !== undefined, 'Cannot have untyped itxn params factory', sourceLocation)
    const fieldsType = getItxnParamsType(this.ptype.kind)

    return new ItxnParamsExpressionBuilder(
      nodeFactory.createInnerTransaction({
        fields: mappedFields,
        sourceLocation,
        wtype: fieldsType.wtype,
      }),
      fieldsType,
    )
  }
}

export function mapTransactionFields(
  mappedFields: Map<TxnField, Expression>,
  fields: InstanceBuilder,
  kind: TransactionKind | undefined,
  sourceLocation: SourceLocation,
  ignoreProps?: Set<string>,
) {
  codeInvariant(fields.ptype instanceof ObjectPType, 'fields argument must be an object type')
  const validFields: TxnFieldsMetaData = kind !== undefined ? txnKindToFields[kind] : anyTxnFields
  for (const [prop] of fields.ptype.orderedProperties()) {
    if (ignoreProps?.has(prop)) continue
    if (prop in validFields) {
      const { field: txnField, ptype: fieldType } = validFields[prop as keyof typeof validFields]
      const txnFieldData = TxnFields[txnField]
      const propValue = fields.memberAccess(prop, sourceLocation)
      if (txnField === TxnField.ApplicationArgs) {
        codeInvariant(isStaticallyIterable(propValue), 'Unsupported expression for appArgs', propValue.sourceLocation)
        mappedFields.set(
          txnField,
          nodeFactory.tupleExpression({
            items: propValue[StaticIterator]().map((i) => i.toBytes(propValue.sourceLocation)),
            sourceLocation: propValue.sourceLocation,
          }),
        )
      } else if (txnFieldData.numValues > 1) {
        if (isStaticallyIterable(propValue)) {
          mappedFields.set(
            txnField,
            nodeFactory.tupleExpression({
              items: propValue[StaticIterator]().map((i) => resolveCompatExpression(i, fieldType)),
              sourceLocation: propValue.sourceLocation,
            }),
          )
        } else if (txnFieldData.arrayPromote) {
          mappedFields.set(
            txnField,
            nodeFactory.tupleExpression({
              items: [resolveCompatExpression(propValue, fieldType)],
              sourceLocation: propValue.sourceLocation,
            }),
          )
        } else {
          logger.error(propValue.sourceLocation, `Unsupported expression for ${prop}`)
        }
      } else {
        mappedFields.set(txnField, resolveCompatExpression(propValue, fieldType))
      }
    } else {
      logger.warn(sourceLocation, `Ignoring additional property: ${prop}`)
    }
  }
}

abstract class InnerTxnFieldsMethodBuilder extends FunctionBuilder {
  constructor(
    protected builder: ItxnParamsExpressionBuilder,
    sourceLocation: SourceLocation,
  ) {
    super(sourceLocation)
  }
}

class SubmitInnerTxnMethodBuilder extends InnerTxnFieldsMethodBuilder {
  call(args: ReadonlyArray<NodeBuilder>, typeArgs: ReadonlyArray<PType>, sourceLocation: SourceLocation): NodeBuilder {
    parseFunctionArgs({
      args,
      typeArgs,
      callLocation: sourceLocation,
      genericTypeArgs: 0,
      funcName: 'submit',
      argSpec: () => [],
    })
    invariant(this.builder.ptype.kind !== undefined, 'Cannot have untyped itxn params type', sourceLocation)

    const transactionPType = getInnerTransactionType(this.builder.ptype.kind)
    return new InnerTransactionExpressionBuilder(
      nodeFactory.submitInnerTransaction({
        itxns: [this.builder.resolve()],
        sourceLocation,
      }),
      transactionPType,
    )
  }
}

export class SubmitItxnGroupFunctionBuilder extends FunctionBuilder {
  ptype = submitGroupItxnFunction

  call(args: ReadonlyArray<NodeBuilder>, typeArgs: ReadonlyArray<PType>, sourceLocation: SourceLocation): NodeBuilder {
    const { args: itxnParams } = parseFunctionArgs({
      args,
      typeArgs,
      genericTypeArgs: 1,
      callLocation: sourceLocation,
      funcName: this.typeDescription,
      argSpec: (a) => [a.required(ItxnParamsPType), ...args.slice(1).map((_) => a.required(ItxnParamsPType))],
    })
    const resultType = new TuplePType({
      items: itxnParams.map((p, i) => {
        codeInvariant(p.ptype instanceof ItxnParamsPType, `Argument ${i} must be an itxn params type`, p.sourceLocation)
        invariant(p.ptype.kind !== undefined, 'Cannot have untyped itxn params type', sourceLocation)

        return getInnerTransactionType(p.ptype.kind)
      }),
    })

    return instanceEb(
      nodeFactory.submitInnerTransaction({
        itxns: itxnParams.map((p) => p.resolve()),
        sourceLocation,
      }),
      resultType,
    )
  }
}

class SetInnerTxnMethodBuilder extends InnerTxnFieldsMethodBuilder {
  call(args: ReadonlyArray<NodeBuilder>, typeArgs: ReadonlyArray<PType>, sourceLocation: SourceLocation): NodeBuilder {
    const {
      args: [updatedFields],
    } = parseFunctionArgs({
      args,
      typeArgs,
      callLocation: sourceLocation,
      genericTypeArgs: 0,
      funcName: 'set',
      argSpec: (a) => [a.required()],
    })

    const mappedFields = new Map<TxnField, Expression>()
    const fieldsType = this.builder.ptype

    mapTransactionFields(mappedFields, updatedFields, fieldsType.kind, sourceLocation)

    return new ItxnParamsExpressionBuilder(
      nodeFactory.updateInnerTransaction({
        itxn: this.builder.resolve(),
        fields: mappedFields,
        sourceLocation,
        wtype: fieldsType.wtype,
      }),
      fieldsType,
    )
  }
}
class CopyInnerTxnMethodBuilder extends InnerTxnFieldsMethodBuilder {
  call(args: ReadonlyArray<NodeBuilder>, typeArgs: ReadonlyArray<PType>, sourceLocation: SourceLocation): NodeBuilder {
    parseFunctionArgs({
      args,
      typeArgs,
      callLocation: sourceLocation,
      genericTypeArgs: 0,
      funcName: 'copy',
      argSpec: () => [],
    })

    return new ItxnParamsExpressionBuilder(
      nodeFactory.copy({
        value: this.builder.resolve(),
        sourceLocation,
      }),
      this.builder.ptype,
    )
  }
}

export class ItxnParamsExpressionBuilder extends InstanceExpressionBuilder<ItxnParamsPType> {
  constructor(expr: Expression, ptype: PType) {
    invariant(ptype instanceof ItxnParamsPType, 'ptype must be InnerTransactionFieldsPType')
    super(expr, ptype)
  }

  memberAccess(name: string, sourceLocation: SourceLocation): NodeBuilder {
    switch (name) {
      case 'submit':
        return new SubmitInnerTxnMethodBuilder(this, sourceLocation)
      case 'set':
        return new SetInnerTxnMethodBuilder(this, sourceLocation)
      case 'copy':
        return new CopyInnerTxnMethodBuilder(this, sourceLocation)
    }
    return super.memberAccess(name, sourceLocation)
  }
}



================================================
FILE: src/awst_build/eb/transactions/inner-transactions.ts
================================================
import { nodeFactory } from '../../../awst/node-factory'
import type { Expression } from '../../../awst/nodes'
import type { SourceLocation } from '../../../awst/source-location'
import { type TxnField, type TxnFieldData, TxnFields } from '../../../awst/txn-fields'
import { invariant } from '../../../util'
import type { PType } from '../../ptypes'
import { InnerTransactionPType, uint64PType } from '../../ptypes'
import { anyTxnFields, txnKindToFields } from '../../txn-fields'
import { instanceEb } from '../../type-registry'
import type { NodeBuilder } from '../index'
import { FunctionBuilder, InstanceExpressionBuilder } from '../index'
import { parseFunctionArgs } from '../util/arg-parsing'

export class InnerTransactionExpressionBuilder extends InstanceExpressionBuilder<InnerTransactionPType> {
  constructor(expr: Expression, ptype: PType) {
    invariant(ptype instanceof InnerTransactionPType, 'ptype must be InnerTransactionPType')
    super(expr, ptype)
  }
  memberAccess(name: string, sourceLocation: SourceLocation): NodeBuilder {
    const txnKind = this.ptype.kind
    const fields = txnKind === undefined ? anyTxnFields : txnKindToFields[txnKind]
    if (name in fields) {
      const { field, ptype: returnType } = fields[name as keyof typeof fields]
      const data = TxnFields[field]

      if (data.numValues === 1) {
        return instanceEb(
          nodeFactory.innerTransactionField({
            sourceLocation,
            itxn: this.resolve(),
            arrayIndex: null,
            field,
            wtype: data.wtype,
          }),
          returnType,
        )
      } else {
        return new IndexedTransactionFieldFunctionBuilder(this._expr, {
          txnData: data,
          returnType,
          memberName: name,
          field,
        })
      }
    }
    return super.memberAccess(name, sourceLocation)
  }
}

class IndexedTransactionFieldFunctionBuilder extends FunctionBuilder {
  constructor(
    private gtxn: Expression,
    private config: { txnData: TxnFieldData; returnType: PType; memberName: string; field: TxnField },
  ) {
    super(gtxn.sourceLocation)
  }

  call(args: ReadonlyArray<NodeBuilder>, typeArgs: ReadonlyArray<PType>, sourceLocation: SourceLocation): NodeBuilder {
    const {
      args: [index],
    } = parseFunctionArgs({
      args,
      typeArgs,
      genericTypeArgs: 0,
      callLocation: sourceLocation,
      funcName: this.config.memberName,
      argSpec: (a) => [a.required(uint64PType)],
    })

    return instanceEb(
      nodeFactory.innerTransactionField({
        sourceLocation,
        itxn: this.gtxn,
        arrayIndex: index.resolve(),
        field: this.config.field,
        wtype: this.config.txnData.wtype,
      }),
      this.config.returnType,
    )
  }
}



================================================
FILE: src/awst_build/eb/transactions/util.ts
================================================
import { TransactionKind } from '../../../awst/models'
import type { GroupTransactionPType, InnerTransactionPType, ItxnParamsPType } from '../../ptypes'
import {
  anyGtxnType,
  applicationCallGtxnType,
  applicationCallItxnParamsType,
  applicationItxnType,
  assetConfigGtxnType,
  assetConfigItxnParamsType,
  assetConfigItxnType,
  assetFreezeGtxnType,
  assetFreezeItxnParamsType,
  assetFreezeItxnType,
  assetTransferGtxnType,
  assetTransferItxnParamsType,
  assetTransferItxnType,
  keyRegistrationGtxnType,
  keyRegistrationItxnParamsType,
  keyRegistrationItxnType,
  paymentGtxnType,
  paymentItxnParamsType,
  paymentItxnType,
} from '../../ptypes'

export function getInnerTransactionType(kind: TransactionKind): InnerTransactionPType {
  switch (kind) {
    case TransactionKind.pay:
      return paymentItxnType
    case TransactionKind.keyreg:
      return keyRegistrationItxnType
    case TransactionKind.acfg:
      return assetConfigItxnType
    case TransactionKind.axfer:
      return assetTransferItxnType
    case TransactionKind.afrz:
      return assetFreezeItxnType
    case TransactionKind.appl:
      return applicationItxnType
  }
}
export function getItxnParamsType(kind: TransactionKind): ItxnParamsPType {
  switch (kind) {
    case TransactionKind.pay:
      return paymentItxnParamsType
    case TransactionKind.keyreg:
      return keyRegistrationItxnParamsType
    case TransactionKind.acfg:
      return assetConfigItxnParamsType
    case TransactionKind.axfer:
      return assetTransferItxnParamsType
    case TransactionKind.afrz:
      return assetFreezeItxnParamsType
    case TransactionKind.appl:
      return applicationCallItxnParamsType
  }
}
export function getGroupTransactionType(kind: TransactionKind | undefined): GroupTransactionPType {
  switch (kind) {
    case TransactionKind.pay:
      return paymentGtxnType
    case TransactionKind.keyreg:
      return keyRegistrationGtxnType
    case TransactionKind.acfg:
      return assetConfigGtxnType
    case TransactionKind.axfer:
      return assetTransferGtxnType
    case TransactionKind.afrz:
      return assetFreezeGtxnType
    case TransactionKind.appl:
      return applicationCallGtxnType
    default:
      return anyGtxnType
  }
}



================================================
FILE: src/awst_build/eb/util/arg-parsing.ts
================================================
import type { SourceLocation } from '../../../awst/source-location'
import { CodeError } from '../../../errors'
import { logger } from '../../../logger'
import type { DeliberateAny, Tuple } from '../../../typescript-helpers'
import type { PType, PTypeOrClass } from '../../ptypes'
import type { InstanceBuilder, NodeBuilder } from '../index'
import { requestBuilderOfType, requireInstanceBuilder } from './index'

function parseTypeArgs<T extends number>(
  typeArgs: ReadonlyArray<PType>,
  sourceLocation: SourceLocation,
  funcName: string,
  expectedCount: T,
): Tuple<PType, T> {
  if (typeArgs.length !== expectedCount) {
    const err = new CodeError(`${funcName} expects exactly ${expectedCount} type argument${expectedCount === 1 ? '' : 's'}`, {
      sourceLocation,
    })
    if (typeArgs.length > expectedCount) {
      logger.error(err)
      return typeArgs.slice(0, expectedCount) as Tuple<PType, T>
    }
    throw err
  }
  return typeArgs as Tuple<PType, T>
}

const ArgSpecDiscriminator = Symbol('_specType')

/**
 * Optional arg spec
 * Will be mapped to `InstanceBuilder | undefined`
 */
type OptionalArg = { t: PTypeOrClass[]; [ArgSpecDiscriminator]: 'arg'; type: 'optional' }
/**
 * Required arg spec
 * Will be mapped to `InstanceBuilder`
 */
type RequiredArg = { t: PTypeOrClass[]; type: 'required'; [ArgSpecDiscriminator]: 'arg' }

/**
 * Passthrough arg spec
 * Will be mapped to NodeBuilder | undefined
 */
type PassthroughArg = { type: 'passthrough'; [ArgSpecDiscriminator]: 'arg' }
type ArgSpec = OptionalArg | RequiredArg | PassthroughArg

/**
 * Object arg spec
 * Will be mapped to an object with the same keys where each property
 * is mapped to a Required or Optional spec
 */
type ObjArgSpec = Record<string, ArgSpec> & { [ArgSpecDiscriminator]: 'obj' }

/**
 * Maps an ObjArgSpec to its output type
 */
type ArgsForObjSpec<T extends ObjArgSpec> = {
  [key in keyof T]: ArgFor<T[key]>
}
/**
 * Defines the expected shape of a single argument.
 * Either an ArgSpec indicting a single value, or an ObjArgSpec indicating an
 * object literal with several properties
 */
type ArgMap = ArgSpec | ObjArgSpec

/**
 * Maps an arg spec to its output type
 */
type ArgFor<T extends ObjArgSpec | ArgSpec> = T extends ObjArgSpec
  ? ArgsForObjSpec<T>
  : T extends PassthroughArg
    ? NodeBuilder | undefined
    : T extends OptionalArg
      ? InstanceBuilder | undefined
      : T extends RequiredArg
        ? InstanceBuilder
        : never
/**
 * Maps each arg to an expected output type
 */
type ParsedArgs<T extends [...DeliberateAny[]]> = T extends [infer T1 extends ArgMap, ...infer TRest]
  ? [ArgFor<T1>, ...ParsedArgs<TRest>]
  : T extends []
    ? []
    : T extends Array<infer TItem extends ArgMap>
      ? Array<ArgFor<TItem>>
      : never

function parseObjArg<T extends ObjArgSpec>(
  arg: NodeBuilder | undefined,
  sourceLocation: SourceLocation,
  subject: string,
  argMap: T,
): ArgsForObjSpec<T> {
  return Object.entries(argMap).reduce(
    (acc, [property, spec]) => {
      if (arg?.hasProperty(property)) {
        const builder = arg.memberAccess(property, sourceLocation)
        if (spec.type === 'passthrough') {
          acc[property] = builder
          return acc
        }
        if (spec.t.length === 0) {
          acc[property] = requireInstanceBuilder(builder)
        } else {
          for (const t of spec.t) {
            const typedBuilder = requestBuilderOfType(builder, t)
            if (typedBuilder) {
              acc[property] = typedBuilder
              return acc
            }
          }
          throw new CodeError(
            `${subject} has an incorrect type for property '${property}' of ${builder.ptype}. Expected ${spec.t.join(' or ')}`,
            {
              sourceLocation: arg?.sourceLocation ?? sourceLocation,
            },
          )
        }
        return acc
      }
      if (spec.type === 'required') {
        throw new CodeError(`${subject} is missing required property ${property}`, {
          sourceLocation: arg?.sourceLocation ?? sourceLocation,
        })
      }
      return acc
    },
    {} as Record<string, InstanceBuilder | NodeBuilder>,
  ) as ArgsForObjSpec<T>
}

const argSpecFactory = {
  /**
   * A required arg with one of the specified types
   * @param ptypes
   */
  required(...ptypes: PTypeOrClass[]): RequiredArg {
    return { t: ptypes, type: 'required', [ArgSpecDiscriminator]: 'arg' }
  },
  /**
   * An optional arg with one of the specified types
   * @param ptypes
   */
  optional(...ptypes: PTypeOrClass[]): OptionalArg {
    return { t: ptypes, type: 'optional', [ArgSpecDiscriminator]: 'arg' }
  },
  /**
   * An object map arg, if all properties are optional - the arg itself becomes optional
   * @param props A mapping of expected properties to expected ptypes
   */
  obj<T extends Omit<ObjArgSpec, typeof ArgSpecDiscriminator>>(props: T): T & { [ArgSpecDiscriminator]: 'obj' } {
    return {
      ...props,
      [ArgSpecDiscriminator]: 'obj',
    }
  },
  passthrough(): PassthroughArg {
    return {
      type: 'passthrough',
      [ArgSpecDiscriminator]: 'arg',
    }
  },
}

export type ArgSpecFactory = typeof argSpecFactory

export function parseFunctionArgs<const TGenericCount extends number, const TArgMap extends [...ArgMap[]]>({
  args,
  typeArgs,
  funcName,
  callLocation,
  genericTypeArgs,
  argSpec,
}: {
  /**
   * Raw args array passed to call function
   */
  args: ReadonlyArray<NodeBuilder>
  /**
   * Raw typeArgs array passed to call function
   */
  typeArgs: ReadonlyArray<PType>
  /**
   * The name of the function being called
   * (Used for error context)
   */
  funcName: string
  /**
   * The location of the call expression in the application source code
   */
  callLocation: SourceLocation
  /**
   * The expected number of generic type arguments
   */
  genericTypeArgs: TGenericCount
  /**
   * A mapping of expected argument types
   */
  argSpec: (a: ArgSpecFactory) => TArgMap
}): {
  /**
   * A tuple of generic type args with a length of `TGenericCount`
   */
  ptypes: Tuple<PType, TGenericCount>
  args: ParsedArgs<TArgMap>
} {
  const argMap = argSpec(argSpecFactory)
  if (args.length > argMap.length) {
    throw new CodeError(`${funcName} has ${args.length - argMap.length} too many args`, { sourceLocation: callLocation })
  }
  return {
    ptypes: parseTypeArgs(typeArgs, callLocation, funcName, genericTypeArgs),
    args: argMap.map((a, i) => {
      const source: NodeBuilder | undefined = args[i]
      if (a[ArgSpecDiscriminator] === 'arg') {
        if (a.type === 'passthrough') {
          return source
        }
        if (source) {
          if (a.t.length === 0) {
            return requireInstanceBuilder(source)
          } else {
            for (const t of a.t) {
              const builder = requestBuilderOfType(source, t)
              if (builder) {
                return builder
              }
            }
            throw new CodeError(`Arg ${i} of ${funcName} has an incorrect type of ${source.ptype}. Expected ${a.t.join(' | ')}`, {
              sourceLocation: source.sourceLocation,
            })
          }
        }
        if (a.type === 'required') {
          throw new CodeError(`Arg ${i} of ${funcName} is missing`, { sourceLocation: callLocation })
        }
      } else {
        return parseObjArg(source, callLocation, `Arg ${i} for ${funcName}`, a)
      }
    }) as ParsedArgs<TArgMap>,
  }
}



================================================
FILE: src/awst_build/eb/util/avm-version.ts
================================================
import type { SupportedAvmVersion } from '../../../constants'
import { Constants } from '../../../constants'
import { codeInvariant, isIn } from '../../../util'
import type { NodeBuilder } from '../index'
import { requireIntegerConstant } from './index'

export function requireAvmVersion(builder: NodeBuilder): SupportedAvmVersion {
  const value = requireIntegerConstant(builder)
  codeInvariant(isIn(value.value, Constants.supportedAvmVersions), `${value.value} is not a supported AVM version`, value.sourceLocation)
  return value.value as SupportedAvmVersion
}



================================================
FILE: src/awst_build/eb/util/compare-bytes.ts
================================================
import { nodeFactory } from '../../../awst/node-factory'
import type { Expression } from '../../../awst/nodes'
import { EqualityComparison } from '../../../awst/nodes'
import type { SourceLocation } from '../../../awst/source-location'
import { logger } from '../../../logger'
import { BooleanExpressionBuilder } from '../boolean-expression-builder'
import { BuilderComparisonOp } from '../index'

const builderCompareToBytesCompare: Record<BuilderComparisonOp, EqualityComparison | undefined> = {
  [BuilderComparisonOp.ne]: EqualityComparison.ne,
  [BuilderComparisonOp.eq]: EqualityComparison.eq,
  [BuilderComparisonOp.lt]: undefined,
  [BuilderComparisonOp.lte]: undefined,
  [BuilderComparisonOp.gt]: undefined,
  [BuilderComparisonOp.gte]: undefined,
}

export function compareBytes(
  left: Expression,
  right: Expression,
  op: BuilderComparisonOp,
  sourceLocation: SourceLocation,
  typeDescription: string,
) {
  const equalityOp = builderCompareToBytesCompare[op]
  if (equalityOp === undefined) {
    logger.error(sourceLocation, `${typeDescription} does not support the '${op}' operator`)
  }
  return new BooleanExpressionBuilder(
    nodeFactory.bytesComparisonExpression({
      sourceLocation,
      operator: equalityOp ?? EqualityComparison.eq,
      lhs: left,
      rhs: right,
    }),
  )
}



================================================
FILE: src/awst_build/eb/util/compare-uint64.ts
================================================
import { nodeFactory } from '../../../awst/node-factory'
import type { Expression } from '../../../awst/nodes'
import { NumericComparison } from '../../../awst/nodes'
import type { SourceLocation } from '../../../awst/source-location'
import { logger } from '../../../logger'
import { tryConvertEnum } from '../../../util'
import { BooleanExpressionBuilder } from '../boolean-expression-builder'
import { BuilderComparisonOp } from '../index'

export function compareUint64(
  left: Expression,
  right: Expression,
  op: BuilderComparisonOp,
  sourceLocation: SourceLocation,
  typeDescription: string,
) {
  const numComOp = tryConvertEnum(op, BuilderComparisonOp, NumericComparison)
  if (numComOp === undefined) {
    logger.error(sourceLocation, `${typeDescription} does not support the '${op}' operator`)
  }
  return new BooleanExpressionBuilder(
    nodeFactory.numericComparisonExpression({
      sourceLocation,
      operator: numComOp ?? NumericComparison.eq,
      lhs: left,
      rhs: right,
    }),
  )
}



================================================
FILE: src/awst_build/eb/util/get-bigint-or-uint64-expr.ts
================================================
import { invariant } from '../../../util'
import { numberPType, uint64PType } from '../../ptypes'
import type { InstanceBuilder } from '../index'
import { BigIntLiteralExpressionBuilder } from '../literal/big-int-literal-expression-builder'

export function getBigIntOrUint64Expr(builder: InstanceBuilder) {
  if (builder.ptype.equals(numberPType)) {
    invariant(builder instanceof BigIntLiteralExpressionBuilder, 'Builder for number type must be BigIntLiteral', builder.sourceLocation)
    return builder.value
  } else {
    invariant(builder.ptype.equals(uint64PType), 'Builder must be uint64 if not number', builder.sourceLocation)
    return builder.resolve()
  }
}



================================================
FILE: src/awst_build/eb/util/index.ts
================================================
import type { awst } from '../../../awst'
import { isConstant } from '../../../awst'
import type { Expression } from '../../../awst/nodes'
import { BoolConstant, IntegerConstant, StringConstant } from '../../../awst/nodes'
import { CodeError } from '../../../errors'
import { codeInvariant } from '../../../util'
import type { PType, PTypeOrClass } from '../../ptypes'
import { biguintPType, boolPType, stringPType, uint64PType } from '../../ptypes'
import type { NodeBuilder } from '../index'
import { InstanceBuilder } from '../index'
import { LiteralExpressionBuilder } from '../literal-expression-builder'
import { BigIntLiteralExpressionBuilder } from '../literal/big-int-literal-expression-builder'

export function requireExpressionOfType(builder: NodeBuilder, ptype: PTypeOrClass): Expression {
  if (builder instanceof InstanceBuilder) {
    if (builder.resolvableToPType(ptype)) {
      return builder.resolveToPType(ptype).resolve()
    }
  }
  throw new CodeError(`Expected expression of type ${ptype}, got ${builder.typeDescription}`, {
    sourceLocation: builder.sourceLocation,
  })
}
export function requireBuilderOfType(builder: NodeBuilder, ptype: PTypeOrClass): InstanceBuilder {
  if (builder instanceof InstanceBuilder) {
    if (builder.resolvableToPType(ptype)) {
      return builder.resolveToPType(ptype)
    }
  }
  throw new CodeError(`Expected expression of type ${ptype}, got ${builder.typeDescription}`, {
    sourceLocation: builder.sourceLocation,
  })
}

export function resolvableToType(builder: NodeBuilder, ptype: PTypeOrClass): builder is InstanceBuilder {
  if (builder instanceof InstanceBuilder) {
    return builder.resolvableToPType(ptype)
  }
  return false
}

export function requestExpressionOfType(builder: NodeBuilder, ptype: PTypeOrClass): Expression | undefined {
  if (builder instanceof InstanceBuilder) {
    if (builder.resolvableToPType(ptype)) {
      return builder.resolveToPType(ptype).resolve()
    }
    return undefined
  }
  return undefined
}
export function requestBuilderOfType(builder: NodeBuilder, ptype: PTypeOrClass): InstanceBuilder | undefined {
  if (builder instanceof InstanceBuilder) {
    if (builder.resolvableToPType(ptype)) {
      return builder.resolveToPType(ptype)
    }
    return undefined
  }
  return undefined
}

export function requireInstanceBuilder(builder: NodeBuilder): InstanceBuilder {
  if (builder instanceof InstanceBuilder) return builder
  throw new CodeError(`Expected instance of a type, got ${builder.typeDescription}`, { sourceLocation: builder.sourceLocation })
}

export function requireStringConstant(builder: NodeBuilder): awst.StringConstant {
  const constant = requireConstantOfType(builder, stringPType)
  codeInvariant(constant instanceof StringConstant, 'Expected string literal', builder.sourceLocation)
  return constant
}
export function requireIntegerConstant(builder: NodeBuilder): awst.IntegerConstant {
  const constant = requestConstantOfType(builder, uint64PType) ?? requestConstantOfType(builder, biguintPType)
  codeInvariant(constant instanceof IntegerConstant, 'Expected integer literal')
  return constant
}
export function requireBooleanConstant(builder: NodeBuilder): awst.BoolConstant {
  const constant = requireConstantOfType(builder, boolPType)
  codeInvariant(constant instanceof BoolConstant, 'Expected boolean literal')
  return constant
}

export function requestConstantOfType(builder: NodeBuilder, ptype: PType): awst.Constant | undefined {
  if (builder instanceof LiteralExpressionBuilder) {
    if (builder.resolvableToPType(ptype)) {
      const expr = builder.resolveToPType(ptype).resolve()
      if (isConstant(expr)) return expr
    }
    return undefined
  }
  if (builder instanceof InstanceBuilder && builder.ptype?.equals(ptype)) {
    const expr = builder.resolve()
    if (isConstant(expr)) return expr
  }
  return undefined
}

export function requireConstantOfType(builder: NodeBuilder, ptype: PType, messageOverride?: string): awst.Constant {
  const constExpr = requestConstantOfType(builder, ptype)
  if (constExpr) return constExpr
  throw new CodeError(messageOverride ?? `Expected constant of type ${ptype}`, { sourceLocation: builder.sourceLocation })
}

export function requireLiteralNumber(builder: NodeBuilder) {
  codeInvariant(builder instanceof BigIntLiteralExpressionBuilder, 'Expected numeric literal', builder.sourceLocation)
  return builder.value
}



================================================
FILE: src/awst_build/eb/util/is-valid-literal-for-ptype.ts
================================================
import type { ConstantValue } from '../../../awst'
import type { PTypeOrClass } from '../../ptypes'
import { bigIntPType, biguintPType, boolPType, bytesPType, numberPType, stringPType, uint64PType } from '../../ptypes'
import { UFixedNxMType, UintNType } from '../../ptypes/arc4-types'

export function isValidLiteralForPType(literalValue: ConstantValue, ptype: PTypeOrClass): boolean {
  if (ptype.equals(stringPType)) {
    return typeof literalValue === 'string'
  }
  if (ptype.equals(numberPType)) {
    return (
      typeof literalValue === 'bigint' && BigInt(Number.MIN_SAFE_INTEGER) <= literalValue && literalValue <= BigInt(Number.MAX_SAFE_INTEGER)
    )
  }
  if (ptype.equals(bigIntPType)) {
    return typeof literalValue === 'bigint'
  }
  if (ptype.equals(uint64PType)) {
    return typeof literalValue === 'bigint' && 0 <= literalValue && literalValue < 2n ** 64n
  }
  if (ptype.equals(biguintPType)) {
    return typeof literalValue === 'bigint' && 0 <= literalValue && literalValue < 2n ** 512n
  }
  if (ptype instanceof UintNType || ptype instanceof UFixedNxMType) {
    return typeof literalValue === 'bigint' && 0 <= literalValue && literalValue < 2n ** ptype.n
  }
  if (ptype.equals(boolPType)) {
    return typeof literalValue === 'boolean'
  }
  if (ptype.equals(bytesPType)) {
    return literalValue instanceof Uint8Array
  }
  return false
}



================================================
FILE: src/awst_build/eb/util/require-constant-value.ts
================================================
import type { ConstantValue } from '../../../awst'
import { isConstant } from '../../../awst'
import type { SourceLocation } from '../../../awst/source-location'
import { codeInvariant } from '../../../util'
import type { NodeBuilder } from '../index'
import { BigIntLiteralExpressionBuilder } from '../literal/big-int-literal-expression-builder'
import { requireInstanceBuilder } from './index'

export function requireConstantValue(builder: NodeBuilder, sourceLocation: SourceLocation): ConstantValue {
  if (builder instanceof BigIntLiteralExpressionBuilder) {
    return builder.value
  }
  const value = requireInstanceBuilder(builder).resolve()
  codeInvariant(isConstant(value), 'Expected compile time constant')
  return value.value
}



================================================
FILE: src/awst_build/eb/util/resolve-compat-builder.ts
================================================
import { CodeError } from '../../../errors'
import { codeInvariant } from '../../../util'
import type { PType } from '../../ptypes'
import { accountPType, applicationPType, assetPType, bytesPType, onCompleteActionType, stringPType, uint64PType } from '../../ptypes'
import { instanceEb } from '../../type-registry'
import type { NodeBuilder } from '../index'
import { InstanceBuilder } from '../index'

/**
 * Given a builder, attempt to resolve it to the target type converting compatible types as possible
 *
 * @param builder
 * @param targetType
 */
export function resolveCompatBuilder(builder: NodeBuilder, targetType: PType) {
  codeInvariant(builder instanceof InstanceBuilder, `Cannot resolve ${builder.typeDescription} to a value`, builder.sourceLocation)

  if (builder.resolvableToPType(targetType)) {
    return builder.resolveToPType(targetType)
  }

  if (targetType.equals(accountPType)) {
    if (builder.resolvableToPType(bytesPType)) {
      // Account bytes should just be cast
      return builder.resolveToPType(bytesPType).reinterpretCast(accountPType)
    }
  } else if (targetType.equals(applicationPType) || targetType.equals(assetPType) || targetType.equals(onCompleteActionType)) {
    if (builder.resolvableToPType(uint64PType)) {
      return builder.resolveToPType(uint64PType).reinterpretCast(targetType)
    }
  } else if (targetType.equals(bytesPType)) {
    if (builder.resolvableToPType(stringPType)) {
      return instanceEb(builder.resolveToPType(stringPType).toBytes(builder.sourceLocation), bytesPType)
    }
  }

  throw new CodeError(`Cannot resolve ${builder.ptype} to ${targetType}`, { sourceLocation: builder.sourceLocation })
}

export function resolveCompatExpression(builder: NodeBuilder, targetType: PType) {
  return resolveCompatBuilder(builder, targetType).resolve()
}



================================================
FILE: src/awst_build/eb/util/scratch-slots.ts
================================================
import { CodeError } from '../../../errors'
import { codeInvariant } from '../../../util'
import { numberPType } from '../../ptypes'
import type { NodeBuilder } from '../index'
import { ArrayLiteralExpressionBuilder } from '../literal/array-literal-expression-builder'
import { StaticIterator } from '../traits/static-iterator'
import { requireLiteralNumber } from './index'

export function processScratchRanges(builder: NodeBuilder): Set<bigint> {
  codeInvariant(
    builder instanceof ArrayLiteralExpressionBuilder,
    'Scratch ranges should be specified in an array literal',
    builder.sourceLocation,
  )
  const slots = new Set<bigint>()
  for (const item of builder[StaticIterator]()) {
    if (item.resolvableToPType(numberPType)) {
      slots.add(requireLiteralNumber(item))
    } else {
      const from = getRangeProp(item, 'from')
      const to = getRangeProp(item, 'to')
      for (let i = from; i <= to; i++) {
        slots.add(i)
      }
    }
  }

  return slots
}

function getRangeProp(builder: NodeBuilder, name: string): bigint {
  if (builder.hasProperty(name)) {
    return requireLiteralNumber(builder.memberAccess(name, builder.sourceLocation))
  }
  throw new CodeError('Scratch slot reservations should be either a single slot or an object containing a from and to property', {
    sourceLocation: builder.sourceLocation,
  })
}



================================================
FILE: src/awst_build/eb/util/string-to-bigint.ts
================================================
import type { SourceLocation } from '../../../awst/source-location'
import { CodeError } from '../../../errors'

export function stringToBigint({ value, sourceLocation }: { value: string; sourceLocation: SourceLocation }): bigint {
  try {
    return BigInt(value)
  } catch (e) {
    if (e instanceof SyntaxError) {
      throw new CodeError(`Cannot convert ${value} to an integer`, { sourceLocation })
    }
    throw e
  }
}



================================================
FILE: src/awst_build/eb/util/translate-negative-index.ts
================================================
import { nodeFactory } from '../../../awst/node-factory'
import type { Expression } from '../../../awst/nodes'
import { UInt64BinaryOperator } from '../../../awst/nodes'
import { logger } from '../../../logger'
import type { InstanceBuilder } from '../index'
import { getBigIntOrUint64Expr } from './get-bigint-or-uint64-expr'

export function translateNegativeIndex(arrayLength: Expression | bigint, index: InstanceBuilder) {
  const indexParam = getBigIntOrUint64Expr(index)

  if (typeof indexParam === 'bigint') {
    if (typeof arrayLength === 'bigint') {
      let indexValue = indexParam < 0 ? arrayLength + indexParam : indexParam
      if (indexValue < 0n || indexValue >= arrayLength) {
        logger.error(index.sourceLocation, 'Index access out of bounds')
        indexValue = 0n
      }
      return nodeFactory.uInt64Constant({
        value: indexValue,
        sourceLocation: index.sourceLocation,
      })
    } else {
      return nodeFactory.uInt64BinaryOperation({
        op: UInt64BinaryOperator.sub,
        left: arrayLength,
        right: nodeFactory.uInt64Constant({
          value: indexParam * -1n,
          sourceLocation: index.sourceLocation,
        }),
        sourceLocation: index.sourceLocation,
      })
    }
  } else {
    return indexParam
  }
}



================================================
FILE: src/awst_build/eb/util/array/common.ts
================================================
import type { SourceLocation } from '../../../../awst/source-location'
import { CodeError } from '../../../../errors'
import type { PType } from '../../../ptypes'
import { ArrayLiteralPType, ArrayPType } from '../../../ptypes'
import { ARC4ArrayType } from '../../../ptypes/arc4-types'

export function arrayElementType(arrayType: PType, sourceLocation: SourceLocation) {
  if (arrayType instanceof ARC4ArrayType) return arrayType.elementType
  if (arrayType instanceof ArrayPType) return arrayType.elementType
  if (arrayType instanceof ArrayLiteralPType) return arrayType.elementType
  throw new CodeError(`${arrayType} does not appear to be an array type`, { sourceLocation })
}



================================================
FILE: src/awst_build/eb/util/array/concat.ts
================================================
import { intrinsicFactory } from '../../../../awst/intrinsic-factory'
import { nodeFactory } from '../../../../awst/node-factory'
import type { Expression } from '../../../../awst/nodes'
import type { SourceLocation } from '../../../../awst/source-location'
import { wtypes } from '../../../../awst/wtypes'
import { CodeError } from '../../../../errors'
import { bigIntToUint8Array, codeInvariant } from '../../../../util'
import type { PType } from '../../../ptypes'
import { ArrayLiteralPType, ArrayPType, TuplePType } from '../../../ptypes'
import { ARC4ArrayType, DynamicArrayType, DynamicBytesType, StaticArrayType, StaticBytesType } from '../../../ptypes/arc4-types'
import { instanceEb } from '../../../type-registry'
import type { InstanceBuilder } from '../../index'

export function concatArrays(left: InstanceBuilder, right: InstanceBuilder, sourceLocation: SourceLocation): InstanceBuilder {
  if (left.ptype instanceof StaticBytesType || left.ptype instanceof StaticArrayType) {
    /*
      TODO: This is only required because puya doesn't support staticarray + other => dynamic array
      To work around this, we convert arc4 static bytes and static array to dynamic bytes and dynamic array
     */
    const dynamicType = left.ptype instanceof StaticBytesType ? DynamicBytesType : new DynamicArrayType({ ...left.ptype })
    return concatArrays(toArc4Dynamic(left.ptype.arraySize, left.resolve(), dynamicType), right, sourceLocation)
  }

  const returnType = getArrayConcatType(left.ptype, right.ptype, sourceLocation)
  return instanceEb(
    nodeFactory.arrayConcat({
      left: left.resolve(),
      right: right.resolve(),
      wtype: returnType.wtype,
      sourceLocation,
    }),
    returnType,
  )
}

function getArrayConcatType(left: PType, right: PType, sourceLocation: SourceLocation) {
  if (left instanceof ARC4ArrayType) {
    if (right instanceof ARC4ArrayType) {
      sameElementType(left.elementType, right.elementType, sourceLocation)
      if (left.equals(DynamicBytesType) || left instanceof StaticBytesType) {
        return DynamicBytesType
      }
      return new DynamicArrayType({
        elementType: left.elementType,
      })
    }
  } else if (left instanceof ArrayPType || left instanceof ArrayLiteralPType) {
    if (right instanceof ArrayPType || right instanceof ArrayLiteralPType || right instanceof ARC4ArrayType) {
      sameElementType(left.elementType, right.elementType, sourceLocation)
      return new ArrayPType({
        elementType: left.elementType,
      })
    }
    if (right instanceof TuplePType) {
      right.items.forEach((i) => sameElementType(left.elementType, i, sourceLocation))
      return new ArrayPType({
        elementType: left.elementType,
      })
    }
  }
  cannotConcat(left, right, sourceLocation)
}

function cannotConcat(left: PType, right: PType, sourceLocation: SourceLocation): never {
  throw new CodeError(`Cannot concat ${left} with ${right}`, { sourceLocation })
}

function sameElementType(left: PType, right: PType, sourceLocation: SourceLocation) {
  codeInvariant(left.equals(right), `Cannot concat array of type ${left} with iterable of type ${right}`, sourceLocation)
}

function toArc4Dynamic(staticSize: bigint, staticBytes: Expression, dynamicType: DynamicArrayType) {
  return instanceEb(
    nodeFactory.reinterpretCast({
      expr: intrinsicFactory.bytesConcat({
        left: nodeFactory.bytesConstant({
          value: bigIntToUint8Array(staticSize, 2),
          sourceLocation: staticBytes.sourceLocation,
        }),
        right: nodeFactory.reinterpretCast({
          expr: staticBytes,
          wtype: wtypes.bytesWType,
          sourceLocation: staticBytes.sourceLocation,
        }),
        sourceLocation: staticBytes.sourceLocation,
      }),
      wtype: dynamicType.wtype,
      sourceLocation: staticBytes.sourceLocation,
    }),
    dynamicType,
  )
}



================================================
FILE: src/awst_build/eb/util/array/index-access.ts
================================================
import { nodeFactory } from '../../../../awst/node-factory'
import { IntegerConstant } from '../../../../awst/nodes'
import type { SourceLocation } from '../../../../awst/source-location'
import { logger } from '../../../../logger'
import { uint64PType } from '../../../ptypes'
import { StaticArrayType } from '../../../ptypes/arc4-types'
import { instanceEb } from '../../../type-registry'
import type { InstanceBuilder } from '../../index'
import { type NodeBuilder } from '../../index'
import { requireExpressionOfType } from '../index'
import { arrayElementType } from './common'

export function indexAccess(target: InstanceBuilder, index: InstanceBuilder, sourceLocation: SourceLocation): NodeBuilder {
  const indexExpr = requireExpressionOfType(index, uint64PType)
  if (indexExpr instanceof IntegerConstant && target.ptype instanceof StaticArrayType && indexExpr.value >= target.ptype.arraySize) {
    logger.error(index.sourceLocation, 'Index access out of bounds')
  }

  const elementType = arrayElementType(target.ptype, sourceLocation)
  return instanceEb(
    nodeFactory.indexExpression({
      base: target.resolve(),
      sourceLocation: sourceLocation,
      index: indexExpr,
      wtype: elementType.wtypeOrThrow,
    }),
    elementType,
  )
}



================================================
FILE: src/awst_build/eb/util/array/length.ts
================================================
import { nodeFactory } from '../../../../awst/node-factory'
import type { SourceLocation } from '../../../../awst/source-location'
import { uint64PType } from '../../../ptypes'
import { instanceEb } from '../../../type-registry'
import type { InstanceBuilder } from '../../index'
import { isStaticallyIterable, StaticIterator } from '../../traits/static-iterator'

export function arrayLength(array: InstanceBuilder, sourceLocation: SourceLocation) {
  if (isStaticallyIterable(array)) {
    return instanceEb(
      nodeFactory.uInt64Constant({
        value: BigInt(array[StaticIterator]().length),
        sourceLocation,
      }),
      uint64PType,
    )
  }

  return instanceEb(
    nodeFactory.arrayLength({
      array: array.resolve(),
      sourceLocation,
    }),
    uint64PType,
  )
}



================================================
FILE: src/awst_build/lib/index.ts
================================================
import { ContractReference } from '../../awst/models'
import { nodeFactory } from '../../awst/node-factory'
import { SourceLocation } from '../../awst/source-location'
import { wtypes } from '../../awst/wtypes'
import { Constants } from '../../constants'
import { AwstBuildContext } from '../context/awst-build-context'
import { ContractClassModel } from '../models/contract-class-model'
import { arc4BaseContractType, baseContractType } from '../ptypes'

export function buildLibAwst() {
  const contractCref = ContractReference.fromPType(arc4BaseContractType)
  const baseContractCref = ContractReference.fromPType(baseContractType)

  const baseContract = new ContractClassModel({
    type: baseContractType,
    isAbstract: true,
    propertyInitialization: [],
    ctor: nodeFactory.contractMethod({
      memberName: Constants.symbolNames.constructorMethodName,
      cref: baseContractCref,
      args: [],
      arc4MethodConfig: null,
      sourceLocation: SourceLocation.None,
      returnType: wtypes.voidWType,
      documentation: nodeFactory.methodDocumentation(),
      body: nodeFactory.block({ sourceLocation: SourceLocation.None }),
      inline: true,
    }),
    methods: [],
    appState: [],
    options: undefined,
    description: null,
    sourceLocation: SourceLocation.None,
    approvalProgram: null,
    clearProgram: nodeFactory.contractMethod({
      memberName: Constants.symbolNames.clearStateProgramMethodName,
      cref: baseContractCref,
      args: [],
      arc4MethodConfig: null,
      sourceLocation: SourceLocation.None,
      returnType: wtypes.boolWType,
      documentation: nodeFactory.methodDocumentation(),
      body: nodeFactory.block(
        {
          sourceLocation: SourceLocation.None,
        },
        nodeFactory.returnStatement({
          sourceLocation: SourceLocation.None,
          value: nodeFactory.boolConstant({ value: true, sourceLocation: SourceLocation.None }),
        }),
      ),
      inline: null,
    }),
  })
  AwstBuildContext.current.addToCompilationSet(baseContractCref, baseContract)
  const contract = new ContractClassModel({
    type: arc4BaseContractType,
    isAbstract: true,
    propertyInitialization: [],
    ctor: null,
    methods: [],
    appState: [],
    options: undefined,
    description: null,
    clearProgram: null,
    sourceLocation: SourceLocation.None,
    approvalProgram: nodeFactory.contractMethod({
      memberName: Constants.symbolNames.approvalProgramMethodName,
      cref: contractCref,
      args: [],
      arc4MethodConfig: null,
      sourceLocation: SourceLocation.None,
      returnType: wtypes.boolWType,
      documentation: nodeFactory.methodDocumentation(),
      body: nodeFactory.block(
        {
          sourceLocation: SourceLocation.None,
        },
        nodeFactory.returnStatement({
          sourceLocation: SourceLocation.None,
          value: nodeFactory.aRC4Router({ sourceLocation: SourceLocation.None, wtype: wtypes.boolWType }),
        }),
      ),
      inline: null,
    }),
  })
  AwstBuildContext.current.addToCompilationSet(contractCref, contract)
}



================================================
FILE: src/awst_build/models/app-storage-declaration.ts
================================================
import { nodeFactory } from '../../awst/node-factory'
import type { AppStorageDefinition, BytesConstant } from '../../awst/nodes'
import { AppStorageKind, BytesEncoding } from '../../awst/nodes'
import type { SourceLocation } from '../../awst/source-location'
import { CodeError } from '../../errors'
import { invariant, utf8ToUint8Array } from '../../util'
import type { ContractClassPType, StorageProxyPType } from '../ptypes'
import { BoxMapPType, BoxPType, BoxRefPType, GlobalStateType, LocalStateType } from '../ptypes'

export class AppStorageDeclaration {
  readonly memberName: string
  readonly ptype: GlobalStateType | LocalStateType | BoxMapPType | BoxPType | BoxRefPType
  readonly keyOverride: BytesConstant | null
  readonly sourceLocation: SourceLocation
  readonly definedIn: ContractClassPType
  readonly description: string | null
  constructor(props: {
    memberName: string
    ptype: StorageProxyPType
    keyOverride: BytesConstant | null
    sourceLocation: SourceLocation
    definedIn: ContractClassPType
    description: string | null
  }) {
    this.memberName = props.memberName
    this.ptype = props.ptype
    this.keyOverride = props.keyOverride
    this.sourceLocation = props.sourceLocation
    this.definedIn = props.definedIn
    this.description = props.description
  }

  get kind(): AppStorageKind {
    if (this.ptype instanceof GlobalStateType) {
      return AppStorageKind.appGlobal
    }
    if (this.ptype instanceof LocalStateType) {
      return AppStorageKind.accountLocal
    }
    invariant(
      this.ptype instanceof BoxPType || this.ptype instanceof BoxRefPType || this.ptype instanceof BoxMapPType,
      'Must be exhaustive check on ptype',
    )
    return AppStorageKind.box
  }

  get key(): BytesConstant {
    if (this.keyOverride) {
      invariant(this.keyOverride.wtype.equals(this.ptype.wtype), 'Key wtype must match ptype')
      return this.keyOverride
    } else {
      return nodeFactory.bytesConstant({
        value: utf8ToUint8Array(this.memberName),
        sourceLocation: this.sourceLocation,
        encoding: BytesEncoding.utf8,
        wtype: this.ptype.wtype,
      })
    }
  }

  get definition(): AppStorageDefinition {
    if (!this.ptype.contentType.wtype || !this.ptype.contentType.wtype.scalarType) {
      throw new CodeError(`${this.ptype.contentType.fullName} is not a valid type for storage`, { sourceLocation: this.sourceLocation })
    }
    return nodeFactory.appStorageDefinition({
      ...this,
      kind: this.kind,
      key: this.key,
      keyWtype: this.ptype instanceof BoxMapPType ? this.ptype.keyType.wtypeOrThrow : null,
      storageWtype: this.ptype.contentType.wtypeOrThrow,
    })
  }
}



================================================
FILE: src/awst_build/models/contract-class-model.ts
================================================
import type { awst } from '../../awst'
import type { LogicSigReference } from '../../awst/models'
import { ContractReference, OnCompletionAction } from '../../awst/models'
import { nodeFactory } from '../../awst/node-factory'
import type { AppStorageDefinition, ContractMethod, Statement } from '../../awst/nodes'
import { ARC4BareMethodConfig, ARC4CreateOption, StateTotals } from '../../awst/nodes'
import { SourceLocation } from '../../awst/source-location'
import { wtypes } from '../../awst/wtypes'
import { Constants } from '../../constants'
import { logger } from '../../logger'
import type { Props } from '../../typescript-helpers'
import { codeInvariant, invariant, isIn } from '../../util'
import { CustomKeyMap } from '../../util/custom-key-map'
import type { ContractClassPType } from '../ptypes'
import { ClusteredContractClassType } from '../ptypes'
import type { ContractOptionsDecoratorData } from './decorator-data'
import { LogicSigClassModel } from './logic-sig-class-model'

export class ContractClassModel {
  public readonly isAbstract: boolean
  public get id(): ContractReference {
    return ContractReference.fromPType(this.type)
  }
  public readonly type: ContractClassPType
  public get name(): string {
    return this.type.name
  }
  public readonly options: ContractOptionsDecoratorData | undefined
  public readonly description: string | null
  public readonly propertyInitialization: Array<Statement>
  public readonly approvalProgram: ContractMethod | null
  public readonly clearProgram: ContractMethod | null
  public readonly ctor: ContractMethod | null
  public readonly methods: Array<ContractMethod>
  public readonly appState: Array<AppStorageDefinition>
  public readonly sourceLocation: SourceLocation
  constructor(props: Props<Omit<ContractClassModel, 'name' | 'id'>>) {
    this.isAbstract = props.isAbstract
    this.type = props.type
    this.description = props.description
    this.propertyInitialization = props.propertyInitialization
    this.ctor = props.ctor
    this.approvalProgram = props.approvalProgram
    this.clearProgram = props.clearProgram
    this.methods = props.methods
    this.appState = props.appState
    this.sourceLocation = props.sourceLocation
    this.options = props.options
  }

  hasExplicitStateTotals() {
    return this.options?.stateTotals !== undefined
  }

  buildContract(compilationSet: CompilationSet): awst.Contract {
    let approvalProgram: ContractMethod | null = this.approvalProgram
    let clearProgram: ContractMethod | null = this.clearProgram
    const methods: ContractMethod[] = [...this.methods]
    const ctors: ContractMethod[] = this.ctor ? [this.ctor] : []
    const methodResolutionOrder: ContractReference[] = []
    let firstBaseWithStateTotals: ContractClassModel | undefined = undefined
    let reservedScratchSpace = new Set<bigint>()

    const seenContractIds = new Set<string>()

    for (const baseType of this.type.allBases()) {
      const baseClass = this.getModelForClass(compilationSet, baseType)
      if (baseClass.hasExplicitStateTotals() && firstBaseWithStateTotals === undefined) {
        firstBaseWithStateTotals = baseClass
      }
      if (baseClass.options?.scratchSlots) {
        reservedScratchSpace = reservedScratchSpace.union(baseClass.options.scratchSlots)
      }
      methodResolutionOrder.push(baseClass.id)
      if (seenContractIds.has(baseClass.id.toString())) {
        continue
      } else {
        seenContractIds.add(baseClass.id.toString())
      }
      approvalProgram ??= baseClass.approvalProgram
      clearProgram ??= baseClass.clearProgram
      if (baseClass.approvalProgram && baseClass.approvalProgram !== approvalProgram) methods.push(baseClass.approvalProgram)
      if (baseClass.clearProgram && baseClass.clearProgram !== clearProgram) methods.push(baseClass.clearProgram)
      for (const method of baseClass.methods) {
        // Maybe need validation??
        methods.push(method)
      }
      if (baseClass.ctor) ctors.push(baseClass.ctor)
    }
    if (this.type.isARC4) {
      const hasCreate = methods.some((m) => isIn(m.arc4MethodConfig?.create, [ARC4CreateOption.allow, ARC4CreateOption.require]))
      const hasBareNoop = methods.some(
        (m) =>
          m.arc4MethodConfig instanceof ARC4BareMethodConfig && isIn(OnCompletionAction.NoOp, m.arc4MethodConfig.allowedCompletionTypes),
      )

      if (!hasCreate) {
        if (hasBareNoop) {
          logger.error(
            this.sourceLocation,
            `Non-abstract ARC4 contract has no methods which can be called to create the contract. ` +
              `An implicit one could not be inserted as there is already a bare method handling the NoOp on completion action. ` +
              `In order to allow creating the contract specify { onCreate: 'allow' } or { onCreate: 'require' } in an @abimethod or @baremethod decorator above the chosen method.`,
          )
        } else {
          methods.push(this.makeDefaultCreate())
        }
      }
    }

    codeInvariant(approvalProgram, 'must have approval')
    codeInvariant(clearProgram, 'must have clear')

    if (!this.hasExplicitStateTotals && firstBaseWithStateTotals) {
      logger.warn(
        this.options?.sourceLocation ?? this.sourceLocation,
        `Contract extends base contract ${firstBaseWithStateTotals.id} with explicit stateTotals, but does not define its own stateTotals. This could result in insufficient reserved state at run time. An empty object may be provided in order to indicate that this contract should revert to the default behaviour`,
      )
    }

    const stateTotals = new StateTotals({
      globalBytes: this.options?.stateTotals?.globalBytes ?? null,
      globalUints: this.options?.stateTotals?.globalUints ?? null,
      localBytes: this.options?.stateTotals?.localBytes ?? null,
      localUints: this.options?.stateTotals?.localUints ?? null,
    })

    if (this.options?.scratchSlots) {
      reservedScratchSpace = reservedScratchSpace.union(this.options.scratchSlots)
    }

    const hasSignificantConstructor = ctors.length > 1

    return nodeFactory.contract({
      name: this.options?.name ?? this.name,
      id: this.id,
      description: this.description,
      approvalProgram: hasSignificantConstructor ? ContractClassModel.patchApprovalToCallCtor(approvalProgram, methods) : approvalProgram,
      clearProgram,
      methodResolutionOrder,
      methods: [...methods, ...(hasSignificantConstructor ? ctors : [])],
      appState: this.appState,
      stateTotals,
      reservedScratchSpace: reservedScratchSpace,
      sourceLocation: this.sourceLocation,
      avmVersion: this.options?.avmVersion ?? null,
    })
  }

  private getModelForClass(compilationSet: CompilationSet, contractType: ContractClassPType): ContractClassModel {
    if (contractType instanceof ClusteredContractClassType) {
      return this.buildClusteredMetaClass(compilationSet, contractType)
    } else {
      return compilationSet.getContractClass(ContractReference.fromPType(contractType))
    }
  }

  private buildClusteredMetaClass(compilationSet: CompilationSet, clusteredType: ClusteredContractClassType): ContractClassModel {
    const ctor = nodeFactory.contractMethod({
      memberName: Constants.symbolNames.constructorMethodName,
      cref: ContractReference.fromPType(clusteredType),
      documentation: nodeFactory.methodDocumentation({}),
      sourceLocation: SourceLocation.None,
      args: [],
      returnType: wtypes.voidWType,
      body: nodeFactory.block({
        sourceLocation: SourceLocation.None,
      }),
      arc4MethodConfig: null,
      inline: null, // TODO: Expose inline hint option
    })
    const ctorTargets: awst.ContractMethod[] = []
    for (const baseType of clusteredType.baseTypes) {
      for (const b of [baseType, ...baseType.allBases()]) {
        const baseClassModel = this.getModelForClass(compilationSet, b)
        if (baseClassModel.ctor) {
          ctorTargets.push(baseClassModel.ctor)
          break
        }
      }
    }
    ctor.body.body.push(
      ...ctorTargets.map((ct) =>
        nodeFactory.expressionStatement({
          expr: nodeFactory.subroutineCallExpression({
            target: nodeFactory.contractMethodTarget({
              memberName: ct.memberName,
              cref: ct.cref,
            }),
            args: [],
            sourceLocation: SourceLocation.None,
            wtype: wtypes.voidWType,
          }),
        }),
      ),
    )
    return new ContractClassModel({
      appState: [],
      approvalProgram: null,
      clearProgram: null,
      isAbstract: true,
      sourceLocation: SourceLocation.None,
      propertyInitialization: [],
      description: null,
      ctor: ctor,
      methods: [],
      options: undefined,
      type: clusteredType,
    })
  }

  private static patchApprovalToCallCtor(approval: ContractMethod, methods: ContractMethod[]): ContractMethod {
    const callCtorIfNew = nodeFactory.ifElse({
      condition: nodeFactory.not({
        expr: nodeFactory.reinterpretCast({
          expr: nodeFactory.intrinsicCall({
            opCode: 'txn',
            immediates: ['ApplicationID'],
            stackArgs: [],
            sourceLocation: SourceLocation.None,
            wtype: wtypes.uint64WType,
          }),
          sourceLocation: SourceLocation.None,
          wtype: wtypes.boolWType,
        }),
        sourceLocation: SourceLocation.None,
      }),
      ifBranch: nodeFactory.block(
        { sourceLocation: SourceLocation.None },
        nodeFactory.expressionStatement({
          expr: nodeFactory.subroutineCallExpression({
            args: [],
            wtype: wtypes.voidWType,
            target: nodeFactory.instanceMethodTarget({
              memberName: Constants.symbolNames.constructorMethodName,
            }),
            sourceLocation: SourceLocation.None,
          }),
        }),
      ),
      sourceLocation: SourceLocation.None,
      elseBranch: null,
    })

    return nodeFactory.contractMethod({
      ...approval,
      body: nodeFactory.block({ sourceLocation: SourceLocation.None }, callCtorIfNew, approval.body),
    })
  }

  private makeDefaultCreate() {
    return nodeFactory.contractMethod({
      memberName: Constants.symbolNames.defaultCreateMethodName,
      cref: ContractReference.fromPType(this.type),
      args: [],
      arc4MethodConfig: new ARC4BareMethodConfig({
        allowedCompletionTypes: [OnCompletionAction.NoOp],
        create: ARC4CreateOption.require,
        sourceLocation: this.sourceLocation,
      }),
      returnType: wtypes.voidWType,
      documentation: nodeFactory.methodDocumentation({
        description: 'Implicitly generated create method',
      }),
      sourceLocation: this.sourceLocation,
      body: nodeFactory.block({
        sourceLocation: this.sourceLocation,
      }),
      inline: null, // TODO: Expose inline hint option?
    })
  }
}

export class CompilationSet extends CustomKeyMap<ContractReference | LogicSigReference, ContractClassModel | LogicSigClassModel> {
  constructor() {
    super((x) => x.toString())
  }

  get compilationOutputSet() {
    return Array.from(this.entries())
      .filter(([, meta]) => !meta.isAbstract)
      .map(([ref]) => ref)
  }

  getContractClass(cref: ContractReference) {
    const maybeClass = this.get(cref)
    invariant(maybeClass instanceof ContractClassModel, 'Contract reference must resolve to a contract class')
    return maybeClass
  }

  getLogicSig(lref: LogicSigReference) {
    const maybeLogicSig = this.get(lref)
    invariant(maybeLogicSig instanceof LogicSigClassModel, 'Logic sig reference must resolve to a logic signature class')
    return maybeLogicSig
  }
}



================================================
FILE: src/awst_build/models/decorator-data.ts
================================================
import type { OnCompletionAction } from '../../awst/models'
import type { ARC4CreateOption } from '../../awst/nodes'
import type { SourceLocation } from '../../awst/source-location'
import type { Constants, SupportedAvmVersion } from '../../constants'
import type { InstanceBuilder } from '../eb'

export type Arc4AbiDecoratorData = {
  type: typeof Constants.symbolNames.arc4AbiDecoratorName
  create?: ARC4CreateOption
  createLocation?: SourceLocation
  allowedCompletionTypes?: OnCompletionAction[]
  allowedCompletionTypesLocation?: SourceLocation
  sourceLocation: SourceLocation
  readonly: boolean
  nameOverride: string | undefined
  defaultArguments: Record<
    string,
    | {
        type: 'constant'
        value: InstanceBuilder
      }
    | {
        type: 'member'
        name: string
      }
  >
}

export type Arc4BareDecoratorData = {
  type: typeof Constants.symbolNames.arc4BareDecoratorName
  create?: ARC4CreateOption
  createLocation?: SourceLocation
  allowedCompletionTypes?: OnCompletionAction[]
  allowedCompletionTypesLocation?: SourceLocation
  sourceLocation: SourceLocation
}

export type LogicSigOptionsDecoratorData = {
  type: typeof Constants.symbolNames.logicSigOptionsDecoratorName
  sourceLocation: SourceLocation
  avmVersion?: SupportedAvmVersion
  name?: string
  scratchSlots?: Set<bigint>
}
export type ContractOptionsDecoratorData = {
  type: typeof Constants.symbolNames.contractOptionsDecoratorName
  sourceLocation: SourceLocation
  avmVersion?: SupportedAvmVersion
  name?: string
  scratchSlots?: Set<bigint>
  stateTotals?: {
    globalUints?: bigint
    globalBytes?: bigint
    localUints?: bigint
    localBytes?: bigint
  }
}

export type DecoratorData = Arc4BareDecoratorData | Arc4AbiDecoratorData | LogicSigOptionsDecoratorData | ContractOptionsDecoratorData
export type RoutingDecoratorData = Arc4AbiDecoratorData | Arc4BareDecoratorData

export type DecoratorType = DecoratorData['type']

export type DecoratorDataForType<TType extends DecoratorType> = DecoratorData extends infer TDec
  ? TDec extends { type: TType }
    ? TDec
    : never
  : never



================================================
FILE: src/awst_build/models/logic-sig-class-model.ts
================================================
import { LogicSigReference } from '../../awst/models'
import { nodeFactory } from '../../awst/node-factory'
import type { LogicSignature, Subroutine } from '../../awst/nodes'
import type { SourceLocation } from '../../awst/source-location'
import type { Props } from '../../typescript-helpers'
import type { LogicSigPType } from '../ptypes'
import type { LogicSigOptionsDecoratorData } from './decorator-data'

export class LogicSigClassModel {
  public readonly isAbstract = false
  public get id(): LogicSigReference {
    return LogicSigReference.fromPType(this.type)
  }
  public readonly type: LogicSigPType
  public get name(): string {
    return this.type.name
  }
  public readonly description: string | null
  public readonly bases: Array<LogicSigReference>
  public readonly options: LogicSigOptionsDecoratorData | undefined
  public readonly program: Subroutine
  public readonly sourceLocation: SourceLocation
  constructor(props: Props<Omit<LogicSigClassModel, 'name' | 'id' | 'isAbstract'>>) {
    this.type = props.type
    this.description = props.description
    this.program = props.program
    this.bases = props.bases
    this.sourceLocation = props.sourceLocation
    this.options = props.options
  }

  public buildLogicSignature(): LogicSignature {
    return nodeFactory.logicSignature({
      id: this.id,
      shortName: this.options?.name ?? this.name,
      program: this.program,
      sourceLocation: this.sourceLocation,
      docstring: this.description,
      avmVersion: this.options?.avmVersion ?? null,
      reservedScratchSpace: this.options?.scratchSlots ?? new Set(),
    })
  }
}



================================================
FILE: src/awst_build/ptypes/arc4-types.ts
================================================
import type { SourceLocation } from '../../awst/source-location'
import { wtypes } from '../../awst/wtypes'
import { Constants } from '../../constants'
import { codeInvariant, invariant } from '../../util'
import { GenericPType, PType } from './base'
import {
  accountPType,
  applicationItxnType,
  ArrayPType,
  biguintPType,
  boolPType,
  bytesPType,
  compiledContractType,
  ContractClassPType,
  LibClassType,
  LibFunctionType,
  NumericLiteralPType,
  ObjectPType,
  stringPType,
  TuplePType,
  uint64PType,
  voidPType,
} from './index'
import ARC4StaticArray = wtypes.ARC4StaticArray
import WTuple = wtypes.WTuple

export const UintNClass = new LibClassType({
  name: 'UintN',
  module: Constants.moduleNames.algoTs.arc4.encodedTypes,
})

export const ByteClass = new LibClassType({
  name: 'Byte',
  module: Constants.moduleNames.algoTs.arc4.encodedTypes,
})
export const UintN8Class = new LibClassType({
  name: 'UintN8',
  module: Constants.moduleNames.algoTs.arc4.encodedTypes,
})
export const UintN16Class = new LibClassType({
  name: 'UintN16',
  module: Constants.moduleNames.algoTs.arc4.encodedTypes,
})
export const UintN32Class = new LibClassType({
  name: 'UintN32',
  module: Constants.moduleNames.algoTs.arc4.encodedTypes,
})
export const UintN64Class = new LibClassType({
  name: 'UintN64',
  module: Constants.moduleNames.algoTs.arc4.encodedTypes,
})
export const UintN128Class = new LibClassType({
  name: 'UintN128',
  module: Constants.moduleNames.algoTs.arc4.encodedTypes,
})
export const UintN256Class = new LibClassType({
  name: 'UintN256',
  module: Constants.moduleNames.algoTs.arc4.encodedTypes,
})
export abstract class ARC4EncodedType extends PType {
  abstract readonly wtype: wtypes.ARC4Type
  abstract readonly nativeType: PType | undefined
  abstract readonly fixedBitSize: bigint | null

  get fixedByteSize(): bigint | null {
    return this.fixedBitSize === null ? null : ARC4EncodedType.bitsToBytes(this.fixedBitSize)
  }

  /**
   * Calculate fixed the number of bits required to store a sequence of ARC4 types using ARC4's bit-packing technique for consecutive booleans.
   *
   * Returns `null` if the sequence contains a dynamically sized type
   * @param types The sequence of types being encoded
   */
  protected static calculateFixedBitSize(types: ARC4EncodedType[]): bigint | null {
    return types.reduce((acc: bigint | null, cur) => {
      if (acc === null || cur.fixedBitSize === null) return null

      if (cur.fixedBitSize === 1n) {
        return acc + cur.fixedBitSize
      } else {
        return this.roundBitsUpToNearestByte(acc) + this.roundBitsUpToNearestByte(cur.fixedBitSize)
      }
    }, 0n)
  }

  /**
   * Get the number of bytes required to represent n bits
   * @param n The number of bits which need representing
   */
  protected static bitsToBytes(n: bigint): bigint {
    return (n + 7n) / 8n
  }

  protected static roundBitsUpToNearestByte(bits: bigint): bigint {
    return this.bitsToBytes(bits) * 8n
  }
}

export abstract class ARC4ArrayType extends ARC4EncodedType {
  readonly elementType: ARC4EncodedType
  constructor({ elementType }: { elementType: ARC4EncodedType }) {
    super()
    this.elementType = elementType
  }
}

export class ARC4InstanceType extends ARC4EncodedType {
  readonly wtype: wtypes.ARC4Type
  readonly name: string
  readonly module = Constants.moduleNames.algoTs.arc4.encodedTypes
  readonly singleton = false
  readonly nativeType: PType
  readonly fixedBitSize: bigint | null
  constructor({
    wtype,
    nativeType,
    name,
    fixedBitSize,
  }: {
    wtype: wtypes.ARC4Type
    name: string
    nativeType: PType
    fixedBitSize: bigint | null
  }) {
    super()
    this.wtype = wtype
    this.name = name
    this.nativeType = nativeType
    this.fixedBitSize = fixedBitSize
  }
}

export const ARC4BoolClass = new LibClassType({
  name: 'Bool',
  module: Constants.moduleNames.algoTs.arc4.encodedTypes,
})

export const ARC4StrClass = new LibClassType({
  name: 'Str',
  module: Constants.moduleNames.algoTs.arc4.encodedTypes,
})

export const arc4BooleanType = new ARC4InstanceType({
  name: 'Bool',
  wtype: wtypes.arc4BooleanWType,
  nativeType: boolPType,
  fixedBitSize: 1n,
})

export const arc4StringType = new ARC4InstanceType({
  name: 'Str',
  wtype: wtypes.arc4StringAliasWType,
  nativeType: stringPType,
  fixedBitSize: null,
})

export class ARC4StructClass extends PType {
  readonly name: string
  readonly module: string
  readonly singleton = true
  readonly instanceType: ARC4StructType
  readonly sourceLocation: SourceLocation | undefined
  readonly wtype = undefined
  constructor({
    name,
    module,
    instanceType,
    sourceLocation,
  }: {
    name: string
    module: string
    instanceType: ARC4StructType
    sourceLocation?: SourceLocation
  }) {
    super()
    this.name = name
    this.module = module
    this.sourceLocation = sourceLocation
    this.instanceType = instanceType
  }

  static fromStructType(ptype: ARC4StructType) {
    return new ARC4StructClass({
      ...ptype,
      instanceType: ptype,
    })
  }
}

export class ARC4StructType extends ARC4EncodedType {
  readonly name: string
  readonly module: string
  readonly description: string | undefined
  readonly singleton = false
  readonly fields: Record<string, ARC4EncodedType>
  readonly sourceLocation: SourceLocation | undefined
  readonly frozen: boolean
  readonly fixedBitSize: bigint | null
  constructor({
    name,
    frozen,
    module,
    fields,
    description,
    sourceLocation,
  }: {
    name: string
    module: string
    frozen: boolean
    description: string | undefined
    fields: Record<string, ARC4EncodedType>
    sourceLocation?: SourceLocation
  }) {
    super()
    this.name = name
    this.module = module
    this.frozen = frozen
    this.fields = fields
    this.description = description
    this.sourceLocation = sourceLocation
    this.fixedBitSize = ARC4EncodedType.calculateFixedBitSize(Object.values(fields))
  }

  get nativeType(): ObjectPType {
    return ObjectPType.anonymous(this.fields)
  }

  get wtype(): wtypes.ARC4Struct {
    return new wtypes.ARC4Struct({
      name: this.name,
      fields: Object.fromEntries(Object.entries(this.fields).map(([f, t]) => [f, t.wtype])),
      sourceLocation: this.sourceLocation,
      desc: this.description ?? null,
      frozen: this.frozen,
    })
  }

  get signature(): string {
    return `${this.name}${this.wtype.arc4Name}`
  }
}

export const arc4StructBaseType = new ARC4StructType({
  name: 'StructBase',
  module: Constants.moduleNames.algoTs.arc4.encodedTypes,
  fields: {},
  description: undefined,
  frozen: false,
})

export const Arc4TupleClass = new LibClassType({
  name: 'Tuple',
  module: Constants.moduleNames.algoTs.arc4.encodedTypes,
})

export const Arc4TupleGeneric = new GenericPType({
  name: 'Tuple',
  module: Constants.moduleNames.algoTs.arc4.encodedTypes,
  parameterise(ptypes: PType[]) {
    codeInvariant(ptypes.length, `${this.name} expects 1 generic parameter`)
    codeInvariant(ptypes[0] instanceof TuplePType, `${this.name} generic parameter must be a native tuple type`)
    const encodedTypes = ptypes[0].items.map((itemType, index) => {
      codeInvariant(itemType instanceof ARC4EncodedType, `Item ${index} of ARC4 Tuple must be an ARC4 encoded type`)
      return itemType
    })
    return new ARC4TupleType({
      types: encodedTypes,
    })
  },
})

export class ARC4TupleType extends ARC4EncodedType {
  readonly name = 'Tuple'
  readonly module = Constants.moduleNames.algoTs.arc4.encodedTypes
  readonly singleton = false
  readonly items: ARC4EncodedType[]
  readonly sourceLocation: SourceLocation | undefined
  readonly fixedBitSize: bigint | null
  readonly nativeType: TuplePType

  constructor({ types, sourceLocation }: { types: ARC4EncodedType[]; sourceLocation?: SourceLocation }) {
    super()
    this.items = types
    this.sourceLocation = sourceLocation
    this.nativeType = new TuplePType({ items: this.items })
    this.fixedBitSize = ARC4EncodedType.calculateFixedBitSize(types)
  }

  get wtype(): wtypes.ARC4Tuple {
    return new wtypes.ARC4Tuple({
      types: this.items.map((t) => t.wtype),
      sourceLocation: this.sourceLocation,
    })
  }
}
export const UintNGeneric = new GenericPType({
  name: 'UintN',
  module: Constants.moduleNames.algoTs.arc4.encodedTypes,
  parameterise(typeArgs: PType[]): UintNType {
    codeInvariant(typeArgs.length === 1, 'UintNType type expects exactly one type parameter')
    const [size] = typeArgs
    codeInvariant(
      size instanceof NumericLiteralPType && size.literalValue,
      `Generic type param for UintNType must be a literal number. Inferred type is ${size.name}`,
    )

    return new UintNType({ n: size.literalValue })
  },
})
export class UintNType extends ARC4EncodedType {
  readonly module = Constants.moduleNames.algoTs.arc4.encodedTypes
  readonly n: bigint
  readonly name: string
  readonly singleton = false
  readonly wtype: wtypes.ARC4UIntN

  get fixedBitSize() {
    return this.n
  }

  get nativeType() {
    return this.n <= 64n ? uint64PType : biguintPType
  }

  constructor({ n, wtype, name }: { n: bigint; wtype?: wtypes.ARC4UIntN; name?: string }) {
    super()
    codeInvariant(n >= 8n && n <= 512n && n % 8n === 0n, 'n must be between 8 and 512, and a multiple of 8')
    this.n = n
    this.name = name ?? `UintN<${n}>`
    this.wtype = wtype ?? new wtypes.ARC4UIntN({ n: this.n })
  }
}
export const UFixedNxMClass = new LibClassType({
  name: 'UFixedNxM',
  module: Constants.moduleNames.algoTs.arc4.encodedTypes,
})
export const UFixedNxMGeneric = new GenericPType({
  name: UFixedNxMClass.name,
  module: UFixedNxMClass.module,
  parameterise(typeArgs: PType[]) {
    codeInvariant(typeArgs.length === 2, `${this.name} expects exactly 2 generic type parameters`)
    const [n, m] = typeArgs
    codeInvariant(
      n instanceof NumericLiteralPType && n.literalValue,
      `Generic type param 'N' for ${this.name}  must be a literal number. Inferred type is ${n.name}`,
    )
    codeInvariant(
      m instanceof NumericLiteralPType && m.literalValue,
      `Generic type param 'M' for UintNType must be a literal number. Inferred type is ${m.name}`,
    )
    return new UFixedNxMType({
      n: n.literalValue,
      m: m.literalValue,
    })
  },
})
export class UFixedNxMType extends ARC4EncodedType {
  readonly module = Constants.moduleNames.algoTs.arc4.encodedTypes
  readonly n: bigint
  readonly m: bigint
  readonly name: string
  readonly singleton = false
  readonly wtype: wtypes.ARC4UFixedNxM

  get fixedBitSize() {
    return this.n
  }

  get nativeType() {
    return this.n <= 64n ? uint64PType : biguintPType
  }

  constructor({ n, m }: { n: bigint; m: bigint }) {
    super()
    codeInvariant(n >= 8n && n <= 512n && n % 8n === 0n, 'n must be between 8 and 512, and a multiple of 8')
    codeInvariant(m >= 1n && m <= 160n, 'm must be between 1 and 160')
    this.n = n
    this.m = m
    this.name = `${UFixedNxMClass.name}<${n}, ${m}>`
    this.wtype = new wtypes.ARC4UFixedNxM({ n: this.n, m: this.m })
  }
}

export const arc4ByteAlias = new UintNType({ n: 8n, wtype: wtypes.arc4ByteAliasWType, name: 'Byte' })

export const DynamicArrayConstructor = new LibClassType({
  name: 'DynamicArray',
  module: Constants.moduleNames.algoTs.arc4.encodedTypes,
})
export const DynamicArrayGeneric = new GenericPType({
  name: 'DynamicArray',
  module: Constants.moduleNames.algoTs.arc4.encodedTypes,
  parameterise: (typeArgs: PType[]): DynamicArrayType => {
    codeInvariant(typeArgs.length === 1, 'DynamicArray type expects exactly one type parameter')
    const [elementType] = typeArgs
    codeInvariant(
      elementType instanceof ARC4EncodedType,
      `Generic type param for DynamicArray must be an ARC4 encoded type. Inferred type is ${elementType.name}`,
    )

    return new DynamicArrayType({ elementType: elementType })
  },
})
export class DynamicArrayType extends ARC4ArrayType {
  readonly module = Constants.moduleNames.algoTs.arc4.encodedTypes

  readonly immutable: boolean
  readonly name: string
  readonly singleton = false
  readonly sourceLocation: SourceLocation | undefined
  readonly nativeType: PType
  readonly wtype: wtypes.ARC4DynamicArray
  readonly fixedBitSize = null

  constructor({
    elementType,
    nativeType,
    sourceLocation,
    name,
    immutable,
  }: {
    elementType: ARC4EncodedType
    sourceLocation?: SourceLocation
    name?: string
    immutable?: boolean
    nativeType?: PType
  }) {
    super({
      elementType,
    })
    this.immutable = immutable ?? false
    this.nativeType = nativeType ?? new ArrayPType({ elementType })
    this.name = name ?? `DynamicArray<${elementType}>`
    this.sourceLocation = sourceLocation
    this.wtype = new wtypes.ARC4DynamicArray({
      elementType: this.elementType.wtype,
      sourceLocation: this.sourceLocation,
      immutable: this.immutable,
      nativeType: this.nativeType.wtype,
    })
  }
}
export const StaticArrayConstructor = new LibClassType({
  name: 'StaticArray',
  module: Constants.moduleNames.algoTs.arc4.encodedTypes,
})
export const StaticArrayGeneric = new GenericPType({
  name: 'StaticArray',
  module: Constants.moduleNames.algoTs.arc4.encodedTypes,
  parameterise: (typeArgs: PType[]): StaticArrayType => {
    codeInvariant(typeArgs.length === 2, 'StaticArray type expects exactly one type parameters')
    const [elementType, arraySize] = typeArgs
    codeInvariant(
      elementType instanceof ARC4EncodedType,
      `Element type generic type param for StaticArray must be an ARC4 encoded type. Inferred type is ${elementType.name}`,
    )
    codeInvariant(
      arraySize instanceof NumericLiteralPType,
      `Array size generic type param for StaticArray must be a literal number. Inferred type is ${arraySize.name}`,
    )

    return new StaticArrayType({ arraySize: arraySize.literalValue, elementType })
  },
})
export class StaticArrayType extends ARC4ArrayType {
  readonly module = Constants.moduleNames.algoTs.arc4.encodedTypes
  readonly arraySize: bigint
  readonly immutable: boolean
  readonly name: string
  readonly singleton = false
  readonly sourceLocation: SourceLocation | undefined
  readonly wtype: wtypes.ARC4StaticArray
  readonly nativeType: PType
  readonly fixedBitSize: bigint | null
  constructor({
    elementType,
    arraySize,
    sourceLocation,
    wtype,
    name,
    immutable,
    nativeType,
  }: {
    immutable?: boolean
    elementType: ARC4EncodedType
    arraySize: bigint
    sourceLocation?: SourceLocation
    wtype?: ARC4StaticArray
    name?: string
    nativeType?: PType
  }) {
    codeInvariant(arraySize >= 0, 'StaticArray length must be greater than or equal to 0')
    super({ elementType })
    this.immutable = immutable ?? false
    this.arraySize = arraySize
    this.name = name ?? `StaticArray<${elementType}, ${arraySize}>`
    this.sourceLocation = sourceLocation
    this.nativeType = nativeType ?? new TuplePType({ items: new Array(Number(arraySize)).fill(elementType) })
    this.wtype =
      wtype ??
      new wtypes.ARC4StaticArray({
        elementType: this.elementType.wtype,
        arraySize: this.arraySize,
        immutable: this.immutable,
        nativeType: nativeType?.wtype,
      })
    this.fixedBitSize = ARC4EncodedType.calculateFixedBitSize(new Array(Number(arraySize)).fill(elementType))
  }
}
export const arc4AddressAlias = new StaticArrayType({
  arraySize: BigInt(Constants.algo.addressLength),
  elementType: arc4ByteAlias,
  wtype: wtypes.arc4AddressAliasWType,
  nativeType: accountPType,
  immutable: true,
  name: 'Address',
})

export const AddressClass = new LibClassType({
  name: 'Address',
  module: Constants.moduleNames.algoTs.arc4.encodedTypes,
})

export const StaticBytesGeneric = new GenericPType({
  name: 'StaticBytes',
  module: Constants.moduleNames.algoTs.arc4.encodedTypes,
  parameterise: (typeArgs: PType[]): StaticBytesType => {
    codeInvariant(typeArgs.length === 1, 'StaticBytes type expects exactly one type parameter')
    const [length] = typeArgs

    codeInvariant(
      length instanceof NumericLiteralPType,
      `Length generic type param for StaticBytes must be a literal number. Inferred type is ${length.name}`,
    )
    return new StaticBytesType({
      length: length.literalValue,
    })
  },
})
export const StaticBytesConstructor = new LibClassType({
  name: 'StaticBytes',
  module: Constants.moduleNames.algoTs.arc4.encodedTypes,
})
export class StaticBytesType extends StaticArrayType {
  constructor({ length }: { length: bigint }) {
    codeInvariant(length >= 0, 'StaticBytes length must be greater than or equal to 0')
    super({
      name: `StaticBytes<${length}>`,
      immutable: true,
      elementType: arc4ByteAlias,
      arraySize: length,
      nativeType: bytesPType,
    })
  }
}
export const DynamicBytesConstructor = new LibClassType({
  name: 'DynamicBytes',
  module: Constants.moduleNames.algoTs.arc4.encodedTypes,
})
export const DynamicBytesType = new DynamicArrayType({
  name: `DynamicBytes`,
  immutable: true,
  elementType: arc4ByteAlias,
  nativeType: bytesPType,
})

export const interpretAsArc4Function = new LibFunctionType({
  name: 'interpretAsArc4',
  module: Constants.moduleNames.algoTs.arc4.index,
})

export const encodeArc4Function = new LibFunctionType({
  name: 'encodeArc4',
  module: Constants.moduleNames.algoTs.arc4.index,
})
export const arc4EncodedLengthFunction = new LibFunctionType({
  name: 'arc4EncodedLength',
  module: Constants.moduleNames.algoTs.arc4.index,
})

export const decodeArc4Function = new LibFunctionType({
  name: 'decodeArc4',
  module: Constants.moduleNames.algoTs.arc4.index,
})

export const methodSelectorFunction = new LibFunctionType({
  name: 'methodSelector',
  module: Constants.moduleNames.algoTs.arc4.index,
})

export const abiCallFunction = new LibFunctionType({
  name: 'abiCall',
  module: Constants.moduleNames.algoTs.arc4.c2c,
})
export const compileArc4Function = new LibFunctionType({
  name: 'compileArc4',
  module: Constants.moduleNames.algoTs.arc4.c2c,
})

export const ContractProxyGeneric = new GenericPType({
  name: 'ContractProxy',
  module: Constants.moduleNames.algoTs.arc4.c2c,
  parameterise(args: PType[]) {
    invariant(args.length === 1, 'ContractProxy expects exactly 1 type arg')
    const [typeArg] = args
    invariant(typeArg instanceof ContractClassPType && typeArg.isARC4, 'Contract Proxy generic type arg must extend arc4 Contract type')
    return new ContractProxyType({ contractType: typeArg })
  },
})

export class ContractProxyType extends PType {
  readonly name: string
  readonly module = Constants.moduleNames.algoTs.arc4.c2c
  readonly wtype: WTuple
  readonly singleton = false
  readonly contractType: ContractClassPType
  constructor({ contractType }: { contractType: ContractClassPType }) {
    super()
    this.name = `ContractProxy<${contractType.name}>`

    this.wtype = compiledContractType.wtype
    this.contractType = contractType
  }
}

export const TypedApplicationCallResponseGeneric = new GenericPType({
  name: 'TypedApplicationCallResponse',
  module: Constants.moduleNames.algoTs.arc4.c2c,
  parameterise(args: PType[]) {
    invariant(args.length === 1, 'TypedApplicationCallResponse expects exactly 1 type arg')
    const [typeArg] = args
    return new TypedApplicationCallResponseType({ returnValue: typeArg })
  },
})

export class TypedApplicationCallResponseType extends ObjectPType {
  readonly name: string
  readonly module = Constants.moduleNames.algoTs.arc4.c2c
  readonly singleton = false
  readonly returnValue: PType

  constructor({ returnValue }: { returnValue: PType }) {
    super({
      properties: returnValue.equals(voidPType)
        ? { itxn: applicationItxnType }
        : {
            itxn: applicationItxnType,
            returnValue,
          },
    })
    this.name = `TypedApplicationCallResponseType<${returnValue.name}>`
    this.returnValue = returnValue
  }
}



================================================
FILE: src/awst_build/ptypes/base.ts
================================================
import { wtypes } from '../../awst/wtypes'
import { CodeError } from '../../errors'
import type { DeliberateAny } from '../../typescript-helpers'
import { zipStrict } from '../../util'

/**
 * Represents a public type visible to a developer of AlgoTS
 */
export abstract class PType {
  /**
   * Get the associated wtype for this ptype if applicable
   */
  abstract readonly wtype: wtypes.WType | undefined

  /**
   * Get the unaliased name of this ptype
   */
  abstract readonly name: string

  /**
   * Get the declaring module of this ptype
   */
  abstract readonly module: string

  abstract readonly singleton: boolean

  get fullName() {
    return `${this.module}::${this.name}`
  }

  get wtypeOrThrow(): wtypes.WType {
    if (!this.wtype) {
      throw new CodeError(`${this.fullName} does not have a wtype`)
    }
    return this.wtype
  }

  equals(other: PType): boolean {
    return ptypesAreEqual(this, other)
  }

  equalsOneOf(...others: PType[]): boolean {
    return others.some((o) => ptypesAreEqual(this, o))
  }

  static equals(other: PType): boolean {
    return other instanceof this
  }

  equalsOrInstanceOf(other: PTypeOrClass): boolean {
    if (other instanceof Function) {
      return this instanceof other
    }
    return this.equals(other)
  }

  toString(): string {
    return this.name
  }
}

export class GenericPType<T extends PType = PType> extends PType {
  readonly name: string
  readonly module: string
  readonly singleton = false
  readonly wtype = undefined
  readonly parameterise: (typeArgs: PType[]) => T
  constructor(props: { name: string; module: string; parameterise: (typeArgs: PType[]) => T }) {
    super()
    this.name = props.name
    this.module = props.module
    this.parameterise = props.parameterise
  }
}

export type PTypeOrClass = PType | { new (...args: DeliberateAny[]): PType; equals(other: PType): boolean }

function ptypesAreEqual(left: PType, right: PType): boolean {
  if (!(right instanceof left.constructor)) {
    return false
  }
  return compareProperties(left, right)
}

const ignoredProperties = new Set(['sourceLocation', 'wtype'])

function notIgnored(key: string): boolean {
  return !ignoredProperties.has(key)
}

function compareProperties(left: object, right: object) {
  const leftProps = Object.entries(left).filter(([key]) => notIgnored(key))
  const rightProps = Object.entries(right).filter(([key]) => notIgnored(key))
  if (leftProps.length !== rightProps.length) return false

  return zipStrict(leftProps, rightProps).every(([[lKey, lValue], [rKey, rValue]]) => {
    if (lKey !== rKey) return false
    return compareValues(lValue, rValue)
  })
}

function compareValues(left: unknown, right: unknown): boolean {
  // Handle primitive comparison
  if (typeof left !== 'object' || left === right) {
    return left === right
  }
  if (left === null) {
    return right === null
  }
  // Recursively compare array items
  if (Array.isArray(left)) {
    return Array.isArray(right) && left.length === right.length && left.every((v, i) => compareValues(v, right[i]))
  }
  // Recursively compare ptypes
  if (left instanceof PType) {
    return right instanceof PType && ptypesAreEqual(left, right)
  }
  if (left instanceof wtypes.WType) {
    return right instanceof wtypes.WType && left.equals(right)
  }
  return typeof right === 'object' && right !== null && compareProperties(left, right)
}



================================================
FILE: src/awst_build/ptypes/for-export.ts
================================================
/* This file aggregates all ptypes into a single export for external consumption of the compiler api */
export { ptypeToArc4EncodedType } from '../arc4-util'
export * from './arc4-types'
export * from './index'



================================================
FILE: src/awst_build/ptypes/index.ts
================================================
import { TransactionKind } from '../../awst/models'
import { SourceLocation } from '../../awst/source-location'
import { wtypes } from '../../awst/wtypes'

import { Constants } from '../../constants'
import { CodeError, InternalError, NotSupported } from '../../errors'
import { codeInvariant, distinctByEquality, sortBy } from '../../util'
import { SymbolName } from '../symbol-name'
import { GenericPType, PType } from './base'
import { transientTypeErrors } from './transient-type-errors'

export * from './base'
export * from './intrinsic-enum-type'
export * from './op-ptypes'

/**
 * Transient types can appear in expressions but should not be used as variable or return types
 */
export abstract class TransientType extends PType {
  readonly name: string
  readonly module: string
  readonly singleton: boolean
  readonly typeMessage: string
  readonly expressionMessage: string

  constructor({
    name,
    module,
    singleton,
    typeMessage,
    expressionMessage,
  }: {
    name: string
    module: string
    singleton: boolean
    typeMessage: string
    expressionMessage: string
  }) {
    super()
    this.name = name
    this.module = module
    this.singleton = singleton
    this.typeMessage = typeMessage
    this.expressionMessage = expressionMessage
  }

  get wtype(): wtypes.WType | undefined {
    return undefined
  }

  get wtypeOrThrow(): wtypes.WType {
    throw new CodeError(this.typeMessage)
  }
}

export class UnsupportedType extends PType {
  readonly wtype: undefined = undefined
  readonly name: string
  readonly module: string
  readonly singleton = false
  #fullName: string | undefined

  constructor({ name, module, fullName }: { name: string; module: string; fullName?: string }) {
    super()
    this.name = name
    this.module = module
    this.#fullName = fullName
  }

  get fullName() {
    return this.#fullName ?? super.fullName
  }

  get wtypeOrThrow(): wtypes.WType {
    throw new NotSupported(`The type ${this.fullName} is not supported`)
  }
}

export class LogicSigPType extends PType {
  readonly wtype = undefined
  readonly name: string
  readonly module: string
  readonly singleton = true
  readonly sourceLocation: SourceLocation
  readonly baseType: LogicSigPType | undefined
  constructor(props: { module: string; name: string; baseType?: LogicSigPType; sourceLocation: SourceLocation }) {
    super()
    this.name = props.name
    this.module = props.module
    this.baseType = props.baseType
    this.sourceLocation = props.sourceLocation
  }
}

export const logicSigBaseType = new LogicSigPType({
  name: 'LogicSig',
  module: Constants.moduleNames.algoTs.logicSig,
  sourceLocation: SourceLocation.None,
})

export class ContractClassPType extends PType {
  readonly wtype = undefined
  readonly name: string
  readonly module: string
  readonly properties: Record<string, PType>
  readonly methods: Record<string, FunctionPType>
  readonly singleton = true
  readonly baseTypes: ContractClassPType[]
  readonly sourceLocation: SourceLocation

  constructor(props: {
    module: string
    name: string
    properties: Record<string, AppStorageType>
    methods: Record<string, FunctionPType>
    baseTypes: ContractClassPType[]
    sourceLocation: SourceLocation
  }) {
    super()
    this.name = props.name
    this.module = props.module
    this.properties = props.properties
    this.methods = props.methods
    this.baseTypes = props.baseTypes
    this.sourceLocation = props.sourceLocation
  }

  get isARC4(): boolean {
    return this.baseTypes.some((b) => b.isARC4)
  }

  *allBases(): IterableIterator<ContractClassPType> {
    for (const b of this.baseTypes) {
      yield b
      yield* b.allBases()
    }
  }
}

export class ClusteredContractClassType extends ContractClassPType {
  constructor(props: { methods: Record<string, FunctionPType>; baseTypes: ContractClassPType[]; sourceLocation: SourceLocation }) {
    super({
      ...props,
      name: `ClusteredContract<${props.baseTypes.map((t) => t.fullName).join(',')}>`,
      module: Constants.moduleNames.polytype,
      methods: Object.assign({}, ...props.baseTypes.toReversed().map((t) => t.methods)),
      properties: Object.assign({}, ...props.baseTypes.toReversed().map((t) => t.properties)),
    })
  }
}

export class BaseContractClassType extends ContractClassPType {
  readonly _isArc4: boolean
  get isARC4(): boolean {
    return this._isArc4
  }

  constructor({
    isArc4,
    ...rest
  }: {
    isArc4: boolean
    module: string
    name: string
    properties: Record<string, AppStorageType>
    methods: Record<string, FunctionPType>
    baseTypes: ContractClassPType[]
    sourceLocation: SourceLocation
  }) {
    super(rest)
    this._isArc4 = isArc4
  }
}

export class IntersectionPType extends TransientType {
  get fullName() {
    return this.types.map((t) => t).join(' & ')
  }
  readonly singleton = false
  readonly types: PType[]

  private constructor({ types }: { types: PType[] }) {
    const name = types.map((t) => t).join(' & ')
    super({
      name,
      module: 'lib.d.ts',
      singleton: false,
      typeMessage: transientTypeErrors.intersectionTypes(name).usedAsType,
      expressionMessage: transientTypeErrors.unionTypes(name).usedInExpression,
    })
    this.types = types
  }

  static fromTypes(types: PType[]) {
    if (types.length === 0) {
      throw new InternalError('Cannot create intersection of zero types')
    }
    const distinctTypes = types.filter(distinctByEquality((a, b) => a.equals(b))).toSorted(sortBy((t) => t.fullName))
    if (distinctTypes.length === 1) {
      return distinctTypes[0]
    }
    return new IntersectionPType({
      types: distinctTypes,
    })
  }
}

export class UnionPType extends TransientType {
  get fullName() {
    return this.types.map((t) => t).join(' | ')
  }
  readonly singleton = false
  readonly types: PType[]

  private constructor({ types }: { types: PType[] }) {
    let typeMessage: string
    let expressionMessage: string
    const name = types.map((t) => t).join(' | ')
    const transientType = types.find((t) => t instanceof TransientType)
    if (transientType) {
      if (transientType instanceof NativeNumericType) {
        typeMessage = transientTypeErrors.nativeNumeric(name).usedAsType
        expressionMessage = transientTypeErrors.nativeNumeric(name).usedInExpression
      } else {
        typeMessage = transientType.typeMessage
        expressionMessage = transientType.expressionMessage
      }
    } else {
      typeMessage = transientTypeErrors.unionTypes(name).usedAsType
      expressionMessage = transientTypeErrors.unionTypes(name).usedInExpression
    }
    super({
      name,
      module: 'lib.d.ts',
      singleton: false,
      typeMessage,
      expressionMessage,
    })
    this.types = types
  }

  static fromTypes(types: PType[]) {
    if (types.length === 0) {
      throw new InternalError('Cannot create union of zero types')
    }
    const distinctTypes = types.filter(distinctByEquality((a, b) => a.equals(b))).toSorted(sortBy((t) => t.fullName))
    if (distinctTypes.length === 1) {
      return distinctTypes[0]
    }
    return new UnionPType({
      types: distinctTypes,
    })
  }
}

export abstract class StorageProxyPType extends PType {
  readonly wtype: wtypes.WType
  readonly contentType: PType
  readonly singleton = false

  protected constructor(props: { content: PType; keyWType: wtypes.WType }) {
    super()
    this.wtype = props.keyWType
    this.contentType = props.content
  }
}
export const GlobalStateGeneric = new GenericPType({
  name: 'GlobalState',
  module: Constants.moduleNames.algoTs.state,
  parameterise(typeArgs: PType[]): GlobalStateType {
    codeInvariant(typeArgs.length === 1, 'GlobalState type expects exactly one type parameter')
    return new GlobalStateType({
      content: typeArgs[0],
    })
  },
})
export class GlobalStateType extends StorageProxyPType {
  static readonly baseName = 'GlobalState'
  static readonly baseFullName = `${Constants.moduleNames.algoTs.state}::${GlobalStateType.baseName}`
  readonly module: string = Constants.moduleNames.algoTs.state
  get name() {
    return `${GlobalStateType.baseName}<${this.contentType.name}>`
  }
  get fullName() {
    return `${GlobalStateType.baseFullName}<${this.contentType.fullName}>`
  }
  constructor(props: { content: PType }) {
    super({ ...props, keyWType: wtypes.stateKeyWType })
  }
}
export const LocalStateGeneric = new GenericPType({
  name: 'LocalState',
  module: Constants.moduleNames.algoTs.state,
  parameterise(typeArgs: PType[]): LocalStateType {
    codeInvariant(typeArgs.length === 1, 'LocalState type expects exactly one type parameter')
    return new LocalStateType({
      content: typeArgs[0],
    })
  },
})
export class LocalStateType extends StorageProxyPType {
  static readonly baseName = 'LocalState'
  static readonly baseFullName = `${Constants.moduleNames.algoTs.state}::${LocalStateType.baseName}`
  readonly module: string = Constants.moduleNames.algoTs.state
  get name() {
    return `${LocalStateType.baseName}<${this.contentType.name}>`
  }
  get fullName() {
    return `${LocalStateType.baseFullName}<${this.contentType.fullName}>`
  }
  constructor(props: { content: PType }) {
    super({ ...props, keyWType: wtypes.stateKeyWType })
  }
  static parameterise(typeArgs: PType[]): LocalStateType {
    codeInvariant(typeArgs.length === 1, 'LocalState type expects exactly one type parameter')
    return new LocalStateType({
      content: typeArgs[0],
    })
  }
}
export const BoxGeneric = new GenericPType({
  name: 'Box',
  module: Constants.moduleNames.algoTs.box,
  parameterise(typeArgs: PType[]): BoxPType {
    codeInvariant(typeArgs.length === 1, `${this.name} type expects exactly one type parameter`)
    return new BoxPType({
      content: typeArgs[0],
    })
  },
})
export class BoxPType extends StorageProxyPType {
  readonly module: string = Constants.moduleNames.algoTs.box
  get name() {
    return `Box<${this.contentType.name}>`
  }
  get fullName() {
    return `${this.module}::${this.name}<${this.contentType.fullName}>`
  }
  constructor(props: { content: PType }) {
    super({ ...props, keyWType: wtypes.boxKeyWType })
  }
}
export const BoxMapGeneric = new GenericPType({
  name: 'BoxMap',
  module: Constants.moduleNames.algoTs.box,
  parameterise(typeArgs: PType[]): BoxMapPType {
    codeInvariant(typeArgs.length === 2, `${this.name} type expects exactly two type parameters`)
    return new BoxMapPType({
      keyType: typeArgs[0],
      content: typeArgs[1],
    })
  },
})
export class BoxMapPType extends StorageProxyPType {
  readonly module: string = Constants.moduleNames.algoTs.box
  get name() {
    return `BoxMap<${this.keyType.name}, ${this.contentType.name}>`
  }
  get fullName() {
    return `${this.module}::${this.name}<${this.keyType.name}, ${this.contentType.fullName}>`
  }
  readonly keyType: PType
  constructor(props: { content: PType; keyType: PType }) {
    super({ ...props, keyWType: wtypes.boxKeyWType })
    this.keyType = props.keyType
  }
}
export class BoxRefPType extends StorageProxyPType {
  readonly module = Constants.moduleNames.algoTs.box
  get name() {
    return 'BoxRef'
  }
  constructor() {
    super({ keyWType: wtypes.boxKeyWType, content: bytesPType })
  }
}
export type AppStorageType = GlobalStateType | LocalStateType

/**
 * An open generic type parameter
 */
export class TypeParameterType extends PType {
  readonly name: string
  readonly module: string
  readonly singleton = false
  readonly wtype = undefined
  constructor({ name, module }: { name: string; module: string }) {
    super()
    this.name = name
    this.module = module
  }
}

/**
 * A type from the typescript libs which might pop up in type reflection
 * but is not relevant to the output of the compiler
 */
export class InternalType extends PType {
  readonly name: string
  readonly module: string
  readonly singleton = false
  readonly wtype = undefined
  constructor({ name, module }: { name: string; module: string }) {
    super()
    this.name = name
    this.module = module
  }
}
export const ClassMethodDecoratorContext = new InternalType({
  module: 'typescript/lib/lib.decorators.d.ts',
  name: 'ClassMethodDecoratorContext',
})

export class AnyPType extends PType {
  get wtype(): never {
    throw new CodeError('`any` is not valid as a variable, parameter, return, or property type.')
  }
  readonly name = 'any'
  readonly module = 'lib.d.ts'
  readonly singleton = false
}

export class InstanceType extends PType {
  readonly wtype: wtypes.WType
  readonly name: string
  readonly module: string
  readonly singleton = false

  constructor({ name, module, wtype }: { name: string; module: string; wtype: wtypes.WType }) {
    super()
    this.name = name
    this.wtype = wtype
    this.module = module
  }
}

export class LibFunctionType extends PType {
  readonly wtype: undefined
  readonly name: string
  readonly module: string
  readonly singleton = true

  constructor({ name, module }: { name: string; module: string }) {
    super()
    this.name = name
    this.module = module
  }
}
export class LibClassType extends PType {
  readonly wtype: undefined
  readonly name: string
  readonly module: string
  readonly singleton = true

  constructor({ name, module }: { name: string; module: string }) {
    super()
    this.name = name
    this.module = module
  }
}

export class IntrinsicFunctionGroupType extends PType {
  readonly wtype: undefined
  readonly name: string
  readonly module: string = Constants.moduleNames.algoTs.op
  readonly singleton = true

  constructor({ name }: { name: string }) {
    super()
    this.name = name
  }
}
export class IntrinsicFunctionGroupTypeType extends PType {
  readonly wtype: undefined
  readonly name: string
  readonly module: string = Constants.moduleNames.algoTs.op
  readonly singleton = false

  constructor({ name }: { name: string }) {
    super()
    this.name = name
  }
}
export class IntrinsicFunctionType extends PType {
  readonly wtype: undefined
  readonly name: string
  readonly module: string = Constants.moduleNames.algoTs.op
  readonly singleton = true

  constructor({ name }: { name: string }) {
    super()
    this.name = name
  }
}
export class IntrinsicFunctionTypeType extends PType {
  readonly wtype: undefined
  readonly name: string
  readonly module: string = Constants.moduleNames.algoTs.op
  readonly singleton = false

  constructor({ name }: { name: string }) {
    super()
    this.name = name
  }
}

export class NamespacePType extends PType {
  readonly wtype: undefined
  readonly name: string
  readonly factory: undefined
  readonly module: string
  readonly singleton = true

  constructor({ name, module }: { name: string; module: string }) {
    super()
    this.name = name
    this.module = module
  }

  get fullName() {
    return `${this.module}::*`
  }

  toString(): string {
    return this.module
  }
}

export class FunctionPType extends PType {
  readonly wtype: undefined
  readonly name: string
  readonly module: string
  readonly returnType: PType
  readonly parameters: Array<readonly [string, PType]>
  readonly singleton = true
  readonly sourceLocation: SourceLocation | undefined

  constructor(props: {
    name: string
    module: string
    returnType: PType
    parameters: Array<readonly [string, PType]>
    sourceLocation: SourceLocation | undefined
  }) {
    super()
    this.name = props.name
    this.module = props.module
    this.sourceLocation = props.sourceLocation
    if (props.returnType instanceof ObjectPType && !props.returnType.alias) {
      this.returnType = new ObjectPType({
        alias: new SymbolName({ name: `${props.name}Result`, module: this.module }),
        properties: props.returnType.properties,
        description: props.returnType.description,
      })
    } else {
      this.returnType = props.returnType
    }
    this.parameters = props.parameters
  }
}
export class ArrayLiteralPType extends TransientType {
  get fullName() {
    return `${this.module}::[${this.items.map((i) => i).join(', ')}]`
  }

  get elementType() {
    return this.items.length ? UnionPType.fromTypes(this.items) : neverPType
  }

  readonly items: PType[]
  readonly immutable = true
  constructor(props: { items: PType[] }) {
    const name = `[${props.items.map((i) => i.name).join(', ')}]`
    super({
      module: 'lib.d.ts',
      name,
      typeMessage: transientTypeErrors.arrays(name).usedAsType,
      expressionMessage: transientTypeErrors.arrays(name).usedInExpression,
      singleton: false,
    })
    this.items = props.items
  }

  getArrayType(): ArrayPType {
    return new ArrayPType({
      elementType: this.elementType,
    })
  }

  getTupleType(): TuplePType {
    return new TuplePType({
      items: this.items,
    })
  }
}

export class TuplePType extends PType {
  readonly module: string = 'lib.d.ts'
  get name() {
    return `Tuple<${this.items.map((i) => i.name).join(', ')}>`
  }
  get fullName() {
    return `${this.module}::Tuple<${this.items.map((i) => i.fullName).join(', ')}>`
  }

  readonly items: PType[]
  readonly singleton = false
  readonly immutable: boolean
  constructor(props: { items: PType[] }) {
    super()
    this.items = props.items
    this.immutable = true
  }

  get wtype(): wtypes.WTuple {
    return new wtypes.WTuple({
      types: this.items.map((i) => i.wtypeOrThrow),
      immutable: this.immutable,
    })
  }
}
export class ArrayPType extends PType {
  readonly elementType: PType
  readonly immutable = true
  readonly singleton = false
  readonly name: string
  readonly module: string = 'lib.d.ts'
  get fullName() {
    return `${this.module}::Array<${this.elementType.fullName}>`
  }
  constructor(props: { elementType: PType }) {
    super()
    this.name = `Array<${props.elementType.name}>`
    this.elementType = props.elementType
  }

  get wtype() {
    return new wtypes.StackArray({
      itemType: this.elementType.wtypeOrThrow,
      immutable: this.immutable,
    })
  }
}

export class ObjectPType extends PType {
  readonly name: string = 'object'
  readonly module: string = 'lib.d.ts'
  readonly alias: SymbolName | null
  readonly description: string | undefined
  readonly properties: Record<string, PType>
  readonly singleton = false

  constructor(props: { alias?: SymbolName | null; properties: Record<string, PType>; description?: string }) {
    super()
    this.properties = props.properties
    this.description = props.description
    this.alias = props.alias ?? null
  }

  static anonymous(props: Record<string, PType> | Array<[string, PType]>) {
    const properties = Array.isArray(props) ? Object.fromEntries(props) : props
    return new ObjectPType({
      properties,
    })
  }

  get wtype(): wtypes.WTuple {
    const tupleTypes: wtypes.WType[] = []
    const tupleNames: string[] = []
    for (const [propName, propType] of this.orderedProperties()) {
      if (propType instanceof TransientType) {
        throw new CodeError(`Property '${propName}' of ${this.name} has an unsupported type: ${propType.typeMessage}`)
      }
      tupleTypes.push(propType.wtypeOrThrow)
      tupleNames.push(propName)
    }
    return new wtypes.WTuple({
      name: this.alias?.fullName ?? this.fullName,
      names: tupleNames,
      types: tupleTypes,
      immutable: true,
    })
  }

  orderedProperties() {
    return Object.entries(this.properties)
  }

  getPropertyType(name: string): PType {
    if (Object.hasOwn(this.properties, name)) {
      return this.properties[name]
    }
    throw new CodeError(`${this} does not have property ${name}`)
  }

  hasProperty(name: string): boolean {
    return Object.hasOwn(this.properties, name)
  }

  hasPropertyOfType(name: string, type: PType) {
    return this.hasProperty(name) && this.properties[name].equals(type)
  }

  toString(): string {
    return `{${this.orderedProperties()
      .map((p) => `${p[0]}:${p[1].name}`)
      .join(',')}}`
  }
}

export const voidPType = new InstanceType({
  name: 'void',
  module: 'lib.d.ts',
  wtype: wtypes.voidWType,
})
export const neverPType = new InstanceType({
  name: 'never',
  module: 'lib.d.ts',
  wtype: wtypes.voidWType,
})
export const unknownPType = new UnsupportedType({
  name: 'unknown',
  module: 'lib.d.ts',
  fullName: 'unknown',
})

export const nullPType = new UnsupportedType({
  name: 'null',
  module: 'lib.d.ts',
  fullName: 'null',
})
export const undefinedPType = new UnsupportedType({
  name: 'undefined',
  module: 'lib.d.ts',
  fullName: 'undefined',
})
export const PromiseGeneric = new GenericPType({
  name: 'Promise',
  module: 'typescript/lib/lib.es5.d.ts',
  parameterise(ptypes: PType[]) {
    codeInvariant(ptypes.length === 1, 'Promise expects exactly 1 generic parameter')
    return new PromiseType({ resolveType: ptypes[0] })
  },
})
export class PromiseType extends UnsupportedType {
  readonly resolveType: PType
  constructor({ resolveType }: { resolveType: PType }) {
    super({
      name: 'Promise',
      module: 'typescript/lib/lib.es5.d.ts',
    })
    this.resolveType = resolveType
  }
}
export const anyPType = new AnyPType()

export const boolPType = new InstanceType({
  name: 'boolean',
  module: 'lib.d.ts',
  wtype: wtypes.boolWType,
})

export const BooleanFunction = new LibFunctionType({
  name: 'Boolean',
  module: 'typescript/lib/lib.es5.d.ts',
})

export class NativeNumericType extends TransientType {}

export const bigIntPType = new NativeNumericType({
  name: 'bigint',
  module: 'lib.d.ts',
  singleton: false,
  typeMessage: transientTypeErrors.nativeNumeric('bigint').usedAsType,
  expressionMessage: transientTypeErrors.nativeNumeric('bigint').usedInExpression,
})

export const stringPType = new InstanceType({
  name: 'string',
  module: 'lib.d.ts',
  wtype: wtypes.stringWType,
})
export const StringFunction = new LibFunctionType({
  name: 'String',
  module: 'typescript/lib/lib.es5.d.ts',
})

export const uint64PType = new InstanceType({
  name: 'uint64',
  module: Constants.moduleNames.algoTs.primitives,
  wtype: wtypes.uint64WType,
})
export const biguintPType = new InstanceType({
  name: 'biguint',
  module: Constants.moduleNames.algoTs.primitives,
  wtype: wtypes.biguintWType,
})
export class NumericLiteralPType extends NativeNumericType {
  readonly literalValue: bigint
  constructor({ literalValue }: { literalValue: bigint }) {
    super({
      name: `${literalValue}`,
      module: 'lib.d.ts',
      singleton: false,
      typeMessage: transientTypeErrors.nativeNumeric(literalValue.toString()).usedAsType,
      expressionMessage: transientTypeErrors.nativeNumeric(literalValue.toString()).usedInExpression,
    })
    this.literalValue = literalValue
  }
}
export class BigIntLiteralPType extends NativeNumericType {
  readonly literalValue: bigint
  constructor({ literalValue }: { literalValue: bigint }) {
    super({
      name: `${literalValue}n`,
      module: 'lib.d.ts',
      singleton: false,
      typeMessage: transientTypeErrors.nativeNumeric(`${literalValue}n`).usedAsType,
      expressionMessage: transientTypeErrors.nativeNumeric(`${literalValue}n`).usedInExpression,
    })
    this.literalValue = literalValue
  }
}
export const numberPType = new NativeNumericType({
  name: 'number',
  module: 'lib.d.ts',
  singleton: false,
  typeMessage: transientTypeErrors.nativeNumeric('number').usedAsType,
  expressionMessage: transientTypeErrors.nativeNumeric('number').usedInExpression,
})
export const Uint64Function = new LibFunctionType({
  name: 'Uint64',
  module: Constants.moduleNames.algoTs.primitives,
})

export const BigUintFunction = new LibFunctionType({
  name: 'BigUint',
  module: Constants.moduleNames.algoTs.primitives,
})
export const bytesPType = new InstanceType({
  name: 'bytes',
  module: Constants.moduleNames.algoTs.primitives,
  wtype: wtypes.bytesWType,
})
export const BytesFunction = new LibFunctionType({
  name: 'Bytes',
  module: Constants.moduleNames.algoTs.primitives,
})

export const logFunction = new LibFunctionType({
  name: 'log',
  module: Constants.moduleNames.algoTs.util,
})
export const assertFunction = new LibFunctionType({
  name: 'assert',
  module: Constants.moduleNames.algoTs.util,
})

export const errFunction = new LibFunctionType({
  name: 'err',
  module: Constants.moduleNames.algoTs.util,
})

export const assetPType = new InstanceType({
  name: 'Asset',
  wtype: wtypes.assetWType,
  module: Constants.moduleNames.algoTs.reference,
})
export const AssetFunction = new LibFunctionType({
  name: 'Asset',
  module: Constants.moduleNames.algoTs.reference,
})
export const accountPType = new InstanceType({
  name: 'Account',
  wtype: wtypes.accountWType,
  module: Constants.moduleNames.algoTs.reference,
})
export const AccountFunction = new LibFunctionType({
  name: 'Account',
  module: Constants.moduleNames.algoTs.reference,
})
export const applicationPType = new InstanceType({
  name: 'Application',
  wtype: wtypes.applicationWType,
  module: Constants.moduleNames.algoTs.reference,
})
export const ApplicationFunctionType = new LibFunctionType({
  name: 'Application',
  module: Constants.moduleNames.algoTs.reference,
})
export const GlobalStateFunction = new LibFunctionType({
  name: 'GlobalState',
  module: Constants.moduleNames.algoTs.state,
})
export const LocalStateFunction = new LibFunctionType({
  name: 'LocalState',
  module: Constants.moduleNames.algoTs.state,
})
export const BoxFunction = new LibFunctionType({
  name: BoxGeneric.name,
  module: Constants.moduleNames.algoTs.box,
})
export const BoxMapFunction = new LibFunctionType({
  name: BoxMapGeneric.name,
  module: Constants.moduleNames.algoTs.box,
})
export const BoxRefFunction = new LibFunctionType({
  name: 'BoxRef',
  module: Constants.moduleNames.algoTs.box,
})
export const boxRefType = new BoxRefPType()

export const ClearStateProgram = new FunctionPType({
  name: Constants.symbolNames.clearStateProgramMethodName,
  module: Constants.moduleNames.algoTs.baseContract,
  returnType: uint64PType,
  parameters: [],
  sourceLocation: undefined,
})

export const ApprovalProgram = new FunctionPType({
  name: Constants.symbolNames.approvalProgramMethodName,
  module: Constants.moduleNames.algoTs.arc4.index,
  returnType: boolPType,
  parameters: [],
  sourceLocation: undefined,
})

export const baseContractType = new BaseContractClassType({
  module: Constants.moduleNames.algoTs.baseContract,
  name: 'BaseContract',
  methods: {
    clearStateProgram: ClearStateProgram,
  },
  properties: {},
  baseTypes: [],
  isArc4: false,
  sourceLocation: SourceLocation.None,
})
export const arc4BaseContractType = new BaseContractClassType({
  module: Constants.moduleNames.algoTs.arc4.index,
  name: 'Contract',
  methods: {
    approvalProgram: ApprovalProgram,
    clearStateProgram: ClearStateProgram,
  },
  properties: {},
  baseTypes: [baseContractType],
  isArc4: true,
  sourceLocation: SourceLocation.None,
})

export const arc4BareMethodDecorator = new LibFunctionType({
  module: Constants.moduleNames.algoTs.arc4.index,
  name: 'baremethod',
})
export const arc4AbiMethodDecorator = new LibFunctionType({
  module: Constants.moduleNames.algoTs.arc4.index,
  name: 'abimethod',
})

export const contractOptionsDecorator = new LibFunctionType({
  module: Constants.moduleNames.algoTs.baseContract,
  name: 'contract',
})

export const logicSigOptionsDecorator = new LibFunctionType({
  module: Constants.moduleNames.algoTs.logicSig,
  name: 'logicsig',
})

export class GroupTransactionPType extends PType {
  get wtype() {
    return new wtypes.WGroupTransaction({
      transactionType: this.kind,
    })
  }
  readonly name: string
  readonly kind: TransactionKind | undefined
  readonly module = Constants.moduleNames.algoTs.gtxn
  readonly singleton = false

  constructor({ kind, name }: { kind?: TransactionKind; name: string }) {
    super()
    this.name = name
    this.kind = kind
  }
}

export class TransactionFunctionType extends LibFunctionType {
  readonly kind: TransactionKind | undefined

  constructor({ name, module, kind }: { name: string; module: string; kind: TransactionKind | undefined }) {
    super({ name, module })
    this.kind = kind
  }
}

export const paymentGtxnType = new GroupTransactionPType({
  name: 'PaymentTxn',
  kind: TransactionKind.pay,
})
export const PaymentTxnFunction = new TransactionFunctionType({
  name: 'PaymentTxn',
  module: Constants.moduleNames.algoTs.gtxn,
  kind: TransactionKind.pay,
})
export const keyRegistrationGtxnType = new GroupTransactionPType({
  name: 'KeyRegistrationTxn',
  kind: TransactionKind.keyreg,
})
export const KeyRegistrationTxnFunction = new TransactionFunctionType({
  name: 'KeyRegistrationTxn',
  module: Constants.moduleNames.algoTs.gtxn,
  kind: TransactionKind.keyreg,
})
export const assetConfigGtxnType = new GroupTransactionPType({
  name: 'AssetConfigTxn',
  kind: TransactionKind.acfg,
})
export const AssetConfigTxnFunction = new TransactionFunctionType({
  name: 'AssetConfigTxn',
  module: Constants.moduleNames.algoTs.gtxn,
  kind: TransactionKind.acfg,
})
export const assetTransferGtxnType = new GroupTransactionPType({
  name: 'AssetTransferTxn',
  kind: TransactionKind.axfer,
})
export const AssetTransferTxnFunction = new TransactionFunctionType({
  name: 'AssetTransferTxn',
  module: Constants.moduleNames.algoTs.gtxn,
  kind: TransactionKind.axfer,
})
export const assetFreezeGtxnType = new GroupTransactionPType({
  name: 'AssetFreezeTxn',
  kind: TransactionKind.afrz,
})
export const AssetFreezeTxnFunction = new TransactionFunctionType({
  name: 'AssetFreezeTxn',
  module: Constants.moduleNames.algoTs.gtxn,
  kind: TransactionKind.afrz,
})
export const applicationCallGtxnType = new GroupTransactionPType({
  name: 'ApplicationCallTxn',
  kind: TransactionKind.appl,
})
export const ApplicationTxnFunction = new TransactionFunctionType({
  name: 'ApplicationCallTxn',
  module: Constants.moduleNames.algoTs.gtxn,
  kind: TransactionKind.appl,
})
export const gtxnUnion = UnionPType.fromTypes([
  paymentGtxnType,
  keyRegistrationGtxnType,
  assetConfigGtxnType,
  assetTransferGtxnType,
  assetFreezeGtxnType,
  applicationCallGtxnType,
])
export const anyGtxnType = new GroupTransactionPType({
  name: 'Transaction',
  kind: undefined,
})
export const TransactionFunction = new TransactionFunctionType({
  name: 'Transaction',
  module: Constants.moduleNames.algoTs.gtxn,
  kind: undefined,
})

export const assertMatchFunction = new LibFunctionType({
  name: 'assertMatch',
  module: Constants.moduleNames.algoTs.util,
})
export const matchFunction = new LibFunctionType({
  name: 'match',
  module: Constants.moduleNames.algoTs.util,
})

export class Uint64EnumMemberType extends PType {
  readonly wtype = wtypes.uint64WType
  readonly name: string
  readonly module: string
  readonly singleton = false
  readonly enumType: Uint64EnumType

  constructor(enumType: Uint64EnumType) {
    super()
    this.name = enumType.name
    this.module = enumType.module
    this.enumType = enumType
  }
}

export class Uint64EnumType extends PType {
  readonly memberType: Uint64EnumMemberType
  readonly wtype = wtypes.uint64WType
  readonly name: string
  readonly module: string
  readonly singleton = true
  readonly members: Record<string, bigint>

  constructor(props: { name: string; module: string; members: Record<string, bigint> }) {
    super()
    this.name = props.name
    this.module = props.module
    this.members = props.members
    this.memberType = new Uint64EnumMemberType(this)
  }
}

export const transactionTypeType = new Uint64EnumType({
  module: Constants.moduleNames.algoTs.transactions,
  name: 'TransactionType',
  members: {
    Payment: 1n,
    KeyRegistration: 2n,
    AssetConfig: 3n,
    AssetTransfer: 4n,
    AssetFreeze: 5n,
    ApplicationCall: 6n,
  },
})
export const onCompleteActionType = new Uint64EnumType({
  module: Constants.moduleNames.algoTs.onCompleteAction,
  name: 'OnCompleteAction',
  members: {
    NoOp: 0n,
    OptIn: 1n,
    CloseOut: 2n,
    ClearState: 3n,
    UpdateApplication: 4n,
    DeleteApplication: 5n,
  },
})
export const ensureBudgetFunction = new LibFunctionType({
  name: 'ensureBudget',
  module: Constants.moduleNames.algoTs.util,
})
export const opUpFeeSourceType = new Uint64EnumType({
  module: Constants.moduleNames.algoTs.util,
  name: 'OpUpFeeSource',
  members: {
    GroupCredit: 0n,
    AppAccount: 1n,
    Any: 2n,
  },
})

export const urangeFunction = new LibFunctionType({
  name: 'urange',
  module: Constants.moduleNames.algoTs.util,
})
export const IterableIteratorGeneric = new GenericPType({
  name: 'IterableIterator',
  module: 'typescript/lib/lib.es2015.iterable.d.ts',
  parameterise(typeArgs: PType[]): IterableIteratorType {
    codeInvariant(typeArgs.length >= 1 && typeArgs.length <= 3, 'IterableIterator type expects 1-3 type parameters')
    // Currently ignoring return and next types
    const [yieldType, _returnType, _nextType] = typeArgs
    return new IterableIteratorType({
      itemType: yieldType,
    })
  },
})
export class IterableIteratorType extends TransientType {
  readonly itemType: PType
  constructor({ itemType }: { itemType: PType }) {
    super({
      name: `IterableIterator<${itemType.name}>`,
      module: 'typescript/lib/lib.es2015.iterable.d.ts',
      typeMessage: '`IterableIterator` is not valid as a variable, parameter, return, or property type. ',
      expressionMessage: 'IterableIterator expressions can only be used in for loops',
      singleton: false,
    })
    this.itemType = itemType
  }

  get wtype(): wtypes.WEnumeration {
    return new wtypes.WEnumeration({ sequenceType: this.itemType.wtypeOrThrow })
  }
}

export const GeneratorGeneric = new GenericPType({
  name: 'Generator',
  module: 'typescript/lib/lib.es2015.generator.d.ts',
  parameterise(ptypes) {
    codeInvariant(ptypes.length === 3, 'Generator type expects exactly 3 type params')

    const [itemType, returnType, nextType] = ptypes
    return new GeneratorType({
      itemType,
      nextType,
      returnType,
    })
  },
})

export class GeneratorType extends UnsupportedType {
  readonly itemType: PType
  readonly returnType: PType
  readonly nextType: PType
  constructor({ itemType, returnType, nextType }: { itemType: PType; returnType: PType; nextType: PType }) {
    super({
      name: 'Generator',
      module: 'typescript/lib/lib.es2015.generator.d.ts',
    })
    this.itemType = itemType
    this.returnType = returnType
    this.nextType = nextType
  }
}

export const paymentItxnFn = new TransactionFunctionType({
  name: 'payment',
  module: Constants.moduleNames.algoTs.itxn,
  kind: TransactionKind.pay,
})
export const keyRegistrationItxnFn = new TransactionFunctionType({
  name: 'keyRegistration',
  module: Constants.moduleNames.algoTs.itxn,
  kind: TransactionKind.keyreg,
})
export const assetConfigItxnFn = new TransactionFunctionType({
  name: 'assetConfig',
  module: Constants.moduleNames.algoTs.itxn,
  kind: TransactionKind.acfg,
})
export const assetTransferItxnFn = new TransactionFunctionType({
  name: 'assetTransfer',
  module: Constants.moduleNames.algoTs.itxn,
  kind: TransactionKind.axfer,
})
export const assetFreezeItxnFn = new TransactionFunctionType({
  name: 'assetFreeze',
  module: Constants.moduleNames.algoTs.itxn,
  kind: TransactionKind.afrz,
})
export const applicationCallItxnFn = new TransactionFunctionType({
  name: 'applicationCall',
  module: Constants.moduleNames.algoTs.itxn,
  kind: TransactionKind.appl,
})

export class InnerTransactionPType extends PType {
  get wtype() {
    return new wtypes.WInnerTransaction({
      transactionType: this.kind,
    })
  }
  readonly name: string
  readonly kind: TransactionKind | undefined
  readonly module = Constants.moduleNames.algoTs.itxn
  readonly singleton = false

  constructor({ kind, name }: { kind?: TransactionKind; name: string }) {
    super()
    this.name = name
    this.kind = kind
  }
}
export class ItxnParamsPType extends PType {
  get wtype() {
    return new wtypes.WInnerTransactionFields({
      transactionType: this.kind,
    })
  }
  readonly name: string
  readonly kind: TransactionKind | undefined
  readonly module = Constants.moduleNames.algoTs.itxn
  readonly singleton = false

  constructor({ kind, name }: { kind?: TransactionKind; name: string }) {
    super()
    this.name = name
    this.kind = kind
  }
}
export const paymentItxnParamsType = new ItxnParamsPType({
  name: 'PaymentItxnParams',
  kind: TransactionKind.pay,
})
export const paymentItxnType = new InnerTransactionPType({
  name: 'PaymentInnerTxn',
  kind: TransactionKind.pay,
})
export const keyRegistrationItxnParamsType = new ItxnParamsPType({
  name: 'KeyRegistrationItxnParams',
  kind: TransactionKind.keyreg,
})
export const keyRegistrationItxnType = new InnerTransactionPType({
  name: 'KeyRegistrationInnerTxn',
  kind: TransactionKind.keyreg,
})
export const assetConfigItxnParamsType = new ItxnParamsPType({
  name: 'AssetConfigItxnParams',
  kind: TransactionKind.acfg,
})
export const assetConfigItxnType = new InnerTransactionPType({
  name: 'AssetConfigInnerTxn',
  kind: TransactionKind.acfg,
})
export const assetTransferItxnParamsType = new ItxnParamsPType({
  name: 'AssetTransferItxnParams',
  kind: TransactionKind.axfer,
})
export const assetTransferItxnType = new InnerTransactionPType({
  name: 'AssetTransferInnerTxn',
  kind: TransactionKind.axfer,
})
export const assetFreezeItxnParamsType = new ItxnParamsPType({
  name: 'AssetFreezeItxnParams',
  kind: TransactionKind.afrz,
})
export const assetFreezeItxnType = new InnerTransactionPType({
  name: 'AssetFreezeInnerTxn',
  kind: TransactionKind.afrz,
})
export const applicationCallItxnParamsType = new ItxnParamsPType({
  name: 'ApplicationCallItxnParams',
  kind: TransactionKind.appl,
})
export const applicationItxnType = new InnerTransactionPType({
  name: 'ApplicationCallInnerTxn',
  kind: TransactionKind.appl,
})
export const anyItxnType = new InnerTransactionPType({
  name: 'InnerTxn',
})

export const submitGroupItxnFunction = new LibFunctionType({
  name: 'submitGroup',
  module: Constants.moduleNames.algoTs.itxn,
})

export const TemplateVarFunction = new LibFunctionType({
  name: 'TemplateVar',
  module: Constants.moduleNames.algoTs.templateVar,
})

export const compileFunctionType = new LibFunctionType({
  name: 'compile',
  module: Constants.moduleNames.algoTs.compiled,
})

export const compiledContractType = new ObjectPType({
  alias: new SymbolName({
    name: 'CompiledContract',
    module: Constants.moduleNames.algoTs.compiled,
  }),
  description: 'Provides compiled programs and state allocation values for a Contract. Created by calling `compile(ExampleContractType)`',
  properties: {
    approvalProgram: new TuplePType({ items: [bytesPType, bytesPType] }),
    clearStateProgram: new TuplePType({ items: [bytesPType, bytesPType] }),
    extraProgramPages: uint64PType,
    globalUints: uint64PType,
    globalBytes: uint64PType,
    localUints: uint64PType,
    localBytes: uint64PType,
  },
})
export const compiledLogicSigType = new ObjectPType({
  alias: new SymbolName({
    name: 'CompiledLogicSig',
    module: Constants.moduleNames.algoTs.compiled,
  }),
  description: 'Provides account for a Logic Signature. Created by calling `compile(LogicSigType)``',
  properties: {
    account: accountPType,
  },
})

export const arc28EmitFunction = new LibFunctionType({
  name: 'emit',
  module: Constants.moduleNames.algoTs.arc28,
})

export const SuperPrototypeSelectorGeneric = new GenericPType({
  name: 'SuperPrototypeSelector',
  module: Constants.moduleNames.polytype,
  parameterise(ptypes: PType[]) {
    return new SuperPrototypeSelector({ bases: ptypes })
  },
})
export class SuperPrototypeSelector extends InternalType {
  constructor({ bases }: { bases: PType[] }) {
    super({
      name: 'SuperPrototypeSelector',
      module: Constants.moduleNames.polytype,
    })
  }
}
export const ClusteredPrototype = new InternalType({
  name: 'ClusteredPrototype',
  module: Constants.moduleNames.polytype,
})
export const PolytypeClassMethodHelper = new LibFunctionType({
  name: 'class',
  module: Constants.moduleNames.polytype,
})

export const MutableArrayConstructor = new LibClassType({
  name: 'MutableArray',
  module: Constants.moduleNames.algoTs.mutableArray,
})
export const MutableArrayGeneric = new GenericPType({
  name: 'MutableArray',
  module: Constants.moduleNames.algoTs.mutableArray,
  parameterise: (typeArgs: PType[]): MutableArrayType => {
    codeInvariant(typeArgs.length === 1, 'MutableArray type expects exactly one type parameter')
    const [elementType] = typeArgs

    return new MutableArrayType({ elementType: elementType })
  },
})
export class MutableArrayType extends PType {
  readonly module = Constants.moduleNames.algoTs.mutableArray
  readonly immutable = false as const
  readonly name: string
  readonly singleton = false
  readonly sourceLocation: SourceLocation | undefined
  readonly elementType: PType

  constructor({
    elementType,
    sourceLocation,
    name,
  }: {
    elementType: PType
    sourceLocation?: SourceLocation
    name?: string
    immutable?: boolean
  }) {
    super()
    this.name = name ?? `MutableArray<${elementType}>`
    this.sourceLocation = sourceLocation
    this.elementType = elementType
  }

  get wtype() {
    return new wtypes.ReferenceArray({
      itemType: this.elementType.wtypeOrThrow,
      sourceLocation: this.sourceLocation,
      immutable: false,
    })
  }
}



================================================
FILE: src/awst_build/ptypes/intrinsic-enum-type.ts
================================================
import { PType } from './base'

export class IntrinsicEnumType extends PType {
  readonly wtype: undefined
  readonly name: string
  readonly factory: undefined
  readonly module: string
  readonly members: Array<[string, string]>
  readonly singleton = true

  constructor({ name, module, members }: { name: string; module: string; members: Array<[string, string]> }) {
    super()
    this.members = members
    this.name = name
    this.module = module
  }
}



================================================
FILE: src/awst_build/ptypes/op-ptypes.ts
================================================
/* THIS FILE IS GENERATED BY ~/scripts/generate-op-ptypes.ts - DO NOT MODIFY DIRECTLY */
import { IntrinsicEnumType } from './intrinsic-enum-type'
import { Constants } from '../../constants'

export const base64PType = new IntrinsicEnumType({
  name: 'Base64',
  module: `${Constants.algoTsPackage}/op.d.ts`,
  members: [
    ['URLEncoding', 'URLEncoding'],
    ['StdEncoding', 'StdEncoding'],
  ],
})
export const ecPType = new IntrinsicEnumType({
  name: 'Ec',
  module: `${Constants.algoTsPackage}/op.d.ts`,
  members: [
    ['BN254g1', 'BN254g1'],
    ['BN254g2', 'BN254g2'],
    ['BLS12_381g1', 'BLS12_381g1'],
    ['BLS12_381g2', 'BLS12_381g2'],
  ],
})
export const ecdsaPType = new IntrinsicEnumType({
  name: 'Ecdsa',
  module: `${Constants.algoTsPackage}/op.d.ts`,
  members: [
    ['Secp256k1', 'Secp256k1'],
    ['Secp256r1', 'Secp256r1'],
  ],
})
export const mimcConfigurationsPType = new IntrinsicEnumType({
  name: 'MimcConfigurations',
  module: `${Constants.algoTsPackage}/op.d.ts`,
  members: [
    ['BN254Mp110', 'BN254Mp110'],
    ['BLS12_381Mp111', 'BLS12_381Mp111'],
  ],
})
export const vrfVerifyPType = new IntrinsicEnumType({
  name: 'VrfVerify',
  module: `${Constants.algoTsPackage}/op.d.ts`,
  members: [['VrfAlgorand', 'VrfAlgorand']],
})
export const ALL_OP_ENUMS = [base64PType, ecPType, ecdsaPType, mimcConfigurationsPType, vrfVerifyPType]



================================================
FILE: src/awst_build/ptypes/register.ts
================================================
import { Arc28EmitFunctionBuilder } from '../eb/arc28/arc-28-emit-function-builder'
import { Arc4AbiMethodDecoratorBuilder, Arc4BareMethodDecoratorBuilder } from '../eb/arc4-bare-method-decorator-builder'
import {
  AddressClassBuilder,
  AddressExpressionBuilder,
  DynamicArrayClassBuilder,
  DynamicArrayExpressionBuilder,
  DynamicBytesClassBuilder,
  DynamicBytesExpressionBuilder,
  StaticArrayClassBuilder,
  StaticArrayExpressionBuilder,
  StaticBytesClassBuilder,
  StaticBytesExpressionBuilder,
} from '../eb/arc4/arrays'
import { BoolClassBuilder, BoolExpressionBuilder } from '../eb/arc4/bool'
import { AbiCallFunctionBuilder, CompileArc4FunctionBuilder, ContractProxyExpressionBuilder } from '../eb/arc4/c2c'
import { StrClassBuilder, StrExpressionBuilder } from '../eb/arc4/string'
import { StructClassBuilder, StructExpressionBuilder } from '../eb/arc4/struct'
import { Arc4TupleClassBuilder, Arc4TupleExpressionBuilder } from '../eb/arc4/tuple'
import { UFixedNxMClassBuilder, UFixedNxMExpressionBuilder } from '../eb/arc4/ufixed'
import { classBuilderForUintNAlias, UintNClassBuilder, UintNExpressionBuilder } from '../eb/arc4/uintn'
import {
  Arc4EncodedLengthFunctionBuilder,
  DecodeArc4FunctionBuilder,
  EncodeArc4FunctionBuilder,
  InterpretAsArc4FunctionBuilder,
  MethodSelectorFunctionBuilder,
} from '../eb/arc4/util'
import { AssertFunctionBuilder, ErrFunctionBuilder } from '../eb/assert-function-builder'
import { AssertMatchFunctionBuilder } from '../eb/assert-match-function-builder'
import { BigUintExpressionBuilder, BigUintFunctionBuilder } from '../eb/biguint-expression-builder'
import { BooleanExpressionBuilder, BooleanFunctionBuilder } from '../eb/boolean-expression-builder'
import { BytesExpressionBuilder, BytesFunctionBuilder } from '../eb/bytes-expression-builder'
import { CompileFunctionBuilder } from '../eb/compiled/compile-function'
import { ContractClassBuilder, ContractOptionsDecoratorBuilder } from '../eb/contract-builder'
import { EnsureBudgetFunctionBuilder } from '../eb/ensure-budget'
import { FreeSubroutineExpressionBuilder } from '../eb/free-subroutine-expression-builder'
import { IntrinsicEnumBuilder } from '../eb/intrinsic-enum-builder'
import { IterableIteratorExpressionBuilder } from '../eb/iterable-iterator-expression-builder'
import { ObjectExpressionBuilder } from '../eb/literal/object-expression-builder'
import { LogFunctionBuilder } from '../eb/log-function-builder'
import { LogicSigClassBuilder, LogicSigOptionsDecoratorBuilder } from '../eb/logic-sig-builder'
import { MatchFunctionBuilder } from '../eb/match-function-builder'
import { MutableArrayClassBuilder, MutableArrayExpressionBuilder } from '../eb/mutable-arrays'
import { NamespaceBuilder } from '../eb/namespace-builder'
import { NativeArrayExpressionBuilder } from '../eb/native-array-expression-builder'
import { NeverExpressionBuilder } from '../eb/never-expression-builder'
import { FreeIntrinsicOpBuilder, IntrinsicOpGroupBuilder, IntrinsicOpGroupOrFunctionTypeBuilder } from '../eb/op-module-builder'
import { AccountExpressionBuilder, AccountFunctionBuilder } from '../eb/reference/account'
import { ApplicationExpressionBuilder, ApplicationFunctionBuilder } from '../eb/reference/application'
import { AssetExpressionBuilder, AssetFunctionBuilder } from '../eb/reference/asset'
import {
  BoxExpressionBuilder,
  BoxFunctionBuilder,
  BoxMapExpressionBuilder,
  BoxMapFunctionBuilder,
  BoxRefExpressionBuilder,
  BoxRefFunctionBuilder,
} from '../eb/storage/box'
import { GlobalStateExpressionBuilder, GlobalStateFunctionBuilder } from '../eb/storage/global-state'
import { LocalStateExpressionBuilder, LocalStateFunctionBuilder } from '../eb/storage/local-state'
import { StringExpressionBuilder, StringFunctionBuilder } from '../eb/string-expression-builder'
import { TemplateVarFunctionBuilder } from '../eb/template-var'
import { GroupTransactionExpressionBuilder, GroupTransactionFunctionBuilder } from '../eb/transactions/group-transactions'
import {
  ItxnParamsExpressionBuilder,
  ItxnParamsFactoryFunctionBuilder,
  SubmitItxnGroupFunctionBuilder,
} from '../eb/transactions/inner-transaction-params'
import { InnerTransactionExpressionBuilder } from '../eb/transactions/inner-transactions'
import { TupleExpressionBuilder } from '../eb/tuple-expression-builder'
import { Uint64EnumMemberExpressionBuilder, Uint64EnumTypeBuilder } from '../eb/uint64-enum-type-builder'
import { UInt64ExpressionBuilder, UInt64FunctionBuilder } from '../eb/uint64-expression-builder'
import { UnresolvableExpressionBuilder } from '../eb/unresolvable-expression-builder'
import { UrangeFunctionBuilder } from '../eb/urange-function'
import { VoidExpressionBuilder } from '../eb/void-expression-builder'
import { OP_METADATA } from '../op-metadata'
import type { TypeRegistry } from '../type-registry'
import {
  abiCallFunction,
  AddressClass,
  arc4AddressAlias,
  ARC4BoolClass,
  arc4BooleanType,
  arc4ByteAlias,
  arc4EncodedLengthFunction,
  ARC4StrClass,
  arc4StringType,
  ARC4StructClass,
  ARC4StructType,
  Arc4TupleClass,
  Arc4TupleGeneric,
  ARC4TupleType,
  ByteClass,
  compileArc4Function,
  ContractProxyGeneric,
  ContractProxyType,
  decodeArc4Function,
  DynamicArrayConstructor,
  DynamicArrayGeneric,
  DynamicArrayType,
  DynamicBytesConstructor,
  DynamicBytesType,
  encodeArc4Function,
  interpretAsArc4Function,
  methodSelectorFunction,
  StaticArrayConstructor,
  StaticArrayGeneric,
  StaticArrayType,
  StaticBytesConstructor,
  StaticBytesGeneric,
  StaticBytesType,
  UFixedNxMClass,
  UFixedNxMGeneric,
  UFixedNxMType,
  UintN128Class,
  UintN16Class,
  UintN256Class,
  UintN32Class,
  UintN64Class,
  UintN8Class,
  UintNClass,
  UintNGeneric,
  UintNType,
} from './arc4-types'
import {
  AccountFunction,
  accountPType,
  anyGtxnType,
  applicationCallGtxnType,
  applicationCallItxnFn,
  applicationCallItxnParamsType,
  ApplicationFunctionType,
  applicationItxnType,
  applicationPType,
  ApplicationTxnFunction,
  arc28EmitFunction,
  arc4AbiMethodDecorator,
  arc4BareMethodDecorator,
  ArrayPType,
  assertFunction,
  assertMatchFunction,
  assetConfigGtxnType,
  assetConfigItxnFn,
  assetConfigItxnParamsType,
  assetConfigItxnType,
  AssetConfigTxnFunction,
  assetFreezeGtxnType,
  assetFreezeItxnFn,
  assetFreezeItxnParamsType,
  assetFreezeItxnType,
  AssetFreezeTxnFunction,
  AssetFunction,
  assetPType,
  assetTransferGtxnType,
  assetTransferItxnFn,
  assetTransferItxnParamsType,
  assetTransferItxnType,
  AssetTransferTxnFunction,
  BigUintFunction,
  biguintPType,
  BooleanFunction,
  boolPType,
  BoxFunction,
  BoxGeneric,
  BoxMapFunction,
  BoxMapGeneric,
  BoxMapPType,
  BoxPType,
  BoxRefFunction,
  boxRefType,
  BytesFunction,
  bytesPType,
  ClassMethodDecoratorContext,
  compileFunctionType,
  ContractClassPType,
  contractOptionsDecorator,
  ensureBudgetFunction,
  errFunction,
  FunctionPType,
  GeneratorGeneric,
  GeneratorType,
  GlobalStateFunction,
  GlobalStateGeneric,
  GlobalStateType,
  IntrinsicFunctionGroupType,
  IntrinsicFunctionGroupTypeType,
  IntrinsicFunctionType,
  IntrinsicFunctionTypeType,
  IterableIteratorGeneric,
  IterableIteratorType,
  keyRegistrationGtxnType,
  keyRegistrationItxnFn,
  keyRegistrationItxnParamsType,
  keyRegistrationItxnType,
  KeyRegistrationTxnFunction,
  LocalStateFunction,
  LocalStateGeneric,
  LocalStateType,
  logFunction,
  logicSigOptionsDecorator,
  LogicSigPType,
  matchFunction,
  MutableArrayConstructor,
  MutableArrayGeneric,
  MutableArrayType,
  NamespacePType,
  neverPType,
  ObjectPType,
  onCompleteActionType,
  opUpFeeSourceType,
  paymentGtxnType,
  paymentItxnFn,
  paymentItxnParamsType,
  paymentItxnType,
  PaymentTxnFunction,
  PolytypeClassMethodHelper,
  PromiseGeneric,
  PromiseType,
  StringFunction,
  stringPType,
  submitGroupItxnFunction,
  SuperPrototypeSelector,
  SuperPrototypeSelectorGeneric,
  TemplateVarFunction,
  TransactionFunction,
  transactionTypeType,
  TuplePType,
  Uint64EnumMemberType,
  Uint64Function,
  uint64PType,
  urangeFunction,
  voidPType,
} from './index'
import { ALL_OP_ENUMS } from './op-ptypes'

export function registerPTypes(typeRegistry: TypeRegistry) {
  if (typeRegistry.hasRegistrations) {
    return
  }
  // Primitives
  typeRegistry.register({ ptype: neverPType, instanceEb: NeverExpressionBuilder })
  typeRegistry.register({ ptype: boolPType, instanceEb: BooleanExpressionBuilder })
  typeRegistry.register({ ptype: BooleanFunction, singletonEb: BooleanFunctionBuilder })
  typeRegistry.register({ ptype: uint64PType, instanceEb: UInt64ExpressionBuilder })
  typeRegistry.register({ ptype: Uint64Function, singletonEb: UInt64FunctionBuilder })
  typeRegistry.register({ ptype: biguintPType, instanceEb: BigUintExpressionBuilder })
  typeRegistry.register({ ptype: BigUintFunction, singletonEb: BigUintFunctionBuilder })
  typeRegistry.register({ ptype: bytesPType, instanceEb: BytesExpressionBuilder })
  typeRegistry.register({ ptype: BytesFunction, singletonEb: BytesFunctionBuilder })
  typeRegistry.register({ ptype: stringPType, instanceEb: StringExpressionBuilder })
  typeRegistry.register({ ptype: voidPType, instanceEb: VoidExpressionBuilder })
  typeRegistry.register({ ptype: StringFunction, singletonEb: StringFunctionBuilder })

  // Compound
  typeRegistry.register({ ptype: ArrayPType, instanceEb: NativeArrayExpressionBuilder })
  typeRegistry.register({ ptype: TuplePType, instanceEb: TupleExpressionBuilder })
  typeRegistry.register({ ptype: ObjectPType, instanceEb: ObjectExpressionBuilder })

  typeRegistry.register({ ptype: MutableArrayConstructor, singletonEb: MutableArrayClassBuilder })
  typeRegistry.registerGeneric({ generic: MutableArrayGeneric, ptype: MutableArrayType, instanceEb: MutableArrayExpressionBuilder })

  // Unresolvable
  typeRegistry.registerGeneric({ ptype: GeneratorType, generic: GeneratorGeneric, instanceEb: UnresolvableExpressionBuilder })
  typeRegistry.registerGeneric({ ptype: PromiseType, generic: PromiseGeneric, instanceEb: UnresolvableExpressionBuilder })
  typeRegistry.register({ ptype: ClassMethodDecoratorContext, instanceEb: UnresolvableExpressionBuilder })
  typeRegistry.registerGeneric({
    ptype: SuperPrototypeSelector,
    generic: SuperPrototypeSelectorGeneric,
    instanceEb: UnresolvableExpressionBuilder,
  })
  typeRegistry.register({ ptype: PolytypeClassMethodHelper, instanceEb: UnresolvableExpressionBuilder })

  // Lib functions
  typeRegistry.register({ ptype: logFunction, singletonEb: LogFunctionBuilder })
  typeRegistry.register({ ptype: assertFunction, singletonEb: AssertFunctionBuilder })
  typeRegistry.register({ ptype: errFunction, singletonEb: ErrFunctionBuilder })
  typeRegistry.register({ ptype: matchFunction, singletonEb: MatchFunctionBuilder })
  typeRegistry.register({ ptype: assertMatchFunction, singletonEb: AssertMatchFunctionBuilder })
  typeRegistry.register({ ptype: ensureBudgetFunction, singletonEb: EnsureBudgetFunctionBuilder })
  typeRegistry.register({ ptype: urangeFunction, singletonEb: UrangeFunctionBuilder })
  typeRegistry.register({ ptype: TemplateVarFunction, singletonEb: TemplateVarFunctionBuilder })
  typeRegistry.register({ ptype: compileFunctionType, singletonEb: CompileFunctionBuilder })
  typeRegistry.register({ ptype: arc28EmitFunction, singletonEb: Arc28EmitFunctionBuilder })

  typeRegistry.register({ ptype: ContractClassPType, singletonEb: ContractClassBuilder })
  typeRegistry.register({ ptype: contractOptionsDecorator, singletonEb: ContractOptionsDecoratorBuilder })
  typeRegistry.register({ ptype: LogicSigPType, singletonEb: LogicSigClassBuilder })
  typeRegistry.register({ ptype: logicSigOptionsDecorator, singletonEb: LogicSigOptionsDecoratorBuilder })

  for (const enumType of [opUpFeeSourceType, onCompleteActionType, transactionTypeType]) {
    typeRegistry.register({ ptype: enumType, singletonEb: Uint64EnumTypeBuilder })
    typeRegistry.register({ ptype: enumType.memberType, instanceEb: Uint64EnumMemberExpressionBuilder })
  }
  typeRegistry.register({ ptype: Uint64EnumMemberType, instanceEb: Uint64EnumMemberExpressionBuilder })

  typeRegistry.registerGeneric({
    generic: IterableIteratorGeneric,
    ptype: IterableIteratorType,
    instanceEb: IterableIteratorExpressionBuilder,
  })

  typeRegistry.register({ ptype: FunctionPType, singletonEb: FreeSubroutineExpressionBuilder })

  // Op types
  typeRegistry.register({ ptype: NamespacePType, singletonEb: NamespaceBuilder })
  for (const enumPType of ALL_OP_ENUMS) {
    typeRegistry.register({ ptype: enumPType, singletonEb: IntrinsicEnumBuilder })
  }
  for (const [name, metadata] of Object.entries(OP_METADATA)) {
    if (metadata.type === 'op-grouping') {
      typeRegistry.register({
        ptype: new IntrinsicFunctionGroupType({
          name,
        }),
        singletonEb: IntrinsicOpGroupBuilder,
      })
      typeRegistry.register({
        ptype: new IntrinsicFunctionGroupTypeType({
          name: `${name}Type`,
        }),
        instanceEb: IntrinsicOpGroupOrFunctionTypeBuilder,
      })
    } else {
      typeRegistry.register({
        ptype: new IntrinsicFunctionType({
          name,
        }),
        singletonEb: FreeIntrinsicOpBuilder,
      })
      typeRegistry.register({
        ptype: new IntrinsicFunctionTypeType({
          name: `${name}Type`,
        }),
        instanceEb: IntrinsicOpGroupOrFunctionTypeBuilder,
      })
    }
  }

  // State
  typeRegistry.register({ ptype: GlobalStateFunction, singletonEb: GlobalStateFunctionBuilder })
  typeRegistry.registerGeneric({ generic: GlobalStateGeneric, ptype: GlobalStateType, instanceEb: GlobalStateExpressionBuilder })
  typeRegistry.register({ ptype: LocalStateFunction, singletonEb: LocalStateFunctionBuilder })
  typeRegistry.registerGeneric({ generic: LocalStateGeneric, ptype: LocalStateType, instanceEb: LocalStateExpressionBuilder })
  typeRegistry.register({ ptype: BoxFunction, singletonEb: BoxFunctionBuilder })
  typeRegistry.registerGeneric({ generic: BoxGeneric, ptype: BoxPType, instanceEb: BoxExpressionBuilder })
  typeRegistry.register({ ptype: BoxMapFunction, singletonEb: BoxMapFunctionBuilder })
  typeRegistry.registerGeneric({ generic: BoxMapGeneric, ptype: BoxMapPType, instanceEb: BoxMapExpressionBuilder })
  typeRegistry.register({ ptype: BoxRefFunction, singletonEb: BoxRefFunctionBuilder })
  typeRegistry.register({ ptype: boxRefType, instanceEb: BoxRefExpressionBuilder })

  // Reference types
  typeRegistry.register({ ptype: ApplicationFunctionType, singletonEb: ApplicationFunctionBuilder })
  typeRegistry.register({ ptype: applicationPType, instanceEb: ApplicationExpressionBuilder })
  typeRegistry.register({ ptype: AccountFunction, singletonEb: AccountFunctionBuilder })
  typeRegistry.register({ ptype: accountPType, instanceEb: AccountExpressionBuilder })
  typeRegistry.register({ ptype: AssetFunction, singletonEb: AssetFunctionBuilder })
  typeRegistry.register({ ptype: assetPType, instanceEb: AssetExpressionBuilder })

  // ARC4 encoded
  typeRegistry.register({ ptype: UintNClass, singletonEb: UintNClassBuilder })
  typeRegistry.register({ ptype: arc4AbiMethodDecorator, singletonEb: Arc4AbiMethodDecoratorBuilder })
  typeRegistry.register({ ptype: arc4BareMethodDecorator, singletonEb: Arc4BareMethodDecoratorBuilder })
  typeRegistry.register({ ptype: ByteClass, singletonEb: classBuilderForUintNAlias(ByteClass, arc4ByteAlias) })
  typeRegistry.register({ ptype: UintN8Class, singletonEb: classBuilderForUintNAlias(UintN8Class, new UintNType({ n: 8n })) })
  typeRegistry.register({ ptype: UintN16Class, singletonEb: classBuilderForUintNAlias(UintN8Class, new UintNType({ n: 16n })) })
  typeRegistry.register({ ptype: UintN32Class, singletonEb: classBuilderForUintNAlias(UintN8Class, new UintNType({ n: 32n })) })
  typeRegistry.register({ ptype: UintN64Class, singletonEb: classBuilderForUintNAlias(UintN8Class, new UintNType({ n: 64n })) })
  typeRegistry.register({ ptype: UintN128Class, singletonEb: classBuilderForUintNAlias(UintN8Class, new UintNType({ n: 128n })) })
  typeRegistry.register({ ptype: UintN256Class, singletonEb: classBuilderForUintNAlias(UintN8Class, new UintNType({ n: 256n })) })
  typeRegistry.registerGeneric({ generic: UintNGeneric, ptype: UintNType, instanceEb: UintNExpressionBuilder })
  typeRegistry.register({ ptype: UFixedNxMClass, singletonEb: UFixedNxMClassBuilder })
  typeRegistry.registerGeneric({ generic: UFixedNxMGeneric, ptype: UFixedNxMType, instanceEb: UFixedNxMExpressionBuilder })
  typeRegistry.register({ ptype: arc4ByteAlias, instanceEb: UintNExpressionBuilder })

  // More specific types need to be registered before their base types
  // This ensures the specific type is selected during type resolution
  // For example, StaticBytesExpressionBuilder should be selected over general StaticArrayExpressionBuilder for StaticBytesType
  typeRegistry.register({ ptype: DynamicBytesConstructor, singletonEb: DynamicBytesClassBuilder })
  typeRegistry.register({ ptype: StaticBytesConstructor, singletonEb: StaticBytesClassBuilder })
  typeRegistry.register({ ptype: DynamicBytesType, instanceEb: DynamicBytesExpressionBuilder })
  typeRegistry.registerGeneric({ generic: StaticBytesGeneric, ptype: StaticBytesType, instanceEb: StaticBytesExpressionBuilder })

  typeRegistry.register({ ptype: DynamicArrayConstructor, singletonEb: DynamicArrayClassBuilder })
  typeRegistry.registerGeneric({ generic: DynamicArrayGeneric, ptype: DynamicArrayType, instanceEb: DynamicArrayExpressionBuilder })
  typeRegistry.register({ ptype: StaticArrayConstructor, singletonEb: StaticArrayClassBuilder })
  typeRegistry.registerGeneric({ generic: StaticArrayGeneric, ptype: StaticArrayType, instanceEb: StaticArrayExpressionBuilder })
  typeRegistry.register({ ptype: arc4AddressAlias, instanceEb: AddressExpressionBuilder })
  typeRegistry.register({ ptype: AddressClass, singletonEb: AddressClassBuilder })
  typeRegistry.register({ ptype: ARC4BoolClass, singletonEb: BoolClassBuilder })
  typeRegistry.register({ ptype: arc4BooleanType, instanceEb: BoolExpressionBuilder })
  typeRegistry.register({ ptype: arc4StringType, instanceEb: StrExpressionBuilder })
  typeRegistry.register({ ptype: ARC4StrClass, singletonEb: StrClassBuilder })
  typeRegistry.register({ ptype: Arc4TupleClass, singletonEb: Arc4TupleClassBuilder })
  typeRegistry.registerGeneric({ generic: Arc4TupleGeneric, ptype: ARC4TupleType, instanceEb: Arc4TupleExpressionBuilder })
  typeRegistry.register({ ptype: ARC4StructType, instanceEb: StructExpressionBuilder })
  typeRegistry.register({ ptype: ARC4StructClass, singletonEb: StructClassBuilder })

  // ARC4 lib
  typeRegistry.register({ ptype: interpretAsArc4Function, singletonEb: InterpretAsArc4FunctionBuilder })
  typeRegistry.register({ ptype: encodeArc4Function, singletonEb: EncodeArc4FunctionBuilder })
  typeRegistry.register({ ptype: decodeArc4Function, singletonEb: DecodeArc4FunctionBuilder })
  typeRegistry.register({ ptype: methodSelectorFunction, singletonEb: MethodSelectorFunctionBuilder })
  typeRegistry.register({ ptype: arc4EncodedLengthFunction, singletonEb: Arc4EncodedLengthFunctionBuilder })
  typeRegistry.register({ ptype: compileArc4Function, singletonEb: CompileArc4FunctionBuilder })
  typeRegistry.register({ ptype: abiCallFunction, singletonEb: AbiCallFunctionBuilder })
  typeRegistry.registerGeneric({ ptype: ContractProxyType, generic: ContractProxyGeneric, instanceEb: ContractProxyExpressionBuilder })

  // GTXN types
  typeRegistry.register({ ptype: paymentGtxnType, instanceEb: GroupTransactionExpressionBuilder })
  typeRegistry.register({ ptype: PaymentTxnFunction, singletonEb: GroupTransactionFunctionBuilder })
  typeRegistry.register({ ptype: keyRegistrationGtxnType, instanceEb: GroupTransactionExpressionBuilder })
  typeRegistry.register({ ptype: KeyRegistrationTxnFunction, singletonEb: GroupTransactionFunctionBuilder })
  typeRegistry.register({ ptype: assetConfigGtxnType, instanceEb: GroupTransactionExpressionBuilder })
  typeRegistry.register({ ptype: AssetConfigTxnFunction, singletonEb: GroupTransactionFunctionBuilder })
  typeRegistry.register({ ptype: assetTransferGtxnType, instanceEb: GroupTransactionExpressionBuilder })
  typeRegistry.register({ ptype: AssetTransferTxnFunction, singletonEb: GroupTransactionFunctionBuilder })
  typeRegistry.register({ ptype: assetFreezeGtxnType, instanceEb: GroupTransactionExpressionBuilder })
  typeRegistry.register({ ptype: AssetFreezeTxnFunction, singletonEb: GroupTransactionFunctionBuilder })
  typeRegistry.register({ ptype: applicationCallGtxnType, instanceEb: GroupTransactionExpressionBuilder })
  typeRegistry.register({ ptype: ApplicationTxnFunction, singletonEb: GroupTransactionFunctionBuilder })
  typeRegistry.register({ ptype: anyGtxnType, instanceEb: GroupTransactionExpressionBuilder })
  typeRegistry.register({ ptype: TransactionFunction, singletonEb: GroupTransactionFunctionBuilder })

  // ITXN Types
  typeRegistry.register({ ptype: paymentItxnFn, singletonEb: ItxnParamsFactoryFunctionBuilder })
  typeRegistry.register({ ptype: keyRegistrationItxnFn, singletonEb: ItxnParamsFactoryFunctionBuilder })
  typeRegistry.register({ ptype: assetConfigItxnFn, singletonEb: ItxnParamsFactoryFunctionBuilder })
  typeRegistry.register({ ptype: assetTransferItxnFn, singletonEb: ItxnParamsFactoryFunctionBuilder })
  typeRegistry.register({ ptype: assetFreezeItxnFn, singletonEb: ItxnParamsFactoryFunctionBuilder })
  typeRegistry.register({ ptype: applicationCallItxnFn, singletonEb: ItxnParamsFactoryFunctionBuilder })
  typeRegistry.register({ ptype: submitGroupItxnFunction, singletonEb: SubmitItxnGroupFunctionBuilder })

  typeRegistry.register({ ptype: paymentItxnType, instanceEb: InnerTransactionExpressionBuilder })
  typeRegistry.register({ ptype: keyRegistrationItxnType, instanceEb: InnerTransactionExpressionBuilder })
  typeRegistry.register({ ptype: assetConfigItxnType, instanceEb: InnerTransactionExpressionBuilder })
  typeRegistry.register({ ptype: assetTransferItxnType, instanceEb: InnerTransactionExpressionBuilder })
  typeRegistry.register({ ptype: assetFreezeItxnType, instanceEb: InnerTransactionExpressionBuilder })
  typeRegistry.register({ ptype: applicationItxnType, instanceEb: InnerTransactionExpressionBuilder })

  typeRegistry.register({ ptype: paymentItxnParamsType, instanceEb: ItxnParamsExpressionBuilder })
  typeRegistry.register({ ptype: keyRegistrationItxnParamsType, instanceEb: ItxnParamsExpressionBuilder })
  typeRegistry.register({ ptype: assetConfigItxnParamsType, instanceEb: ItxnParamsExpressionBuilder })
  typeRegistry.register({ ptype: assetTransferItxnParamsType, instanceEb: ItxnParamsExpressionBuilder })
  typeRegistry.register({ ptype: assetFreezeItxnParamsType, instanceEb: ItxnParamsExpressionBuilder })
  typeRegistry.register({ ptype: applicationCallItxnParamsType, instanceEb: ItxnParamsExpressionBuilder })
}



================================================
FILE: src/awst_build/ptypes/transient-type-errors.ts
================================================
type TransientTypeError = {
  usedAsType: string
  usedInExpression: string
}

export const transientTypeErrors = {
  arrays: (typeName) => ({
    usedAsType: `\`${typeName}\` is not valid as a variable, parameter, return, or property type. Please define a static tuple type or use an \`as const\` expression`,
    usedInExpression: `Expression of type \`${typeName}\` cannot be used conditionally`,
  }),
  nativeNumeric: (typeName) => ({
    usedAsType: `\`${typeName}\` is not valid as a variable, parameter, return, or property type. Please use an algo-ts type such as \`biguint\` or \`uint64\``,
    usedInExpression: `Expression of type \`${typeName}\` must be explicitly converted to an algo-ts type, for example by wrapping the expression in \`Uint64(...)\` or \`BigUint(...)\``,
  }),
  unionTypes: (typeName) => ({
    usedAsType: `Union types are not valid as a variable, parameter, return, or property type. Expression type is ${typeName}`,
    usedInExpression: `Union types are only valid in boolean expressions. Expression type is ${typeName}`,
  }),
  intersectionTypes: (typeName) => ({
    usedAsType: `Intersection types are not valid as a variable, parameter, return, or property type. Expression type is ${typeName}`,
    usedInExpression: `Intersection types not valid here. Expression type is ${typeName}`,
  }),
} satisfies Record<string, (typeName: string) => TransientTypeError>



================================================
FILE: src/awst_build/ptypes/util.ts
================================================
import type { SourceLocation } from '../../awst/source-location'
import { CodeError } from '../../errors'
import { codeInvariant } from '../../util'
import { DynamicArrayType, StaticArrayType } from './arc4-types'
import type { PType } from './base'
import { ArrayPType, IterableIteratorType, MutableArrayType, TuplePType, UnionPType } from './index'

export const getSequenceItemType = (sequence: PType, sequenceLocation: SourceLocation) => {
  if (sequence instanceof IterableIteratorType) return sequence.itemType
  if (sequence instanceof ArrayPType) return sequence.elementType
  if (sequence instanceof MutableArrayType) return sequence.elementType
  if (sequence instanceof TuplePType) {
    codeInvariant(
      sequence.items.every((i) => i.equals(sequence.items[0])),
      `Tuples are only iterable if all item types are the same type. Item type is ${UnionPType.fromTypes(sequence.items)}`,
      sequenceLocation,
    )
    return sequence.items[0]
  }
  if (sequence instanceof DynamicArrayType || sequence instanceof StaticArrayType) {
    return sequence.elementType
  }
  throw new CodeError(`Target is not iterable: ${sequence}`, { sourceLocation: sequenceLocation })
}

export const ptypeIn = (target: PType, ...ptypes: [PType, ...PType[]]): boolean => {
  return ptypes.some((t) => t.equals(target))
}



================================================
FILE: src/cli/app-version.ts
================================================
import fs from 'fs'
import { fileURLToPath } from 'node:url'
import upath from 'upath'
import { Constants } from '../constants'

export function appVersion(name: string = 'puya-ts') {
  let dirName = upath.dirname(fileURLToPath(import.meta.url))

  while (true) {
    const packageJsonPath = upath.join(dirName, 'package.json')
    if (fs.existsSync(packageJsonPath)) {
      const version = JSON.parse(fs.readFileSync(packageJsonPath, 'utf8')).version
      return [
        `${name} ${version}`,
        '',
        'Targets:',
        `puya ${Constants.targetedPuyaVersion}`,
        `AVM ${Constants.supportedAvmVersions.join(', ')}`,
      ].join('\r\n')
    }
    if (dirName === upath.dirname(dirName)) break
    dirName = upath.dirname(dirName)
  }
  return `Cannot determine puya-ts version`
}



================================================
FILE: src/cli/build-command.ts
================================================
import type { ArgumentParser } from 'argparse'
import { BooleanOptionalAction } from 'argparse'
import { compile } from '../compile'
import { processInputPaths } from '../input-paths/process-input-paths'
import { logger, LoggingContext, LogLevel } from '../logger'
import { ConsoleLogSink } from '../logger/sinks/console-log-sink'
import { CompileOptions, defaultPuyaOptions, LocalsCoalescingStrategy } from '../options'

import { parseCliTemplateVar } from '../util/template-var-cli-parser'
import { addEnumArg, convertInt } from './util'

export interface BuildCommandArgs {
  command: 'build'
  log_level: LogLevel
  output_awst: boolean
  output_awst_json: boolean
  dry_run: boolean
  skip_version_check: boolean
  output_teal: boolean
  output_source_map: boolean
  output_arc32: boolean
  output_arc56: boolean
  output_ssa_ir: boolean
  output_optimization_ir: boolean
  output_destructured_ir: boolean
  output_memory_ir: boolean
  output_bytecode: boolean
  out_dir: string
  debug_level: string
  optimization_level: string
  target_avm_version: string
  cli_template_definitions: string[]
  template_vars_prefix: string
  locals_coalescing_strategy: LocalsCoalescingStrategy
  paths: string[]
  puya_path: string
}

export function addBuildCommand(parser: ArgumentParser) {
  addEnumArg(parser, {
    name: '--log-level',
    default: LogLevel.Info,
    enumType: LogLevel,
    help: 'The minimum log level to output',
  })

  parser.add_argument('--output-awst', {
    help: 'Output debugging awst file per parsed file',
    default: false,
    action: BooleanOptionalAction,
  })

  parser.add_argument('--output-awst-json', {
    action: BooleanOptionalAction,
    default: false,
    help: 'Output debugging awst json file per parsed file',
  })

  parser.add_argument('--dry-run', {
    action: BooleanOptionalAction,
    default: false,
    help: "Just parse typescript files, don't invoke puya compiler",
  })
  parser.add_argument('--skip-version-check', {
    action: BooleanOptionalAction,
    default: false,
    help: "Don't verify installed puya compiler version matches targeted version",
  })
  parser.add_argument('--output-teal', {
    action: BooleanOptionalAction,
    help: 'Output TEAL code',
    default: defaultPuyaOptions.outputTeal,
  })
  parser.add_argument('--output-source-map', {
    action: BooleanOptionalAction,
    help: 'Output debug source maps ',
    default: defaultPuyaOptions.outputSourceMap,
  })
  parser.add_argument('--output-arc32', {
    action: BooleanOptionalAction,
    help: 'Output {contract}.arc32.json ARC-32 app spec file. Only applicable to ARC4 contracts ',
    default: defaultPuyaOptions.outputArc32,
  })
  parser.add_argument('--output-arc56', {
    action: BooleanOptionalAction,
    help: 'Output {contract}.arc56.json ARC-56 app spec file. Only applicable to ARC4 contracts ',
    default: defaultPuyaOptions.outputArc56,
  })
  parser.add_argument('--output-ssa-ir', {
    action: BooleanOptionalAction,
    help: 'Output IR (in SSA form) before optimisations',
    default: defaultPuyaOptions.outputSsaIr,
  })
  parser.add_argument('--output-optimization-ir', {
    action: BooleanOptionalAction,
    help: 'Output IR after each optimization',
    default: defaultPuyaOptions.outputOptimizationIr,
  })
  parser.add_argument('--output-destructured-ir', {
    action: BooleanOptionalAction,
    help: 'Output IR after SSA destructuring and before MIR',
    default: defaultPuyaOptions.outputDestructuredIr,
  })
  parser.add_argument('--output-memory-ir', {
    action: BooleanOptionalAction,
    help: 'Output MIR before lowering to TealOps',
    default: defaultPuyaOptions.outputMemoryIr,
  })
  parser.add_argument('--output-bytecode', {
    action: BooleanOptionalAction,
    help: 'Output AVM bytecode',
    default: defaultPuyaOptions.outputBytecode,
  })

  parser.add_argument('--out-dir', {
    action: 'store',
    help: 'Where to output builder artifacts. Can use [name] placeholder to include contract name in path',
    default: 'out',
  })

  parser.add_argument('--debug-level', {
    default: defaultPuyaOptions.debugLevel.toString(),
    choices: ['0', '1', '2'],
    help: 'Output debug information level, 0 = none, 1 = debug, 2 = reserved for future use',
  })
  parser.add_argument('--optimization-level', {
    default: defaultPuyaOptions.optimizationLevel.toString(),
    choices: ['0', '1', '2'],
    help: 'Set optimization level of output TEAL / AVM bytecode, 0 = none, 1 = normal, 2 = intensive',
  })
  parser.add_argument('--target-avm-version', {
    default: defaultPuyaOptions.targetAvmVersion.toString(),
    choices: ['10', '11'],
    help: 'Select the targeted AVM version for compilation output',
  })

  parser.add_argument('--cli-template-definitions', {
    metavar: 'VAR=VALUE',
    nargs: '+',
    help: 'Define template vars for use when assembling via --output-bytecode, should be specified without the prefix (see --template-vars-prefix)',
  })

  parser.add_argument('--template-vars-prefix', {
    help: 'Define the prefix to use with --template-var',
    default: defaultPuyaOptions.templateVarsPrefix,
  })

  addEnumArg(parser, {
    name: '--locals-coalescing-strategy',
    enumType: LocalsCoalescingStrategy,
    help: 'Strategy choice for out-of-ssa local variable coalescing. The best choice for your app is best determined through experimentation',
    default: defaultPuyaOptions.localsCoalescingStrategy,
  })

  parser.add_argument('paths', {
    metavar: 'PATHS',
    nargs: '*',
    help: 'The path, or paths to search for compatible .algo.ts files',
    default: ['.'],
  })

  parser.add_argument('--puya-path', {
    help: 'The path to Puya. If not provided, puya-ts will automatically download the appropriate binary for your system',
  })
}

export async function buildCommand(args: BuildCommandArgs) {
  const logCtx = LoggingContext.create()
  return logCtx.run(async () => {
    logger.configure([new ConsoleLogSink(args.log_level)])
    try {
      const filePaths = processInputPaths({ paths: args.paths, outDir: args.out_dir })

      await compile(
        new CompileOptions({
          filePaths,
          outputAwst: args.output_awst,
          outputAwstJson: args.output_awst_json,

          skipVersionCheck: args.skip_version_check,
          dryRun: args.dry_run,
          logLevel: args.log_level,

          outputTeal: args.output_teal,
          outputArc32: args.output_arc32,
          outputArc56: args.output_arc56,
          outputSsaIr: args.output_ssa_ir,
          outputOptimizationIr: args.output_optimization_ir,
          outputDestructuredIr: args.output_destructured_ir,
          outputMemoryIr: args.output_memory_ir,
          outputBytecode: args.output_bytecode,
          outputSourceMap: args.output_source_map,
          debugLevel: convertInt(args.debug_level),
          optimizationLevel: convertInt(args.optimization_level),
          targetAvmVersion: convertInt(args.target_avm_version),
          cliTemplateDefinitions: Object.fromEntries(args.cli_template_definitions?.map(parseCliTemplateVar) ?? []),
          templateVarsPrefix: args.template_vars_prefix,
          localsCoalescingStrategy: args.locals_coalescing_strategy,

          customPuyaPath: args.puya_path,
        }),
      )
      logCtx.exitIfErrors()
    } catch (e) {
      if (e instanceof Error) {
        logger.error(e)
      } else {
        throw e
      }
    }
  })
}



================================================
FILE: src/cli/check-node-version.ts
================================================
import chalk from 'chalk'
import { Constants } from '../constants'
import { parseSemVer } from '../puya/semver'

function writeError(text: string) {
  // eslint-disable-next-line no-console
  console.error(chalk.red(text))
}

export function checkNodeVersion() {
  const min = parseSemVer(Constants.minNodeVersion)
  const actual = parseSemVer(process.versions.node)

  if (
    actual.major < min.major ||
    (actual.major === min.major && actual.minor < min.minor) ||
    (actual.major === min.major && actual.minor === min.minor && actual.rev < min.rev)
  ) {
    writeError(
      `Installed node version ${process.versions.node} is older than the minimum required version ${Constants.minNodeVersion}. You may experience compatability issues.`,
    )
  }
}



================================================
FILE: src/cli/parse.ts
================================================
import { ArgumentParser } from 'argparse'
import { appVersion } from './app-version'
import type { BuildCommandArgs } from './build-command'
import { addBuildCommand, buildCommand } from './build-command'
import { checkNodeVersion } from './check-node-version'

export async function parseCliArguments() {
  checkNodeVersion()
  const parser = new ArgumentParser({
    prog: 'puya-ts',
  })

  parser.add_argument('--version', {
    action: 'store_const',
    help: 'Show application version',
    const: 'version',
    dest: 'command',
  })
  parser.set_defaults({
    command: 'build',
  })
  addBuildCommand(parser)
  const result: PuyaTsCommand = parser.parse_args()
  switch (result.command) {
    case 'build':
      await buildCommand(result)
      break
    case 'version':
      /* eslint-disable-next-line no-console */
      console.log(appVersion())
      break
    default:
      parser.print_help()
      break
  }
}

type PuyaTsCommand = NoCommandArgs | BuildCommandArgs | VersionCommand
interface NoCommandArgs {
  command: 'none'
}
interface VersionCommand {
  command: 'version'
}



================================================
FILE: src/cli/util.ts
================================================
import type { ArgumentParser } from 'argparse'
import { enumFromValue } from '../util'

export function addEnumArg<T>(
  parser: ArgumentParser,
  { name, enumType, default: defaultValue, help }: { name: string; enumType: Record<string, string>; default?: T; help: string },
) {
  parser.add_argument(name, {
    type: (v: string) => enumFromValue(v, enumType),
    choices: Array.from(Object.values(enumType)),
    default: defaultValue,
    help,
  })
}

export function convertInt(val: string) {
  const res = Number(val)
  if (isNaN(res) || Math.round(res) !== res) {
    throw new Error(`'${val}' could not be converted to a number`)
  }
  return res
}



================================================
FILE: src/input-paths/determine-out-dir.spec.ts
================================================
import os from 'os'
import { describe, expect, it } from 'vitest'
import { determineOutDir } from './determine-out-dir'

describe('determineOutDir', () => {
  const isWindows = os.platform() === 'win32'
  it.each([
    // Relative input path with explicit ./
    ['./examples/*', 'examples/hello/contract.algo.ts', 'out', 'examples/hello/out'],
    ['./examples/*', 'examples/hello/nested/contract.algo.ts', 'out', 'examples/hello/out/nested'],
    ['./examples/**', 'examples/hello/nested/contract.algo.ts', 'out', 'examples/hello/nested/out'],
    ['./examples', 'examples/hello/contract.algo.ts', 'out', 'examples/out/hello'],
    ['./examples/hello', 'examples/hello/contract.algo.ts', 'out', 'examples/hello/out'],
    ['./examples/hello/contract.algo.ts', 'examples/hello/contract.algo.ts', 'out', 'examples/hello/out'],
    // Relative outDir
    ['examples/*', 'examples/hello/contract.algo.ts', 'out', 'examples/hello/out'],
    ['examples/*', 'examples/hello/nested/contract.algo.ts', 'out', 'examples/hello/out/nested'],
    ['examples/**', 'examples/hello/nested/contract.algo.ts', 'out', 'examples/hello/nested/out'],
    ['examples', 'examples/hello/contract.algo.ts', 'out', 'examples/out/hello'],
    ['examples/hello', 'examples/hello/contract.algo.ts', 'out', 'examples/hello/out'],
    ['examples/hello/contract.algo.ts', 'examples/hello/contract.algo.ts', 'out', 'examples/hello/out'],
    // Alternative relative outDir
    ['examples/*', 'examples/hello/contract.algo.ts', './out', 'examples/hello/out'],
    ['examples/*', 'examples/hello/nested/contract.algo.ts', './out', 'examples/hello/out/nested'],
    ['examples/**', 'examples/hello/nested/contract.algo.ts', './out', 'examples/hello/nested/out'],
    ['examples', 'examples/hello/contract.algo.ts', './out', 'examples/out/hello'],
    ['examples/hello', 'examples/hello/contract.algo.ts', './out', 'examples/hello/out'],
    ['examples/hello/contract.algo.ts', 'examples/hello/contract.algo.ts', './out', 'examples/hello/out'],
    // Windows absolute outDir
    ['examples/*', 'examples/hello/contract.algo.ts', 'c:/out', isWindows ? 'c:/out' : 'examples/hello/c:/out'],
    ['examples/*', 'examples/hello/nested/contract.algo.ts', 'c:/out', isWindows ? 'c:/out/nested' : 'examples/hello/c:/out/nested'],
    ['examples/**', 'examples/hello/nested/contract.algo.ts', 'c:/out', isWindows ? 'c:/out' : 'examples/hello/nested/c:/out'],
    ['examples', 'examples/hello/contract.algo.ts', 'c:/out', isWindows ? 'c:/out/hello' : 'examples/c:/out/hello'],
    ['examples/hello', 'examples/hello/contract.algo.ts', 'c:/out', isWindows ? 'c:/out' : 'examples/hello/c:/out'],
    ['examples/hello/contract.algo.ts', 'examples/hello/contract.algo.ts', 'c:/out', isWindows ? 'c:/out' : 'examples/hello/c:/out'],
    // Unix absolute outDir
    ['examples/*', 'examples/hello/contract.algo.ts', '/out', '/out'],
    ['examples/*', 'examples/hello/nested/contract.algo.ts', '/out', '/out/nested'],
    ['examples/**', 'examples/hello/nested/contract.algo.ts', '/out', '/out'],
    ['examples', 'examples/hello/contract.algo.ts', '/out', '/out/hello'],
    ['examples/hello', 'examples/hello/contract.algo.ts', '/out', '/out'],
    ['examples/hello/contract.algo.ts', 'examples/hello/contract.algo.ts', '/out', '/out'],

    // Dot paths
    ['.', 'examples/hello/contract.algo.ts', 'out', 'out/examples/hello'],
    ['./', 'examples/hello/contract.algo.ts', 'out', 'out/examples/hello'],

    // Unix Absolute inputs
    ['/users/bob/src/', '/users/bob/src/contract.algo.ts', 'out', '/users/bob/src/out'],
  ])('returns the correct out dir', (inputPath, sourceFile, outDir, result) => {
    const calculatedOutDir = determineOutDir(inputPath, sourceFile, outDir)
    expect(calculatedOutDir).toBe(result)
  })
})



================================================
FILE: src/input-paths/determine-out-dir.ts
================================================
import { minimatch } from 'minimatch'
import upath from 'upath'

export function determineOutDir(inputPath: string, sourceFile: string, outDir: string) {
  const outDirBase = findMinimalMatch(upath.normalizeTrim(inputPath), sourceFile)

  const subPath = upath.dirname(sourceFile.slice(outDirBase.length))

  if (upath.isAbsolute(outDir)) {
    return upath.normalizeTrim(upath.join(outDir, subPath))
  }
  return upath.normalizeTrim(upath.join(outDirBase, outDir, subPath))
}

function trimCurrentDir(path: string) {
  return path.startsWith('./') ? path.slice(2) : path
}

function findMinimalMatch(inputPath: string, testPath: string): string {
  if (inputPath === '.' || testPath === '.') {
    return ''
  }
  const [matchedPath] = minimatch.match([trimCurrentDir(testPath)], trimCurrentDir(inputPath))
  if (matchedPath) {
    if (matchedPath.endsWith('.algo.ts')) {
      return upath.dirname(matchedPath)
    }
    return matchedPath
  }
  return findMinimalMatch(inputPath, upath.dirname(testPath))
}



================================================
FILE: src/input-paths/process-input-paths.ts
================================================
import { globSync } from 'glob'
import fs from 'node:fs'
import upath from 'upath'
import { PuyaError } from '../errors'
import { logger } from '../logger'
import type { AlgoFile } from '../options'
import { normalisePath } from '../util'
import { determineOutDir } from './determine-out-dir'

export const processInputPaths = ({
  paths,
  workingDirectory = process.cwd(),
  outDir = 'out',
}: {
  paths: string[]
  outDir?: string
  workingDirectory?: string
}): AlgoFile[] => {
  const filePaths: AlgoFile[] = []

  for (const p of paths.map((p) => upath.normalizeTrim(p))) {
    if (p.endsWith('.algo.ts')) {
      if (fs.existsSync(p)) {
        const sourceFile = normalisePath(p, workingDirectory)

        filePaths.push({
          sourceFile,
          outDir: determineOutDir(p, sourceFile, outDir),
        })
      } else {
        logger.warn(undefined, `File ${p} could not be found`)
      }
    } else if (p.endsWith('.ts')) {
      logger.warn(undefined, `Ignoring path ${p} as it does use the .algo.ts extension`)
    } else {
      const matches = globSync(upath.join(p, '**/*.algo.ts'))
      if (matches.length) {
        for (const match of matches) {
          const sourceFile = normalisePath(match, workingDirectory)
          filePaths.push({
            sourceFile,
            outDir: determineOutDir(p, sourceFile, outDir),
          })
        }
      } else {
        logger.warn(undefined, `Path '${p}' did not match any .algo.ts files`)
      }
    }
  }
  if (filePaths.length === 0) {
    throw new PuyaError('Input paths did not match any .algo.ts files')
  }

  return filePaths.map(replaceOutDirTokens)
}

function replaceOutDirTokens(algoFile: AlgoFile): AlgoFile {
  const replacements = {
    name: upath.basename(algoFile.sourceFile).replace('.algo.ts', ''),
  }

  return {
    ...algoFile,
    outDir: algoFile.outDir.replaceAll('[name]', replacements.name),
  }
}



================================================
FILE: src/language-server/diagnostics.ts
================================================
import upath from 'upath'
import type { Connection, Diagnostic } from 'vscode-languageserver'
import { DiagnosticSeverity } from 'vscode-languageserver'
import type { TextDocument } from 'vscode-languageserver-textdocument'
import type { TextDocuments } from 'vscode-languageserver/node.js'
import { URI } from 'vscode-uri'
import type { SourceLocation } from '../awst/source-location'
import { compile } from '../compile'
import { Constants } from '../constants'
import { processInputPaths } from '../input-paths/process-input-paths'
import type { LogEvent } from '../logger'
import { LoggingContext, LogLevel } from '../logger'
import type { AlgoFile } from '../options'
import { CompileOptions } from '../options'

type LogEventWithSource = LogEvent & { sourceLocation: SourceLocation & { file: string } }

function prepareFiles(workspaceFolder: string, documents: TextDocuments<TextDocument>) {
  const files = processInputPaths({ paths: [workspaceFolder] })

  // To support unsaved files, we need to replace the file content with the content of the document
  return files.map((file) => {
    const fileUri = URI.file(file.sourceFile).toString()
    const document = documents.get(fileUri)

    if (document) {
      return {
        sourceFile: file.sourceFile,
        outDir: '',
        fileContents: document.getText(),
      } satisfies AlgoFile
    }
    return file
  })
}

async function compileAndExtractLogs(files: AlgoFile[]): Promise<LogEventWithSource[]> {
  const logCtx = LoggingContext.create()
  await logCtx.run(async () => {
    await compile(
      new CompileOptions({
        filePaths: files,
        dryRun: false,
      }),
    )
  })
  return logCtx.logEvents
    .filter((e) => e.level === LogLevel.Error || e.level === LogLevel.Warning)
    .filter((e): e is LogEventWithSource => Boolean(e.sourceLocation?.file))
}

function mapToDiagnostic(event: LogEventWithSource): Diagnostic {
  return {
    source: Constants.languageServerSource,
    severity: event.level === LogLevel.Error ? DiagnosticSeverity.Error : DiagnosticSeverity.Warning,
    range: {
      start: {
        line: event.sourceLocation.line - 1,
        character: event.sourceLocation.column,
      },
      end: {
        line: event.sourceLocation.endLine - 1,
        character: event.sourceLocation.endColumn,
      },
    },
    message: event.message,
  }
}

export async function getWorkspaceDiagnostics(
  connection: Connection,
  workspaceFolder: string,
  documents: TextDocuments<TextDocument>,
): Promise<Map<string, Diagnostic[]>> {
  try {
    connection.console.debug(`Parsing ${workspaceFolder}`)

    const files = prepareFiles(workspaceFolder, documents)
    const logEvents = await compileAndExtractLogs(files)

    return files.reduce((acc, file) => {
      const diagnostics = logEvents.filter((e) => e.sourceLocation.file === file.sourceFile).map(mapToDiagnostic)
      acc.set(
        URI.file(upath.isAbsolute(file.sourceFile) ? file.sourceFile : upath.join(workspaceFolder, file.sourceFile)).toString(),
        diagnostics,
      )
      return acc
    }, new Map<string, Diagnostic[]>())
  } catch (error) {
    connection.console.error(`Failed to compile: ${JSON.stringify(error)}`)
    return new Map()
  }
}



================================================
FILE: src/language-server/language-server.ts
================================================
import { concatMap, debounceTime, map, Observable } from 'rxjs'
import { TextDocument } from 'vscode-languageserver-textdocument'
import type {
  CodeAction,
  Connection,
  Diagnostic,
  Disposable,
  InitializeResult,
  TextDocumentChangeEvent,
} from 'vscode-languageserver/node.js'
import {
  createClientSocketTransport,
  createConnection,
  ProposedFeatures,
  TextDocuments,
  TextDocumentSyncKind,
} from 'vscode-languageserver/node.js'
import { URI } from 'vscode-uri'
import { Constants } from '../constants'
import { getWorkspaceDiagnostics } from './diagnostics'

export const getDebugLspPort = () => {
  const port = Number(process.env.PUYA_TS_DEBUG_LSP_PORT)
  return !isNaN(port) && port > 0 ? port : undefined
}

const resolveConnection = async () => {
  const lspPort = getDebugLspPort()

  if (!lspPort) {
    return createConnection(ProposedFeatures.all)
  }

  // When the debug env variable PUYA_TS_DEBUG_LSP_PORT is set, we start the server with socket transport.
  // Note: this is actually the oposite to how vscode-languageserver is designed.
  // Normally, the extension is the web socker server and the language server is the client.
  // Here, we flip it. This allows an easier debugging experience.
  // If changes are made to the language server, you can just restart the debugger
  // and choose the option "Restart language server" in the VS Code extension host instance.
  const transport = await createClientSocketTransport(lspPort)
  const protocol = await transport.onConnected()

  return createConnection(ProposedFeatures.all, protocol[0], protocol[1])
}

export async function startLanguageServer() {
  const connection = await resolveConnection()

  // Create a simple text document manager.
  const documents = new TextDocuments(TextDocument)
  let workspaceFolder: string | undefined

  const disposables: Disposable[] = []

  disposables.push(
    connection.onInitialize((params) => {
      // The extension sets the workspaceFolder property
      // therefore, workspaceFolders is an array with one element
      workspaceFolder = params.workspaceFolders?.[0]?.uri

      const result: InitializeResult = {
        capabilities: {
          textDocumentSync: TextDocumentSyncKind.Incremental,
          codeActionProvider: {
            resolveProvider: false,
          },
        },
      }
      return result
    }),
  )

  disposables.push(
    connection.onInitialized(() => {
      connection.console.log(`${Constants.languageServerSource}-ls initialized`)
    }),
  )

  const documentChangeObservable = new Observable<TextDocumentChangeEvent<TextDocument>>((subscriber) => {
    const subscription = documents.onDidChangeContent((event) => {
      subscriber.next(event)
    })

    return subscription.dispose
  })

  const documentChangeSubscription = documentChangeObservable
    .pipe(
      debounceTime(200),
      map((_) => buildWorkspaceDiagnosticsMap(connection, workspaceFolder, documents)),
      concatMap(async (v) => sendDiagnostics(connection, await v)),
    )
    .subscribe(async () => {
      // All logic for handling the document change event is done inside the pipe
      // This is to make sure that the diagnostics are sent in the right order
      // The empty subscribe function here is to make the observable run
    })

  // Make the text document manager listen on the connection
  // for open, change and close text document events
  disposables.push(documents.listen(connection))

  disposables.push(
    connection.onCodeAction((params) => {
      const document = documents.get(params.textDocument.uri)
      if (!document) {
        return []
      }

      const codeActions: CodeAction[] = []

      return codeActions
    }),
  )

  const shutdownDisposable = connection.onShutdown(() => {
    documentChangeSubscription.unsubscribe()
    disposables.forEach((d) => d.dispose())
  })

  connection.onExit(() => {
    shutdownDisposable.dispose()
  })

  connection.listen()
}

async function buildWorkspaceDiagnosticsMap(
  connection: Connection,
  workspaceFolder: string | undefined,
  documents: TextDocuments<TextDocument>,
): Promise<Map<string, Diagnostic[]>> {
  if (!workspaceFolder) {
    connection.console.error('Workspace folder not set')

    return new Map()
  }

  const workspacePath = URI.parse(workspaceFolder).fsPath
  return await getWorkspaceDiagnostics(connection, workspacePath, documents)
}

async function sendDiagnostics(connection: Connection, diagnosticsMap: Map<string, Diagnostic[]>) {
  await Promise.all(
    Array.from(diagnosticsMap, ([docUri, diagnostics]) =>
      connection.sendDiagnostics({
        uri: docUri,
        diagnostics: diagnostics,
      }),
    ),
  )
}



================================================
FILE: src/language-server/parse.ts
================================================
import { ArgumentParser } from 'argparse'
import { appVersion } from '../cli/app-version'
import { checkNodeVersion } from '../cli/check-node-version'
import { startLanguageServer } from './language-server'

export async function parseCliArguments() {
  checkNodeVersion()
  const prog = 'puyats-ls'
  const parser = new ArgumentParser({
    prog,
  })

  parser.add_argument('--version', {
    action: 'store_const',
    help: 'Show application version',
    const: 'version',
    dest: 'command',
  })
  const [result, _] = parser.parse_known_args() as [PuyaTsCommand, unknown]

  switch (result.command) {
    case 'version':
      /* eslint-disable-next-line no-console */
      console.log(appVersion(prog))
      break
    default:
      await startLanguageServer()
      break
  }
}

type PuyaTsCommand = NoCommandArgs | VersionCommand
interface NoCommandArgs {
  command: 'none'
}
interface VersionCommand {
  command: 'version'
}



================================================
FILE: src/logger/index.ts
================================================
import { AsyncLocalStorage } from 'node:async_hooks'
import { SourceLocation } from '../awst/source-location'
import { PuyaError, UserError } from '../errors'
import type { LogSink } from './sinks'

type NodeOrSourceLocation = SourceLocation | { sourceLocation: SourceLocation }

export enum LogLevel {
  Error = 'error',
  Info = 'info',
  Warning = 'warning',
  Debug = 'debug',
  Critical = 'critical',
}
const logLevelToInt = {
  [LogLevel.Critical]: 4,
  [LogLevel.Error]: 3,
  [LogLevel.Info]: 1,
  [LogLevel.Warning]: 2,
  [LogLevel.Debug]: 0,
}

export const isMinLevel = (logLevel: LogLevel, minLevel: LogLevel): boolean => {
  return logLevelToInt[minLevel] <= logLevelToInt[logLevel]
}

const errorOrCritical = new Set([LogLevel.Error, LogLevel.Critical])

export const isErrorOrCritical = (l: LogLevel) => errorOrCritical.has(l)

export type LogEvent = {
  level: LogLevel
  message: string
  sourceLocation: SourceLocation | undefined
}

class PuyaLogger {
  private logSinks: LogSink[] = []
  public configure(sinks: LogSink[]) {
    this.logSinks = sinks
  }

  addLog(level: LogEvent['level'], source: NodeOrSourceLocation | undefined, message: string) {
    const logEvent: LogEvent = {
      sourceLocation: source ? (source instanceof SourceLocation ? source : source.sourceLocation) : undefined,
      message,
      level,
    }
    LoggingContext.current.logEvents.push(logEvent)
    for (const sink of this.logSinks) {
      if (isMinLevel(logEvent.level, sink.minLogLevel)) sink.add(logEvent)
    }
  }

  error(error: Error): void
  error(source: NodeOrSourceLocation | undefined, message: string): void
  error(source: NodeOrSourceLocation | undefined | Error, message?: string): void {
    if (source instanceof Error) {
      // Don't include the stack for user errors as the message and source location is what's relevant
      const stack = source instanceof UserError ? '' : `\n ${source.stack}`
      this.addLog(LogLevel.Error, tryGetSourceLocationFromError(source), `${source.message}${stack}`)
      if (source.cause) {
        this.addLog(LogLevel.Error, tryGetSourceLocationFromError(source.cause), `Caused by: ${source.cause}`)
      }
    } else {
      this.addLog(LogLevel.Error, source, message ?? '')
    }
  }
  info(source: NodeOrSourceLocation | undefined, message: string): void {
    this.addLog(LogLevel.Info, source, message)
  }
  debug(source: NodeOrSourceLocation | undefined, message: string): void {
    this.addLog(LogLevel.Debug, source, message)
  }
  warn(source: NodeOrSourceLocation | undefined, message: string): void {
    this.addLog(LogLevel.Warning, source, message)
  }
  critical(source: NodeOrSourceLocation | undefined, message: string): void {
    this.addLog(LogLevel.Critical, source, message)
  }
}

const tryGetSourceLocationFromError = (error: unknown): SourceLocation | undefined => {
  if (error instanceof PuyaError) {
    return error.sourceLocation
  }
  return undefined
}

export const logger = new PuyaLogger()

export const patchErrorLocation = <TArgs extends unknown[], TReturn>(
  action: (...args: TArgs) => TReturn,
  sourceLocation: SourceLocation,
) => {
  return (...args: TArgs) => {
    try {
      return action(...args)
    } catch (e) {
      if (e instanceof PuyaError && !e.sourceLocation) {
        Object.assign(e, { sourceLocation })
      }
      throw e
    }
  }
}

export class LoggingContext {
  logEvents: LogEvent[] = []
  sourcesByPath: Record<string, string[]> = {}

  private constructor() {}

  hasErrors(): boolean {
    return this.logEvents.some((e) => isErrorOrCritical(e.level))
  }

  exitIfErrors(): void {
    if (this.hasErrors()) process.exit(1)
  }

  enterContext() {
    LoggingContext.asyncStore.enterWith(this)
    return this
  }

  run<R>(cb: () => R) {
    return LoggingContext.asyncStore.run(this, cb)
  }
  private static fallbackContext = new LoggingContext()
  private static asyncStore = new AsyncLocalStorage<LoggingContext>()

  static create(): LoggingContext {
    return new LoggingContext()
  }
  static get current() {
    const ctx = this.asyncStore.getStore()
    if (!ctx) {
      return this.fallbackContext
    }
    return ctx
  }
}



================================================
FILE: src/logger/sinks/console-log-sink.ts
================================================
import chalk from 'chalk'
import type { SourceLocation } from '../../awst/source-location'
import type { LogEvent } from '../index'
import { isMinLevel, LoggingContext, LogLevel } from '../index'
import type { LogSink } from './index'

type ColorFn = (text: string) => string
const levelConfig: Record<LogEvent['level'], { colorFn: ColorFn; writeFn: (...args: unknown[]) => void }> = {
  /* eslint-disable no-console */
  debug: { colorFn: chalk.green, writeFn: console.debug },
  info: { colorFn: chalk.green, writeFn: console.info },
  warning: { colorFn: chalk.yellow, writeFn: console.warn },
  error: { colorFn: chalk.red, writeFn: console.error },
  critical: { colorFn: chalk.red, writeFn: console.error },
  /* eslint-enable no-console */
}

export class ConsoleLogSink implements LogSink {
  constructor(public readonly minLogLevel: LogLevel) {}

  add(logEvent: LogEvent): void {
    const config = levelConfig[logEvent.level]

    let logText = `${config.colorFn(logEvent.level)}: ${logEvent.message}`
    if (logEvent.sourceLocation) {
      const sourceLocationText = logEvent.sourceLocation.toString()
      const indentSize = sourceLocationText.length + logEvent.level.length + 4

      const sourceSummary = isMinLevel(logEvent.level, LogLevel.Warning) ? this.getSourceSummary(logEvent.sourceLocation, indentSize) : ''
      logText = `${sourceLocationText} ${logText}${sourceSummary}`
    }
    config.writeFn(logText)
  }

  getSourceSummary(sourceLocation: SourceLocation, indent: number): string {
    const sourceFile = sourceLocation.file && LoggingContext.current.sourcesByPath[sourceLocation.file]
    if (!sourceFile || sourceLocation.scope === 'file') return ''

    const line = sourceFile[sourceLocation.line - 1]
    const trimmedLine = line.trimStart()
    const marker = `${''.padStart(sourceLocation.column - (line.length - trimmedLine.length))}^${''.padStart(Math.max(sourceLocation.endColumn - sourceLocation.column - 1, 0), '~')}`
    const indentChars = ''.padStart(indent, ' ')
    return `\n${indentChars}${trimmedLine}\n${indentChars}${marker}`
  }
}



================================================
FILE: src/logger/sinks/index.ts
================================================
import type { LogEvent, LogLevel } from '../index'

export type LogSink = {
  readonly minLogLevel: LogLevel
  add(e: LogEvent): void
}



================================================
FILE: src/parser/index.ts
================================================
import ts from 'typescript'
import { SourceLocation } from '../awst/source-location'
import { logger, LoggingContext } from '../logger'
import type { AlgoFile, CompileOptions } from '../options'
import type { DeliberateAny } from '../typescript-helpers'
import { normalisePath } from '../util'
import { resolveModuleNameLiterals } from './resolve-module-name-literals'

export type SourceFileMapping = Record<string, ts.SourceFile>
export type CreateProgramResult = {
  sourceFiles: SourceFileMapping
  program: ts.Program
  programDirectory: string
}

export function createTsProgram(options: Pick<CompileOptions, 'filePaths'>): CreateProgramResult {
  const compilerOptions: ts.CompilerOptions = {
    allowJs: false,
    strict: true,
    // Lib names need to be the full file name from the typescript package 'lib' folder.
    lib: ['lib.es2023.d.ts'],
    libReplacement: false,
    target: ts.ScriptTarget.ES2023,
    module: ts.ModuleKind.ESNext,
    moduleResolution: ts.ModuleResolutionKind.Bundler,
  }

  const host = ts.createCompilerHost(compilerOptions)

  const fileMap = options.filePaths.reduce((acc, cur) => acc.set(cur.sourceFile, cur), new Map<string, AlgoFile>())
  const { fileExists, readFile } = host
  host.fileExists = function (fileName): boolean {
    return fileMap.has(fileName) || fileExists(fileName)
  }
  host.readFile = function (fileName): string | undefined {
    const matchedFile = fileMap.get(fileName)
    if (matchedFile?.fileContents) {
      return matchedFile.fileContents
    }
    return readFile(fileName)
  }
  host.resolveModuleNameLiterals = resolveModuleNameLiterals

  const program = ts.createProgram(
    options.filePaths.map((p) => p.sourceFile),
    compilerOptions,
    host,
  )
  const programDirectory = program.getCurrentDirectory()

  const sourceFiles = Object.fromEntries(
    program
      .getSourceFiles()
      .filter((f) => !f.isDeclarationFile)
      .map((f) => {
        if (!(f as DeliberateAny)['externalModuleIndicator']) {
          logger.warn(
            SourceLocation.fromFile(f, programDirectory),
            'File is being interpreted as a script because it has no import or export statements. Containing statements will be evaluated in a global context.',
          )
        }
        return [normalisePath(f.fileName, programDirectory), f]
      }),
  )

  LoggingContext.current.sourcesByPath = Object.fromEntries(
    Object.entries(sourceFiles).map(([path, file]) => {
      return [path, file.getFullText().replace(/\r\n/g, '\n').split(/\n/g)]
    }),
  )

  reportDiagnostics(program)
  return {
    sourceFiles,
    program,
    programDirectory: program.getCurrentDirectory(),
  }
}

function reportDiagnostics(program: ts.Program) {
  function reportDiagnostic(diagnostic: ts.Diagnostic) {
    if (isDiagnosticWithLocation(diagnostic)) {
      const sourceLocation = SourceLocation.fromDiagnostic(diagnostic, program.getCurrentDirectory())
      const text = typeof diagnostic.messageText === 'string' ? diagnostic.messageText : diagnostic.messageText.messageText
      switch (diagnostic.category) {
        case ts.DiagnosticCategory.Error:
          logger.error(sourceLocation, text)
          break
        case ts.DiagnosticCategory.Warning:
          logger.warn(sourceLocation, text)
          break
      }
    }
  }

  function isDiagnosticWithLocation(d: ts.Diagnostic): d is ts.DiagnosticWithLocation {
    return Object.hasOwn(d, 'file')
  }

  program.getSemanticDiagnostics().forEach(reportDiagnostic)
  program.getSyntacticDiagnostics().forEach(reportDiagnostic)
}



================================================
FILE: src/parser/json-serialize-source-files.ts
================================================
import path from 'node:path'
import ts from 'typescript'
import type { SourceFileMapping } from './index'

export function jsonSerializeSourceFiles(sourceFiles: SourceFileMapping, programDirectory: string) {
  return JSON.stringify(
    Object.fromEntries(Object.entries(sourceFiles).map(([key, value]) => [path.join(programDirectory, key), value] as const)),
    (key, value) => {
      if (ts.isSourceFile(value)) {
        return value.getFullText().replace(/\r\n/g, '\n').split(/\n/g)
      }
      return value
    },
    2,
  )
}



================================================
FILE: src/parser/resolve-module-name-literals.ts
================================================
import ts from 'typescript'
import { logger } from '../logger'

export function resolveModuleNameLiterals(
  moduleLiterals: readonly ts.StringLiteralLike[],
  containingFile: string,
  redirectedReference: ts.ResolvedProjectReference | undefined,
  options: ts.CompilerOptions,
): readonly ts.ResolvedModuleWithFailedLookupLocations[] {
  return moduleLiterals.map(({ text: moduleName }) => {
    const result = ts.resolveModuleName(
      moduleName,
      containingFile,
      options,
      {
        fileExists: ts.sys.fileExists,
        readFile: ts.sys.readFile,
      },
      undefined,
      redirectedReference,
    )
    if (!result.resolvedModule && !containingFile.endsWith('.d.ts')) {
      logger.warn(undefined, `Could not resolve typings for module ${moduleName} referenced by file ${containingFile}. `)
    }

    return result
  })
}



================================================
FILE: src/puya/build-compilation-set-mapping.ts
================================================
import type { AWST } from '../awst/nodes'
import type { CompilationSet } from '../awst_build/models/contract-class-model'
import type { AlgoFile, CompilationSetMapping } from '../options'
import { mkDirIfNotExists } from '../util'

export function buildCompilationSetMapping({
  awst,
  inputPaths,
  compilationSet,
}: {
  awst: AWST[]
  inputPaths: AlgoFile[]
  compilationSet: CompilationSet
}): CompilationSetMapping {
  const setIds = new Set(compilationSet.compilationOutputSet.map((s) => s.id))

  return awst.reduce((acc, cur) => {
    if (setIds.has(cur.id.toString())) {
      const matchedPath = inputPaths.find((p) => p.sourceFile === cur.sourceLocation.file)
      if (matchedPath) {
        mkDirIfNotExists(matchedPath.outDir)
        acc[cur.id.toString()] = matchedPath.outDir
      }
    }
    return acc
  }, {} as CompilationSetMapping)
}



================================================
FILE: src/puya/check-puya-version.ts
================================================
import { Constants } from '../constants'
import { logger } from '../logger'
import { runPuya } from './run-puya'
import type { SemVer } from './semver'

export enum VersionCompareVerdict {
  ExactMatch = 'ExactMatch',
  Inconclusive = 'Inconclusive',
  MajorMismatch = 'MajorMismatch',
  MinorMismatch = 'MinorMismatch',
  OlderRevision = 'OlderRevision',
  NewerRevision = 'NewerRevision',
}

export async function comparePuyaVersion(puyaPath: string): Promise<{
  target: string
  found?: string
  verdict: VersionCompareVerdict
}> {
  const target = Constants.targetedPuyaVersion

  const versionParser = new VersionParser()
  await runPuya({
    command: puyaPath,
    args: ['--version'],
    onOutput: (line) => versionParser.receiveLine(line),
  })

  if (!versionParser.version) return { target, verdict: VersionCompareVerdict.Inconclusive }
  const ver = versionParser.version

  // Compare
  const [major, minor, rev] = target.split('.').map((x) => Number(x))
  if (ver.major !== major) return { verdict: VersionCompareVerdict.MajorMismatch, target, found: ver.formatted }
  if (ver.minor !== minor) return { verdict: VersionCompareVerdict.MinorMismatch, target, found: ver.formatted }
  if (ver.rev < rev) return { verdict: VersionCompareVerdict.OlderRevision, target, found: ver.formatted }
  if (ver.rev > rev) return { verdict: VersionCompareVerdict.NewerRevision, target, found: ver.formatted }
  return { verdict: VersionCompareVerdict.ExactMatch, target, found: ver.formatted }
}

export async function checkPuyaVersion(puyaPath: string) {
  const result = await comparePuyaVersion(puyaPath)

  switch (result.verdict) {
    case VersionCompareVerdict.Inconclusive:
      logger.warn(undefined, `Unable to verify the version of Puya at ${puyaPath}.`)
      break
    case VersionCompareVerdict.MajorMismatch:
    case VersionCompareVerdict.MinorMismatch:
      logger.warn(
        undefined,
        `Version of Puya at ${puyaPath} (${result.found}) does not match targeted version (${result.target}). There may be compatibility issues.`,
      )
      break
    case VersionCompareVerdict.OlderRevision:
      logger.warn(undefined, `Revision of Puya at ${puyaPath} (${result.found}) is older than the targeted revision (${result.target})`)
      break
    case VersionCompareVerdict.NewerRevision:
      logger.debug(undefined, `Revision of Puya at ${puyaPath} (${result.found}) is newer than the targeted revision (${result.target})`)
      break
  }
}

class VersionParser {
  #ver: SemVer | undefined

  receiveLine(line: string): void {
    const matched = /^puya ((\d+)\.(\d+)\.(\d+))$/.exec(line)
    if (!matched) {
      logger.debug(undefined, `'puya --version' command returned unexpected output: "${line}"`)
    } else {
      this.#ver = {
        formatted: matched[1],
        major: Number(matched[2]),
        minor: Number(matched[3]),
        rev: Number(matched[4]),
      }
    }
  }

  get version(): undefined | SemVer {
    return this.#ver
  }
}



================================================
FILE: src/puya/index.ts
================================================
import { AwstSerializer, SnakeCaseSerializer } from '../awst/json-serialize-awst'
import type { AWST } from '../awst/nodes'
import type { CompilationSet } from '../awst_build/models/contract-class-model'
import { logger, LogLevel } from '../logger'
import type { CompileOptions } from '../options'
import type { SourceFileMapping } from '../parser'
import { jsonSerializeSourceFiles } from '../parser/json-serialize-source-files'
import { generateTempFile } from '../util/generate-temp-file'
import { buildCompilationSetMapping } from './build-compilation-set-mapping'
import { checkPuyaVersion } from './check-puya-version'
import { deserializeAndLog } from './log-deserializer'
import { resolvePuyaPath } from './resolve-puya-path'
import { runPuya } from './run-puya'

export async function invokePuya({
  moduleAwst,
  programDirectory,
  sourceFiles,
  options,
  compilationSet,
}: {
  moduleAwst: AWST[]
  programDirectory: string
  sourceFiles: SourceFileMapping
  options: CompileOptions
  compilationSet: CompilationSet
}) {
  if (options.customPuyaPath && !options.skipVersionCheck) {
    checkPuyaVersion(options.customPuyaPath)
  }

  const puyaPath = options.customPuyaPath ?? (await resolvePuyaPath())

  // Write AWST file
  using moduleAwstFile = generateTempFile()
  logger.debug(undefined, `Writing awst to ${moduleAwstFile.filePath}`)
  const serializer = new AwstSerializer({
    programDirectory: programDirectory,
    sourcePaths: 'absolute',
  })
  moduleAwstFile.writeFileSync(serializer.serialize(moduleAwst), 'utf-8')

  // Write source annotations
  using moduleSourceFile = generateTempFile()
  logger.debug(undefined, `Write source to ${moduleSourceFile.filePath}`)
  moduleSourceFile.writeFileSync(jsonSerializeSourceFiles(sourceFiles, programDirectory), 'utf-8')

  // Write puya options
  const puyaOptions = options.buildPuyaOptions(
    buildCompilationSetMapping({
      awst: moduleAwst,
      inputPaths: options.filePaths,
      compilationSet,
    }),
  )
  using optionsFile = generateTempFile()
  logger.debug(undefined, `Write options to ${optionsFile.filePath}`)
  optionsFile.writeFileSync(new SnakeCaseSerializer().serialize(puyaOptions))
  const puyaArgs = [
    '--options',
    optionsFile.filePath,
    `--awst`,
    moduleAwstFile.filePath,
    `--source-annotations`,
    moduleSourceFile.filePath,
    '--log-level',
    getPuyaLogLevel(options.logLevel),
    '--log-format',
    'json',
  ]
  // Useful to have this in a var to copy/paste when debugging puya
  const puyaArgsStr = puyaArgs.join(' ')
  logger.debug(undefined, `Invoking puya: ${puyaPath} ${puyaArgsStr}`)
  await runPuya({
    command: puyaPath,
    args: puyaArgs,
    cwd: programDirectory,
    onOutput: deserializeAndLog,
  })
}

function getPuyaLogLevel(logLevel: LogLevel): string {
  switch (logLevel) {
    case LogLevel.Debug:
      return 'debug'
    case LogLevel.Info:
      return 'info'
    case LogLevel.Warning:
      return 'warning'
    case LogLevel.Error:
      return 'error'
    case LogLevel.Critical:
      return 'critical'
  }
}



================================================
FILE: src/puya/log-deserializer.ts
================================================
import upath from 'upath'
import { z } from 'zod'
import { SourceLocation } from '../awst/source-location'
import { logger, LogLevel } from '../logger'

const puyaLog = z.object({
  level: z.nativeEnum(LogLevel),
  location: z
    .object({
      file: z.string(),
      line: z.number(),
      end_line: z.number().or(z.null()),
      column: z.number(),
      end_column: z.number().or(z.null()),
    })
    .or(z.null()),
  message: z.string(),
})

export function deserializeAndLog(logText: string) {
  try {
    const log = puyaLog.parse(JSON.parse(logText))

    const sourceLocation = log.location
      ? new SourceLocation({
          file: upath.normalize(log.location.file),
          line: log.location.line,
          endLine: log.location.end_line ?? log.location.line + 1,
          column: log.location.column,
          endColumn: log.location.end_column ?? log.location.column,
          scope: 'range',
        })
      : undefined
    logger.addLog(log.level, sourceLocation, log.message)
  } catch (e) {
    logger.error(undefined, `Could not parse log output from puya cli ${e}`)
  }
}



================================================
FILE: src/puya/puya-binary.ts
================================================
import * as crypto from 'crypto'
import * as fs from 'fs'
import { fileURLToPath } from 'node:url'
import * as path from 'path'
import * as tar from 'tar'
import upath from 'upath'
import { Constants } from '../constants'
import { InternalError } from '../errors'
import { logger } from '../logger'
import { generateTempDir } from '../util/generate-temp-file'
import type { SemVer } from './semver'

/**
 * Gets the platform-specific binary name
 * @returns The appropriate binary name for the current platform
 */
function getBinaryName(): string {
  return process.platform === 'win32' ? 'puya.exe' : 'puya'
}

function getPuyaTsDir(): string {
  try {
    return upath.dirname(require.resolve('@algorandfoundation/puya-ts'))
  } catch {
    return upath.dirname(fileURLToPath(import.meta.url))
  }
}

export function getPuyaStorageDir(): string {
  const puyaTsDirName = getPuyaTsDir()
  return path.join(puyaTsDirName, '.puya')
}

export function getCachedPuyaBinaryPath(puyaStorageDir: string, version: SemVer): string {
  const binaryFileName = getBinaryName()
  return path.join(puyaStorageDir, version.formatted, binaryFileName)
}

/**
 * Gets the platform-specific details for downloads
 * @returns Object containing OS and architecture information
 */
function getPlatformDetails(): { os: string; arch: string } {
  const cliMessage = `Please refer to the puya-ts CLI documentation for information on how to install the Puya backend manually.`

  // Map Node.js platform to OS name used in filenames
  let os: string
  switch (process.platform) {
    case 'win32':
      os = 'windows'
      break
    case 'darwin':
      os = 'macos'
      break
    case 'linux':
      os = 'linux'
      break
    default:
      throw new InternalError(`Unsupported platform: ${process.platform}. ${cliMessage}`)
  }

  // Map Node.js architecture to architecture name used in filenames
  let arch: string
  switch (process.arch) {
    case 'x64':
      arch = 'x64'
      break
    case 'arm64':
      arch = 'arm64'
      break
    default:
      throw new InternalError(`Unsupported architecture: ${process.arch}. ${cliMessage}`)
  }

  return { os, arch }
}

/**
 * Downloads the Puya binary for a specific release version
 * @param version The release version to download (e.g., "1.0.0")
 * @returns Promise that resolves to the path of the extracted binary
 */
export async function downloadPuyaBinary(puyaStorageDir: string, version: SemVer): Promise<string> {
  // Get platform-specific details
  const { os, arch } = getPlatformDetails()

  // Build platform-specific filenames
  const platformId = `${os}_${arch}`
  const archiveFileName = `puya-${version.formatted}-${platformId}.tar.gz`
  const checksumFileName = `puya-${version.formatted}-${platformId}.sha256.txt`
  const binaryFileName = getBinaryName()

  const extractedDir = path.join(puyaStorageDir, version.formatted)

  // Ensure our storage directories exist
  if (!fs.existsSync(extractedDir)) {
    fs.mkdirSync(extractedDir, { recursive: true })
  }

  using tempDir = generateTempDir()

  const archiveFilePath = path.join(tempDir.dirPath, archiveFileName)
  const checksumFilePath = path.join(tempDir.dirPath, checksumFileName)
  const extractedBinaryPath = path.join(extractedDir, binaryFileName)

  logger.debug(undefined, `Downloading Puya binary for version ${version.formatted} and platform ${platformId}`)
  const archiveUrl = `https://github.com/${Constants.puyaGithubRepo}/releases/download/v${version.formatted}/${archiveFileName}`
  const checksumUrl = `https://github.com/${Constants.puyaGithubRepo}/releases/download/v${version.formatted}/${checksumFileName}`

  await downloadFile(archiveUrl, archiveFilePath)
  await downloadFile(checksumUrl, checksumFilePath)

  await verifyChecksum(archiveFilePath, archiveFileName, checksumFilePath)

  await tar.extract({
    file: archiveFilePath,
    cwd: extractedDir,
  })

  // Check if extraction was successful and binary exists
  if (!fs.existsSync(extractedBinaryPath)) {
    throw new InternalError(`Binary file ${binaryFileName} not found in the extracted archive`)
  }

  logger.debug(undefined, `Successfully downloaded and extracted Puya binary to ${extractedBinaryPath}`)
  return extractedBinaryPath
}

/**
 * Downloads a file from a URL to a specified path
 * @param url The URL to download from
 * @param destination The local path to save the file to
 * @returns Promise that resolves when the download is complete
 */
async function downloadFile(url: string, destination: string): Promise<void> {
  const response = await fetch(url)
  if (!response.ok) {
    throw new Error(`Failed to download file. Status Code: ${response.status}`)
  }
  const buffer = await response.arrayBuffer()
  return await new Promise<void>((resolve, reject) => {
    const fileStream = fs.createWriteStream(destination)
    const nodeBuffer = Buffer.from(buffer)

    fileStream.write(nodeBuffer)
    fileStream.end()

    fileStream.on('finish', () => {
      resolve()
    })

    fileStream.on('error', (err) => {
      fs.unlinkSync(destination)
      reject(err)
    })
  })
}

/**
 * Verifies the checksum of a downloaded file
 * @param filePath Path to the file to verify
 * @param checksumFilePath Path to the checksum file
 * @returns Promise that resolves to true if the checksum matches, false otherwise
 */
async function verifyChecksum(filePath: string, fileName: string, checksumFilePath: string): Promise<void> {
  return new Promise((resolve, reject) => {
    // Read the checksum file
    const expectedChecksum = fs.readFileSync(checksumFilePath, 'utf8').trim().toLowerCase()

    // Calculate the SHA256 checksum of the downloaded file
    const hash = crypto.createHash('sha256')
    const stream = fs.createReadStream(filePath)

    stream.on('data', (data) => {
      hash.update(data)
    })

    stream.on('end', () => {
      const calculatedChecksum = hash.digest('hex').toLowerCase()

      if (`${calculatedChecksum}  ${fileName}` === expectedChecksum) {
        resolve()
      }
      reject(new InternalError(`Checksum verification failed. Expected checksum: ${expectedChecksum} but got: ${calculatedChecksum}`))
    })
  })
}



================================================
FILE: src/puya/resolve-puya-path.ts
================================================
import * as fs from 'fs'
import { Constants } from '../constants'
import { logger } from '../logger'
import { createLockFile } from '../util/lock-file'
import { downloadPuyaBinary, getCachedPuyaBinaryPath, getPuyaStorageDir } from './puya-binary'
import { parseSemVer } from './semver'

export async function resolvePuyaPath(): Promise<string> {
  const version = parseSemVer(Constants.targetedPuyaVersion)

  const puyaStorageDir = getPuyaStorageDir()
  const cachedBinaryPath = getCachedPuyaBinaryPath(puyaStorageDir, version)

  if (isBinaryCached(cachedBinaryPath)) {
    return cachedBinaryPath
  }

  await using _ = await createLockFile(`${puyaStorageDir}.lock`, { maxRetries: 30, delayMs: 1000, staleMs: 60 * 1000 })

  // Between the first check and acquiring the lock, the binary may have been downloaded by another process.
  // In this case there is no need to download the binary again.
  if (isBinaryCached(cachedBinaryPath)) {
    return cachedBinaryPath
  }
  return await downloadPuyaBinary(puyaStorageDir, version)
}

function isBinaryCached(cachePath: string): boolean {
  if (fs.existsSync(cachePath)) {
    logger.debug(undefined, `Found cached Puya binary at ${cachePath}`)
    return true
  }
  return false
}



================================================
FILE: src/puya/run-puya.ts
================================================
import { logger } from '../logger'
import { invokeCli } from '../util/invoke-cli'

export async function runPuya({
  command,
  args,
  cwd,
  onOutput,
}: {
  command: string
  args: string[]
  cwd?: string
  onOutput: (line: string) => void
}) {
  const result = await invokeCli({
    command,
    args,
    cwd,
    onReceiveLine: onOutput,
    dontThrowOnNonzeroCode: true,
  })

  if (result.code !== 0) {
    logger.critical(undefined, `Compilation exited with status ${result.code}`)
  }
}



================================================
FILE: src/puya/semver.ts
================================================
import { InternalError } from '../errors'

export type SemVer = {
  major: number
  minor: number
  rev: number
  formatted: string
}

export function parseSemVer(version: string): SemVer {
  const matched = /^(\d+)\.(\d+)\.(\d+)$/.exec(version)
  if (!matched) {
    throw new InternalError(`Invalid version string: ${version}`)
  }

  return {
    major: Number(matched[1]),
    minor: Number(matched[2]),
    rev: Number(matched[3]),
    formatted: version,
  }
}



================================================
FILE: src/util/add-postinstall-script.ts
================================================
/* eslint-disable no-console */
import fs from 'fs'
import path from 'path'

// Get input folder from command line arguments
const inputFolder = process.argv[2]

if (!inputFolder) {
  console.error('Please provide an input folder as argument')
  process.exit(1)
}

try {
  // Construct path to package.json
  const packageJsonPath = path.join(inputFolder, 'package.json')

  // Read and parse package.json
  const packageJsonContent = fs.readFileSync(packageJsonPath, 'utf-8')
  const packageJson = JSON.parse(packageJsonContent)

  // Add or update scripts section
  packageJson.scripts = {
    ...(packageJson.scripts || {}),
    postinstall: 'node bin/download-puya-binary.mjs',
  }

  // Write back to file with proper formatting
  fs.writeFileSync(packageJsonPath, `${JSON.stringify(packageJson, null, 2)}\n`)

  console.log('Successfully added postinstall script to package.json')
} catch (error) {
  console.error('Error processing package.json:', error)
  process.exit(1)
}



================================================
FILE: src/util/arc4-signature-parser.spec.ts
================================================
import { describe, expect, it } from 'vitest'
import { Arc4ParseError, parseArc4Type } from './arc4-signature-parser'
import { invariant } from './index'

describe('arc4 signature parser', () => {
  describe('can parse valid types', () => {
    it.each([
      ['byte'],
      ['byte[]'],
      ['byte[5]'],
      ['bool'],
      ['bool[]'],
      ['bool[12]'],
      ['uint8'],
      ['uint8[]'],
      ['uint8[12]'],
      ['uint16'],
      ['uint16[]'],
      ['uint16[12]'],
      ['uint32'],
      ['uint32[]'],
      ['uint32[12]'],
      ['uint64'],
      ['uint64[]'],
      ['uint64[12]'],
      ['uint128'],
      ['uint128[]'],
      ['uint128[12]'],
      ['uint256'],
      ['uint256[]'],
      ['uint256[12]'],
      ['string'],
      ['string[]'],
      ['string[12]'],
      ['byte[][][]'],
      ['byte[2][2][2]'],
      ['(bool)'],
      ['(bool,string,uint8,(uint16,string[]),bool[])[1][]'],
    ])('%s parses', (arc4TypeString) => {
      const match = parseArc4Type(arc4TypeString)

      expect(match.wtype.arc4Name).toBe(arc4TypeString)
    })
  })
  describe('errors on invalid types', () => {
    it.each([
      ['float', "Expecting string 'uint', got 'floa...'", 0],
      ['uint2', 'n must be between 8 and 512, and a multiple of 8', 0],
      ['(uint8,uint2)', 'n must be between 8 and 512, and a multiple of 8', 7],
      ['uint8[', "Expecting character ']', but got end of input.", 6],
      ['uint8]', "Expecting ',', '[', or ')', but got ]", 6],
      ['uint8,uint8', 'Signature contained more than one type. Wrap multiple types in parentheses to declare a tuple type', 0],
      ['(uint8', 'Tuple has not been closed', 6],
      ['(uint8,bool))', "Char ')' has no matching opening '('", 13],
    ])('%s returns error %s', (typeString, errorMessage, errorIndex) => {
      try {
        parseArc4Type(typeString)
      } catch (e) {
        invariant(e instanceof Arc4ParseError, 'e must be instance of Arc4ParseError')
        expect(e.message).toBe(errorMessage)
        expect(e.index).toBe(errorIndex)
        return
      }
      expect.fail('Expected error but none was thrown')
    })
  })
})



================================================
FILE: src/util/arc4-signature-parser.ts
================================================
import * as A from 'arcsecond'
import * as arc4Types from '../awst_build/ptypes/arc4-types'

const peek = A.lookAhead(A.regex(/^./))

const integer = A.regex(/^\d+/).map((x) => BigInt(x))

const uint = A.sequenceOf([A.str('uint'), integer]).map(([_, n]) => new arc4Types.UintNType({ n: n }))
const ufixed = A.sequenceOf([A.str('ufixed'), integer, A.char('x'), integer]).map(([_, n, __, m]) => new arc4Types.UFixedNxMType({ n, m }))

const simpleType = (name: string, ptype: arc4Types.ARC4EncodedType) => A.str(name).map(() => ptype)

const scalarType = A.choice([
  uint,
  ufixed,
  simpleType('byte', arc4Types.arc4ByteAlias),
  simpleType('string', arc4Types.arc4StringType),
  simpleType('bool', arc4Types.arc4BooleanType),
  simpleType('address', arc4Types.arc4AddressAlias),
  simpleType('account', new arc4Types.UintNType({ n: 8n })),
  simpleType('asset', new arc4Types.UintNType({ n: 8n })),
  simpleType('application', new arc4Types.UintNType({ n: 8n })),
])

class TypeBuilder {
  #stack: arc4Types.ARC4EncodedType[][] = [[]]

  private get workingSet() {
    return this.#stack[this.#stack.length - 1]
  }

  get hasOpenTuple() {
    return this.#stack.length > 1
  }

  enterTuple() {
    this.#stack.push([])
  }
  exitTuple() {
    if (this.#stack.length === 1) {
      throw new Error('Invalid operation, no tuple has been entered')
    }
    const tupleType = new arc4Types.ARC4TupleType({ types: this.workingSet })
    this.#stack.pop()
    this.workingSet.push(tupleType)
  }

  get result() {
    if (this.#stack.length > 1) {
      throw new Error(`Tuple has not been closed`)
    }
    return this.workingSet
  }

  push(ptype: arc4Types.ARC4EncodedType) {
    this.workingSet.push(ptype)
  }

  replaceLast(replacer: (lastType: arc4Types.ARC4EncodedType) => arc4Types.ARC4EncodedType) {
    if (this.workingSet.length === 0) {
      throw new Error('Invalid operation, no type to replace')
    }
    const latest = this.workingSet.pop()!
    this.workingSet.push(replacer(latest))
  }
}

const arc4Type = A.coroutine((parse) => {
  try {
    enum States {
      BeginTuple,
      EndTuple,
      ArrayBrackets,
      TypeOrBeginTuple,
      AfterType,
    }
    let state = States.TypeOrBeginTuple

    const typeBuilder = new TypeBuilder()
    while (true) {
      const next = parse(A.possibly(peek))
      if (next === null) {
        return typeBuilder.result
      }

      switch (state) {
        case States.TypeOrBeginTuple: {
          if (next === '(') {
            state = States.BeginTuple
          } else {
            const type = parse(scalarType)
            typeBuilder.push(type)
            state = States.AfterType
          }
          break
        }
        case States.BeginTuple: {
          parse(A.char('('))
          typeBuilder.enterTuple()
          state = States.TypeOrBeginTuple
          break
        }
        case States.EndTuple: {
          parse(A.char(')'))
          if (!typeBuilder.hasOpenTuple) {
            return parse(A.fail("Char ')' has no matching opening '('"))
          }
          typeBuilder.exitTuple()
          state = States.AfterType
          break
        }
        case States.ArrayBrackets: {
          parse(A.char('['))
          const size = parse(A.possibly(integer))
          parse(A.char(']'))

          typeBuilder.replaceLast((previous) =>
            size === null
              ? new arc4Types.DynamicArrayType({ elementType: previous })
              : new arc4Types.StaticArrayType({ elementType: previous, arraySize: size }),
          )
          state = States.AfterType
          break
        }
        case States.AfterType: {
          switch (next) {
            case ',':
              parse(A.char(','))
              state = States.TypeOrBeginTuple
              continue
            case '[':
              state = States.ArrayBrackets
              continue
            case ')':
              state = States.EndTuple
              continue
            default:
              // Parse the next char rather than just peeking at it so the fail below happens at the right position
              parse(A.anyChar)
              parse(A.fail(`Expecting ',', '[', or ')', but got ${next}`))
          }
        }
      }
    }
  } catch (e) {
    if (e instanceof Error) {
      return parse(A.fail(e.message))
    } else {
      throw e
    }
  }
})

export class Arc4ParseError extends Error {
  constructor(
    message: string,
    public index: number,
  ) {
    super(message)
  }
}
export const parseArc4Type = (signature: string): arc4Types.ARC4EncodedType => {
  const parseResult = arc4Type.run(signature)
  if (parseResult.isError) {
    const maybeErrorMessage = /^ParseError \(position \d+\): (.*)/.exec(parseResult.error)
    const message = maybeErrorMessage ? maybeErrorMessage[1] : parseResult.error
    throw new Arc4ParseError(message, parseResult.index)
  } else {
    if (parseResult.result.length === 0) {
      throw new Arc4ParseError('Signature contained no types', 0)
    } else if (parseResult.result.length > 1) {
      throw new Arc4ParseError('Signature contained more than one type. Wrap multiple types in parentheses to declare a tuple type', 0)
    }
    return parseResult.result[0]
  }
}



================================================
FILE: src/util/base-32.spec.ts
================================================
import { describe, expect, it } from 'vitest'
import { base32ToUint8Array, uint8ArrayToBase32 } from './base-32'
import { hexToUint8Array } from './index'

describe('base-32 encoding', () => {
  const ZERO_ADDRESS = 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAY5HFKQ'
  it(`Zero address should be ${ZERO_ADDRESS}`, () => {
    const publicKey = new Uint8Array(32)
    const hash = hexToUint8Array('0C74E554')
    const zeroAddressBytes = new Uint8Array([...publicKey, ...hash])
    //const zeroAddressBytes = hexToUint8Array('00000000000000000000000000000000000000000000000000000000000000000c74e554')
    const addressStr = uint8ArrayToBase32(zeroAddressBytes)
    expect(addressStr).toBe(ZERO_ADDRESS)
  })

  describe('encode and decode should return same value', () => {
    it.each([
      [new Uint8Array()],
      [new Uint8Array([1])],
      [new Uint8Array([1, 2, 3, 4, 5, 6, 7, 8])],
      [new Uint8Array(32)],
      [new Uint8Array(36)],
    ])('%s', (value) => {
      const encoded = uint8ArrayToBase32(value)

      const decoded = base32ToUint8Array(encoded)

      expect(decoded).toStrictEqual(value)
    })
  })
})



================================================
FILE: src/util/base-32.ts
================================================
const BASE32_ALPHABET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'.split('')

const CHAR_TO_NUM = BASE32_ALPHABET.reduce((acc, cur, index) => ((acc[cur] = index), acc), {} as Record<string, number>)

export const base32ToUint8Array = (value: string): Uint8Array => {
  let allChars = value
    .split('')
    .filter((c) => c !== '=')
    .map((c) => {
      const cUpper = c.toUpperCase()
      if (cUpper in CHAR_TO_NUM) return CHAR_TO_NUM[cUpper]
      throw new Error(`Invalid base32 char ${c}`)
    })
  const bytes = new Array<number>()
  while (allChars.length) {
    const [a, b, c, d, e, f, g, h, ...rest] = allChars
    if (a === undefined || b === undefined) break
    bytes.push(((a << 3) | (b >>> 2)) & 255)
    if (c === undefined || d === undefined) break
    bytes.push(((b << 6) | (c << 1) | (d >>> 4)) & 255)
    if (e === undefined) break
    bytes.push(((d << 4) | (e >>> 1)) & 255)
    if (f === undefined || g === undefined) break
    bytes.push(((e << 7) | (f << 2) | (g >>> 3)) & 255)
    if (h === undefined) break
    bytes.push(((g << 5) | h) & 255)
    allChars = rest
  }
  return new Uint8Array(bytes)
}

export const uint8ArrayToBase32 = (value: Uint8Array): string => {
  let allBytes = Array.from(value)
  let base32str = ''
  while (allBytes.length) {
    const [a, b, c, d, e, ...rest] = allBytes ?? [0, 0, 0, 0, 0]

    if (allBytes.length < 1) break
    base32str += BASE32_ALPHABET[a >>> 3]
    base32str += BASE32_ALPHABET[((a << 2) | ((b || 0) >>> 6)) & 31]
    if (allBytes.length < 2) break
    base32str += BASE32_ALPHABET[(b >>> 1) & 31]
    base32str += BASE32_ALPHABET[((b << 4) | (c >>> 4)) & 31]
    if (allBytes.length < 3) break
    base32str += BASE32_ALPHABET[((c << 1) | (d >>> 7)) & 31]
    if (allBytes.length < 4) break
    base32str += BASE32_ALPHABET[(d >>> 2) & 31]
    base32str += BASE32_ALPHABET[((d << 3) | (e >>> 5)) & 31]
    if (allBytes.length < 5) break
    base32str += BASE32_ALPHABET[e & 31]
    allBytes = rest
  }
  return base32str
}



================================================
FILE: src/util/base-85.ts
================================================
function positiveMod(x: number, m: number) {
  return ((x % m) + m) % m
}
function repeat<T>(c: T, n: number): T[] {
  return new Array<T>(n).fill(c)
}
function* batchBytesToUintN(bytes: Uint8Array, n: number): Generator<bigint> {
  const numberBytes = n / 8
  for (let i = 0; i < bytes.length / numberBytes; i += 1) {
    yield new Array(numberBytes).fill(null).reduce((acc, _, index) => {
      const offset = index + i * numberBytes
      if (offset >= bytes.length) {
        throw new Error('Needs padding')
      }
      return (acc << 8n) + BigInt(bytes[offset])
    }, 0n)
  }
}

/**
 * This implementation of base85 encoding matches python's base64.b85encode(...) function which is based on the character set of rfc1924
 * but supports arbitrary sized input.
 *
 * It IS NOT an ascii85 implementation
 */
export function buildBase85Encoder() {
  const b85Alphabet = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz!#$%&()*+-;<=>?@^_`{|}~'
  const b85Chars = b85Alphabet.split('')
  const b85DoubleChars = b85Chars.flatMap((c) => b85Chars.map((c2) => c + c2))

  function encode(b: Uint8Array, chars: string[], doubleChars: string[]) {
    const padding = positiveMod(-b.length, 4)
    if (padding) {
      b = new Uint8Array([...b, ...repeat(0, padding)])
    }
    let result = ''
    for (const word of batchBytesToUintN(b, 4 * 8)) {
      result += doubleChars[Number(word / 85n ** 3n)]
      result += doubleChars[Number((word / 85n) % 85n ** 2n)]
      result += chars[Number(word % 85n)]
    }
    return result.slice(0, result.length - padding)
  }

  return {
    encode(b: Uint8Array) {
      return encode(b, b85Chars, b85DoubleChars)
    },
    encodeUtf8(s: string) {
      const b = new TextEncoder().encode(s)
      return this.encode(b)
    },
  }
}



================================================
FILE: src/util/custom-key-map.ts
================================================
import type { DeliberateAny } from '../typescript-helpers'

type Primitive = number | bigint | string | boolean

export abstract class CustomKeyMap<TKey, TValue> implements Map<TKey, TValue> {
  #keySerializer: (key: TKey) => Primitive
  #map = new Map<Primitive, [TKey, TValue]>()

  constructor(keySerializer: (key: TKey) => number | bigint | string) {
    this.#keySerializer = keySerializer
  }

  clear(): void {
    this.#map.clear()
  }
  delete(key: TKey): boolean {
    return this.#map.delete(this.#keySerializer(key))
  }
  forEach(callbackfn: (value: TValue, key: TKey, map: Map<TKey, TValue>) => void, thisArg?: DeliberateAny): void {
    for (const [key, value] of this.#map.values()) {
      callbackfn.call(thisArg ?? this, value, key, this)
    }
  }
  get(key: TKey): TValue | undefined {
    return this.#map.get(this.#keySerializer(key))?.[1]
  }
  has(key: TKey): boolean {
    return this.#map.has(this.#keySerializer(key))
  }
  set(key: TKey, value: TValue): this {
    this.#map.set(this.#keySerializer(key), [key, value])
    return this
  }
  get size(): number {
    return this.#map.size
  }
  entries(): MapIterator<[TKey, TValue]> {
    return this.#map.values()
  }
  *keys(): MapIterator<TKey> {
    for (const [key] of this.#map.values()) {
      yield key
    }
  }
  *values(): MapIterator<TValue> {
    for (const [, value] of this.#map.values()) {
      yield value
    }
  }
  [Symbol.iterator](): MapIterator<[TKey, TValue]> {
    return this.#map.values()
  }
  get [Symbol.toStringTag](): string {
    return this.constructor.name
  }
}



================================================
FILE: src/util/default-map.ts
================================================
export function defaultRecord<TKey extends PropertyKey, TValue>(defaultInit: (key: TKey) => TValue) {
  return new Proxy({} as Record<TKey, TValue>, {
    get(target, property, receiver) {
      if (!(property in target)) {
        Object.assign(target, { [property]: defaultInit(property as TKey) })
      }
      return Reflect.get(target, property, receiver)
    },
  })
}



================================================
FILE: src/util/generate-temp-file.ts
================================================
import { randomUUID } from 'crypto'
import fs from 'fs'
import { globIterateSync } from 'glob'
import type { WriteFileOptions } from 'node:fs'
import os from 'os'
import upath from 'upath'
import { mkDirIfNotExists } from './index'

export type TempFile = {
  writeFileSync(data: NodeJS.ArrayBufferView, options?: WriteFileOptions): void
  writeFileSync(data: string, options?: WriteFileOptions): void
  readonly filePath: string
} & Disposable

function ensureTempDir(): string {
  const tempDir = upath.join(os.tmpdir(), 'puya-ts')
  mkDirIfNotExists(tempDir)
  return tempDir
}

export function generateTempFile(options?: { ext?: string }): TempFile {
  const { ext = 'tmp' } = options ?? {}
  const filePath = upath.join(ensureTempDir(), `${randomUUID()}.${ext}`)

  return {
    get filePath() {
      return filePath
    },
    writeFileSync(data: string | NodeJS.ArrayBufferView, options?: WriteFileOptions) {
      fs.writeFileSync(filePath, data, options)
    },
    [Symbol.dispose]() {
      fs.rmSync(filePath)
    },
  }
}
export type TempDir = {
  readonly dirPath: string
  files(): IterableIterator<string>
} & Disposable

export function generateTempDir(): TempDir {
  const dirPath = upath.join(ensureTempDir(), `${randomUUID()}`)
  mkDirIfNotExists(dirPath)

  return {
    get dirPath() {
      return dirPath
    },
    *files(): IterableIterator<string> {
      for (const p of globIterateSync(upath.join(dirPath, '**'), {
        nodir: true,
      })) {
        yield p
      }
    },
    [Symbol.dispose]() {
      fs.rmSync(dirPath, { recursive: true, force: true })
    },
  }
}



================================================
FILE: src/util/index.ts
================================================
import { Buffer } from 'node:buffer'
import fs from 'node:fs'
import { TextDecoder } from 'node:util'
import upath from 'upath'
import type { SourceLocation } from '../awst/source-location'
import { Constants } from '../constants'
import { CodeError, InternalError } from '../errors'
import type { DeliberateAny } from '../typescript-helpers'

export { base32ToUint8Array, uint8ArrayToBase32 } from './base-32'

class InvariantError extends InternalError {}

/**
 * Checks an invariant condition hold true. If this check fails it indicates the compiler is in an unstable state. For invariants related to
 * user code, use codeInvariant below.
 *
 * @param condition
 * @param message
 * @param sourceLocation
 */
export function invariant(condition: unknown, message: string, sourceLocation?: SourceLocation): asserts condition {
  if (!condition) {
    throw new InvariantError(message, { sourceLocation })
  }
}

/**
 * Checks an invariant related to user code holds true. If this check fails it indicates the user code is not valid. For invariants the user
 * has no control over, use invariant above.
 * @param condition
 * @param message
 * @param sourceLocation
 */
export function codeInvariant(condition: unknown, message: string, sourceLocation?: SourceLocation): asserts condition {
  if (!condition) {
    throw new CodeError(message, {
      sourceLocation,
    })
  }
}

export const enumFromValue = <TValue, TEnum extends TValue>(
  value: TValue,
  enumType: Record<string, TEnum | string>,
  message: string = 'Invalid enum value: ',
) => {
  if (Object.values(enumType).some((v) => v === value)) {
    return value as TEnum
  }
  throw new Error(`${message} ${value}`)
}

export const enumKeyFromValue = <TValue, TEnum extends TValue>(
  value: TValue,
  enumType: Record<string, TEnum>,
  message: string = 'Invalid enum value: ',
) => {
  const key = Object.entries(enumType).find(([_, v]) => v === value)?.[0]
  if (key) {
    return key
  }
  throw new Error(`${message} ${value}`)
}

export const convertEnum = <TEnumIn, TEnumOut, TKeys extends string>(
  value: TEnumIn,
  fromEnum: Record<TKeys, TEnumIn>,
  toEnum: Record<TKeys, TEnumOut>,
): TEnumOut => {
  const keyOfValue = Object.entries(fromEnum).find(([, v]) => v === value)?.[0]
  if (!keyOfValue) {
    // missing value
    throw new Error(`key missing: ${value}`)
  }
  return toEnum[keyOfValue as keyof typeof toEnum]
}

export const tryConvertEnum = <TEnumIn, TEnumOut, TKeys extends string>(
  value: TEnumIn,
  fromEnum: Record<TKeys, TEnumIn>,
  toEnum: Record<string, TEnumOut>,
): TEnumOut | undefined => {
  const keyOfValue = Object.entries(fromEnum).find(([, v]) => v === value)?.[0]
  if (!keyOfValue) {
    return undefined
  }
  return toEnum[keyOfValue as keyof typeof toEnum]
}

export const expandMaybeArray = <T>(maybeArray: T | T[]): T[] => {
  return Array.isArray(maybeArray) ? maybeArray : [maybeArray]
}

export const uint8ArrayToBase64 = (value: Uint8Array): string => Buffer.from(value).toString('base64')

export const hexToUint8Array = (value: string): Uint8Array => {
  invariant(value.length % 2 === 0, 'Hex string must have even number of characters')
  return Uint8Array.from(Buffer.from(value, 'hex'))
}

export const base64ToUint8Array = (value: string): Uint8Array => {
  return Uint8Array.from(Buffer.from(value, 'base64'))
}

export const utf8ToUint8Array = (value: string): Uint8Array => {
  const encoder = new TextEncoder()
  return encoder.encode(value)
}

export const uint8ArrayToBigInt = (v: Uint8Array): bigint => {
  // Assume big-endian
  return Array.from(v)
    .toReversed()
    .map((byte_value, i): bigint => BigInt(byte_value) << BigInt(i * 8))
    .reduce((a, b) => a + b, 0n)
}

export const uint8ArrayToHex = (value: Uint8Array): string => Buffer.from(value).toString('hex')

export const uint8ArrayToUtf8 = (value: Uint8Array): string => {
  const decoder = new TextDecoder()
  return decoder.decode(value)
}

export const bigIntToUint8Array = (val: bigint, fixedSize: number | 'dynamic' = 'dynamic'): Uint8Array => {
  if (val === 0n && fixedSize === 'dynamic') {
    return new Uint8Array(0)
  }
  const maxBytes = fixedSize === 'dynamic' ? 4096 : fixedSize

  let hex = val.toString(16)

  // Pad the hex with zeros so it matches the size in bytes
  if (fixedSize !== 'dynamic' && hex.length !== fixedSize * 2) {
    hex = hex.padStart(fixedSize * 2, '0')
  } else if (hex.length % 2 === 1) {
    // Pad to 'whole' byte
    hex = `0${hex}`
  }
  if (hex.length > maxBytes * 2) {
    throw new InternalError(`Cannot encode ${val} as ${maxBytes} bytes as it would overflow`)
  }
  const byteArray = new Uint8Array(hex.length / 2)
  for (let i = 0, j = 0; i < hex.length / 2; i++, j += 2) {
    byteArray[i] = parseInt(hex.slice(j, j + 2), 16)
  }
  return byteArray
}

export const hasFlags = <T extends number>(value: T, flags: T): boolean => (value & flags) === flags
export const intersectsFlags = <T extends number>(value: T, flags: T): boolean => Boolean(value & flags)

export function* enumerate<T>(iterable: Iterable<T>): IterableIterator<readonly [number, T]> {
  let i = 0
  for (const item of iterable) {
    yield [i, item]
    i++
  }
}

export function toSubScript(num: number) {
  const subNumbers = ['\u2080', '\u2081', '\u2082', '\u2083', '\u2084', '\u2085', '\u2086', '\u2087', '\u2088', '\u2089']
  return num
    .toFixed(0)
    .split('')
    .map((x) => subNumbers[parseInt(x)])
    .join('')
}

export function instanceOfAny<T extends Array<{ new (...args: DeliberateAny[]): DeliberateAny }>>(
  x: unknown,
  ...types: T
): x is InstanceType<T[number]> {
  return types.some((t) => x instanceof t)
}

/**
 * Normalise a file path to only include relevant segments.
 *
 *  - Anything in /node_modules/ is truncated to <package-name>/path.ext
 *  - Anything in workingDirectory is truncated relative to the workingDirectory
 *  - Forward slashes are used to segment paths
 * @param filePath
 * @param workingDirectory
 */
export function normalisePath(filePath: string, workingDirectory: string): string {
  const localPackageName = /packages\/algo-ts\/dist\/(.*)$/.exec(filePath)
  if (localPackageName) {
    return `${Constants.algoTsPackage}/${localPackageName[1]}`
  }
  const nodeModuleName = /.*\/node_modules\/(.*)$/.exec(filePath)
  if (nodeModuleName) {
    return nodeModuleName[1]
  }
  const cwd = upath.normalize(`${workingDirectory}/`)
  const normalizedPath = upath.normalize(filePath)
  const moduleName = normalizedPath.startsWith(cwd) ? normalizedPath.slice(cwd.length) : normalizedPath
  return moduleName.replaceAll('\\', '/')
}

type SortDir = 'asc' | 'desc'
export const sortBy =
  <T, TKey>(keySelector: (item: T) => TKey, dir: SortDir = 'asc') =>
  (a: T, b: T) => {
    const keyA = keySelector(a)
    const keyB = keySelector(b)
    return (dir === 'desc' ? -1 : 1) * (keyA < keyB ? -1 : keyA > keyB ? 1 : 0)
  }
/**
 * Can be used to filter a collection to a set of distinct items as determined by a specified key.
 * @param keySelector A lambda which when given an item, returns the items unique identifier
 *
 * Usage:
 *
 * ```
 * const distinctItems = nonDistinctItems.filter(distinct(x => x.uniqueId))
 * ```
 */
export const distinct = <T>(keySelector?: (item: T) => unknown) => {
  const ks = keySelector || ((x: T) => x)
  const set = new Set()
  return (item: T) => {
    if (set.has(ks(item))) {
      return false
    }

    set.add(ks(item))
    return true
  }
}

export const distinctByEquality = <T>(areEqual: (a: T, b: T) => boolean) => {
  const set: T[] = []
  return (item: T) => {
    if (set.some((s) => areEqual(s, item))) return false
    set.push(item)
    return true
  }
}

export function mkDirIfNotExists(dir: string) {
  if (!fs.existsSync(dir)) {
    fs.mkdirSync(dir, { recursive: true })
  }
}

export function sameSets<T>(a: Iterable<T>, b: Iterable<T>) {
  const setA = new Set(a)
  const setB = new Set(b)
  return setA.intersection(setB).size === setA.size
}

export const zipStrict = <T1, T2>(array1: T1[], array2: T2[]): [T1, T2][] => {
  invariant(array1.length === array2.length, 'Array lengths must match')
  return array1.map((t1, idx) => [t1, array2[idx]])
}

export function isIn<TSubject, TItem extends TSubject>(subject: TSubject, items: readonly TItem[]): subject is TItem {
  return items.some((i) => i === subject)
}

export function joinUint8Arrays(...arrays: Uint8Array[]): Uint8Array {
  const length = arrays.reduce((acc, cur) => acc + cur.length, 0)
  const result = new Uint8Array(length)
  let offset = 0
  for (const a of arrays) {
    result.set(a, offset)
    offset += a.length
  }
  return result
}



================================================
FILE: src/util/invoke-cli.ts
================================================
import { spawn } from 'cross-spawn'

type InvokeCliOptions = {
  command: string
  args: string[]
  cwd?: string
  onReceiveLine?(line: string): void
  dontThrowOnNonzeroCode?: boolean
}

type InvokeCliResponse = {
  lines: string[]
  code: number
}

class InvokeCliError extends Error {
  constructor(public exit: { code?: number | null; signal?: NodeJS.Signals | null }) {
    if (exit.code) {
      super(`Exited with code ${exit.code}`)
    } else if (exit.signal) {
      super(`Exited with signal ${exit.signal}`)
    } else {
      super('Exited with unknown cause')
    }
  }
}

export function invokeCli(options: InvokeCliOptions): Promise<InvokeCliResponse> {
  return new Promise<InvokeCliResponse>((resolve, reject) => {
    const lineAggregator = new LineAggregator(options.onReceiveLine)
    const process = spawn(options.command, options.args, {
      stdio: 'pipe',
    })

    process.stdout.on('data', (data) => lineAggregator.aggregate(data))
    process.once('close', (code) => {
      if (code !== 0 && !options.dontThrowOnNonzeroCode) {
        reject(new InvokeCliError({ code }))
      }
      lineAggregator.flush()
      resolve({
        code: code ?? 0,
        lines: lineAggregator.lines,
      })
    })
    process.once('exit', (code, signal) => {
      if (signal !== null) {
        reject(new InvokeCliError({ signal }))
      }
      if (code !== 0 && !options.dontThrowOnNonzeroCode) {
        reject(new InvokeCliError({ code }))
      }
      lineAggregator.flush()
      resolve({
        code: code ?? 0,
        lines: lineAggregator.lines,
      })
    })
    process.once('error', reject)
  })
}

class LineAggregator {
  #line = ''
  #lines: string[] = []
  constructor(private readonly onLine?: (line: string) => void) {}

  aggregate(chunk: Buffer<ArrayBufferLike> | null | undefined) {
    if (chunk === undefined || chunk === null) return
    const text = chunk.toString('utf-8')
    for (const c of text) {
      switch (c) {
        case '\n':
          this.flushLine()
          break
        case '\r':
          continue
        default:
          this.#line += c
          break
      }
    }
  }

  flush() {
    if (this.#line) this.flushLine()
  }

  private flushLine() {
    this.#lines.push(this.#line)
    this.onLine?.(this.#line)
    this.#line = ''
  }

  get lines() {
    return this.#lines
  }
}



================================================
FILE: src/util/lock-file.spec.ts
================================================
import { existsSync, mkdirSync, rmdirSync } from 'fs'
import { afterEach, beforeEach, describe, expect, it } from 'vitest'
import { createLockFile } from './lock-file'
import { sleep } from './sleep'

describe('lock-file', () => {
  const lockPath = `test-lock-file.lock`

  beforeEach(() => {
    // Clean up any existing lock files before each test
    if (existsSync(lockPath)) {
      rmdirSync(lockPath)
    }
  })

  afterEach(() => {
    // Clean up after each test
    if (existsSync(lockPath)) {
      rmdirSync(lockPath)
    }
  })

  it('should create and remove lock file', async () => {
    {
      await using _ = await createLockFile(lockPath)
      expect(existsSync(lockPath)).toBe(true)
    }

    expect(existsSync(lockPath)).toBe(false)
  })

  it('should throw error when lock already exists', async () => {
    await createLockFile(lockPath)

    // Set maxRetries to 0 to fail immediately without retrying
    await expect(createLockFile(lockPath, { maxRetries: 0 })).rejects.toThrow('Failed to lock file')
  })

  it('should handle stale locks', async () => {
    // Create a lock file
    mkdirSync(lockPath)

    // Wait for the lock to become stale
    await sleep(1100)

    // Should succeed because the lock is stale
    await expect(createLockFile(lockPath, { staleMs: 1000 })).resolves.not.toThrow()
  })

  it('should retry specified number of times', async () => {
    // Create a lock that won't expire
    mkdirSync(lockPath)

    const startTime = Date.now()

    // Try to acquire lock with 2 retries and 100ms delay
    await expect(createLockFile(lockPath, { maxRetries: 2, delayMs: 100, staleMs: 5000 })).rejects.toThrow('Failed to lock file')

    const duration = Date.now() - startTime

    // Should have waited approximately 200ms (2 retries * 100ms)
    expect(duration).toBeGreaterThanOrEqual(200)
    expect(duration).toBeLessThan(300) // Add some buffer for timing variations

    rmdirSync(lockPath)
  })

  it('should succeed if lock becomes available during retry', async () => {
    // Create initial lock
    mkdirSync(lockPath)

    // Remove lock after 150ms
    setTimeout(() => {
      rmdirSync(lockPath)
    }, 150)

    // Should succeed on second retry
    await expect(createLockFile(lockPath, { maxRetries: 3, delayMs: 100 })).resolves.not.toThrow()
  })
})



================================================
FILE: src/util/lock-file.ts
================================================
import { existsSync, mkdirSync, rmdirSync, statSync } from 'fs'
import { onExit } from 'signal-exit'
import { logger } from '../logger'
import { sleep } from './sleep'

const lockPaths = new Set<string>()

function acquireLock(path: string, options?: { staleMs?: number }) {
  const { staleMs = 60 * 1000 } = options ?? {}
  lockPaths.add(path)

  if (existsSync(path)) {
    const now = Date.now()
    const fileStat = statSync(path)

    if (now - fileStat.mtime.getTime() > staleMs) {
      // Remove the lock file if it has expired
      rmdirSync(path)
    } else {
      throw new Error('Lock file already exists')
    }
  }

  mkdirSync(path, { recursive: true })
}

export async function createLockFile(
  path: string,
  options?: { staleMs?: number; maxRetries?: number; delayMs?: number },
): Promise<AsyncDisposable> {
  const { maxRetries = 3, delayMs = 1000 } = options ?? {}

  for (let i = 0; i < maxRetries; i++) {
    try {
      acquireLock(path, options)

      return {
        async [Symbol.asyncDispose]() {
          await unlockFile(path)
        },
      }
    } catch (err) {
      logger.debug(undefined, `Failed to acquire lock file ${path}: ${err}`)
      await sleep(delayMs)
    }
  }

  throw new Error('Failed to lock file')
}

async function unlockFile(path: string): Promise<void> {
  try {
    rmdirSync(path)
    lockPaths.delete(path)
  } catch (err) {
    logger.warn(undefined, `Failed to unlock file ${path}: ${err}`)
  }
}

onExit(() => {
  for (const path of lockPaths) {
    unlockFile(path)
  }
})



================================================
FILE: src/util/sleep.ts
================================================
export function sleep(ms: number): Promise<void> {
  return new Promise((resolve) => setTimeout(resolve, ms))
}



================================================
FILE: src/util/template-var-cli-parser.ts
================================================
import * as A from 'arcsecond'
import { hexToUint8Array, utf8ToUint8Array } from './index'

export const TemplateVarNameRegex = /^[A-Z\d_]+/

const templateVarName = A.regex(TemplateVarNameRegex)

const hexBytes = A.sequenceOf([A.str('0x'), A.regex(/^([A-F0-9]{2})*/)]).map(([prefix, chars]) => hexToUint8Array(chars))

const integer = A.regex(/^\d+/).map((x) => BigInt(x))

const string = A.regex(/^.*/).map(utf8ToUint8Array)

const templateVarValue = A.choice([hexBytes, integer, string])

const templateVar = A.coroutine((parse) => {
  const name = parse(templateVarName)
  parse(A.char('='))
  const value = parse(templateVarValue)
  parse(A.endOfInput)
  return [name, value] as const
})

export const parseCliTemplateVar = (text: string): readonly [string, Uint8Array | bigint] => {
  const result = templateVar.run(text)
  if (result.isError) {
    throw new Error('Cannot parse cli template var. Make sure it is in the form VAR_NAME={value}', { cause: result.error })
  } else {
    return result.result
  }
}



================================================
FILE: src/visitor/syntax-names.ts
================================================
import ts from 'typescript'
import { BinaryBooleanOperator } from '../awst/nodes'
import { BuilderBinaryOp, BuilderComparisonOp, BuilderUnaryOp } from '../awst_build/eb'
import type { DeliberateAny } from '../typescript-helpers'

export const SyntaxKindName = {
  [ts.SyntaxKind.Unknown]: 'Unknown',
  [ts.SyntaxKind.EndOfFileToken]: 'EndOfFileToken',
  [ts.SyntaxKind.SingleLineCommentTrivia]: 'SingleLineCommentTrivia',
  [ts.SyntaxKind.MultiLineCommentTrivia]: 'MultiLineCommentTrivia',
  [ts.SyntaxKind.NewLineTrivia]: 'NewLineTrivia',
  [ts.SyntaxKind.WhitespaceTrivia]: 'WhitespaceTrivia',
  [ts.SyntaxKind.ShebangTrivia]: 'ShebangTrivia',
  [ts.SyntaxKind.ConflictMarkerTrivia]: 'ConflictMarkerTrivia',
  [ts.SyntaxKind.NonTextFileMarkerTrivia]: 'NonTextFileMarkerTrivia',
  [ts.SyntaxKind.NumericLiteral]: 'NumericLiteral',
  [ts.SyntaxKind.BigIntLiteral]: 'BigIntLiteral',
  [ts.SyntaxKind.StringLiteral]: 'StringLiteral',
  [ts.SyntaxKind.JsxText]: 'JsxText',
  [ts.SyntaxKind.JsxTextAllWhiteSpaces]: 'JsxTextAllWhiteSpaces',
  [ts.SyntaxKind.RegularExpressionLiteral]: 'RegularExpressionLiteral',
  [ts.SyntaxKind.NoSubstitutionTemplateLiteral]: 'NoSubstitutionTemplateLiteral',
  [ts.SyntaxKind.TemplateHead]: 'TemplateHead',
  [ts.SyntaxKind.TemplateMiddle]: 'TemplateMiddle',
  [ts.SyntaxKind.TemplateTail]: 'TemplateTail',
  [ts.SyntaxKind.OpenBraceToken]: 'OpenBraceToken',
  [ts.SyntaxKind.CloseBraceToken]: 'CloseBraceToken',
  [ts.SyntaxKind.OpenParenToken]: 'OpenParenToken',
  [ts.SyntaxKind.CloseParenToken]: 'CloseParenToken',
  [ts.SyntaxKind.OpenBracketToken]: 'OpenBracketToken',
  [ts.SyntaxKind.CloseBracketToken]: 'CloseBracketToken',
  [ts.SyntaxKind.DotToken]: 'DotToken',
  [ts.SyntaxKind.DotDotDotToken]: 'DotDotDotToken',
  [ts.SyntaxKind.SemicolonToken]: 'SemicolonToken',
  [ts.SyntaxKind.CommaToken]: 'CommaToken',
  [ts.SyntaxKind.QuestionDotToken]: 'QuestionDotToken',
  [ts.SyntaxKind.LessThanToken]: 'LessThanToken',
  [ts.SyntaxKind.LessThanSlashToken]: 'LessThanSlashToken',
  [ts.SyntaxKind.GreaterThanToken]: 'GreaterThanToken',
  [ts.SyntaxKind.LessThanEqualsToken]: 'LessThanEqualsToken',
  [ts.SyntaxKind.GreaterThanEqualsToken]: 'GreaterThanEqualsToken',
  [ts.SyntaxKind.EqualsEqualsToken]: 'EqualsEqualsToken',
  [ts.SyntaxKind.ExclamationEqualsToken]: 'ExclamationEqualsToken',
  [ts.SyntaxKind.EqualsEqualsEqualsToken]: 'EqualsEqualsEqualsToken',
  [ts.SyntaxKind.ExclamationEqualsEqualsToken]: 'ExclamationEqualsEqualsToken',
  [ts.SyntaxKind.EqualsGreaterThanToken]: 'EqualsGreaterThanToken',
  [ts.SyntaxKind.PlusToken]: 'PlusToken',
  [ts.SyntaxKind.MinusToken]: 'MinusToken',
  [ts.SyntaxKind.AsteriskToken]: 'AsteriskToken',
  [ts.SyntaxKind.AsteriskAsteriskToken]: 'AsteriskAsteriskToken',
  [ts.SyntaxKind.SlashToken]: 'SlashToken',
  [ts.SyntaxKind.PercentToken]: 'PercentToken',
  [ts.SyntaxKind.PlusPlusToken]: 'PlusPlusToken',
  [ts.SyntaxKind.MinusMinusToken]: 'MinusMinusToken',
  [ts.SyntaxKind.LessThanLessThanToken]: 'LessThanLessThanToken',
  [ts.SyntaxKind.GreaterThanGreaterThanToken]: 'GreaterThanGreaterThanToken',
  [ts.SyntaxKind.GreaterThanGreaterThanGreaterThanToken]: 'GreaterThanGreaterThanGreaterThanToken',
  [ts.SyntaxKind.AmpersandToken]: 'AmpersandToken',
  [ts.SyntaxKind.BarToken]: 'BarToken',
  [ts.SyntaxKind.CaretToken]: 'CaretToken',
  [ts.SyntaxKind.ExclamationToken]: 'ExclamationToken',
  [ts.SyntaxKind.TildeToken]: 'TildeToken',
  [ts.SyntaxKind.AmpersandAmpersandToken]: 'AmpersandAmpersandToken',
  [ts.SyntaxKind.BarBarToken]: 'BarBarToken',
  [ts.SyntaxKind.QuestionToken]: 'QuestionToken',
  [ts.SyntaxKind.ColonToken]: 'ColonToken',
  [ts.SyntaxKind.AtToken]: 'AtToken',
  [ts.SyntaxKind.QuestionQuestionToken]: 'QuestionQuestionToken',
  [ts.SyntaxKind.BacktickToken]: 'BacktickToken',
  [ts.SyntaxKind.HashToken]: 'HashToken',
  [ts.SyntaxKind.EqualsToken]: 'EqualsToken',
  [ts.SyntaxKind.PlusEqualsToken]: 'PlusEqualsToken',
  [ts.SyntaxKind.MinusEqualsToken]: 'MinusEqualsToken',
  [ts.SyntaxKind.AsteriskEqualsToken]: 'AsteriskEqualsToken',
  [ts.SyntaxKind.AsteriskAsteriskEqualsToken]: 'AsteriskAsteriskEqualsToken',
  [ts.SyntaxKind.SlashEqualsToken]: 'SlashEqualsToken',
  [ts.SyntaxKind.PercentEqualsToken]: 'PercentEqualsToken',
  [ts.SyntaxKind.LessThanLessThanEqualsToken]: 'LessThanLessThanEqualsToken',
  [ts.SyntaxKind.GreaterThanGreaterThanEqualsToken]: 'GreaterThanGreaterThanEqualsToken',
  [ts.SyntaxKind.GreaterThanGreaterThanGreaterThanEqualsToken]: 'GreaterThanGreaterThanGreaterThanEqualsToken',
  [ts.SyntaxKind.AmpersandEqualsToken]: 'AmpersandEqualsToken',
  [ts.SyntaxKind.BarEqualsToken]: 'BarEqualsToken',
  [ts.SyntaxKind.BarBarEqualsToken]: 'BarBarEqualsToken',
  [ts.SyntaxKind.AmpersandAmpersandEqualsToken]: 'AmpersandAmpersandEqualsToken',
  [ts.SyntaxKind.QuestionQuestionEqualsToken]: 'QuestionQuestionEqualsToken',
  [ts.SyntaxKind.CaretEqualsToken]: 'CaretEqualsToken',
  [ts.SyntaxKind.Identifier]: 'Identifier',
  [ts.SyntaxKind.PrivateIdentifier]: 'PrivateIdentifier',
  [ts.SyntaxKind.BreakKeyword]: 'BreakKeyword',
  [ts.SyntaxKind.CaseKeyword]: 'CaseKeyword',
  [ts.SyntaxKind.CatchKeyword]: 'CatchKeyword',
  [ts.SyntaxKind.ClassKeyword]: 'ClassKeyword',
  [ts.SyntaxKind.ConstKeyword]: 'ConstKeyword',
  [ts.SyntaxKind.ContinueKeyword]: 'ContinueKeyword',
  [ts.SyntaxKind.DebuggerKeyword]: 'DebuggerKeyword',
  [ts.SyntaxKind.DefaultKeyword]: 'DefaultKeyword',
  [ts.SyntaxKind.DeleteKeyword]: 'DeleteKeyword',
  [ts.SyntaxKind.DoKeyword]: 'DoKeyword',
  [ts.SyntaxKind.ElseKeyword]: 'ElseKeyword',
  [ts.SyntaxKind.EnumKeyword]: 'EnumKeyword',
  [ts.SyntaxKind.ExportKeyword]: 'ExportKeyword',
  [ts.SyntaxKind.ExtendsKeyword]: 'ExtendsKeyword',
  [ts.SyntaxKind.FalseKeyword]: 'FalseKeyword',
  [ts.SyntaxKind.FinallyKeyword]: 'FinallyKeyword',
  [ts.SyntaxKind.ForKeyword]: 'ForKeyword',
  [ts.SyntaxKind.FunctionKeyword]: 'FunctionKeyword',
  [ts.SyntaxKind.IfKeyword]: 'IfKeyword',
  [ts.SyntaxKind.ImportKeyword]: 'ImportKeyword',
  [ts.SyntaxKind.InKeyword]: 'InKeyword',
  [ts.SyntaxKind.InstanceOfKeyword]: 'InstanceOfKeyword',
  [ts.SyntaxKind.NewKeyword]: 'NewKeyword',
  [ts.SyntaxKind.NullKeyword]: 'NullKeyword',
  [ts.SyntaxKind.ReturnKeyword]: 'ReturnKeyword',
  [ts.SyntaxKind.SuperKeyword]: 'SuperKeyword',
  [ts.SyntaxKind.SwitchKeyword]: 'SwitchKeyword',
  [ts.SyntaxKind.ThisKeyword]: 'ThisKeyword',
  [ts.SyntaxKind.ThrowKeyword]: 'ThrowKeyword',
  [ts.SyntaxKind.TrueKeyword]: 'TrueKeyword',
  [ts.SyntaxKind.TryKeyword]: 'TryKeyword',
  [ts.SyntaxKind.TypeOfKeyword]: 'TypeOfKeyword',
  [ts.SyntaxKind.VarKeyword]: 'VarKeyword',
  [ts.SyntaxKind.VoidKeyword]: 'VoidKeyword',
  [ts.SyntaxKind.WhileKeyword]: 'WhileKeyword',
  [ts.SyntaxKind.WithKeyword]: 'WithKeyword',
  [ts.SyntaxKind.ImplementsKeyword]: 'ImplementsKeyword',
  [ts.SyntaxKind.InterfaceKeyword]: 'InterfaceKeyword',
  [ts.SyntaxKind.LetKeyword]: 'LetKeyword',
  [ts.SyntaxKind.PackageKeyword]: 'PackageKeyword',
  [ts.SyntaxKind.PrivateKeyword]: 'PrivateKeyword',
  [ts.SyntaxKind.ProtectedKeyword]: 'ProtectedKeyword',
  [ts.SyntaxKind.PublicKeyword]: 'PublicKeyword',
  [ts.SyntaxKind.StaticKeyword]: 'StaticKeyword',
  [ts.SyntaxKind.YieldKeyword]: 'YieldKeyword',
  [ts.SyntaxKind.AbstractKeyword]: 'AbstractKeyword',
  [ts.SyntaxKind.AccessorKeyword]: 'AccessorKeyword',
  [ts.SyntaxKind.AsKeyword]: 'AsKeyword',
  [ts.SyntaxKind.AssertsKeyword]: 'AssertsKeyword',
  [ts.SyntaxKind.AssertKeyword]: 'AssertKeyword',
  [ts.SyntaxKind.AnyKeyword]: 'AnyKeyword',
  [ts.SyntaxKind.AsyncKeyword]: 'AsyncKeyword',
  [ts.SyntaxKind.AwaitKeyword]: 'AwaitKeyword',
  [ts.SyntaxKind.BooleanKeyword]: 'BooleanKeyword',
  [ts.SyntaxKind.ConstructorKeyword]: 'ConstructorKeyword',
  [ts.SyntaxKind.DeclareKeyword]: 'DeclareKeyword',
  [ts.SyntaxKind.GetKeyword]: 'GetKeyword',
  [ts.SyntaxKind.InferKeyword]: 'InferKeyword',
  [ts.SyntaxKind.IntrinsicKeyword]: 'IntrinsicKeyword',
  [ts.SyntaxKind.IsKeyword]: 'IsKeyword',
  [ts.SyntaxKind.KeyOfKeyword]: 'KeyOfKeyword',
  [ts.SyntaxKind.ModuleKeyword]: 'ModuleKeyword',
  [ts.SyntaxKind.NamespaceKeyword]: 'NamespaceKeyword',
  [ts.SyntaxKind.NeverKeyword]: 'NeverKeyword',
  [ts.SyntaxKind.OutKeyword]: 'OutKeyword',
  [ts.SyntaxKind.ReadonlyKeyword]: 'ReadonlyKeyword',
  [ts.SyntaxKind.RequireKeyword]: 'RequireKeyword',
  [ts.SyntaxKind.NumberKeyword]: 'NumberKeyword',
  [ts.SyntaxKind.ObjectKeyword]: 'ObjectKeyword',
  [ts.SyntaxKind.SatisfiesKeyword]: 'SatisfiesKeyword',
  [ts.SyntaxKind.SetKeyword]: 'SetKeyword',
  [ts.SyntaxKind.StringKeyword]: 'StringKeyword',
  [ts.SyntaxKind.SymbolKeyword]: 'SymbolKeyword',
  [ts.SyntaxKind.TypeKeyword]: 'TypeKeyword',
  [ts.SyntaxKind.UndefinedKeyword]: 'UndefinedKeyword',
  [ts.SyntaxKind.UniqueKeyword]: 'UniqueKeyword',
  [ts.SyntaxKind.UnknownKeyword]: 'UnknownKeyword',
  [ts.SyntaxKind.UsingKeyword]: 'UsingKeyword',
  [ts.SyntaxKind.FromKeyword]: 'FromKeyword',
  [ts.SyntaxKind.GlobalKeyword]: 'GlobalKeyword',
  [ts.SyntaxKind.BigIntKeyword]: 'BigIntKeyword',
  [ts.SyntaxKind.OverrideKeyword]: 'OverrideKeyword',
  [ts.SyntaxKind.OfKeyword]: 'OfKeyword',
  [ts.SyntaxKind.QualifiedName]: 'QualifiedName',
  [ts.SyntaxKind.ComputedPropertyName]: 'ComputedPropertyName',
  [ts.SyntaxKind.TypeParameter]: 'TypeParameter',
  [ts.SyntaxKind.Parameter]: 'Parameter',
  [ts.SyntaxKind.Decorator]: 'Decorator',
  [ts.SyntaxKind.PropertySignature]: 'PropertySignature',
  [ts.SyntaxKind.PropertyDeclaration]: 'PropertyDeclaration',
  [ts.SyntaxKind.MethodSignature]: 'MethodSignature',
  [ts.SyntaxKind.MethodDeclaration]: 'MethodDeclaration',
  [ts.SyntaxKind.ClassStaticBlockDeclaration]: 'ClassStaticBlockDeclaration',
  [ts.SyntaxKind.Constructor]: 'Constructor',
  [ts.SyntaxKind.GetAccessor]: 'GetAccessor',
  [ts.SyntaxKind.SetAccessor]: 'SetAccessor',
  [ts.SyntaxKind.CallSignature]: 'CallSignature',
  [ts.SyntaxKind.ConstructSignature]: 'ConstructSignature',
  [ts.SyntaxKind.IndexSignature]: 'IndexSignature',
  [ts.SyntaxKind.TypePredicate]: 'TypePredicate',
  [ts.SyntaxKind.TypeReference]: 'TypeReference',
  [ts.SyntaxKind.FunctionType]: 'FunctionType',
  [ts.SyntaxKind.ConstructorType]: 'ConstructorType',
  [ts.SyntaxKind.TypeQuery]: 'TypeQuery',
  [ts.SyntaxKind.TypeLiteral]: 'TypeLiteral',
  [ts.SyntaxKind.ArrayType]: 'ArrayType',
  [ts.SyntaxKind.TupleType]: 'TupleType',
  [ts.SyntaxKind.OptionalType]: 'OptionalType',
  [ts.SyntaxKind.RestType]: 'RestType',
  [ts.SyntaxKind.UnionType]: 'UnionType',
  [ts.SyntaxKind.IntersectionType]: 'IntersectionType',
  [ts.SyntaxKind.ConditionalType]: 'ConditionalType',
  [ts.SyntaxKind.InferType]: 'InferType',
  [ts.SyntaxKind.ParenthesizedType]: 'ParenthesizedType',
  [ts.SyntaxKind.ThisType]: 'ThisType',
  [ts.SyntaxKind.TypeOperator]: 'TypeOperator',
  [ts.SyntaxKind.IndexedAccessType]: 'IndexedAccessType',
  [ts.SyntaxKind.MappedType]: 'MappedType',
  [ts.SyntaxKind.LiteralType]: 'LiteralType',
  [ts.SyntaxKind.NamedTupleMember]: 'NamedTupleMember',
  [ts.SyntaxKind.TemplateLiteralType]: 'TemplateLiteralType',
  [ts.SyntaxKind.TemplateLiteralTypeSpan]: 'TemplateLiteralTypeSpan',
  [ts.SyntaxKind.ImportType]: 'ImportType',
  [ts.SyntaxKind.ObjectBindingPattern]: 'ObjectBindingPattern',
  [ts.SyntaxKind.ArrayBindingPattern]: 'ArrayBindingPattern',
  [ts.SyntaxKind.BindingElement]: 'BindingElement',
  [ts.SyntaxKind.ArrayLiteralExpression]: 'ArrayLiteralExpression',
  [ts.SyntaxKind.ObjectLiteralExpression]: 'ObjectLiteralExpression',
  [ts.SyntaxKind.PropertyAccessExpression]: 'PropertyAccessExpression',
  [ts.SyntaxKind.ElementAccessExpression]: 'ElementAccessExpression',
  [ts.SyntaxKind.CallExpression]: 'CallExpression',
  [ts.SyntaxKind.NewExpression]: 'NewExpression',
  [ts.SyntaxKind.TaggedTemplateExpression]: 'TaggedTemplateExpression',
  [ts.SyntaxKind.TypeAssertionExpression]: 'TypeAssertionExpression',
  [ts.SyntaxKind.ParenthesizedExpression]: 'ParenthesizedExpression',
  [ts.SyntaxKind.FunctionExpression]: 'FunctionExpression',
  [ts.SyntaxKind.ArrowFunction]: 'ArrowFunction',
  [ts.SyntaxKind.DeleteExpression]: 'DeleteExpression',
  [ts.SyntaxKind.TypeOfExpression]: 'TypeOfExpression',
  [ts.SyntaxKind.VoidExpression]: 'VoidExpression',
  [ts.SyntaxKind.AwaitExpression]: 'AwaitExpression',
  [ts.SyntaxKind.PrefixUnaryExpression]: 'PrefixUnaryExpression',
  [ts.SyntaxKind.PostfixUnaryExpression]: 'PostfixUnaryExpression',
  [ts.SyntaxKind.BinaryExpression]: 'BinaryExpression',
  [ts.SyntaxKind.ConditionalExpression]: 'ConditionalExpression',
  [ts.SyntaxKind.TemplateExpression]: 'TemplateExpression',
  [ts.SyntaxKind.YieldExpression]: 'YieldExpression',
  [ts.SyntaxKind.SpreadElement]: 'SpreadElement',
  [ts.SyntaxKind.ClassExpression]: 'ClassExpression',
  [ts.SyntaxKind.OmittedExpression]: 'OmittedExpression',
  [ts.SyntaxKind.ExpressionWithTypeArguments]: 'ExpressionWithTypeArguments',
  [ts.SyntaxKind.AsExpression]: 'AsExpression',
  [ts.SyntaxKind.NonNullExpression]: 'NonNullExpression',
  [ts.SyntaxKind.MetaProperty]: 'MetaProperty',
  [ts.SyntaxKind.SyntheticExpression]: 'SyntheticExpression',
  [ts.SyntaxKind.SatisfiesExpression]: 'SatisfiesExpression',
  [ts.SyntaxKind.TemplateSpan]: 'TemplateSpan',
  [ts.SyntaxKind.SemicolonClassElement]: 'SemicolonClassElement',
  [ts.SyntaxKind.Block]: 'Block',
  [ts.SyntaxKind.EmptyStatement]: 'EmptyStatement',
  [ts.SyntaxKind.VariableStatement]: 'VariableStatement',
  [ts.SyntaxKind.ExpressionStatement]: 'ExpressionStatement',
  [ts.SyntaxKind.IfStatement]: 'IfStatement',
  [ts.SyntaxKind.DoStatement]: 'DoStatement',
  [ts.SyntaxKind.WhileStatement]: 'WhileStatement',
  [ts.SyntaxKind.ForStatement]: 'ForStatement',
  [ts.SyntaxKind.ForInStatement]: 'ForInStatement',
  [ts.SyntaxKind.ForOfStatement]: 'ForOfStatement',
  [ts.SyntaxKind.ContinueStatement]: 'ContinueStatement',
  [ts.SyntaxKind.BreakStatement]: 'BreakStatement',
  [ts.SyntaxKind.ReturnStatement]: 'ReturnStatement',
  [ts.SyntaxKind.WithStatement]: 'WithStatement',
  [ts.SyntaxKind.SwitchStatement]: 'SwitchStatement',
  [ts.SyntaxKind.LabeledStatement]: 'LabeledStatement',
  [ts.SyntaxKind.ThrowStatement]: 'ThrowStatement',
  [ts.SyntaxKind.TryStatement]: 'TryStatement',
  [ts.SyntaxKind.DebuggerStatement]: 'DebuggerStatement',
  [ts.SyntaxKind.VariableDeclaration]: 'VariableDeclaration',
  [ts.SyntaxKind.VariableDeclarationList]: 'VariableDeclarationList',
  [ts.SyntaxKind.FunctionDeclaration]: 'FunctionDeclaration',
  [ts.SyntaxKind.ClassDeclaration]: 'ClassDeclaration',
  [ts.SyntaxKind.InterfaceDeclaration]: 'InterfaceDeclaration',
  [ts.SyntaxKind.TypeAliasDeclaration]: 'TypeAliasDeclaration',
  [ts.SyntaxKind.EnumDeclaration]: 'EnumDeclaration',
  [ts.SyntaxKind.ModuleDeclaration]: 'ModuleDeclaration',
  [ts.SyntaxKind.ModuleBlock]: 'ModuleBlock',
  [ts.SyntaxKind.CaseBlock]: 'CaseBlock',
  [ts.SyntaxKind.NamespaceExportDeclaration]: 'NamespaceExportDeclaration',
  [ts.SyntaxKind.ImportEqualsDeclaration]: 'ImportEqualsDeclaration',
  [ts.SyntaxKind.ImportDeclaration]: 'ImportDeclaration',
  [ts.SyntaxKind.ImportClause]: 'ImportClause',
  [ts.SyntaxKind.NamespaceImport]: 'NamespaceImport',
  [ts.SyntaxKind.NamedImports]: 'NamedImports',
  [ts.SyntaxKind.ImportSpecifier]: 'ImportSpecifier',
  [ts.SyntaxKind.ExportAssignment]: 'ExportAssignment',
  [ts.SyntaxKind.ExportDeclaration]: 'ExportDeclaration',
  [ts.SyntaxKind.NamedExports]: 'NamedExports',
  [ts.SyntaxKind.NamespaceExport]: 'NamespaceExport',
  [ts.SyntaxKind.ExportSpecifier]: 'ExportSpecifier',
  [ts.SyntaxKind.MissingDeclaration]: 'MissingDeclaration',
  [ts.SyntaxKind.ExternalModuleReference]: 'ExternalModuleReference',
  [ts.SyntaxKind.JsxElement]: 'JsxElement',
  [ts.SyntaxKind.JsxSelfClosingElement]: 'JsxSelfClosingElement',
  [ts.SyntaxKind.JsxOpeningElement]: 'JsxOpeningElement',
  [ts.SyntaxKind.JsxClosingElement]: 'JsxClosingElement',
  [ts.SyntaxKind.JsxFragment]: 'JsxFragment',
  [ts.SyntaxKind.JsxOpeningFragment]: 'JsxOpeningFragment',
  [ts.SyntaxKind.JsxClosingFragment]: 'JsxClosingFragment',
  [ts.SyntaxKind.JsxAttribute]: 'JsxAttribute',
  [ts.SyntaxKind.JsxAttributes]: 'JsxAttributes',
  [ts.SyntaxKind.JsxSpreadAttribute]: 'JsxSpreadAttribute',
  [ts.SyntaxKind.JsxExpression]: 'JsxExpression',
  [ts.SyntaxKind.JsxNamespacedName]: 'JsxNamespacedName',
  [ts.SyntaxKind.CaseClause]: 'CaseClause',
  [ts.SyntaxKind.DefaultClause]: 'DefaultClause',
  [ts.SyntaxKind.HeritageClause]: 'HeritageClause',
  [ts.SyntaxKind.CatchClause]: 'CatchClause',
  [ts.SyntaxKind.ImportAttributes]: 'ImportAttributes',
  [ts.SyntaxKind.ImportAttribute]: 'ImportAttribute',
  [ts.SyntaxKind.PropertyAssignment]: 'PropertyAssignment',
  [ts.SyntaxKind.ShorthandPropertyAssignment]: 'ShorthandPropertyAssignment',
  [ts.SyntaxKind.SpreadAssignment]: 'SpreadAssignment',
  [ts.SyntaxKind.EnumMember]: 'EnumMember',
  [ts.SyntaxKind.SourceFile]: 'SourceFile',
  [ts.SyntaxKind.Bundle]: 'Bundle',
  [ts.SyntaxKind.JSDocTypeExpression]: 'JSDocTypeExpression',
  [ts.SyntaxKind.JSDocNameReference]: 'JSDocNameReference',
  [ts.SyntaxKind.JSDocMemberName]: 'JSDocMemberName',
  [ts.SyntaxKind.JSDocAllType]: 'JSDocAllType',
  [ts.SyntaxKind.JSDocUnknownType]: 'JSDocUnknownType',
  [ts.SyntaxKind.JSDocNullableType]: 'JSDocNullableType',
  [ts.SyntaxKind.JSDocNonNullableType]: 'JSDocNonNullableType',
  [ts.SyntaxKind.JSDocOptionalType]: 'JSDocOptionalType',
  [ts.SyntaxKind.JSDocFunctionType]: 'JSDocFunctionType',
  [ts.SyntaxKind.JSDocVariadicType]: 'JSDocVariadicType',
  [ts.SyntaxKind.JSDocNamepathType]: 'JSDocNamepathType',
  [ts.SyntaxKind.JSDoc]: 'JSDoc',
  [ts.SyntaxKind.JSDocText]: 'JSDocText',
  [ts.SyntaxKind.JSDocTypeLiteral]: 'JSDocTypeLiteral',
  [ts.SyntaxKind.JSDocSignature]: 'JSDocSignature',
  [ts.SyntaxKind.JSDocLink]: 'JSDocLink',
  [ts.SyntaxKind.JSDocLinkCode]: 'JSDocLinkCode',
  [ts.SyntaxKind.JSDocLinkPlain]: 'JSDocLinkPlain',
  [ts.SyntaxKind.JSDocTag]: 'JSDocTag',
  [ts.SyntaxKind.JSDocAugmentsTag]: 'JSDocAugmentsTag',
  [ts.SyntaxKind.JSDocImplementsTag]: 'JSDocImplementsTag',
  [ts.SyntaxKind.JSDocAuthorTag]: 'JSDocAuthorTag',
  [ts.SyntaxKind.JSDocDeprecatedTag]: 'JSDocDeprecatedTag',
  [ts.SyntaxKind.JSDocClassTag]: 'JSDocClassTag',
  [ts.SyntaxKind.JSDocPublicTag]: 'JSDocPublicTag',
  [ts.SyntaxKind.JSDocPrivateTag]: 'JSDocPrivateTag',
  [ts.SyntaxKind.JSDocProtectedTag]: 'JSDocProtectedTag',
  [ts.SyntaxKind.JSDocReadonlyTag]: 'JSDocReadonlyTag',
  [ts.SyntaxKind.JSDocOverrideTag]: 'JSDocOverrideTag',
  [ts.SyntaxKind.JSDocCallbackTag]: 'JSDocCallbackTag',
  [ts.SyntaxKind.JSDocOverloadTag]: 'JSDocOverloadTag',
  [ts.SyntaxKind.JSDocEnumTag]: 'JSDocEnumTag',
  [ts.SyntaxKind.JSDocParameterTag]: 'JSDocParameterTag',
  [ts.SyntaxKind.JSDocReturnTag]: 'JSDocReturnTag',
  [ts.SyntaxKind.JSDocThisTag]: 'JSDocThisTag',
  [ts.SyntaxKind.JSDocTypeTag]: 'JSDocTypeTag',
  [ts.SyntaxKind.JSDocTemplateTag]: 'JSDocTemplateTag',
  [ts.SyntaxKind.JSDocTypedefTag]: 'JSDocTypedefTag',
  [ts.SyntaxKind.JSDocSeeTag]: 'JSDocSeeTag',
  [ts.SyntaxKind.JSDocPropertyTag]: 'JSDocPropertyTag',
  [ts.SyntaxKind.JSDocThrowsTag]: 'JSDocThrowsTag',
  [ts.SyntaxKind.JSDocSatisfiesTag]: 'JSDocSatisfiesTag',
  [ts.SyntaxKind.SyntaxList]: 'SyntaxList',
  [ts.SyntaxKind.NotEmittedStatement]: 'NotEmittedStatement',
  [ts.SyntaxKind.PartiallyEmittedExpression]: 'PartiallyEmittedExpression',
  [ts.SyntaxKind.CommaListExpression]: 'CommaListExpression',
  [ts.SyntaxKind.SyntheticReferenceExpression]: 'SyntheticReferenceExpression',
  [ts.SyntaxKind.Count]: 'Count',
} as const

const namesRecord = SyntaxKindName as Record<ts.SyntaxKind, string | undefined>

export const getNodeName = (node: ts.Node): string => {
  return namesRecord[node.kind] ?? 'Unknown'
}

export const getSyntaxName = (kind: ts.SyntaxKind): string => {
  return namesRecord[kind] ?? 'Unknown'
}

export type SyntaxKindNameType = typeof SyntaxKindName

export type ModuleStatements =
  | ts.ClassDeclaration
  | ts.ImportDeclaration
  | ts.VariableStatement
  | ts.FunctionDeclaration
  | ts.TypeAliasDeclaration
  | ts.InterfaceDeclaration

export type PrimaryExpressions =
  | LiteralExpressions
  | ts.TrueLiteral
  | ts.FalseLiteral
  | ts.ArrayLiteralExpression
  | ts.ClassExpression
  | ts.FunctionExpression
  | ts.Identifier
  | ts.ImportExpression
  | ts.NewExpression
  | ts.NullLiteral
  | ts.ObjectLiteralExpression
  | ts.PrivateIdentifier
  | ts.ParenthesizedExpression
  | ts.SuperExpression
  | ts.TemplateExpression
  | ts.ThisExpression

export type MemberExpressions =
  | PrimaryExpressions
  | ts.ElementAccessExpression
  | ts.ExpressionWithTypeArguments
  | ts.PropertyAccessExpression
  | ts.TaggedTemplateExpression

export type LeftHandSideExpression = ts.CallExpression | MemberExpressions | ts.NonNullExpression

/**
 * All concrete types which extends ts.ClassElement
 */
export type ClassElements =
  | ts.ClassStaticBlockDeclaration
  | ts.ConstructorDeclaration
  | ts.GetAccessorDeclaration
  | ts.IndexSignatureDeclaration
  | ts.MethodDeclaration
  | ts.PropertyDeclaration
  | ts.SemicolonClassElement
  | ts.SetAccessorDeclaration

/**
 * All concrete types which extends ts.Statement
 */
export type Statements =
  | ts.EmptyStatement
  | ts.VariableStatement
  | ts.ExpressionStatement
  | ts.IfStatement
  | ts.DoStatement
  | ts.WhileStatement
  | ts.ForStatement
  | ts.ForInStatement
  | ts.ForOfStatement
  | ts.ContinueStatement
  | ts.BreakStatement
  | ts.ReturnStatement
  | ts.WithStatement
  | ts.SwitchStatement
  | ts.LabeledStatement
  | ts.ThrowStatement
  | ts.TryStatement
  | ts.DebuggerStatement
  | ts.ImportDeclaration
  | ts.ClassDeclaration
  | ts.TypeAliasDeclaration

/**
 * All concrete types which extends ts.LiteralExpression
 */
export type LiteralExpressions =
  | ts.NumericLiteral
  | ts.BigIntLiteral
  | ts.StringLiteral
  | ts.RegularExpressionLiteral
  | ts.NoSubstitutionTemplateLiteral

/**
 * All concrete types which extend ts.Expression
 */
export type Expressions =
  | ts.PropertyAccessExpression
  | ts.ElementAccessExpression
  | ts.TypeAssertion
  | ts.ParenthesizedExpression
  | ts.FunctionExpression
  | ts.DeleteExpression
  | ts.TypeOfExpression
  | ts.VoidExpression
  | ts.AwaitExpression
  | ts.PrefixUnaryExpression
  | ts.PostfixUnaryExpression
  | ts.BinaryExpression
  | ts.ConditionalExpression
  | ts.TemplateExpression
  | ts.YieldExpression
  | ts.OmittedExpression
  | ts.ExpressionWithTypeArguments
  | ts.AsExpression
  | ts.NonNullExpression
  | ts.SatisfiesExpression
  | ts.SpreadElement
  | PrimaryExpressions
  | LeftHandSideExpression

/**
 * Map an inherited base type to a union type of "all" the nodes which extend that base type
 * where "all" is limited to nodes relevant to this compiler.
 */
export type MapBaseType<T> = T extends DeliberateAny
  ? IfEquals<
      T,
      ts.Expression,
      Expressions,
      IfEquals<
        T,
        ts.LeftHandSideExpression,
        LeftHandSideExpression,
        IfEquals<T, ts.Statement, Statements, IfEquals<T, ts.ClassElement, ClassElements, T>>
      >
    >
  : never

type IfEquals<T, U, Y = unknown, N = never> = ((x: T) => T) extends (x: U) => U ? (((x: U) => U) extends (x: T) => T ? Y : N) : N

export const BinaryOpSyntaxes = {
  [ts.SyntaxKind.PlusToken]: BuilderBinaryOp.add,
  [ts.SyntaxKind.MinusToken]: BuilderBinaryOp.sub,
  [ts.SyntaxKind.AsteriskToken]: BuilderBinaryOp.mult,
  [ts.SyntaxKind.SlashToken]: BuilderBinaryOp.div,
  [ts.SyntaxKind.PercentToken]: BuilderBinaryOp.mod,
  [ts.SyntaxKind.AsteriskAsteriskToken]: BuilderBinaryOp.pow,
  [ts.SyntaxKind.BarToken]: BuilderBinaryOp.bitOr,
  [ts.SyntaxKind.CaretToken]: BuilderBinaryOp.bitXor,
  [ts.SyntaxKind.AmpersandToken]: BuilderBinaryOp.bitAnd,
  [ts.SyntaxKind.LessThanLessThanToken]: BuilderBinaryOp.lshift,
  [ts.SyntaxKind.GreaterThanGreaterThanToken]: BuilderBinaryOp.rshift,
} as const

export const LogicalOpSyntaxes = {
  [ts.SyntaxKind.AmpersandAmpersandToken]: BinaryBooleanOperator.and,
  [ts.SyntaxKind.BarBarToken]: BinaryBooleanOperator.or,
}
export const AugmentedAssignmentLogicalOpSyntaxes = {
  [ts.SyntaxKind.AmpersandAmpersandEqualsToken]: BinaryBooleanOperator.and,
  [ts.SyntaxKind.BarBarEqualsToken]: BinaryBooleanOperator.or,
}

export function isKeyOf<TMap extends object>(key: PropertyKey, map: TMap): key is keyof TMap {
  return Object.hasOwn(map, key)
}

export const ComparisonOpSyntaxes = {
  [ts.SyntaxKind.EqualsEqualsEqualsToken]: BuilderComparisonOp.eq,
  [ts.SyntaxKind.ExclamationEqualsEqualsToken]: BuilderComparisonOp.ne,
  [ts.SyntaxKind.LessThanToken]: BuilderComparisonOp.lt,
  [ts.SyntaxKind.LessThanEqualsToken]: BuilderComparisonOp.lte,
  [ts.SyntaxKind.GreaterThanToken]: BuilderComparisonOp.gt,
  [ts.SyntaxKind.GreaterThanEqualsToken]: BuilderComparisonOp.gte,
} as const

export const AugmentedAssignmentBinaryOp = {
  [ts.SyntaxKind.PlusEqualsToken]: BuilderBinaryOp.add,
  [ts.SyntaxKind.MinusEqualsToken]: BuilderBinaryOp.sub,
  [ts.SyntaxKind.AsteriskEqualsToken]: BuilderBinaryOp.mult,
  [ts.SyntaxKind.SlashEqualsToken]: BuilderBinaryOp.div,
  [ts.SyntaxKind.PercentEqualsToken]: BuilderBinaryOp.mod,
  [ts.SyntaxKind.AsteriskAsteriskEqualsToken]: BuilderBinaryOp.pow,
  [ts.SyntaxKind.BarEqualsToken]: BuilderBinaryOp.bitOr,
  [ts.SyntaxKind.CaretEqualsToken]: BuilderBinaryOp.bitXor,
  [ts.SyntaxKind.AmpersandEqualsToken]: BuilderBinaryOp.bitAnd,
  [ts.SyntaxKind.LessThanLessThanEqualsToken]: BuilderBinaryOp.lshift,
  [ts.SyntaxKind.GreaterThanGreaterThanEqualsToken]: BuilderBinaryOp.rshift,
} as const

export const UnaryExpressionUnaryOps = {
  [ts.SyntaxKind.PlusPlusToken]: BuilderUnaryOp.inc,
  [ts.SyntaxKind.MinusMinusToken]: BuilderUnaryOp.dec,
  [ts.SyntaxKind.PlusToken]: BuilderUnaryOp.pos,
  [ts.SyntaxKind.MinusToken]: BuilderUnaryOp.neg,
  [ts.SyntaxKind.TildeToken]: BuilderUnaryOp.bit_inv,
}



================================================
FILE: src/visitor/visitor.ts
================================================
import type ts from 'typescript'
import type { AwstBuildContext } from '../awst_build/context/awst-build-context'
import { CodeError } from '../errors'
import { patchErrorLocation } from '../logger'
import type { DeliberateAny } from '../typescript-helpers'
import type { MapBaseType, SyntaxKindNameType } from './syntax-names'
import { getNodeName, SyntaxKindName } from './syntax-names'

type UnionToIntersection<T> = (T extends DeliberateAny ? (x: T) => void : never) extends (x: infer TIntersection) => void
  ? TIntersection
  : never

export type Visitor<T extends { kind: ts.SyntaxKind }, TReturn> = UnionToIntersection<
  T extends DeliberateAny
    ? { [key in T['kind'] as key extends keyof SyntaxKindNameType ? `visit${SyntaxKindNameType[key]}` : never]: (node: T) => TReturn }
    : never
>

/**
 * This type relies on `T` being a concrete node with a `kind` property that is resolved to a single `SyntaxKind`.
 * There are lots of nodes (such as ts.Expression) which are base types for several nodes which means this type
 * will return `typeof SyntaxKind` instead of `typeof SyntaxKind.someValue` and that will break the rest of the
 * generic types here. `MapBaseType<TNode>` exists to convert these base types into a union of their concrete implementors
 */
export type KindForNode<T extends ts.Node> = T extends { kind: infer TKind } ? TKind : never

export type VisitorMethod<TKind> = TKind extends keyof SyntaxKindNameType ? `visit${SyntaxKindNameType[TKind]}` : never

export type MethodReturnType<TMethod, TVisitor> = TMethod extends keyof TVisitor
  ? TVisitor[TMethod] extends (...args: DeliberateAny[]) => infer TReturn
    ? TReturn
    : never
  : never

export type ReturnTypeForNode<T extends ts.Node, TVisitor> = MethodReturnType<VisitorMethod<KindForNode<T>>, TVisitor>

export const accept = <TSelf extends { context: AwstBuildContext }, T extends ts.Node>(
  visitor: TSelf,
  node: T,
): ReturnTypeForNode<MapBaseType<T>, TSelf> => {
  const sourceLocation = visitor.context.getSourceLocation(node)
  if (node.kind in SyntaxKindName) {
    const nodeName = getNodeName(node)
    const visitFunction = `visit${nodeName}`
    if (visitFunction in Object.getPrototypeOf(visitor)) {
      return patchErrorLocation(() => Object.getPrototypeOf(visitor)[visitFunction].call(visitor, node), sourceLocation)()
    } else {
      throw new CodeError(`Unsupported syntax visitor ${nodeName}`, { sourceLocation })
    }
  } else {
    throw new CodeError(`Unknown syntax kind ${node.kind}`, { sourceLocation })
  }
}



================================================
FILE: tests/approvals.spec.ts
================================================
import { globSync } from 'glob'
import { rimraf } from 'rimraf'
import { describe, expect, it } from 'vitest'
import { compile, CompileOptions, processInputPaths } from '../src'
import { isErrorOrCritical, LoggingContext, LogLevel } from '../src/logger'
import { normalisePath } from '../src/util'
import { invokeCli } from '../src/util/invoke-cli'

describe('Approvals', async () => {
  await rimraf('tests/approvals/out')

  const contractFiles = globSync('tests/approvals/*.algo.ts')
    .map((p) => normalisePath(p, process.cwd()))
    .toSorted()
  describe.each([
    ['Unoptimized', 'out/unoptimized/[name]', { optimizationLevel: 0, outputAwstJson: true, outputAwst: true }],
    ['O1', 'out/o1/[name]', { optimizationLevel: 1 }],
    ['O2', 'out/o2/[name]', { optimizationLevel: 2 }],
  ])('Compile %s', async (desc, outDir, puyaOptions) => {
    const logCtx = LoggingContext.create()
    const result = await logCtx.run(() => {
      const filePaths = processInputPaths({ paths: ['tests/approvals'], outDir })
      return compile(
        new CompileOptions({
          filePaths,
          dryRun: false,
          logLevel: LogLevel.Warning,
          skipVersionCheck: true,
          outputSourceMap: false,
          outputAwstJson: false,
          outputAwst: false,
          outputTeal: true,
          outputArc32: true,
          outputArc56: true,
          outputSsaIr: true,
          ...puyaOptions,
        }),
      )
    })
    it.each(contractFiles)('%s', (contractFilePath) => {
      const awst = result.awst?.filter((s) => s.sourceLocation.file === contractFilePath)

      const errors = logCtx.logEvents.filter(
        (l) => (!l.sourceLocation || l.sourceLocation.file === contractFilePath) && isErrorOrCritical(l.level),
      )
      if (errors.length === 0) {
        expect(errors.length).toBe(0)
      } else {
        expect.fail(`Errors: \n${errors.map((e) => e.message).join('\n')}`)
      }

      expect(awst, 'Contract file must produce awst').toBeDefined()
    })
  })

  it('There should be no differences to committed changes', async () => {
    const result = await invokeCli({
      command: 'git',
      args: ['status', '--porcelain'],
    })
    const diffs = result.lines

    if (diffs.length) {
      expect.fail(
        `There are uncommitted changes: \n\n${diffs.slice(0, 5).join('\n')}${diffs.length > 5 ? `\n +${diffs.length - 5} more` : ''}`,
      )
    }
  })
})



================================================
FILE: tests/expected-output.spec.ts
================================================
import ts from 'typescript'
import { describe, it } from 'vitest'
import { compile } from '../src'
import { SourceLocation } from '../src/awst/source-location'
import { processInputPaths } from '../src/input-paths/process-input-paths'
import type { LogEvent } from '../src/logger'
import { isMinLevel, LoggingContext, LogLevel } from '../src/logger'
import { CompileOptions } from '../src/options'
import { enumFromValue, invariant } from '../src/util'

/**
 * Verify that specific code produces specific compiler output.
 *
 * Code files in `tests/expected-output/**` are parsed and comments which match the pattern of
 * // @expect-<level> message
 * are extracted. These patterns indicate that a particular log message is expected from the compiler at the next line.
 *
 * After compilation these expected logs are matched to actual output.
 *
 * All expected logs MUST be found in the output
 * All output logs MUST be expected
 *
 * The line numbers MUST match the line after the comment
 * The expected log level MUST match the observed log level
 * If the message ends in a `...` token, the observed log message MUST start with the expected log message (minus the `...`)
 * Otherwise the expected message MUST match the observed log message verbatim.
 *
 */
describe('Expected output', async () => {
  const logCtx = LoggingContext.create()
  const result = await logCtx.run(() => {
    const filePaths = processInputPaths({ paths: ['tests/expected-output'] })
    return compile(
      new CompileOptions({
        filePaths,
        dryRun: true,
        logLevel: LogLevel.Info,
      }),
    )
  })
  invariant(result.ast, 'Compilation must result in ast')
  const paths = Object.entries(result.ast ?? {}).map(([path, ast]) => ({
    path,
    ast,
    logs: logCtx.logEvents.filter((l) => l.sourceLocation?.file === path && l.message !== 'AWST build failure. See previous errors'),
  }))

  describe.each(paths)('$path', ({ logs, ast }) => {
    it('has expected output', () => {
      const expectedLogs = extractExpectLogs(ast, result.programDirectory)
      const matchedLogs = new Set<LogEvent>()
      for (const expectedLog of expectedLogs) {
        const matchedLog = logs.find((l) => expectedLog.test(l))
        if (!matchedLog) {
          const potentialCandidates = logs.filter(
            (l) => l.sourceLocation?.file === expectedLog.sourceLocation.file && l.sourceLocation.line === expectedLog.sourceLocation.line,
          )
          throw new MissingLogError(expectedLog, potentialCandidates)
        } else {
          matchedLogs.add(matchedLog)
        }
      }
      const unmatchedLogs = logs.filter((l) => !matchedLogs.has(l) && isMinLevel(l.level, LogLevel.Warning))
      if (unmatchedLogs.length) {
        const [firstUnmatched] = unmatchedLogs
        invariant(firstUnmatched.sourceLocation, 'Log must have source location')
        throw new AdditionalLogError({
          sourceLocation: firstUnmatched.sourceLocation,
          message: firstUnmatched.message,
          level: firstUnmatched.level,
        })
      }
    })
  })
})

class MissingLogError implements Error {
  constructor(
    private expectedLog: {
      level: LogLevel
      message: string
      sourceLocation: SourceLocation
    },
    private potentialMatches?: LogEvent[],
  ) {}
  get message() {
    const foundLog = this.potentialMatches
      ? `Found logs: ${this.potentialMatches.map((m) => `[${m.level}] ${m.message}`).join('\n')}`
      : 'Found log: <none>'
    return `Expected log: [${this.expectedLog.level}] ${this.expectedLog.message}\n${foundLog}`
  }
  get stack() {
    return this.potentialMatches?.[0]?.sourceLocation?.toString() ?? this.expectedLog.sourceLocation.toString()
  }
  get name() {
    return 'MissingLogError'
  }
}

class AdditionalLogError implements Error {
  constructor(
    private expectedLog: {
      level: LogLevel
      message: string
      sourceLocation: SourceLocation
    },
  ) {}
  get message() {
    return `Additional log: [${this.expectedLog.level}] ${this.expectedLog.message}`
  }
  get stack() {
    return this.expectedLog.sourceLocation.toString()
  }
  get name() {
    return 'AdditionalLogError'
  }
}

type ExpectedLog = {
  level: LogLevel
  message: string
  sourceLocation: SourceLocation
  test(log: LogEvent): boolean
}

function extractExpectLogs(sourceFile: ts.SourceFile, programDirectory: string) {
  const expectedLogs: ExpectedLog[] = []

  ts.visitNode(sourceFile, visit)

  function visit(node: ts.Node): ts.Node {
    const commentRanges = ts.getLeadingCommentRanges(sourceFile.getFullText(), node.getFullStart())
    if (commentRanges?.length) {
      for (const commentRange of commentRanges) {
        const comment = sourceFile.getFullText().slice(commentRange.pos, commentRange.end)
        const match = /^\/\/ @expect-(\w+)\s+(.*)$/.exec(comment)
        if (match) {
          const level = enumFromValue(match[1], LogLevel, 'Unexpected log level in @expect-* comment: ')
          const message = match[2]
          const targetLocation = SourceLocation.fromNode(node, programDirectory)
          expectedLogs.push({
            level,
            message,
            sourceLocation: targetLocation,
            test(log) {
              if (log.level === this.level && log.sourceLocation?.line === this.sourceLocation.line) {
                if (this.message.endsWith('...')) {
                  return log.message.startsWith(this.message.slice(0, -3))
                } else {
                  return log.message === this.message
                }
              }
              return false
            },
          })
        }
      }
    }

    return ts.visitEachChild(node, visit, undefined)
  }
  return expectedLogs
}



================================================
FILE: tests/virtual-file.spec.ts
================================================
import { describe, expect, it } from 'vitest'
import { compile, LoggingContext } from '../src'
import { Contract } from '../src/awst/nodes'
import { CompileOptions } from '../src/options'
import { invariant } from '../src/util'

describe('Virtual files', () => {
  const contractVirtualFile = `
import { Contract } from '@algorandfoundation/algorand-typescript'

class TestContract extends Contract {
  sayHello() {
    return 'Hello'
  }
}
  `

  it('can be compiled as if they existed', async () => {
    const logging = LoggingContext.create().enterContext()

    const result = await compile(
      new CompileOptions({
        filePaths: [
          {
            sourceFile: 'tests/virtual-file/test-contract.algo.ts',
            outDir: 'tests/virtual-file/out',
            fileContents: contractVirtualFile,
          },
        ],
        dryRun: true,
      }),
    )
    expect(logging.hasErrors()).toBeFalsy()
    expect(result.awst?.length).toBe(1)
    const [contract] = result.awst!
    invariant(contract instanceof Contract, 'AWST should be a contract node')

    expect(contract.name).toBe('TestContract')
  })
})



================================================
FILE: tests/approvals/abi-decorators.algo.ts
================================================
import type { uint64 } from '@algorandfoundation/algorand-typescript'
import { abimethod, Contract, GlobalState, Uint64 } from '@algorandfoundation/algorand-typescript'

export default class AbiDecorators extends Contract {
  @abimethod({ allowActions: 'NoOp' })
  public justNoop(): void {}
  @abimethod({ onCreate: 'require' })
  public createMethod(): void {}
  @abimethod({ allowActions: ['NoOp', 'OptIn', 'CloseOut', 'DeleteApplication', 'UpdateApplication'] })
  public allActions(): void {}
  @abimethod({ readonly: true, name: 'overrideReadonlyName' })
  public readonly(): uint64 {
    return 5
  }

  globalValue = GlobalState({ initialValue: Uint64(123) })

  @abimethod({ defaultArguments: { a: { from: 'globalValue' }, b: { from: 'readonly' }, c: { constant: 145 } } })
  public methodWithDefaults(a: uint64, b: uint64, c: uint64): uint64 {
    return a * b + c
  }
}

export class OverloadedMethods extends Contract {
  @abimethod({ name: 'doThing' })
  doThingOne(x: uint64): uint64 {
    return x
  }

  @abimethod({ name: 'doThing' })
  doThingTwo(x: uint64, y: uint64): uint64 {
    return x * y
  }
}

export class BaseAbi extends Contract {
  @abimethod({ allowActions: 'OptIn' })
  someMethod() {
    return 'base-abi:optin'
  }
}

export class SubAbi extends BaseAbi {
  @abimethod({ allowActions: 'OptIn' })
  someMethod() {
    return 'sub-abi:optin'
  }
}

export class SubAbi2 extends BaseAbi {
  // Implicitly overrides base with NoOp
  someMethod(): string {
    return 'sub-abi-2:noop'
  }
}



================================================
FILE: tests/approvals/accounts.algo.ts
================================================
import type { Asset } from '@algorandfoundation/algorand-typescript'
import { Account, Bytes, Contract, ensureBudget, Global } from '@algorandfoundation/algorand-typescript'

const ADDRESS_B32 = 'A7NMWS3NT3IUDMLVO26ULGXGIIOUQ3ND2TXSER6EBGRZNOBOUIQXHIBGDE'

const PUBLICKEY_B16 = '07DACB4B6D9ED141B17576BD459AE6421D486DA3D4EF2247C409A396B82EA221'

export class AccountsContract extends Contract {
  public getAccountInfo(account: Account, asset: Asset) {
    ensureBudget(1400)
    return {
      bytes: account.bytes,
      balance: account.balance,
      minBalance: account.minBalance,
      authAddress: account.authAddress.bytes,
      totalNumUint: account.totalNumUint,
      totalNumByteSlice: account.totalNumByteSlice,
      totalExtraAppPages: account.totalExtraAppPages,
      totalAppsCreated: account.totalAppsCreated,
      totalAppsOptedIn: account.totalAppsOptedIn,
      totalAssetsCreated: account.totalAssetsCreated,
      totalAssets: account.totalAssets,
      totalBoxes: account.totalBoxes,
      totalBoxBytes: account.totalBoxBytes,
      isOptInApp: account.isOptedIn(Global.currentApplicationId),
      isOptInAsset: account.isOptedIn(asset),
    }
  }

  public otherAccount() {
    // Create from account address
    const account = Account('A7NMWS3NT3IUDMLVO26ULGXGIIOUQ3ND2TXSER6EBGRZNOBOUIQXHIBGDE')
    // Create from account public key byte
    const account2 = Account(Bytes.fromHex('07DACB4B6D9ED141B17576BD459AE6421D486DA3D4EF2247C409A396B82EA221'))

    const a3 = Account(ADDRESS_B32)
    const a4 = Account(Bytes.fromHex(PUBLICKEY_B16))

    const addr = ADDRESS_B32
    const pkey = PUBLICKEY_B16

    const a5 = Account(addr)
    const a6 = Account(Bytes.fromHex(pkey))
  }
}



================================================
FILE: tests/approvals/arc-28-events.algo.ts
================================================
import type { bytes } from '@algorandfoundation/algorand-typescript'
import { Contract, emit } from '@algorandfoundation/algorand-typescript'
import type { DynamicBytes, UintN8 } from '@algorandfoundation/algorand-typescript/arc4'
import { Struct } from '@algorandfoundation/algorand-typescript/arc4'

type Swapped = {
  a: UintN8
  b: UintN8
}

class SwappedArc4 extends Struct<{ a: UintN8; b: UintN8 }> {}

class EventEmitter extends Contract {
  emitSwapped(a: UintN8, b: UintN8) {
    emit<Swapped>({ a: b, b: a })

    const x: Swapped = { a: b, b: a }
    emit(x)

    const y = new SwappedArc4({
      a: b,
      b: a,
    })
    emit(y)

    emit('Swapped', b, a)

    emit('Swapped(uint8,uint8)', b, a)
    emit('Swapped((uint8,uint8),uint8)', [b, b] as const, a)
  }

  emitCustom(arg0: string, arg1: boolean) {
    emit('Custom', arg0, arg1)
    emit('Custom(string,bool)', arg0, arg1)
  }

  emitDynamicBytes(x: bytes, y: DynamicBytes) {
    emit('DB(byte[],byte[])', x, y)
  }
}



================================================
FILE: tests/approvals/arc4-encode-decode.algo.ts
================================================
import type { biguint, bytes, uint64 } from '@algorandfoundation/algorand-typescript'
import { assert, assertMatch, Bytes, Contract, ensureBudget, log } from '@algorandfoundation/algorand-typescript'
import type { Address } from '@algorandfoundation/algorand-typescript/arc4'
import {
  arc4EncodedLength,
  Bool,
  decodeArc4,
  DynamicArray,
  DynamicBytes,
  encodeArc4,
  StaticArray,
  Str,
  Struct,
  UintN,
  UintN64,
} from '@algorandfoundation/algorand-typescript/arc4'
import { itob } from '@algorandfoundation/algorand-typescript/op'

class TestStruct extends Struct<{ a: UintN64; b: DynamicBytes }> {}
type TestObj = { a: UintN64; b: DynamicBytes }
export class Arc4EncodeDecode extends Contract {
  testEncoding(a: uint64, b: boolean, c: biguint, d: bytes, e: string, f: Address) {
    ensureBudget(1400)
    assert(encodeArc4(a) === new UintN64(a).bytes)
    assert(encodeArc4(b) === new Bool(b).bytes)
    assert(encodeArc4(c) === new UintN<512>(c).bytes)
    assert(encodeArc4(d) === new DynamicBytes(d).bytes)
    assert(encodeArc4(e) === new Str(e).bytes)
    assert(encodeArc4({ a, b: d }) === new TestStruct({ a: new UintN64(a), b: new DynamicBytes(d) }).bytes)
    assert(encodeArc4(f) === f.bytes)

    assert(encodeArc4([a]) === new StaticArray(new UintN64(a)).bytes)
    assert(encodeArc4([b]) === new StaticArray(new Bool(b)).bytes)
    assert(encodeArc4([c]) === new StaticArray(new UintN<512>(c)).bytes)
    assert(encodeArc4([d]) === new StaticArray(new DynamicBytes(d)).bytes)
    assert(encodeArc4([e]) === new StaticArray(new Str(e)).bytes)
    assert(encodeArc4([f]) === new StaticArray(f).bytes)

    assert(encodeArc4<uint64[]>([a]) === new DynamicArray(new UintN64(a)).bytes)
    assert(encodeArc4<boolean[]>([b]) === new DynamicArray(new Bool(b)).bytes)
    assert(encodeArc4<biguint[]>([c]) === new DynamicArray(new UintN<512>(c)).bytes)
    assert(encodeArc4<bytes[]>([d]) === new DynamicArray(new DynamicBytes(d)).bytes)
    assert(encodeArc4<string[]>([e]) === new DynamicArray(new Str(e)).bytes)
    assert(encodeArc4<Address[]>([f]) === new DynamicArray(f).bytes)

    assert(arc4EncodedLength<uint64>() === 8)
    assert(arc4EncodedLength<boolean>() === 1)
    assert(arc4EncodedLength<UintN<512>>() === 64)
    assert(arc4EncodedLength<[uint64, uint64, boolean]>() === 17)
    assert(arc4EncodedLength<[uint64, uint64, boolean, boolean]>() === 17)
    assert(arc4EncodedLength<[StaticArray<Bool, 10>, boolean, boolean]>() === 3)
    assert(
      arc4EncodedLength<
        [[boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean], boolean, boolean]
      >() === 3,
    )
  }

  testDecoding(
    a: uint64,
    a_bytes: bytes,
    b: boolean,
    b_bytes: bytes,
    c: biguint,
    c_bytes: bytes,
    d: string,
    d_bytes: bytes,
    e: TestObj,
    e_bytes: bytes,
    f: Address,
    f_bytes: bytes,
  ) {
    assert(decodeArc4<uint64>(a_bytes) === a)
    assert(decodeArc4<boolean>(b_bytes) === b)
    assert(decodeArc4<biguint>(c_bytes) === c)
    assert(decodeArc4<string>(d_bytes) === d)
    assertMatch(decodeArc4<TestObj>(e_bytes), e)

    const lenPrefix = itob(1).slice(6, 8)
    const offsetHeader = itob(2).slice(6, 8)
    assertMatch(decodeArc4<uint64[]>(lenPrefix.concat(a_bytes)), [a], 'Array of uint64 matches')
    assertMatch(decodeArc4<boolean[]>(lenPrefix.concat(b_bytes)), [b], 'Array of boolean matches')
    log(lenPrefix.concat(c_bytes))
    assertMatch(decodeArc4<biguint[]>(lenPrefix.concat(c_bytes)), [c], 'Array of biguint matches')
    assertMatch(decodeArc4<string[]>(Bytes`${lenPrefix}${offsetHeader}${d_bytes}`), [d], 'Array of string matches')

    assertMatch(decodeArc4<TestObj[]>(Bytes`${lenPrefix}${offsetHeader}${e_bytes}`), [e], 'Array of struct matches')
    assertMatch(decodeArc4<Address[]>(Bytes`${lenPrefix}${f_bytes}`), [f], 'Array of address matches')
  }
}



================================================
FILE: tests/approvals/arc4-hybrid.algo.ts
================================================
import { Contract, log } from '@algorandfoundation/algorand-typescript'

class Arc4HybridAlgo extends Contract {
  override approvalProgram(): boolean {
    log('before')
    const result = super.approvalProgram()
    log('after')
    return result
  }

  override clearStateProgram(): boolean {
    log('clearing state')
    return true
  }

  someMethod() {
    log('some method')
  }
}



================================================
FILE: tests/approvals/arc4-method-selector.algo.ts
================================================
import type { Account, Application, Asset, gtxn } from '@algorandfoundation/algorand-typescript'
import { abimethod, assert, Contract, Uint64 } from '@algorandfoundation/algorand-typescript'
import { methodSelector } from '@algorandfoundation/algorand-typescript/arc4'

class ContractOne extends Contract {
  test() {
    return methodSelector(ContractTwo.prototype.someMethod) === methodSelector('renamedSomeMethod()void')
  }
  someMethod() {
    return someConst
  }

  test2() {
    assert(
      methodSelector(ContractTwo.prototype.referenceTypes) === methodSelector('referenceTypes(pay,asset,account,application,appl)void'),
    )
  }
}

class ContractTwo extends Contract {
  @abimethod({ name: 'renamedSomeMethod' })
  someMethod() {}

  test() {
    return methodSelector(ContractOne.prototype.someMethod) === methodSelector('someMethod()uint64')
  }

  referenceTypes(pay: gtxn.PaymentTxn, asset: Asset, account: Account, app: Application, appTxn: gtxn.ApplicationCallTxn) {}
}

const someConst = Uint64(123)



================================================
FILE: tests/approvals/arc4-struct.algo.ts
================================================
import type { uint64 } from '@algorandfoundation/algorand-typescript'
import { arc4, assert, Box, BoxMap, Contract, log } from '@algorandfoundation/algorand-typescript'
import { interpretAsArc4, methodSelector, Struct, UintN } from '@algorandfoundation/algorand-typescript/arc4'

type ARC4Uint64 = UintN<64>
const ARC4Uint64 = UintN<64>

class Vector extends Struct<{ x: ARC4Uint64; y: ARC4Uint64 }> {}

class StructDemo extends Contract {
  public testVectorCreationAndEquality() {
    const v1 = new Vector({ x: new ARC4Uint64(0), y: new ARC4Uint64(0) })
    log(v1.x)
    log(v1.y)
    const v2 = new Vector({ y: new ARC4Uint64(0), x: new ARC4Uint64(0) })
    assert(v1 === v2)
  }

  public addVectors(v1: Vector, v2: Vector) {
    return new Vector({
      x: new ARC4Uint64(v1.x.native + v2.x.native),
      y: new ARC4Uint64(v1.y.native + v2.y.native),
    })
  }

  public mutateVector(v1: Vector, newX: ARC4Uint64, newY: ARC4Uint64): Vector {
    v1.x = newX
    v1.y = newY
    return v1
  }

  public implicitCastingAndSpreading(v1: Vector) {
    const v2 = new Vector(v1)
    const v3 = new Vector({ ...v2 })
    assert(v1.bytes === v2.bytes)
    assert(v3.bytes === v1.bytes)
  }

  public toAndFromBytes(v1: Vector): Vector {
    const v1_bytes = v1.bytes
    return interpretAsArc4<Vector>(v1_bytes)
  }

  public toNative(v1: Vector) {
    return v1.native
  }

  plugins = BoxMap<string, PluginInfo>({ keyPrefix: 'plugins' })

  plugin = Box<PluginInfo>({ key: 'main' })

  public getPlugin(key: string): PluginInfo {
    const value = this.plugins(key).value.copy()
    assert(value.lastCalled.native > 0, 'Last called not zero')
    return value
  }

  public getMain() {
    const value = this.plugin.value.copy()
    assert(value.lastCalled.native > 0, 'Last called not zero')
    return value
  }

  public setLastCalled(key: string, index: uint64, lastCalled: uint64) {
    this.plugins(key).value.methods[index].lastCalled = new arc4.UintN64(lastCalled)
  }

  public setPlugin(key: string) {
    this.plugins(key).value = new PluginInfo({
      lastValidRound: new arc4.UintN64(1),
      cooldown: new arc4.UintN64(),
      lastCalled: new arc4.UintN64(),
      adminPrivileges: new arc4.Bool(false),
      methods: new arc4.DynamicArray(
        new MethodInfo({
          selector: new arc4.StaticBytes<4>(methodSelector('test()void')),
          cooldown: new arc4.UintN64(1),
          lastCalled: new arc4.UintN64(1),
        }),
      ),
    })
  }
}

export class PluginInfo extends arc4.Struct<{
  /** The last round at which this plugin can be called */
  lastValidRound: arc4.UintN64
  /** The number of rounds that must pass before the plugin can be called again */
  cooldown: arc4.UintN64
  /** The last round the plugin was called */
  lastCalled: arc4.UintN64
  /** Whether the plugin has permissions to change the admin account */
  adminPrivileges: arc4.Bool
  /** The methods that are allowed to be called for the plugin by the address */
  methods: arc4.DynamicArray<MethodInfo>
}> {}

export class MethodInfo extends arc4.Struct<{
  /** The method signature */
  selector: arc4.StaticBytes<4>
  /** The number of rounds that must pass before the method can be called again */
  cooldown: arc4.UintN64
  /** The last round the method was called */
  lastCalled: arc4.UintN64
}> {}



================================================
FILE: tests/approvals/arc4-types.algo.ts
================================================
import type { biguint, bytes, uint64 } from '@algorandfoundation/algorand-typescript'
import { arc4, assert, assertMatch, BaseContract, BigUint, Bytes, ensureBudget, Txn } from '@algorandfoundation/algorand-typescript'
import {
  Address,
  Bool,
  Byte,
  DynamicArray,
  DynamicBytes,
  encodeArc4,
  interpretAsArc4,
  StaticArray,
  StaticBytes,
  Str,
  Tuple,
  UFixedNxM,
  UintN,
  UintN128,
  UintN32,
  UintN64,
  UintN8,
} from '@algorandfoundation/algorand-typescript/arc4'
import { bzero } from '@algorandfoundation/algorand-typescript/op'

function testUFixed() {
  const a = new UFixedNxM<32, 4>('1.244')
  const c = new UFixedNxM<32, 4>('1.244')

  assert(a === c)
}

function testUintN(n: uint64, b: biguint, c: UintN<256>) {
  const x = new UintN<8>(4)
  assert(x.bytes.length === 1)
  const x2 = new UintN<8>(255n)
  assert(x2.bytes === Bytes.fromHex('ff'))

  const y = new UintN<16>()
  assert(y.bytes.length === 2)
  const z = new UintN<8>(n)
  const z_native = z.native
  assert(z_native === n)
  const big128 = new UintN128(2n ** 100n)

  const a = new UintN<128>(b)
  const a_native = a.native
  assert(a_native === b)

  assert(c.bytes.length === 256 / 8)

  const a_bytes = a.bytes
  const a_from_bytes = interpretAsArc4<UintN<128>>(a_bytes)

  assert(a_from_bytes === a)

  const aliased64 = new UintN64(12)

  assert(aliased64.native === 12)
  const aliased32 = new UintN32(50545)
  assert(BigUint(aliased32.bytes) === 50545n)

  const byte = new Byte(255)

  assert(byte.bytes.bitwiseInvert() === Bytes.fromHex('00'))
}

function testStr() {
  const s1 = new Str()
  assert(s1.bytes === new UintN<16>(0).bytes, 'Empty string should equal the uint16 length prefix')
  const s2 = new Str('Hello')
  assert(s2.native === 'Hello')

  const s2_bytes = s2.bytes

  const s2_from_bytes = interpretAsArc4<Str>(s2_bytes)

  assert(s2 === s2_from_bytes)
}

function testDynamicBytes(someBytes: bytes) {
  const db1 = new DynamicBytes()
  assert(db1.native === Bytes(), 'No args should give empty bytes')
  assert(db1.bytes === new UintN<16>(0).bytes, 'bytes prop should return length header (of 0)')
  const db2 = new DynamicBytes(someBytes)
  assert(db2.native === someBytes)

  const db3 = new DynamicBytes('hello')
  assert(db3.native === Bytes('hello'))

  const db4 = db3.concat(new DynamicBytes(' world'))
  assert(db4.native === Bytes('hello world'))
}

function testStaticBytes() {
  const s1 = new StaticBytes()
  const s2 = new StaticBytes<4>()
  const s3 = new StaticBytes<5>(Bytes.fromHex('AABBCCDDEE'))

  const s5 = new StaticArray<StaticBytes<5>, 1>(new StaticBytes<5>(Bytes.fromHex('AABBCCDDEE')))
  assert(s5[0].native === Bytes.fromHex('AABBCCDDEE'))

  const s4 = s2.concat(s3)
  assert(s4.native === Bytes.fromHex('00000000AABBCCDDEE'))
}

type ARC4Uint64 = UintN<64>
const ARC4Uint64 = UintN<64>

function testArrays(n: ARC4Uint64) {
  const myArray = new DynamicArray(n, n, n)

  myArray.push(n)

  const doubleArray = myArray.concat(myArray)

  assert(doubleArray === new DynamicArray(n, n, n, n, n, n, n, n))

  const myStatic = new StaticArray(n, n)

  assert(myStatic[0] === myArray.pop())

  myStatic[1] = new UintN<64>(50)

  const myStatic2 = new StaticArray<ARC4Uint64, 3>(n, n, n)

  const staticNative = myStatic2.native
  assertMatch(staticNative, [n, n, n])

  const dynamicNative = doubleArray.native
  assertMatch(dynamicNative, [n, n, n, n, n, n, n, n])
}

function testByte() {
  const b = new Byte()
  const b2 = new Byte(0)
  assert(b === b2)
}

function testAddress() {
  const a = new Address()
  const b = new Address(Txn.sender)

  assert(b.native === Txn.sender)

  assert(a !== b, 'Zero address should not match sender')
  assert(a === new Address(), 'Two zero addresses should match')
  assert(a[0] === new Byte(), 'Zero address should start with zero byte')
}

function testTuple() {
  const t = new Tuple(new ARC4Uint64(34))
  const firstItem = t.at(0)
  const firstItemIndexer = t.native[0]
  assert(firstItem === firstItemIndexer)
  const t1 = new Tuple(new Address(), new Byte())
  assert(t1.length === 2)
}

export class Arc4TypesTestContract extends BaseContract {
  public getArc4Values(): [Byte, UintN<8>, Address] {
    return [new Byte(), new UintN(255), new Address()]
  }

  public approvalProgram(): boolean {
    ensureBudget(1400)
    const x = new ARC4Uint64()
    testStr()
    testUintN(1, 2n, new UintN<256>(4))
    testUFixed()
    testByte()
    testArrays(new UintN<64>(65))
    testAddress()
    testTuple()
    testUFixed()
    testDynamicBytes(Bytes('hmmmmmmmmm'))
    testStaticBytes()
    testZeroValues()
    const result = new arc4.DynamicArray<arc4.UintN<64>>()
    assert(result.length === 0)
    return true
  }
}

function testZeroValues() {
  assert(new StaticArray<UintN8, 4>().bytes === new StaticArray(new UintN8(0), new UintN8(0), new UintN8(0), new UintN8(0)).bytes)
  assert(new StaticArray<Bool, 4>().bytes === new StaticArray(new Bool(false), new Bool(false), new Bool(false), new Bool(false)).bytes)
  assert(
    new StaticArray<Bool, 9>().bytes ===
      new StaticArray(
        new Bool(false),
        new Bool(false),
        new Bool(false),
        new Bool(false),
        new Bool(false),
        new Bool(false),
        new Bool(false),
        new Bool(false),
        new Bool(false),
      ).bytes,
  )
  assert(new DynamicArray<UintN8>().bytes === bzero(2))
  assert(
    new Tuple<[Bool, Bool, Bool, Bool, Bool, Bool, Bool, Bool, Bool]>().bytes ===
      encodeArc4([false, false, false, false, false, false, false, false, false]),
  )
  assert(new Str().bytes === bzero(2))
  assert(new DynamicBytes().bytes === bzero(2))
  assert(new StaticBytes<5>().bytes === bzero(5))
  assert(new Address().bytes === bzero(32))
  assert(new UFixedNxM<32, 4>().bytes === bzero(32 / 8))
  assert(new Bool().bytes === bzero(1))
  assert(new UintN32().bytes === bzero(32 / 8))
}



================================================
FILE: tests/approvals/array-destructuring.algo.ts
================================================
import type { biguint, bytes, uint64 } from '@algorandfoundation/algorand-typescript'
import { assert, assertMatch, Bytes, Contract, Uint64 } from '@algorandfoundation/algorand-typescript'

export class ArrayDestructuringAlgo extends Contract {
  testNested(arg: [uint64, [biguint, biguint]]) {
    const [a, b] = arg
    const [c, [d]] = arg
    return [a, b, c, d] as const
  }

  test() {
    const [a, b, c, d] = this.produceItems()
    const [, , e] = this.produceItems()

    let g: uint64, i: biguint
    const f = ([g, , , i] = this.produceItems())

    assert(a === 5)
    assert(b === Bytes())
    assert(!c)
    assert(d === 6n)
    assert(!e)
    assert(g === 5)
    assert(i === 6n)
    assertMatch(f, [5, Bytes(), false, 6n])
  }

  private produceItems(): [uint64, bytes, boolean, biguint] {
    return [5, Bytes(), false, 6n]
  }

  testLiteralDestructuring() {
    let a = Uint64(1)
    let b = Uint64(2)

    const [x, y] = ([b, a] = [a, b])

    assert(x === b)
    assert(y === a)
  }
}



================================================
FILE: tests/approvals/array-literals.algo.ts
================================================
import type { uint64 } from '@algorandfoundation/algorand-typescript'

function test(a: uint64, b: uint64) {
  const inferTuple = [a, b] as const
  const explicitTuple: [uint64, uint64] = [a, b]

  const conditionalExplicitTuple: [uint64, uint64] = a < b ? [a, b] : [b, a]

  const [c, d] = [a, b]

  //const [...f] = [a, b] as const
  const [, g] = [a, b] as const
  const [h] = [a, b] as const
}



================================================
FILE: tests/approvals/assert-match.algo.ts
================================================
import type { gtxn } from '@algorandfoundation/algorand-typescript'
import { assertMatch, Contract, Global, Txn } from '@algorandfoundation/algorand-typescript'

export class AssertMatchContract extends Contract {
  public testPay(pay: gtxn.PaymentTxn): boolean {
    assertMatch(Txn, {
      fee: { greaterThan: 0 },
    })

    assertMatch(pay, {
      amount: { between: [100_000, 105_000] },
      sender: Txn.sender,
      receiver: Global.currentApplicationAddress,
      closeRemainderTo: Global.zeroAddress,
      firstValid: { greaterThan: 1 },
      lastValid: { lessThan: 2 ** 40 },
    })
    return true
  }
}



================================================
FILE: tests/approvals/asset-proxy.algo.ts
================================================
import type { Asset } from '@algorandfoundation/algorand-typescript'
import { Contract, log, Txn } from '@algorandfoundation/algorand-typescript'

export class AssetProxyAlgo extends Contract {
  testAsset(asset: Asset): void {
    log(asset.id)
    log(asset.total)
    log(asset.decimals)
    log(asset.defaultFrozen)
    log(asset.unitName)
    log(asset.name)
    log(asset.url)
    log(asset.metadataHash)
    log(asset.manager)
    log(asset.reserve)
    log(asset.freeze)
    log(asset.clawback)
    log(asset.creator)

    log(asset.balance(Txn.sender))
    log(asset.frozen(Txn.sender))
  }
}



================================================
FILE: tests/approvals/avm11.algo.ts
================================================
import type { uint64 } from '@algorandfoundation/algorand-typescript'
import {
  assert,
  Bytes,
  Contract,
  contract,
  Global,
  logicsig,
  LogicSig,
  MimcConfigurations,
  op,
  Txn,
} from '@algorandfoundation/algorand-typescript'

@logicsig({ name: 'AVM11SIG', avmVersion: 11 })
export class Avm11Sig extends LogicSig {
  program(): uint64 {
    const a = Bytes.fromHex('00000000000000000000000000000000000000000000000000000000499602d2')
    return op.mimc(MimcConfigurations.BN254Mp110, a).length
  }
}

@contract({ name: 'AVM11Contract', avmVersion: 11 })
export class Avm11Contract extends Contract {
  testNewOps() {
    // Ops
    const x = Bytes.fromHex('00000000000000000000000000000000000000000000000000000000499602d2')
    assert(op.mimc(MimcConfigurations.BLS12_381Mp111, x))
    assert(op.onlineStake())

    // AcctParams
    const [a, b] = op.AcctParams.acctIncentiveEligible(Txn.sender)
    const [c, d] = op.AcctParams.acctLastProposed(Txn.sender)
    const [e, f] = op.AcctParams.acctLastProposed(Txn.sender)

    // Block
    assert(op.Block.blkProposer(0) !== Global.zeroAddress, 'proposer')
    assert(op.Block.blkFeesCollected(0), 'fees collected')
    assert(op.Block.blkBonus(0), 'bonus')
    assert(op.Block.blkBranch(0), 'branch')
    assert(op.Block.blkFeeSink(0) !== Global.zeroAddress, 'fee sink')
    assert(op.Block.blkProtocol(0), 'protocol')
    assert(op.Block.blkTxnCounter(0), 'txn counter')
    assert(op.Block.blkProposerPayout(0), 'proposer payout')

    // Global
    assert(op.Global.payoutsEnabled, 'payouts_enabled')
    assert(op.Global.payoutsGoOnlineFee, 'payouts_go_online_fee')
    assert(op.Global.payoutsPercent, 'payouts_percent')
    assert(op.Global.payoutsMinBalance, 'payouts_min_balance')
    assert(op.Global.payoutsMaxBalance, 'payouts_max_balance')
    // Voter params
    const [g, h] = op.VoterParams.voterBalance(0)
    const [i, j] = op.VoterParams.voterIncentiveEligible(0)
  }
}



================================================
FILE: tests/approvals/biguint-expressions.algo.ts
================================================
import type { biguint, bytes, uint64 } from '@algorandfoundation/algorand-typescript'
import { assert, BaseContract, BigUint, Bytes, op } from '@algorandfoundation/algorand-typescript'
import { itob } from '@algorandfoundation/algorand-typescript/op'

function testConstructor(a: uint64, a_b: biguint, b: boolean, b_b: biguint, c: bytes, c_b: biguint) {
  assert(BigUint() === 0n)
  assert(BigUint(true) === 1n)
  assert(BigUint(false) === 0n)
  assert(BigUint(0) === 0n)
  assert(BigUint(1) === 1n)
  assert(BigUint(0n) === 0n)
  assert(BigUint(1n) === 1n)
  assert(BigUint(2n ** 512n - 1n) === 2n ** 512n - 1n)
  assert(BigUint('1231232134123123') === 1231232134123123n)
  assert(BigUint(a) === a_b)
  assert(BigUint(a * a) === a_b * a_b)
  assert(BigUint(b) === b_b)
  assert(BigUint(c) === c_b)
}

function testOps(smaller: biguint, larger: biguint) {
  assert(smaller < larger)
  assert(smaller <= smaller)
  assert(larger > smaller)
  assert(larger >= larger)
  assert(smaller === BigUint(smaller))
  assert(smaller === BigUint(op.bzero(4).concat(Bytes(smaller))), 'Leading zeros should be ignored in equality')
}

class DemoContract extends BaseContract {
  public approvalProgram() {
    testConstructor(12312312, 12312312n, false, 0n, itob(4), 4n)
    testOps(500n, 1000n)
    return true
  }
}



================================================
FILE: tests/approvals/boolean-conversions.algo.ts
================================================
import { assert, BaseContract, BigUint, Bytes, Uint64 } from '@algorandfoundation/algorand-typescript'

function test_truthyness() {
  assert(!0, 'Zero is falsy')
  assert(1, 'Non zero is truthy')
  assert(!Uint64(0), 'Zero is falsy')
  assert(Uint64(1), 'Non zero is truthy')
  assert(!BigUint(0), 'Zero is falsy')
  assert(BigUint(1), 'Non zero is truthy')
  assert(!Bytes(), 'Empty is falsy')
  assert(Bytes('abc'), 'Non empty is truthy')
  const empty = ''
  assert(!empty, 'Empty is falsy')
  assert('abc', 'Non empty is truthy')
  assert(!false, 'False is falsy')
  assert(true, 'True is truthy')
}

function test_booleans_are_equal() {
  // eslint-disable-next-line no-constant-binary-expression
  assert(Boolean(1) === Boolean(5))
  assert(Boolean(Uint64(1)) === Boolean(Uint64(5)))
  assert(Boolean(BigUint(1)) === Boolean(BigUint(5)))
  assert(Boolean(Bytes('abc')) === Boolean(Bytes('abcdef')))
  // eslint-disable-next-line no-constant-binary-expression
  assert(Boolean('abc') === Boolean('abcdef'))

  const boolNoArgs = Boolean()
  assert(!boolNoArgs)
}

export class BooleanConversionsAlgo extends BaseContract {
  approvalProgram(): boolean {
    test_truthyness()
    test_booleans_are_equal()
    return true
  }
}



================================================
FILE: tests/approvals/boolean-expressions.algo.ts
================================================
import type { bytes, uint64 } from '@algorandfoundation/algorand-typescript'
import { assert } from '@algorandfoundation/algorand-typescript'

function test(a: uint64, b: uint64, c: string, d: bytes, e: uint64) {
  const x = a || b || e
  assert(a && b && e, 'a or b')
  const y = a && b
  const z = (a && d) || y ? x || y : x && y
  if (a || (c && d)) {
    return true
  }

  let f: uint64 = 0
  if ((f = a || b)) {
    return true
  }
  return false
}



================================================
FILE: tests/approvals/box-enum-contract.algo.ts
================================================
import { arc4, assert, Box, Bytes, OnCompleteAction, op, TransactionType } from '@algorandfoundation/algorand-typescript'
import { Tuple, UintN64 } from '@algorandfoundation/algorand-typescript/arc4'

export class BoxContract extends arc4.Contract {
  oca = Box<OnCompleteAction>({ key: Bytes('oca') })
  txn = Box<TransactionType>({ key: Bytes('txn') })

  @arc4.abimethod({ name: 'store_enums' })
  public storeEnums(): void {
    this.oca.value = OnCompleteAction.OptIn
    this.txn.value = TransactionType.ApplicationCall
  }

  @arc4.abimethod({ name: 'read_enums' })
  public readEnums(): Tuple<[UintN64, UintN64]> {
    assert(op.Box.get(Bytes('oca'))[0] === op.itob(this.oca.value))
    assert(op.Box.get(Bytes('txn'))[0] === op.itob(this.txn.value))

    return new Tuple(new UintN64(this.oca.value), new UintN64(this.txn.value))
  }
}



================================================
FILE: tests/approvals/box-proxies.algo.ts
================================================
import type { Account, bytes, uint64 } from '@algorandfoundation/algorand-typescript'
import { assert, BaseContract, Box, BoxMap, BoxRef, Bytes, Contract, Txn } from '@algorandfoundation/algorand-typescript'
import type { Bool, DynamicArray, StaticArray, Tuple, UintN32, UintN8 } from '@algorandfoundation/algorand-typescript/arc4'
import { itob } from '@algorandfoundation/algorand-typescript/op'

const boxA = Box<string>({ key: Bytes('A') })
function testBox(box: Box<string>, value: string) {
  box.value = value
  boxA.value = value

  assert(box.key === Bytes('one'))
  assert(boxA.key === Bytes('A'))

  assert(box.value === boxA.value)

  assert(box.exists && boxA.exists)

  assert(box.length)

  assert(box.delete(), 'delete failed')
  const isBoxADeleted = boxA.delete()
  assert(isBoxADeleted, 'delete failed')
  assert(!box.exists && !boxA.exists)

  const defaultVal = 'O'
  assert(boxA.get({ default: defaultVal }) === box.get({ default: defaultVal }))

  let [, e] = box.maybe()
  assert(!e)
  box.value = value
  ;[, e] = box.maybe()
  assert(e)
}

const boxMap = BoxMap<string, bytes>({ keyPrefix: '' })

function testBoxMap(box: BoxMap<string, bytes>, key: string, value: bytes) {
  box(key).value = value
  boxMap(key).value = value

  const boxMapItem = boxMap(key)

  assert(boxMapItem.exists)

  assert(box.keyPrefix === Bytes('two'))
  assert(boxMap.keyPrefix === Bytes(''))

  assert(box(key).length)

  assert(box(key).maybe()[1])

  assert(box(key).value === boxMap(key).value)

  const isBoxDeleted = box(key).delete()
  assert(isBoxDeleted, 'delete failed')

  assert(box(`${key}x`).get({ default: Bytes('b') }) === boxMap(`${key}x`).get({ default: Bytes('b') }))
}

const boxRef = BoxRef({ key: 'abc' })

function testBoxRef(box: BoxRef, length: uint64) {
  assert(box.key === Bytes('three'))
  assert(boxRef.key === Bytes('abc'))

  if (!boxRef.exists) {
    boxRef.create({ size: 1000 })
  } else if (boxRef.length !== length) {
    boxRef.resize(length)
  }
  if (box.exists) {
    box.resize(4)
  } else {
    box.create({ size: 4 })
  }
  const someBytes = Bytes.fromHex('FFFFFFFF')
  box.put(someBytes)

  assert(box.get({ default: Bytes() }) === Bytes.fromHex('FFFFFFFF'))

  const maybeBox = box.maybe()
  assert(maybeBox[1])

  assert(box.value === Bytes.fromHex('FFFFFFFF'))
  box.splice(1, 1, Bytes.fromHex('00'))
  assert(box.value === Bytes.fromHex('FF00FFFF'))

  const x = box.delete()
  assert(x, 'delete failed')
  assert(!box.exists)
}

export class BoxContract extends BaseContract {
  boxOne = Box<string>({ key: 'one' })
  boxMapTwo = BoxMap<string, bytes>({ keyPrefix: 'two' })
  boxRefThree = BoxRef({ key: 'three' })

  approvalProgram(): boolean {
    if (Txn.applicationId.id !== 0) {
      testBox(this.boxOne, 'aaaaaargh')

      testBoxMap(this.boxMapTwo, 'what?', itob(256456))

      testBoxRef(this.boxRefThree, 99)
    }
    return true
  }
}

class BoxNotExist extends BaseContract {
  approvalProgram(): boolean {
    if (Txn.applicationId.id !== 0) {
      switch (Txn.applicationArgs(0).toString()) {
        case 'box':
          return Box<boolean>({ key: 'abc' }).value
        case 'boxmap':
          return BoxMap<string, boolean>({ keyPrefix: 'a' })('bc').value
        case 'createbox':
          Box<boolean>({ key: 'abc' }).value = true
          return true
      }
    }
    return true
  }
}

class BoxCreate extends Contract {
  boxBool = Box<boolean>({ key: 'bool' })
  boxArc4Bool = Box<Bool>({ key: 'arc4b' })
  boxStr = Box<string>({ key: 'a' })
  boxUint = Box<uint64>({ key: 'b' })
  boxStaticArray = Box<StaticArray<UintN32, 10>>({ key: 'c' })
  boxDynamicArray = Box<DynamicArray<UintN8>>({ key: 'd' })
  boxTuple = Box<Tuple<[UintN8, UintN8, Bool, Bool]>>({ key: 'e' })

  createBoxes() {
    this.boxStr.create({ size: 10 })
    assert(this.boxStr.length === 10)
    this.boxUint.create()
    assert(this.boxUint.length === 8)
    this.boxStaticArray.create()
    assert(this.boxStaticArray.length === (32 / 8) * 10)
    this.boxDynamicArray.create({ size: 2 })
    assert(this.boxDynamicArray.length === 2)
    this.boxTuple.create()
    assert(this.boxTuple.length === 3)
    this.boxBool.create()
    assert(this.boxBool.length === 8)
    this.boxArc4Bool.create()
    assert(this.boxArc4Bool.length === 1)
  }
}

class BoxMapTest extends Contract {
  bmap = BoxMap<Account, string>({ keyPrefix: '' })
}



================================================
FILE: tests/approvals/byte-expressions.algo.ts
================================================
import type { biguint, uint64 } from '@algorandfoundation/algorand-typescript'
import { assert, BigUint, Bytes, Contract, op, Uint64 } from '@algorandfoundation/algorand-typescript'

function test(a: uint64, b: biguint, c: string) {
  assert(Bytes().length === 0, 'Empty bytes has length of 0')
  assert(Bytes(a) === op.itob(a), 'Bytes(uint64) is equivalent to itob')
  assert(Bytes(Uint64(1)) === Bytes.fromHex('0000000000000001'), 'Bytes(uint64) returns an 8 byte encoding')
  assert(Bytes(BigUint(256)) === Bytes.fromHex('0100'))
  assert(BigUint(Bytes(b)) === b, 'Round trip of biguint to bytes and back results in the same value')
  assert(String(Bytes(c)) === c)
  assert(Bytes(Bytes('123')) === Bytes('123'))
  assert(Bytes([1, 2, 3, 4]) === Bytes.fromHex('01020304'))
}

class DemoContract extends Contract {
  public test() {
    test(1, 50n, 'things')
    return true
  }
}



================================================
FILE: tests/approvals/call-expressions.algo.ts
================================================
import type { uint64 } from '@algorandfoundation/algorand-typescript'
import { BaseContract } from '@algorandfoundation/algorand-typescript'

abstract class ExampleBase extends BaseContract {
  protected baseMethod(): uint64 {
    return 2
  }
}

export default class Example extends ExampleBase {
  public approvalProgram(): boolean {
    return this.localMethod() + super.baseMethod() === freeMethod() - this.baseMethod()
  }
  protected baseMethod(): uint64 {
    return 1
  }
  private localMethod(): uint64 {
    return 5
  }
}

function freeMethod(): uint64 {
  return 7
}



================================================
FILE: tests/approvals/casting.algo.ts
================================================
import type { uint64 } from '@algorandfoundation/algorand-typescript'
import { BaseContract } from '@algorandfoundation/algorand-typescript'

export class CastingAlgo extends BaseContract {
  approvalProgram(): boolean {
    const x = 123 as uint64

    const y = [1, 2, 3] as [uint64, uint64, uint64]

    const z = [1 as uint64, 2 as uint64, 3 as uint64] as const

    return x > y[0] * y[1] * y[2] * z[0] * z[1] * z[2]
  }
}



================================================
FILE: tests/approvals/conditional-expression.algo.ts
================================================
import type { uint64 } from '@algorandfoundation/algorand-typescript'
import { Uint64 } from '@algorandfoundation/algorand-typescript'

function test(x: uint64, y: uint64) {
  const a: uint64 = (x < 4 ? x : y) + x
  const b: uint64 = y % 2 ? 2 : 1
  const c: uint64 = x > y ? (y > 10 ? 3 : y) : x
  const d: uint64 = Uint64(y % 2 ? 2 : 1) + (x < 4 ? x : y)
  const e: uint64 = x || 4
  const f: boolean = Uint64(y % 2 ? 2 : 1) === (x < 4 ? x : y)

  return true
}



================================================
FILE: tests/approvals/destructured-params.algo.ts
================================================
import type { bytes, uint64 } from '@algorandfoundation/algorand-typescript'
import { Bytes, Contract, log, Uint64 } from '@algorandfoundation/algorand-typescript'

export class DestructuredParamsAlgo extends Contract {
  test({ a, b, c }: { a: uint64; b: bytes; c: boolean }): void {
    log(a, b, c)
  }

  init() {
    this.test({ a: 456, b: Bytes(''), c: false })
    const temp = { a: Uint64(2), b: Bytes('Hello'), c: true }
    this.test(temp)
  }
}



================================================
FILE: tests/approvals/destructuring-iterators.algo.ts
================================================
import type { uint64 } from '@algorandfoundation/algorand-typescript'
import { assert, Uint64 } from '@algorandfoundation/algorand-typescript'

function test() {
  const items = [
    { a: Uint64(1), b: Uint64(2) },
    { a: Uint64(2), b: Uint64(2) },
    { a: Uint64(3), b: Uint64(2) },
  ] as const
  let total: uint64 = 0
  for (const { a } of items) {
    total += a
  }
  assert(total === 6)
}



================================================
FILE: tests/approvals/do-loops.algo.ts
================================================
import type { uint64 } from '@algorandfoundation/algorand-typescript'
import { Contract, Uint64 } from '@algorandfoundation/algorand-typescript'

export class DoLoopsAlgo extends Contract {
  testDo(stop: uint64) {
    let i = Uint64(0)
    do {
      i += 1
    } while (i < stop)
    return i
  }
  testDoBreak(stop: uint64, breakMod: uint64) {
    let total = Uint64(0)
    let i = Uint64(0)
    do {
      if (i > 0 && i % breakMod === 0) break

      i += 1
      total += i
    } while (i < stop)
    return total
  }
  testDoContinue(stop: uint64, mod: uint64) {
    let i = Uint64(0)
    let total = Uint64(0)
    do {
      if (i > 0 && i % mod === 0) {
        total += 2
        i += 1
        continue
      }
      total += 1
      i += 1
    } while (i < stop)
    return total
  }
}



================================================
FILE: tests/approvals/ensure-budget.algo.ts
================================================
import { BaseContract, ensureBudget, OpUpFeeSource } from '@algorandfoundation/algorand-typescript'

export class EnsureBudgetContract extends BaseContract {
  public approvalProgram(): boolean {
    ensureBudget(100)
    ensureBudget(100, OpUpFeeSource.GroupCredit)
    ensureBudget(100, OpUpFeeSource.AppAccount)
    ensureBudget(100, OpUpFeeSource.Any)

    return true
  }
}



================================================
FILE: tests/approvals/extract-bytes.algo.ts
================================================
import type { uint64 } from '@algorandfoundation/algorand-typescript'
import { assert, BaseContract, Bytes } from '@algorandfoundation/algorand-typescript'
import { extract } from '@algorandfoundation/algorand-typescript/op'

export class ExtractBytesAlgo extends BaseContract {
  approvalProgram(): boolean {
    this.test(2, 0)
    return true
  }

  private test(two: uint64, zero: uint64) {
    assert(two === 2, 'Param two should be 2')
    assert(zero === 0, 'Param zero should be 0')
    const b = Bytes('abcdefg')
    assert(extract(b, 2) === Bytes('cdefg'))
    assert(extract(b, two) === Bytes('cdefg'))

    assert(extract(b, 2, 2) === Bytes('cd'))
    assert(extract(b, two, two) === Bytes('cd'))

    assert(extract(b, two, zero) === Bytes(''))
  }
}



================================================
FILE: tests/approvals/for-loops.algo.ts
================================================
import type { uint64 } from '@algorandfoundation/algorand-typescript'
import { Contract, Uint64 } from '@algorandfoundation/algorand-typescript'

class ForLoopsAlgo extends Contract {
  test_for_loop(start: uint64, stop: uint64, step: uint64) {
    let total = Uint64(0)
    for (let i = start; i < stop; i += step) {
      total += i
    }
    return total
  }

  test_for_loop_break(start: uint64, stop: uint64, step: uint64) {
    let total = Uint64(0)
    for (let i = start; i < stop; i += step) {
      total += i
      if (total > 10) {
        break
      }
    }
    return total
  }

  test_for_loop_continue(start: uint64, stop: uint64, step: uint64) {
    let total = Uint64(0)
    for (let i = start; i < stop; i += step) {
      if (i % 5 === 0) continue
      total += i
    }
    return total
  }
  test_for_loop_labelled(start: uint64, stop: uint64, step: uint64) {
    let total = Uint64(0)
    outer: for (let i = start; i < stop; i += step) {
      for (let j = start; j < stop; j += step) {
        total += i + j

        if (i * j > stop) break outer
      }
    }
    return total
  }
}



================================================
FILE: tests/approvals/for-of-loops.algo.ts
================================================
import type { uint64 } from '@algorandfoundation/algorand-typescript'
import { Contract, MutableArray } from '@algorandfoundation/algorand-typescript'
import type { DynamicArray, StaticArray, UintN64 } from '@algorandfoundation/algorand-typescript/arc4'

const stopNumber: uint64 = 42

export class ForOfLoopsAlgo extends Contract {
  test_for_of_loop_tuple(items: readonly [uint64, uint64, uint64]) {
    let total: uint64 = 0
    for (const item of items) {
      total += item
      if (item === stopNumber) break
    }
    return total
  }

  test_for_of_loop_arc4_dynamic_array(items: DynamicArray<UintN64>) {
    let total: uint64 = 0
    for (const item of items) {
      total += item.native
      if (item.native === stopNumber) break
    }
    return total
  }

  test_for_of_loop_arc4_static_array(items: StaticArray<UintN64, 5>) {
    let total: uint64 = 0
    for (const item of items) {
      total += item.native
      if (item.native === stopNumber) break
    }
    return total
  }

  test_for_of_loop_native_immutable_array(items: Array<uint64>) {
    let total: uint64 = 0
    for (const item of items) {
      total += item
      if (item === stopNumber) break
    }
    return total
  }

  test_for_of_loop_native_mutable_array(items: [uint64, uint64, uint64]) {
    const mutable = new MutableArray(...items)
    let total: uint64 = 0
    for (const item of mutable) {
      total += item
      if (item === stopNumber) break
    }
    return total
  }
}



================================================
FILE: tests/approvals/global-state.algo.ts
================================================
import type { bytes, uint64 } from '@algorandfoundation/algorand-typescript'
import { assert, BaseContract, Bytes, contract, Contract, GlobalState, op, Txn, Uint64 } from '@algorandfoundation/algorand-typescript'

export abstract class BaseTestContract extends BaseContract {
  baseTestState = GlobalState({ initialValue: 'testing 123' })
}

export class TestContract extends BaseTestContract {
  noInitial = GlobalState<bytes>()
  noInitialInt = GlobalState<uint64>()
  testState = GlobalState({ initialValue: Uint64(2) })
  testState2 = GlobalState({ initialValue: Uint64(5), key: Bytes('TESTSTATE') })

  constructor() {
    const someValue: uint64 = 2 ** 56
    super()
    assert(this.baseTestState.value === 'testing 123', 'Base class state should be initialized after super call')
    this.noInitialInt.value = someValue * this.testState.value
  }

  public approvalProgram(): boolean {
    assert(this.testState.hasValue, 'State should have value')
    assert(this.testState.value === 2, 'Value should equal 2')

    this.testState.value = op.btoi(Txn.applicationArgs(0))

    this.noInitial.value = Bytes('abc')

    return true
  }
}

@contract({ stateTotals: { globalUints: 5 } })
export class TestArc4 extends Contract {
  setState(key: string, value: uint64) {
    const proxy = GlobalState<uint64>({ key })

    proxy.value = value
  }

  deleteState(key: string) {
    GlobalState<uint64>({ key }).delete()
  }
}



================================================
FILE: tests/approvals/gtxns.algo.ts
================================================
import {
  assert,
  Bytes,
  Contract,
  Global,
  gtxn,
  log,
  OnCompleteAction,
  TransactionType,
  Txn,
  urange,
} from '@algorandfoundation/algorand-typescript'
import { methodSelector } from '@algorandfoundation/algorand-typescript/arc4'

export class GtxnsAlgo extends Contract {
  test() {
    assert(gtxn.PaymentTxn(0).amount > 0)
  }

  test2() {
    for (const i of urange(Global.groupSize)) {
      const txn = gtxn.Transaction(i)
      switch (txn.type) {
        case TransactionType.ApplicationCall:
          log(txn.appId.id)
          break
        case TransactionType.AssetTransfer:
          log(txn.xferAsset.id)
          break
        case TransactionType.AssetConfig:
          log(txn.configAsset.id)
          break
        case TransactionType.Payment:
          log(txn.receiver)
          break
        case TransactionType.KeyRegistration:
          log(txn.voteKey)
          break
        default:
          log(txn.freezeAsset.id)
          break
      }
    }
  }

  test3() {
    assert(Txn.onCompletion === OnCompleteAction.NoOp, 'OCA must be NoOp')
    assert(Txn.typeEnum === TransactionType.ApplicationCall)
    log('Hello test4')
  }

  test4(other: gtxn.ApplicationCallTxn) {
    assert(other.onCompletion === OnCompleteAction.NoOp, 'Other txn must be NoOp')
    assert(other.type === TransactionType.ApplicationCall)
    assert(other.lastLog === Bytes('Hello test4'))
    assert(other.appArgs(0) === methodSelector(GtxnsAlgo.prototype.test3))
    assert(other.appId === Global.currentApplicationId)
  }
}



================================================
FILE: tests/approvals/implicit-create.algo.ts
================================================
import { abimethod, Contract } from '@algorandfoundation/algorand-typescript'
import { baremethod } from '@algorandfoundation/algorand-typescript/arc4'

export class NoBare extends Contract {
  @abimethod({ allowActions: 'NoOp' })
  public handleNoop() {}
}
export class NoNoOp extends Contract {
  @baremethod({ allowActions: 'UpdateApplication' })
  public handleUpdate() {}
}

class BaseWithBareCreate extends Contract {
  @baremethod({ onCreate: 'require' })
  public create() {}
}
class BaseWithAbiCreate extends Contract {
  @abimethod({ onCreate: 'require' })
  public create() {}
}
export class ExplicitBareCreateFromBase extends BaseWithBareCreate {}

export class ExplicitAbiCreateFromBase extends BaseWithAbiCreate {}



================================================
FILE: tests/approvals/inheritance-a.algo.ts
================================================
import type { uint64 } from '@algorandfoundation/algorand-typescript'
import { BaseContract, Contract, GlobalState } from '@algorandfoundation/algorand-typescript'

export abstract class SimpleContract extends BaseContract {
  someState = GlobalState<uint64>()
  public simpleMethod(a: uint64, b: uint64): uint64 {
    return a * b
  }
}

export abstract class Arc4Contract extends Contract {
  someState = GlobalState<uint64>()
  private simpleMethod(a: uint64, b: uint64): uint64 {
    return a * b
  }

  public simpleAbiMethod(a: uint64, b: uint64): uint64 {
    return a + b
  }
}

export const VERY_IMPORTANT_VALUE = '42'



================================================
FILE: tests/approvals/inheritance-b.algo.ts
================================================
import type { uint64 } from '@algorandfoundation/algorand-typescript'
import { GlobalState, log, op, Txn } from '@algorandfoundation/algorand-typescript'
import { Arc4Contract, SimpleContract, VERY_IMPORTANT_VALUE } from './inheritance-a.algo'

const OTHER_IMPORTANT_VALUE = 'hello'

export class ConcreteSimpleContract extends SimpleContract {
  public approvalProgram(): uint64 {
    const a = op.btoi(Txn.applicationArgs(0))
    const b = op.btoi(Txn.applicationArgs(1))
    log(this.simpleMethod(a, b))
    return 1
  }
}

export class ConcreteArc4Contract extends Arc4Contract {
  concreteState = GlobalState({ initialValue: 'testing' })
  public getVeryImportantValue() {
    return VERY_IMPORTANT_VALUE + OTHER_IMPORTANT_VALUE
  }
}



================================================
FILE: tests/approvals/intrinsic-calls.algo.ts
================================================
import type { bytes, uint64 } from '@algorandfoundation/algorand-typescript'
import { op } from '@algorandfoundation/algorand-typescript'
import { itob, sha256 } from '@algorandfoundation/algorand-typescript/op'

function test(a: uint64, b: bytes) {
  const x = op.setBit(a, 8, 1)
  const y = op.setBit(b, 12, 9)

  const z = itob(x)
  const g = sha256(z)
}



================================================
FILE: tests/approvals/itxn.algo.ts
================================================
import { assert, Bytes, Contract, Global, GlobalState, itxn, OnCompleteAction, op, Txn } from '@algorandfoundation/algorand-typescript'

const LOG_1ST_ARG_AND_APPROVE = Bytes.fromHex('09361A00B08101')
const APPROVE = Bytes.fromHex('098101')

export class ItxnDemoContract extends Contract {
  name = GlobalState({ initialValue: Bytes() })

  public test1() {
    this.name.value = Bytes('AST1')

    const assetParams = itxn.assetConfig({
      total: 1000,
      assetName: this.name.value,
      unitName: 'unit',
      decimals: 3,
      manager: Global.currentApplicationAddress,
      reserve: Global.currentApplicationAddress,
    })

    this.name.value = Bytes('AST2')
    const asset1_txn = assetParams.submit()
    assetParams.set({
      assetName: this.name.value,
    })
    const asset2_txn = assetParams.submit()

    assert(asset1_txn.assetName === Bytes('AST1'), 'asset1_txn is correct')
    assert(asset2_txn.assetName === Bytes('AST2'), 'asset2_txn is correct')
    assert(asset1_txn.createdAsset.name === Bytes('AST1'), 'created asset 1 is correct')
    assert(asset2_txn.createdAsset.name === Bytes('AST2'), 'created asset 2 is correct')

    const appCreateParams = itxn.applicationCall({
      approvalProgram: APPROVE,
      clearStateProgram: APPROVE,
      fee: 0,
    })

    assetParams.set({
      assetName: 'AST3',
    })

    const [appCreateTxn, asset3_txn] = itxn.submitGroup(appCreateParams, assetParams)

    assert(appCreateTxn.createdApp, 'app is created')
    assert(asset3_txn.assetName === Bytes('AST3'), 'asset3_txn is correct')

    appCreateParams.set({
      note: '3rd',
    })
    assetParams.set({
      note: '3rd',
    })
    itxn.submitGroup(appCreateParams, assetParams)
  }

  public test2() {
    let createAppParams: itxn.ApplicationCallItxnParams
    if (Txn.numAppArgs) {
      const args = [Bytes('1'), Bytes('2')] as const
      createAppParams = itxn.applicationCall({
        approvalProgram: APPROVE,
        clearStateProgram: APPROVE,
        appArgs: args,
        onCompletion: OnCompleteAction.NoOp,
        note: 'with args param set',
      })
    } else {
      createAppParams = itxn.applicationCall({
        approvalProgram: APPROVE,
        clearStateProgram: APPROVE,
        appArgs: [Bytes('3'), '4', Bytes('5')],
        note: 'no args param set',
      })
    }
    const createAppTxn = createAppParams.submit()
    assert(createAppTxn.appArgs(0) === Bytes('1'), 'correct args used 1')
    assert(createAppTxn.appArgs(1) === Bytes('2'), 'correct args used 2')

    if (Txn.numAppArgs > 1) {
      const createAppTxn2 = itxn
        .applicationCall({
          approvalProgram: APPROVE,
          clearStateProgram: APPROVE,
          onCompletion: OnCompleteAction.DeleteApplication,
          appArgs: [Bytes('42')],
        })
        .submit()
      assert(createAppTxn2.appArgs(0) === Bytes('42'), 'correct args used 2')
      assert(createAppTxn.note === Bytes('with args param set'))
    }
  }

  public test3() {
    const appTxn1 = itxn.applicationCall({
      approvalProgram: LOG_1ST_ARG_AND_APPROVE,
      clearStateProgram: APPROVE,
      onCompletion: OnCompleteAction.DeleteApplication,
      appArgs: [Bytes('1')],
    })

    const appTxn2 = appTxn1.copy()
    appTxn2.set({ appArgs: [Bytes('2')] })
    const appTxn3 = appTxn1.copy()
    appTxn3.set({ appArgs: [Bytes('3')] })
    const appTxn4 = appTxn1.copy()
    appTxn4.set({ appArgs: [Bytes('4')] })
    const appTxn5 = appTxn1.copy()
    appTxn5.set({ appArgs: [Bytes('5')] })
    const appTxn6 = appTxn1.copy()
    appTxn6.set({ appArgs: [Bytes('6')] })
    const appTxn7 = appTxn1.copy()
    appTxn7.set({ appArgs: [Bytes('7')] })
    const appTxn8 = appTxn1.copy()
    appTxn8.set({ appArgs: [Bytes('8')] })
    const appTxn9 = appTxn1.copy()
    appTxn9.set({ appArgs: [Bytes('9')] })
    const appTxn10 = appTxn1.copy()
    appTxn10.set({ appArgs: [Bytes('10')] })
    const appTxn11 = appTxn1.copy()
    appTxn11.set({ appArgs: [Bytes('11')] })
    const appTxn12 = appTxn1.copy()
    appTxn12.set({ appArgs: [Bytes('12')] })
    const appTxn13 = appTxn1.copy()
    appTxn13.set({ appArgs: [Bytes('13')] })
    const appTxn14 = appTxn1.copy()
    appTxn14.set({ appArgs: [Bytes('14')] })
    const appTxn15 = appTxn1.copy()
    appTxn15.set({ appArgs: [Bytes('15')] })
    const appTxn16 = appTxn1.copy()
    appTxn16.set({ appArgs: [Bytes('16')] })

    const [app1, app2, app3, app4, app5, app6, app7, app8, app9, app10, app11, app12, app13, app14, app15, app16] = itxn.submitGroup(
      appTxn1,
      appTxn2,
      appTxn3,
      appTxn4,
      appTxn5,
      appTxn6,
      appTxn7,
      appTxn8,
      appTxn9,
      appTxn10,
      appTxn11,
      appTxn12,
      appTxn13,
      appTxn14,
      appTxn15,
      appTxn16,
    )

    assert(app1.logs(0) === Bytes('1'))
    assert(app2.logs(0) === Bytes('2'))
    assert(app3.logs(0) === Bytes('3'))
    assert(app4.logs(0) === Bytes('4'))
    assert(app5.logs(0) === Bytes('5'))
    assert(app6.logs(0) === Bytes('6'))
    assert(app7.logs(0) === Bytes('7'))
    assert(app8.logs(0) === Bytes('8'))
    assert(app9.logs(0) === Bytes('9'))
    assert(app10.logs(0) === Bytes('10'))
    assert(app11.logs(0) === Bytes('11'))
    assert(app12.logs(0) === Bytes('12'))
    assert(app13.logs(0) === Bytes('13'))
    assert(app14.logs(0) === Bytes('14'))
    assert(app15.logs(0) === Bytes('15'))
    assert(app16.logs(0) === Bytes('16'))
  }

  public test4() {
    const lotsOfBytes = op.bzero(2044)
    const approval1 = APPROVE
    const approval2 = Bytes.fromHex('80' + 'FC0f')
      .concat(lotsOfBytes)
      .concat(Bytes.fromHex('48'))

    const appTxn1 = itxn.applicationCall({
      approvalProgram: [approval1, approval2, approval2, approval2],
      clearStateProgram: APPROVE,
      onCompletion: OnCompleteAction.DeleteApplication,
      appArgs: [Bytes('1')],
      extraProgramPages: 3,
    })
    const app1 = appTxn1.submit()
    assert(app1.extraProgramPages === 3, 'extra pages = 3')
    assert(app1.numApprovalProgramPages === 2, 'approval pages = 2')
    assert(app1.approvalProgramPages(0) === approval1.concat(approval2).concat(approval2.slice(0, -3)), 'expected approval page 0')
    assert(app1.approvalProgramPages(1) === approval2.slice(-3).concat(approval2), 'expected approval page 1')
    assert(app1.numClearStateProgramPages === 1, 'clear state pages = 1')
    assert(app1.clearStateProgramPages(0) === APPROVE, 'expected clear state page')
  }
}



================================================
FILE: tests/approvals/jsdoc.algo.ts
================================================
import type { bytes, uint64 } from '@algorandfoundation/algorand-typescript'
import { Contract, GlobalState, LocalState } from '@algorandfoundation/algorand-typescript'
import { Struct, UintN } from '@algorandfoundation/algorand-typescript/arc4'

/**
 * This is the description for demo struct
 */
class DemoStruct extends Struct<{ a: UintN<64> }> {}

/**
 * This is the description for demo type
 */
type DemoType = {
  a: bytes
}

/**
 * This is the description for the contract
 */
export class JSDocDemo extends Contract {
  globalState = GlobalState<string>()
  localState = LocalState<uint64>()

  /**
   * This is the description of the method
   * @param a This is the description of 'a'
   * @param b This is the description of 'b'
   * @returns This is the description of the return value
   */
  test(a: uint64, b: bytes): DemoStruct {
    return new DemoStruct({ a: new UintN<64>(a) })
  }

  /**
   * This is the description of the method
   * @param a This is the description of 'a'
   * @returns This is the description of the return value
   */
  test2(a: bytes): DemoType {
    return {
      a,
    }
  }
}



================================================
FILE: tests/approvals/local-state.algo.ts
================================================
import type { bytes, uint64 } from '@algorandfoundation/algorand-typescript'
import { abimethod, Contract, LocalState, Txn } from '@algorandfoundation/algorand-typescript'
import type { StaticArray, UintN } from '@algorandfoundation/algorand-typescript/arc4'

type SampleArray = StaticArray<UintN<64>, 10>

export class LocalStateDemo extends Contract {
  localUint = LocalState<uint64>({ key: 'l1' })
  localUint2 = LocalState<uint64>()
  localBytes = LocalState<bytes>({ key: 'b1' })
  localBytes2 = LocalState<bytes>()
  localEncoded = LocalState<SampleArray>()

  @abimethod({ allowActions: 'OptIn' })
  optIn() {}

  public setState({ a, b }: { a: uint64; b: bytes }, c: SampleArray) {
    this.localUint(Txn.sender).value = a
    this.localUint2(Txn.sender).value = a
    this.localBytes(Txn.sender).value = b
    this.localBytes2(Txn.sender).value = b
    this.localEncoded(Txn.sender).value = c.copy()
  }

  public getState() {
    return {
      localUint: this.localUint(Txn.sender).value,
      localUint2: this.localUint2(Txn.sender).value,
      localBytes: this.localBytes(Txn.sender).value,
      localBytes2: this.localBytes2(Txn.sender).value,
      localEncoded: this.localEncoded(Txn.sender).value.copy(),
    }
  }

  public clearState() {
    this.localUint(Txn.sender).delete()
    this.localUint2(Txn.sender).delete()
    this.localBytes(Txn.sender).delete()
    this.localBytes2(Txn.sender).delete()
    this.localEncoded(Txn.sender).delete()
  }
}



================================================
FILE: tests/approvals/logic-sig.algo.ts
================================================
import { assert, LogicSig, Txn, Uint64 } from '@algorandfoundation/algorand-typescript'

export class AlwaysAllow extends LogicSig {
  program() {
    return true
  }
}

function feeIsZero() {
  assert(Txn.fee === 0, 'Fee must be zero')
}

export class AllowNoFee extends LogicSig {
  program() {
    feeIsZero()
    return Uint64(1)
  }
}



================================================
FILE: tests/approvals/match-expr.algo.ts
================================================
import type { uint64 } from '@algorandfoundation/algorand-typescript'
import { assert, assertMatch, Contract, match } from '@algorandfoundation/algorand-typescript'

class MatchExprAlgo extends Contract {
  public testMatches(x: uint64) {
    const xObj = { x }
    assertMatch(xObj, { x: 5 }, 'x should be 5')

    assert(match(xObj, { x: { greaterThan: 4 } }))
    assert(match(xObj, { x: { lessThan: 6 } }))
    assert(match(xObj, { x: { greaterThanEq: 5 } }))
    assert(match(xObj, { x: { lessThanEq: 5 } }))

    const xArray = [x]

    assert(match(xArray, [5]))
    assert(match(xArray, [{ greaterThan: 4 }]))
    assert(match(xArray, [{ lessThan: 6 }]))
    assert(match(xArray, [{ greaterThanEq: 5 }]))
    assert(match(xArray, [{ lessThanEq: 5 }]))
  }
}



================================================
FILE: tests/approvals/module-constants.algo.ts
================================================
import type { biguint, uint64 } from '@algorandfoundation/algorand-typescript'
import { BigUint, Contract, Uint64 } from '@algorandfoundation/algorand-typescript'

const b_a = true
const b_b = false

const b_and = b_a && b_b
const b_or = b_a || b_b

const u_a = Uint64(10)
const u_b = Uint64(2)

const u_add: uint64 = u_a + u_b
const u_sub: uint64 = u_a - u_b
const u_mul: uint64 = u_a * u_b
const u_div: uint64 = u_a / u_b
const u_mod: uint64 = u_a % u_b
const u_pow: uint64 = u_a ** u_b
const u_lshift: uint64 = u_a << u_b
const u_rshift: uint64 = u_a >> u_b
const u_bitOr: uint64 = u_a | u_b
const u_bitXor: uint64 = u_a ^ u_b
const u_bitAnd: uint64 = u_a & u_b

const bu_a = BigUint(10)
const bu_b = BigUint(2)

const bu_add: biguint = bu_a + bu_b
const bu_sub: biguint = bu_a - bu_b
const bu_mul: biguint = bu_a * bu_b
const bu_div: biguint = bu_a / bu_b
const bu_mod: biguint = bu_a % bu_b
const bu_bitOr: biguint = bu_a | bu_b
const bu_bitXor: biguint = bu_a ^ bu_b
const bu_bitAnd: biguint = bu_a & bu_b

const s_a = 'a'
const s_b = 'b'

const s_add = s_a + s_b

class ModuleConstantsAlgo extends Contract {
  getBoolConstants() {
    return [b_and, b_or] as const
  }
  getUintConstants() {
    return [u_add, u_sub, u_mul, u_div, u_mod, u_pow, u_lshift, u_rshift, u_bitOr, u_bitXor, u_bitAnd] as const
  }
  getBigUintConstants() {
    return [bu_add, bu_sub, bu_mul, bu_div, bu_mod, bu_bitOr, bu_bitXor, bu_bitAnd] as const
  }
  getStringConstants() {
    return [s_add]
  }
}



================================================
FILE: tests/approvals/multi-inheritance-2.algo.ts
================================================
import type { uint64 } from '@algorandfoundation/algorand-typescript'
import { Contract, GlobalState } from '@algorandfoundation/algorand-typescript'
import { classes } from 'polytype'

class StoreString extends Contract {
  stringStore = GlobalState<string>()

  setStore(value: string) {
    this.stringStore.value = value
  }
}

class StoreUint64 extends Contract {
  uint64Store = GlobalState<uint64>()

  setStore(value: uint64) {
    this.uint64Store.value = value
  }
}

class StoreBoth extends classes(StoreString, StoreUint64) {
  test(theString: string, theUint: uint64) {
    // setStore resolved from first base type
    this.setStore(theString)

    // Can explicitly resolve from other base type with .class
    super.class(StoreUint64).setStore(theUint)
  }
}



================================================
FILE: tests/approvals/multi-inheritance.algo.ts
================================================
import type { uint64 } from '@algorandfoundation/algorand-typescript'
import { Contract, GlobalState, Uint64 } from '@algorandfoundation/algorand-typescript'
import { classes } from 'polytype'

export class CommonBase extends Contract {
  stateCommon = GlobalState<uint64>({ initialValue: 123 })

  methodCommon() {
    return 'common'
  }

  b2CantOverride(): string {
    return 'common'
  }
}

export class BaseOne extends CommonBase {
  stateOne = GlobalState({ initialValue: Uint64(45) })
  methodOne() {
    return 'base-one'
  }
}

export class BaseTwo extends CommonBase {
  stateTwo = GlobalState({ initialValue: 'Hello' })
  methodTwo() {
    return 'base-two'
  }

  /**
   * Because CommonBase implements this method, and MRO for polytype is depth first; this method
   * should not be accessible from MultiBases as the MRO should be `BaseOne => CommonBase => BaseTwo => CommonBase`
   * and since CommonBase provides an implementation, this one should not be used
   */
  b2CantOverride(): string {
    return 'base-two'
  }
}

export class MultiBases extends classes(BaseOne, BaseTwo) {
  stateMulti = GlobalState({ initialValue: 'Hmmm' })

  methodMulti() {
    return 'multi-bases'
  }

  methodCallsSuper() {
    return super.methodTwo()
  }

  callB2CantOverride() {
    return super.class(BaseTwo).b2CantOverride()
  }

  callB2Common() {
    return super.class(BaseTwo).methodCommon()
  }
}



================================================
FILE: tests/approvals/mutable-arrays.algo.ts
================================================
import type { uint64 } from '@algorandfoundation/algorand-typescript'
import { assert, Contract, ensureBudget, MutableArray } from '@algorandfoundation/algorand-typescript'

class MutableArraysAlgo extends Contract {
  test(length: uint64) {
    ensureBudget(2000)
    const ma = new MutableArray<uint64>()
    for (let i: uint64 = 0; i < length; i++) {
      ma.push(i)
    }

    assert(ma.length === length)
    assert(length, 'has length')
    const popped = ma.pop()

    assert(popped === length - 1)
    assert(ma.at(-1) === length - 2)
    assert(ma.at(1) === 1)
  }
}



================================================
FILE: tests/approvals/named-types.algo.ts
================================================
import type { uint64 } from '@algorandfoundation/algorand-typescript'
import { assertMatch, Contract, Uint64 } from '@algorandfoundation/algorand-typescript'

type XY = {
  x: uint64
  y: uint64
}

type YX = {
  y: uint64
  x: uint64
}

export class MyContract extends Contract {
  public getXY(): XY {
    return {
      x: 1,
      y: 2,
    }
  }

  public getYX(): YX {
    return {
      x: 222,
      y: 111,
    }
  }

  public getAnon() {
    return {
      x: Uint64(3),
      y: Uint64(4),
    }
  }

  public test(x: XY, y: YX) {
    assertMatch(x, { ...y })
  }

  public testing() {
    const a = this.getXY()
    const b = this.getYX()
    const c = this.getAnon()
    return [a, b, c] as const
  }
}



================================================
FILE: tests/approvals/native-arrays.algo.ts
================================================
import type { uint64 } from '@algorandfoundation/algorand-typescript'
import { assert, assertMatch, Contract, Uint64 } from '@algorandfoundation/algorand-typescript'
import { Bool, DynamicArray, StaticArray, UintN32 } from '@algorandfoundation/algorand-typescript/arc4'

type Vector = { x: uint64; y: uint64 }
export class NativeArraysAlgo extends Contract {
  buildArray(): uint64[] {
    return [1, 2, 3, 4]
  }

  doThings() {
    let arr = this.buildArray()

    assertMatch(arr, [1, 2, 3, 4])

    // append
    arr = [...arr, Uint64(5)]

    assertMatch(arr, [1, 2, 3, 4, 5])

    // pop
    const top = arr[arr.length - 1]
    assert(top === 5)
    // TODO: Uncomment this once puya supports array slicing
    //arr = arr.slice(0, -1)
    arr = [1, 2, 3, 4]

    assertMatch(arr, [1, 2, 3, 4])

    // replace
    arr = arr.with(1, 10)

    assertMatch(arr, [1, 10, 3, 4])

    // concat
    const t1: [uint64, uint64] = [12, 13]
    arr = arr.concat(arr, 11, t1)

    assertMatch(arr, [1, 10, 3, 4, 1, 10, 3, 4, 11, 12, 13])
  }

  arc4Interop() {
    const u1 = new UintN32(123)

    const da1 = new DynamicArray(u1, u1)
    const sa1 = new StaticArray(u1, u1)
    let a1 = [u1, u1]

    a1 = [...a1, ...da1, ...sa1]

    assertMatch(a1, [u1, u1, u1, u1, u1, u1])
  }

  structs({ x, y }: Vector) {
    let myVectors: Vector[] = []

    myVectors = [{ x, y }]

    assertMatch(myVectors, [{ x, y }])
    return myVectors
  }

  booleans() {
    return [true, false, true]
  }

  booleansStatic() {
    return [true, false, true] as const
  }

  arc4Booleans() {
    return [new Bool(true), new Bool(false), new Bool(true)]
  }

  arc4BooleansStatic() {
    return [new Bool(true), new Bool(false), new Bool(true)] as const
  }
}



================================================
FILE: tests/approvals/non-arc4.algo.ts
================================================
import { BaseContract, log, op } from '@algorandfoundation/algorand-typescript'

export default class HelloWorldContract extends BaseContract {
  public approvalProgram(): boolean {
    const name = String(op.Txn.applicationArgs(0))
    log(`Hello, ${name}`)
    return true
  }

  public clearStateProgram(): boolean {
    return true
  }
}



================================================
FILE: tests/approvals/object-destructuring.algo.ts
================================================
import type { biguint, bytes, uint64 } from '@algorandfoundation/algorand-typescript'
import { Bytes } from '@algorandfoundation/algorand-typescript'

function testPartialDestructure(arg: { x: uint64; y: uint64; z: uint64 }) {
  const { x } = arg
  const {
    nested: { y },
  } = { nested: arg }
}

function test() {
  const { a, b, c, d } = produceItems()
  const { d: e } = produceItems()
  let g: uint64, i: biguint
  const f = ({ a: g, d: i } = produceItems())
  receivePartial(produceItems())
}

function produceItems(): { a: uint64; b: bytes; c: boolean; d: biguint } {
  return {
    a: 1,
    b: Bytes(''),
    c: false,
    d: 999n,
  }
}

function receivePartial(x: { a: uint64; d: biguint }) {}

function testLiteralToLiteral() {
  const a: uint64 = 4
  const b: uint64 = 1
  let c: uint64
  let d: uint64

  const { a: e, b: f } = ({ a: c, b: d } = { a, b })
}

function testNumericResolution() {
  let y: { a: uint64 }
  const x: { a: uint64 } = (y = { a: 434 })
}

function test2(args: { x: boolean; y: boolean; z: readonly [string, string] }) {
  const {
    a,
    b,
    args: { x, y },
  } = { a: true, b: false, args }

  const args2 = { ...args, x: true, y: true }
}



================================================
FILE: tests/approvals/ops.algo.ts
================================================
import { assert, Contract, op, Txn } from '@algorandfoundation/algorand-typescript'
import { methodSelector } from '@algorandfoundation/algorand-typescript/arc4'
import * as op2 from '@algorandfoundation/algorand-typescript/op'
import { bzero, GTxn } from '@algorandfoundation/algorand-typescript/op'

class MyContract extends Contract {
  test() {
    const a = bzero(8).bitwiseInvert()
    const b = op2.btoi(a)
    assert(b === 2 ** 64 - 1)

    const c = op.shr(b, 32)

    assert(c === 2 ** 32 - 1)

    assert(GTxn.applicationId(Txn.groupIndex) === Txn.applicationId)

    assert(Txn.applicationArgs(0) === methodSelector('test()void'))
    assert(GTxn.applicationArgs(Txn.groupIndex, 0) === methodSelector(MyContract.prototype.test))
  }
}



================================================
FILE: tests/approvals/pre-approved-sale.algo.ts
================================================
import type { Account, Asset, uint64 } from '@algorandfoundation/algorand-typescript'
import { assertMatch, Global, gtxn, LogicSig, TemplateVar, Uint64 } from '@algorandfoundation/algorand-typescript'

/**
 * Allows for pre-authorising the sale of an asset for a pre-determined price, but to an
 * undetermined buyer.
 *
 * The checks here are not meant to be exhaustive
 */
export class PreApprovedSale extends LogicSig {
  program() {
    const seller = TemplateVar<Account>('SELLER')
    const price = TemplateVar<uint64>('PRICE')
    const asset = TemplateVar<Asset>('ASSET')

    const payTxn = gtxn.PaymentTxn(0)
    const assetTxn = gtxn.AssetTransferTxn(1)
    assertMatch(payTxn, {
      receiver: seller,
      amount: price,
    })

    assertMatch(assetTxn, {
      assetAmount: Uint64(1),
      sender: seller,
      xferAsset: asset,
      assetCloseTo: Global.zeroAddress,
      rekeyTo: Global.zeroAddress,
    })

    return true
  }
}



================================================
FILE: tests/approvals/precompiled-apps.algo.ts
================================================
import type { Account, Application, Asset, bytes, gtxn, uint64 } from '@algorandfoundation/algorand-typescript'
import {
  abimethod,
  assert,
  Contract,
  err,
  GlobalState,
  log,
  LogicSig,
  op,
  TemplateVar,
  TransactionType,
} from '@algorandfoundation/algorand-typescript'

abstract class HelloBase extends Contract {
  greeting = GlobalState({ initialValue: '' })

  @abimethod({ allowActions: 'DeleteApplication' })
  delete() {}

  @abimethod({ allowActions: 'UpdateApplication' })
  update() {}

  greet(name: string): string {
    return `${this.greeting.value} ${name}`
  }
}

export class Hello extends HelloBase {
  @abimethod({ name: 'helloCreate', onCreate: 'require' })
  create(greeting: string) {
    this.greeting.value = greeting
  }
}

export class HelloTemplate extends HelloBase {
  constructor() {
    super()
    this.greeting.value = TemplateVar<string>('GREETING')
  }

  @abimethod({ onCreate: 'require' })
  create() {}
}

export class HelloTemplateCustomPrefix extends HelloBase {
  constructor() {
    super()
    this.greeting.value = TemplateVar<string>('GREETING', 'PRFX_')
  }

  @abimethod({ onCreate: 'require' })
  create() {}
}

function getBigBytes() {
  return op.bzero(4096)
}

export class LargeProgram extends Contract {
  getBigBytesLength() {
    return getBigBytes().length
  }

  @abimethod({ allowActions: 'DeleteApplication' })
  delete() {}
}

/**
 * This logic sig can be used to create a custodial account that will allow any transaction to transfer its
 * funds/assets.
 */
export class TerribleCustodialAccount extends LogicSig {
  program() {
    return true
  }
}

export class ReceivesTxns extends Contract {
  getOne(): uint64 {
    return 1
  }

  receivesAnyTxn(txn: gtxn.Transaction): uint64 {
    switch (txn.type) {
      case TransactionType.AssetConfig:
        return txn.createdAsset.id || txn.configAsset.id
      case TransactionType.ApplicationCall:
        return txn.createdApp.id || txn.appId.id
      default:
        return 0
    }
  }

  receivesAssetConfig(assetCfg: gtxn.AssetConfigTxn): bytes {
    return assetCfg.txnId
  }
  receivesAssetConfigAndPay(assetCfg: gtxn.AssetConfigTxn, payTxn: gtxn.PaymentTxn): void {
    assert(assetCfg.type === TransactionType.AssetConfig)
    assert(payTxn.type === TransactionType.Payment)
  }
}

export class ReceivesReferenceTypes extends Contract {
  receivesReferenceTypes(app: Application, acc: Account, asset: Asset) {
    log(app.address)
    log(acc.bytes)
    log(asset.name)
  }
}

export abstract class HelloStubbed extends Contract {
  greet(name: string): string {
    err('stub only')
  }
}



================================================
FILE: tests/approvals/precompiled-factory.algo.ts
================================================
import type { uint64 } from '@algorandfoundation/algorand-typescript'
import { assert, compile, Contract, itxn, OnCompleteAction } from '@algorandfoundation/algorand-typescript'
import { decodeArc4, encodeArc4, methodSelector } from '@algorandfoundation/algorand-typescript/arc4'
import { Hello, HelloTemplate, HelloTemplateCustomPrefix, LargeProgram } from './precompiled-apps.algo'

class HelloFactory extends Contract {
  test_compile_contract() {
    const compiled = compile(Hello)

    const helloApp = itxn
      .applicationCall({
        appArgs: [methodSelector(Hello.prototype.create), encodeArc4('hello')],
        approvalProgram: compiled.approvalProgram,
        clearStateProgram: compiled.clearStateProgram,
        globalNumBytes: compiled.globalBytes,
      })
      .submit().createdApp

    const txn = itxn
      .applicationCall({
        appArgs: [methodSelector(Hello.prototype.greet), encodeArc4('world')],
        appId: helloApp,
      })
      .submit()
    const result = decodeArc4<string>(txn.lastLog, 'log')

    assert(result === 'hello world')

    itxn
      .applicationCall({
        appId: helloApp,
        appArgs: [methodSelector(Hello.prototype.delete)],
        onCompletion: OnCompleteAction.DeleteApplication,
      })
      .submit()
  }

  test_compile_contract_with_template() {
    const compiled = compile(HelloTemplate, { templateVars: { GREETING: 'hey' } })

    const helloApp = itxn
      .applicationCall({
        appArgs: [methodSelector('create()void')],
        approvalProgram: compiled.approvalProgram,
        clearStateProgram: compiled.clearStateProgram,
        globalNumBytes: 1,
      })
      .submit().createdApp

    const txn = itxn
      .applicationCall({
        appArgs: [methodSelector('greet(string)string'), encodeArc4('world')],
        appId: helloApp,
      })
      .submit()
    const result = decodeArc4<string>(txn.lastLog, 'log')

    assert(result === 'hey world')

    itxn
      .applicationCall({
        appId: helloApp,
        appArgs: [methodSelector('delete()void')],
        onCompletion: OnCompleteAction.DeleteApplication,
      })
      .submit()
  }

  test_compile_contract_with_template_and_custom_prefix() {
    const compiled = compile(HelloTemplateCustomPrefix, { templateVars: { GREETING: 'bonjour' }, templateVarsPrefix: 'PRFX_' })

    const helloApp = itxn
      .applicationCall({
        appArgs: [methodSelector('create()void')],
        approvalProgram: compiled.approvalProgram,
        clearStateProgram: compiled.clearStateProgram,
        globalNumBytes: 1,
      })
      .submit().createdApp

    const txn = itxn
      .applicationCall({
        appArgs: [methodSelector('greet(string)string'), encodeArc4('world')],
        appId: helloApp,
      })
      .submit()
    const result = decodeArc4<string>(txn.lastLog, 'log')

    assert(result === 'bonjour world')

    itxn
      .applicationCall({
        appId: helloApp,
        appArgs: [methodSelector('delete()void')],
        onCompletion: OnCompleteAction.DeleteApplication,
      })
      .submit()
  }

  test_compile_contract_large() {
    const compiled = compile(LargeProgram)

    const largeApp = itxn
      .applicationCall({
        approvalProgram: compiled.approvalProgram,
        clearStateProgram: compiled.clearStateProgram,
        extraProgramPages: compiled.extraProgramPages,
        globalNumBytes: compiled.globalBytes,
      })
      .submit().createdApp

    const txn = itxn
      .applicationCall({
        appArgs: [methodSelector('getBigBytesLength()uint64')],
        appId: largeApp,
      })
      .submit()
    const result = decodeArc4<uint64>(txn.lastLog, 'log')

    assert(result === 4096)

    itxn
      .applicationCall({
        appId: largeApp,
        appArgs: [methodSelector('delete()void')],
        onCompletion: OnCompleteAction.DeleteApplication,
      })
      .submit()
  }
}



================================================
FILE: tests/approvals/precompiled-typed.algo.ts
================================================
import { assert, Contract, Global, itxn, Txn } from '@algorandfoundation/algorand-typescript'
import { abiCall, compileArc4, methodSelector } from '@algorandfoundation/algorand-typescript/arc4'
import {
  Hello,
  HelloStubbed,
  HelloTemplate,
  HelloTemplateCustomPrefix,
  LargeProgram,
  ReceivesReferenceTypes,
  ReceivesTxns,
} from './precompiled-apps.algo'

class HelloFactory extends Contract {
  test_compile_contract() {
    const compiled = compileArc4(Hello)

    const app = compiled.call.create({
      args: ['hello'],
    }).itxn.createdApp

    const result = compiled.call.greet({
      args: ['world'],
      appId: app,
    }).returnValue
    assert(result === 'hello world')

    const result2 = abiCall(Hello.prototype.greet, {
      appId: app,
      args: ['abi'],
    }).returnValue

    assert(result2 === 'hello abi')

    const result3 = abiCall(HelloStubbed.prototype.greet, {
      appId: app,
      args: ['stubbed'],
    }).returnValue
    assert(result3 === 'hello stubbed')

    compiled.call.delete({
      appId: app,
    })
  }

  test_compile_contract_with_template() {
    const compiled = compileArc4(HelloTemplate, { templateVars: { GREETING: 'hey' } })

    const helloApp = compiled.call.create().itxn.createdApp

    const txn = compiled.call.greet({
      args: ['world'],
      appId: helloApp,
    })

    assert(txn.returnValue === 'hey world')

    compiled.call.delete({
      appId: helloApp,
    })
  }

  test_compile_contract_with_template_and_custom_prefix() {
    const compiled = compileArc4(HelloTemplateCustomPrefix, { templateVars: { GREETING: 'bonjour' }, templateVarsPrefix: 'PRFX_' })

    const helloApp = compiled.call.create().itxn.createdApp

    const { returnValue: result } = compiled.call.greet({
      args: ['world'],
      appId: helloApp,
    })

    assert(result === 'bonjour world')

    compiled.call.delete({
      appId: helloApp,
    })
  }

  test_compile_contract_large() {
    const compiled = compileArc4(LargeProgram)

    const largeApp = compiled.bareCreate().createdApp

    const { returnValue: result } = compiled.call.getBigBytesLength({
      appId: largeApp,
    })

    assert(result === 4096)

    compiled.call.delete({
      appId: largeApp,
    })
  }

  test_call_contract_with_transactions() {
    const compiled = compileArc4(ReceivesTxns)

    const appId = compiled.bareCreate().createdApp

    const assetCreate = itxn.assetConfig({
      total: 1,
      unitName: 'T',
      assetName: 'TEST',
    })

    compiled.call.receivesAnyTxn({
      args: [assetCreate],
      appId,
    })

    const appCall = itxn.applicationCall({
      appId,
      appArgs: [methodSelector(ReceivesTxns.prototype.getOne)],
    })

    compiled.call.receivesAnyTxn({
      appId,
      args: [appCall],
    })

    compiled.call.receivesAssetConfig({
      appId,
      args: [assetCreate],
    })

    const pay = itxn.payment({
      receiver: appId.address,
      amount: 100000,
      sender: Global.currentApplicationId.address,
    })

    compiled.call.receivesAssetConfigAndPay({
      appId,
      args: [assetCreate, pay],
    })
  }

  test_call_contract_with_reference_types() {
    const compiled = compileArc4(ReceivesReferenceTypes)

    const appId = compiled.bareCreate().createdApp

    const asset = itxn
      .assetConfig({
        total: 1,
        unitName: 'T',
        assetName: 'TEST',
      })
      .submit().createdAsset

    const result = compiled.call.receivesReferenceTypes({
      args: [Global.currentApplicationId, Txn.sender, asset],
      appId,
    })

    assert(result.itxn.logs(0) === Global.currentApplicationAddress.bytes)
    assert(result.itxn.logs(1) === Txn.sender.bytes)
    assert(result.itxn.logs(2) === asset.name)
  }
}



================================================
FILE: tests/approvals/prefix-postfix-operators.algo.ts
================================================
import type { biguint, bytes, uint64 } from '@algorandfoundation/algorand-typescript'
import { assert, Bytes, Contract } from '@algorandfoundation/algorand-typescript'
import { bzero } from '@algorandfoundation/algorand-typescript/op'

function test_uint64(x: uint64, y: uint64) {
  assert(x === 10, 'x input must be 10')
  assert(y === 5, 'y input must be 5')
  x++
  assert(x === 11)
  x--
  assert(x === 10)
  x -= --y
  assert(x === 6)
  assert(y === 4)
  x += y++
  assert(x === 10)
  assert(y === 5)
  const inverted: uint64 = ~y
  assert(inverted === 2 ** 64 - 1 - y)
  /*
  00001010
  11110101 = 245
   */
  //

  assert(y)
  assert(!!y)
  return !y
}
function test_biguint(x: biguint, y: biguint) {
  assert(x === 10n, 'x input must be 10')
  assert(y === 5n, 'y input must be 5')

  x++
  assert(x === 11n)

  x--

  assert(x === 10n)
  x -= --y
  assert(y === 4n)
  assert(x === 6n)
  x += y++
  assert(y === 5n)
  assert(x === 10n)
  assert(y)
  assert(!!y)
  return !y
}
function test_bytes(x: bytes) {
  assert(x === bzero(4), 'x must be 4 unset bytes')
  const y = x.bitwiseInvert()

  assert(y === Bytes.fromHex('FFFFFFFF'))
}

export class DemoContract extends Contract {
  test() {
    test_uint64(10, 5)
    test_biguint(10n, 5n)

    test_bytes(bzero(4))

    return true
  }
}



================================================
FILE: tests/approvals/property-ordering.algo.ts
================================================
import type { uint64 } from '@algorandfoundation/algorand-typescript'
import { BaseContract } from '@algorandfoundation/algorand-typescript'

type BthenA = { b: uint64; a: uint64 }

function test_assign_from_var(x: { a: uint64; b: uint64 }) {
  const obj: BthenA = x
}

function test_assign_from_literal(x: uint64) {
  let b: uint64
  const obj: { a: uint64; z: uint64 } = {
    z: (b = x * 2),
    a: b,
  }
}

export class Demo extends BaseContract {
  public approvalProgram(): boolean {
    test_assign_from_literal(4)

    test_assign_from_var({ a: 3, b: 4 })

    return true
  }
}



================================================
FILE: tests/approvals/reserve-scratch.algo.ts
================================================
import { assert, BaseContract, Bytes, contract } from '@algorandfoundation/algorand-typescript'
import { gloadBytes, gloadUint64, Scratch } from '@algorandfoundation/algorand-typescript/op'

function test() {
  const b = gloadBytes(0, 1)
  const u = gloadUint64(1, 2)
}

@contract({ scratchSlots: [0, 1, { from: 10, to: 20 }] })
export class ReserveScratchAlgo extends BaseContract {
  setThings() {
    Scratch.store(0, 1)
    Scratch.store(1, Bytes('hello'))
    Scratch.store(15, 45)
  }

  approvalProgram(): boolean {
    this.setThings()

    assert(Scratch.loadUint64(0) === 1)
    assert(Scratch.loadBytes(1) === Bytes('hello'))
    assert(Scratch.loadUint64(15) === 45)
    return true
  }
}

@contract({ scratchSlots: [50] })
export class SubReserveScratchAlgo extends ReserveScratchAlgo {
  approvalProgram(): boolean {
    super.approvalProgram()
    Scratch.store(50, Bytes('world'))
    Scratch.store(16, Bytes('world'))
    return true
  }
}



================================================
FILE: tests/approvals/shadowed-variables.algo.ts
================================================
import type { bytes, uint64 } from '@algorandfoundation/algorand-typescript'
import { assert, BaseContract, Bytes, Uint64 } from '@algorandfoundation/algorand-typescript'

const a = Bytes('123')

class ShadowedVariablesAlgo extends BaseContract {
  public approvalProgram(): boolean {
    const [b, u, f] = this.getValues()
    assert(a === b, 'a should be module const (bytes)')
    {
      const a = u
      assert(a === 123, 'a should be local const (uint)')
      {
        let a = f
        assert(!a, 'a should be local let (bool)')
        {
          a = !a
          assert(a, 'a should be modified local let (bool)')
        }
        assert(a, 'a should still be modified local let (bool)')
      }
      assert(a === 123, 'a should be local const (uint)')
    }
    assert(a === Bytes('123'), 'a should be module const (bytes)')
    return true
  }

  private getValues(): [bytes, uint64, boolean] {
    return [a, Uint64(123), false]
  }
}



================================================
FILE: tests/approvals/single-eval.algo.ts
================================================
import type { uint64 } from '@algorandfoundation/algorand-typescript'
import { assert, Contract, GlobalState } from '@algorandfoundation/algorand-typescript'

class SingleEvalAlgo extends Contract {
  myState = GlobalState<uint64>()

  private a() {
    this.myState.value += 1
    return 'a'
  }

  private b() {
    return 'b'
  }

  test() {
    this.myState.value = 0
    const result = this.a() || this.b()
    assert(this.myState.value === 1, 'a() should only be called once')
    assert(result === 'a', 'Result should be "a"')
  }
}



================================================
FILE: tests/approvals/state-totals.algo.ts
================================================
import type { bytes, uint64 } from '@algorandfoundation/algorand-typescript'
import { abimethod, contract, Contract, GlobalState, LocalState, Txn, Uint64 } from '@algorandfoundation/algorand-typescript'

export class BaseWithState extends Contract {
  oneGlobal = GlobalState({ initialValue: Uint64(1) })
  twoGlobal = GlobalState<uint64>()
  oneLocalBytes = LocalState<bytes>()

  setState(n: uint64) {
    this.oneGlobal.value = n
    this.twoGlobal.value = n
  }
}

export class SubClassWithState extends BaseWithState {
  threeGlobal = GlobalState<uint64>()
  twoLocalBytes = LocalState<bytes>()
  setState(n: uint64) {
    super.setState(n)
    this.threeGlobal.value = n
  }
}

@contract({ stateTotals: { globalUints: 4, localUints: 0 } })
export class SubClassWithExplicitTotals extends BaseWithState {}

@contract({ stateTotals: {} })
export class ExtendsSubWithTotals extends SubClassWithExplicitTotals {
  oneLocal = LocalState<uint64>()

  @abimethod({ allowActions: 'OptIn' })
  setState(n: uint64) {
    super.setState(n)

    this.oneLocal(Txn.sender).value = n
  }
}



================================================
FILE: tests/approvals/strings.algo.ts
================================================
import { Contract } from '@algorandfoundation/algorand-typescript'

class StringContract extends Contract {
  join(a: string, b: string): string {
    return a + b
  }

  interpolate(a: string): string {
    return `You interpolated ${a}`
  }
}



================================================
FILE: tests/approvals/super-calls.algo.ts
================================================
import type { uint64 } from '@algorandfoundation/algorand-typescript'
import { assert, BaseContract, GlobalState, Uint64 } from '@algorandfoundation/algorand-typescript'

export class SuperContract extends BaseContract {
  g1 = GlobalState({ initialValue: Uint64(1) })

  approvalProgram(): boolean {
    assert(this.g1.value === 1)
    return true
  }

  superMethod() {
    return true
  }
}

export class SubContract extends SuperContract {
  g2 = GlobalState({ initialValue: Uint64(2) })

  approvalProgram(): boolean {
    assert(this.g1.value === 1)
    assert(this.g2.value === 2)
    return true
  }
}

export class SubSubContract extends SubContract {
  approvalProgram(): boolean {
    assert(this.g1.value === 1)
    assert(this.g2.value === 2)
    return true
  }
}

export class SubSubSubContract extends SubSubContract {
  g3 = GlobalState<uint64>()
  constructor() {
    super()
    this.g3.value = 3
  }
  approvalProgram(): boolean {
    assert(this.g1.value === 1)
    assert(this.g2.value === 2)
    assert(this.g3.value === 3)
    return true
  }

  subSubSubMethod() {
    return super.superMethod()
  }
}



================================================
FILE: tests/approvals/switch-statements.algo.ts
================================================
import type { bytes, uint64 } from '@algorandfoundation/algorand-typescript'
import { assert, Bytes, Contract, GlobalState, Uint64 } from '@algorandfoundation/algorand-typescript'

export class DemoContract extends Contract {
  run() {
    assert(this.test_uint64(1) === 3)
    assert(this.test_uint64(2) === 3)
    assert(this.test_uint64(3) === 1)
    assert(this.test_uint64(4) === 3)

    assert(this.test_break(1) === 11)
    assert(this.test_break(2) === 12)
    assert(this.test_break(3) === 10)
    assert(this.test_break(4) === 14)
    assert(this.test_break(5) === 50)

    assert(this.test_bytes(Bytes('hmmm')))
    assert(this.test_bytes(Bytes.fromHex('ff')))
    assert(this.test_bytes(Bytes.fromBase64('ZHNmc2Rmc2Q=')))
    assert(this.test_bytes(Bytes.fromBase32('ONSGMZ3OMJTGOZDGMRSGM===')))
    assert(!this.test_bytes(Bytes()))
  }

  private test_uint64(x: uint64): uint64 {
    switch (x) {
      case 1:
      case 2:
      case Uint64(4):
        return 3
      default: {
        return 1
      }
    }
  }

  private test_break(x: uint64): uint64 {
    let i: uint64 = 10
    switch (x) {
      case 1:
      case 2:
      case Uint64(4):
        i += x
        break
      case 5:
        i *= x
    }
    return i
  }

  private test_bytes(x: bytes): boolean {
    switch (x) {
      case Bytes('hmmm'):
      case Bytes.fromHex('Ff'):
      case Bytes.fromBase64('ZHNmc2Rmc2Q='):
      case Bytes.fromBase32('ONSGMZ3OMJTGOZDGMRSGM==='):
        return true
    }
    return false
  }

  evalCount = GlobalState<uint64>()

  private increaseEvalAndReturn(n: uint64) {
    this.evalCount.value++
    return n
  }

  public test_side_effects(n: uint64) {
    this.evalCount.value = 0

    switch (n) {
      case this.increaseEvalAndReturn(n - 1):
        break
      case this.increaseEvalAndReturn(n):
        break
      case this.increaseEvalAndReturn(n + 1):
        break
    }

    assert(this.evalCount.value === 2, 'Only two functions should be evaluated')
  }

  public test_non_trivial_termination_of_clause(n: uint64, y: uint64): uint64 {
    switch (n) {
      case 1:
        if (y % 2 === 0) {
          return y
        } else {
          return n
        }
      default:
        return y * n
    }
  }
}



================================================
FILE: tests/approvals/teal-script-conventions.algo.ts
================================================
import type { bytes, uint64 } from '@algorandfoundation/algorand-typescript'
import { abimethod, baremethod, Contract, GlobalState, LocalState, Txn } from '@algorandfoundation/algorand-typescript'
import type { ConventionalRouting } from '@algorandfoundation/algorand-typescript/arc4'

export class TealScriptConventionsAlgo extends Contract implements ConventionalRouting {
  global = GlobalState<bytes>()
  local = LocalState<string>()
  @abimethod({ name: 'noMoreThanks' })
  closeOutOfApplication(arg: uint64) {
    return arg
  }
  @abimethod({ allowActions: ['NoOp', 'DeleteApplication'] })
  createApplication(value: bytes) {
    this.global.value = value
  }

  setLocal(value: string) {
    this.local(Txn.sender).value = value
  }
  @baremethod()
  deleteApplication() {}

  optInToApplication() {}

  updateApplication() {}

  clearStateProgram(): boolean {
    return true
  }
}



================================================
FILE: tests/approvals/template-var.algo.ts
================================================
import type { bytes, uint64 } from '@algorandfoundation/algorand-typescript'
import { Contract, TemplateVar } from '@algorandfoundation/algorand-typescript'
import type { Address } from '@algorandfoundation/algorand-typescript/arc4'

const specialAddress = TemplateVar<Address>('AN_ADDRESS')

export class MyContract extends Contract {
  getInt() {
    return TemplateVar<uint64>('AN_INT')
  }

  getString() {
    return TemplateVar<string>('A_STRING')
  }

  getBytes() {
    return TemplateVar<bytes>('SOME_BYTES')
  }

  getAddress() {
    return specialAddress
  }
}



================================================
FILE: tests/approvals/uint64-expressions.algo.ts
================================================
import { assertMatch, BaseContract, Uint64 } from '@algorandfoundation/algorand-typescript'

function test() {
  return [Uint64(), Uint64(0), Uint64('1'), Uint64(1n), Uint64(true)] as const
}

function test2() {
  const x = Uint64(123)
  const y = Uint64(x * 100)
  return [x, y] as const
}

class DemoContract extends BaseContract {
  public approvalProgram(): boolean {
    assertMatch(test2(), [123, 12300])
    assertMatch(test(), [0, 0, 1, 1, 1])
    return true
  }
}



================================================
FILE: tests/approvals/urange.algo.ts
================================================
import type { uint64 } from '@algorandfoundation/algorand-typescript'
import { Contract, urange } from '@algorandfoundation/algorand-typescript'

class UrangeAlgo extends Contract {
  testSingleArg() {
    let results: uint64[] = []
    for (const i of urange(5)) {
      results = [...results, i]
    }
    return results
  }
  testTwoArg() {
    let results: uint64[] = []
    for (const i of urange(2, 5)) {
      results = [...results, i]
    }
    return results
  }
  testThreeArg() {
    let results: uint64[] = []
    for (const i of urange(2, 10, 3)) {
      results = [...results, i]
    }
    return results
  }
}



================================================
FILE: tests/approvals/while-loops.algo.ts
================================================
import type { uint64 } from '@algorandfoundation/algorand-typescript'
import { Contract, Uint64 } from '@algorandfoundation/algorand-typescript'

class DemoContract extends Contract {
  public testWhile(stop: uint64) {
    let i = Uint64(0)
    while (i < stop) {
      i += 1
    }

    return i
  }
}



================================================
FILE: tests/expected-output/abi-decorators.algo.ts
================================================
import type { Account, Application, Asset, bytes, gtxn, itxn, uint64 } from '@algorandfoundation/algorand-typescript'
import { abimethod, baremethod, Contract, err, GlobalState, Uint64 } from '@algorandfoundation/algorand-typescript'

export default class AbiDecorators extends Contract {
  // @expect-warning Duplicate on completion actions
  @abimethod({ allowActions: ['NoOp', 'NoOp'] })
  public justNoop(): void {}
  // @expect-error Private or protected methods cannot be exposed as an abi method
  @abimethod({ onCreate: 'require' })
  private createMethod(): void {}
  @abimethod({ allowActions: ['NoOp'] })
  // @expect-error Only one decorator is allowed per method. Multiple on complete actions can be provided in a single decorator
  @abimethod({ allowActions: ['OptIn'] })
  public duplicateDecorators(): void {}

  globalValue = GlobalState({ initialValue: Uint64(123) })

  // @expect-error Default argument specification for 'a' does not match parameter type
  @abimethod({ defaultArguments: { a: { from: 'globalValue' } } })
  public methodWithDefaults(a: bytes): void {}

  // @expect-error Asset cannot be used as an ABI return type
  badReturnsAsset(): Asset {
    err('No implementation')
  }
  // @expect-error Account cannot be used as an ABI return type
  badReturnsAccount(): Account {
    err('No implementation')
  }
  // @expect-error Application cannot be used as an ABI return type
  badReturnsApplication(): Application {
    err('No implementation')
  }
  // @expect-error PaymentTxn cannot be used as an ABI return type
  badReturnsGtxn(): gtxn.PaymentTxn {
    err('No implementation')
  }

  // @expect-error PaymentInnerTxn cannot be used as an ABI return type
  badReturnsItxn(): itxn.PaymentInnerTxn {
    err('No implementation')
  }

  // @expect-error Bare methods cannot have any parameters
  @baremethod()
  badBareParams(x: uint64): void {}
  // @expect-error Bare method return type must be void
  @baremethod()
  badBareReturn(): uint64 {
    return 1
  }
}

export class OverloadedMethods extends Contract {
  // @expect-error User defined functions must have exactly 1 call signature
  public overloaded(x: uint64): uint64
  public overloaded(x: uint64, y: uint64): uint64
  public overloaded(x: uint64, y?: uint64): uint64 {
    return Uint64(4)
  }
}



================================================
FILE: tests/expected-output/arc28-events.algo.ts
================================================
import type { uint64 } from '@algorandfoundation/algorand-typescript'
import { Asset, Contract, emit } from '@algorandfoundation/algorand-typescript'

type Named = { a: uint64; b: Asset }

class EventEmitter extends Contract {
  emitSwapped(a: uint64, b: uint64) {
    // @expect-error Event cannot be an anonymous type...
    emit({ a: b, b: a })

    // @expect-error Asset cannot be encoded to an ARC4 type
    emit<Named>({ a: b, b: Asset(a) })

    // @expect-error Event signature length (2) does not match number of provided values (1).
    emit('Swapped(uint64,uint64)', b)

    // @expect-error Invalid signature: Tuple has not been closed
    emit('Swapped(uint64', b)

    // @expect-error Expected type UintN<16> does not match actual type UintN<64>
    emit('Swapped(uint16,uint64)', b, a)

    // @expect-error [uint64, uint64] cannot be encoded to an ARC4 type
    emit('Swapped((uint64,uint64),uint64)', [b, b], a)
  }

  emitCustom(arg0: string, arg1: boolean) {
    // @expect-error Expression of type `number` must be explicitly converted to an algo-ts type...
    emit('Custom2', 1)
  }
}



================================================
FILE: tests/expected-output/arc4-encode-decode.algo.ts
================================================
import type { biguint, bytes, uint64 } from '@algorandfoundation/algorand-typescript'
import { Contract } from '@algorandfoundation/algorand-typescript'
import type { DynamicBytes, UintN64 } from '@algorandfoundation/algorand-typescript/arc4'
import { arc4EncodedLength, Struct } from '@algorandfoundation/algorand-typescript/arc4'

class TestStruct extends Struct<{ a: UintN64; b: DynamicBytes }> {}
type TestObj = { a: UintN64; b: DynamicBytes }
export class Arc4EncodeDecode extends Contract {
  testEncoding(a: uint64, b: boolean, c: biguint, d: bytes, e: string) {
    // @expect-error Target type must encode to a fixed size...
    arc4EncodedLength<TestObj>()
    // @expect-error Target type must encode to a fixed size...
    arc4EncodedLength<string>()
    // @expect-error Target type must encode to a fixed size...
    arc4EncodedLength<uint64[]>()
    // @expect-error Target type must encode to a fixed size...
    arc4EncodedLength<TestStruct>()
  }
}



================================================
FILE: tests/expected-output/arc4-hybrid.algo.ts
================================================
import { Contract, log } from '@algorandfoundation/algorand-typescript'

class Arc4HybridAlgo extends Contract {
  // @expect-warning Contract overrides approval program method but does not appear to call super.approvalProgram(). ARC4 routing may not work as expected
  override approvalProgram(): boolean {
    return true
  }

  someMethod() {
    log('some method')
  }
}



================================================
FILE: tests/expected-output/arc4-method-selector.algo.ts
================================================
import { Contract } from '@algorandfoundation/algorand-typescript'
import { baremethod, methodSelector } from '@algorandfoundation/algorand-typescript/arc4'

class ContractOne extends Contract {
  test() {
    // @expect-error bareMethod is not an ABI method
    return methodSelector(ContractTwo.prototype.bareMethod)
  }
  test2() {
    // @expect-error Expected contract instance method, found someSubroutine
    return methodSelector(someSubroutine)
  }
  test3() {
    // @expect-error approvalProgram is not an ABI method
    return methodSelector(ContractTwo.prototype.approvalProgram)
  }
  test4() {
    // @expect-error subroutine is not an ABI method
    return methodSelector(this.subroutine)
  }
  private subroutine() {}
}

class ContractTwo extends Contract {
  @baremethod({ onCreate: 'allow' })
  bareMethod() {}
}

function someSubroutine() {
  return true
}



================================================
FILE: tests/expected-output/arc4-struct.algo.ts
================================================
import { Str, Struct } from '@algorandfoundation/algorand-typescript/arc4'

class BadStruct extends Struct<{ x: Str }> {
  // @expect-error Property declarations are not supported in ARC4 struct definitions
  static staticProp: string
  // @expect-error Class static block declarations are not supported in ARC4 struct definitions
  static {
    this.staticProp = 'oh noes'
  }

  // @expect-error Constructor declarations are not supported in ARC4 struct definitions
  constructor() {
    super({ x: new Str('hi') })
  }

  // @expect-error Property declarations are not supported in ARC4 struct definitions
  instanceProp: string = ''

  // @expect-error Property declarations are not supported in ARC4 struct definitions
  get readAccessor() {
    return this.instanceProp
  }

  // @expect-error Property declarations are not supported in ARC4 struct definitions
  set writeAccessor(val: string) {
    this.instanceProp = val
  }

  // @expect-error Method declarations are not supported in ARC4 struct definitions
  public someMethod() {
    return this.instanceProp + BadStruct.staticProp
  }
}



================================================
FILE: tests/expected-output/arc4-types.algo.ts
================================================
import type { biguint, bytes, uint64 } from '@algorandfoundation/algorand-typescript'
import { arc4, assert, BaseContract, Bytes, Txn } from '@algorandfoundation/algorand-typescript'
import type { Bool } from '@algorandfoundation/algorand-typescript/arc4'
import {
  Address,
  Byte,
  DynamicArray,
  DynamicBytes,
  StaticArray,
  StaticBytes,
  Str,
  Tuple,
  UFixedNxM,
  UintN,
  type UintN8,
} from '@algorandfoundation/algorand-typescript/arc4'

function testUFixed() {
  const a = new UFixedNxM<32, 4>('1.244')
  const c = new UFixedNxM<32, 4>('1.244')

  assert(a === c)
}

function test(n: uint64, b: biguint, c: UintN<256>) {
  const x = new UintN<8>(4)
  assert(x.bytes.length === 1)
  const x2 = new UintN<8>(255n)
  assert(x2.bytes === Bytes.fromHex('ff'))

  const y = new UintN<16>()
  assert(y.bytes.length === 2)
  const z = new UintN<8>(n)
  const z_native = z.native
  assert(z_native === n)
  const a = new UintN<128>(b)
  const a_native = a.native
  assert(a_native === b)

  assert(c.bytes.length === 256 / 8)
}

function testStr() {
  const s1 = new Str()
  assert(s1.bytes === new UintN<16>(0).bytes, 'Empty string should equal the uint16 length prefix')
  const s2 = new Str('Hello')
  assert(s2.native === 'Hello')
}

function testDynamicBytes(someBytes: bytes) {
  const db1 = new DynamicBytes()
  const db2 = new DynamicBytes(someBytes)
  const db3 = new DynamicBytes('hello')
}

function testStaticBytes() {
  // @expect-error StaticBytes length must be greater than or equal to 0
  const s1 = new StaticBytes<-1>()
  // @expect-error Value should have byte length of 4
  const s2 = new StaticBytes<4>('')
}

type ARC4Uint64 = UintN<64>
const ARC4Uint64 = UintN<64>

function testArrays(n: ARC4Uint64) {
  const myArray = new DynamicArray(n, n, n)

  myArray.push(n)

  const myStatic = new StaticArray(n, n)

  assert(myStatic[0] === myArray.pop())

  myStatic[1] = new UintN<64>(50)

  // const myStatic2 = new StaticArray<ARC4Uint64, 3>(n, n, n)
}

function testByte() {
  const b = new Byte()
  const b2 = new Byte(0)
  assert(b === b2)
}

function testAddress() {
  const a = new Address()
  const b = new Address(Txn.sender)

  assert(a !== b, 'Zero address should not match sender')
  assert(a === new Address(), 'Two zero addresses should match')
  assert(a[0] === new Byte(), 'Zero address should start with zero byte')
}

function testTuple() {
  const t = new Tuple(new ARC4Uint64(34))
  const firstItem = t.at(0)
  const firstItemIndexer = t.native[0]
  assert(firstItem === firstItemIndexer)
  const t1 = new Tuple(new Address(), new Byte())
  assert(t1.length === 2)
}

export class Arc4TypesTestContract extends BaseContract {
  public getArc4Values(): [Byte, UintN<8>, Address] {
    return [new Byte(), new UintN(255), new Address()]
  }

  public approvalProgram(): boolean {
    const x = new ARC4Uint64()
    testStr()
    test(1, 2n, new UintN<256>(4))
    testByte()
    testArrays(new UintN<64>(65))
    testAddress()
    testTuple()
    testUFixed()
    testDynamicBytes(Bytes('hmmmmmmmmm'))
    testStaticBytes()
    const result = new arc4.DynamicArray<arc4.UintN<64>>()
    assert(result.length === 0)
    return true
  }
}

function testNoArg() {
  // @expect-error Zero arg constructor can only be used for static arrays with a fixed size encoding.
  const a = new StaticArray<Str, 4>()
  // @expect-error Zero arg constructor can only be used for tuples with a fixed size encoding.
  const b = new Tuple<[UintN8, Bool, Bool, Str]>()
}



================================================
FILE: tests/expected-output/array-destructuring.algo.ts
================================================
import type { biguint, bytes, uint64 } from '@algorandfoundation/algorand-typescript'
import { Bytes } from '@algorandfoundation/algorand-typescript'

function test() {
  // @expect-error Spread operator is not currently supported with tuple expressions
  const [a, ...b] = produceItems()
}

function produceItems(): [uint64, bytes, boolean, biguint] {
  return [5, Bytes(), false, 6n]
}



================================================
FILE: tests/expected-output/array-literals.algo.ts
================================================
import type { uint64 } from '@algorandfoundation/algorand-typescript'

function test(a: uint64, b: uint64) {
  // @expect-error Spread operator is not supported in assignment expressions where the resulting type is a variadic array
  const [...e] = [a, b]
  // @expect-error Spread operator is not currently supported with tuple expressions
  const [...f] = [a, b] as const
  const [, g] = [a, b] as const
  const [h] = [a, b] as const
}



================================================
FILE: tests/expected-output/biguint-expressions.algo.ts
================================================
import { BigUint } from '@algorandfoundation/algorand-typescript'

function testErrors(b: string) {
  // @expect-error Arg 0 of BigUInt has an incorrect type of -1. Expected boolean | string | bytes | biguint | uint64
  BigUint(-1)
  // @expect-error Arg 0 of BigUInt has an incorrect type of -1n. Expected boolean | string | bytes | biguint | uint64
  BigUint(-1n)
  // @expect-error biguint overflow or underflow...
  BigUint(2n ** 512n)
  // @expect-error Only compile time constant string values are supported
  BigUint(b)
}



================================================
FILE: tests/expected-output/box-proxies.algo.ts
================================================
import type { bytes, uint64 } from '@algorandfoundation/algorand-typescript'
import { Box } from '@algorandfoundation/algorand-typescript'
import type { DynamicArray, UintN8 } from '@algorandfoundation/algorand-typescript/arc4'

function test() {
  const b = Box<string>({ key: 'b' })
  // @expect-error string does not have a fixed byte size. Please specify a size argument.
  b.create()

  const b2 = Box<bytes>({ key: 'b2' })
  // @expect-error bytes does not have a fixed byte size. Please specify a size argument.
  b2.create()

  // @expect-error DynamicArray<UintN<8>> does not have a fixed byte size. Please specify a size argument.
  Box<DynamicArray<UintN8>>({ key: 'b3' }).create()

  // @expect-error Objects of type {a:uint64,b:uint64} cannot be stored in a box
  const bObj = Box<{ a: uint64; b: uint64 }>({ key: 'bObj' })
}



================================================
FILE: tests/expected-output/byte-expressions.algo.ts
================================================
import { Bytes } from '@algorandfoundation/algorand-typescript'

function testUnsupported() {
  // @expect-error Expression of type `number` must be explicitly converted to an algo-ts type...
  Bytes(1)
  // @expect-error Expression of type `bigint` must be explicitly converted to an algo-ts type...
  Bytes(1n)
  // @expect-error A compile time constant value between 0 and 255 is expected here...
  Bytes([500])
}



================================================
FILE: tests/expected-output/cant-create.algo.ts
================================================
import { Contract } from '@algorandfoundation/algorand-typescript'
import { baremethod } from '@algorandfoundation/algorand-typescript/arc4'

// @expect-error Non-abstract ARC4 contract has no methods which can be called to create the contract...
export class CantCreate extends Contract {
  @baremethod({ allowActions: 'NoOp' })
  public handleBare() {}
}

abstract class CantCreateAbstract extends Contract {
  @baremethod({ allowActions: 'NoOp' })
  public handleBare() {}
}

// @expect-error Non-abstract ARC4 contract has no methods which can be called to create the contract...
export class CantCreateBecauseBase extends CantCreateAbstract {}



================================================
FILE: tests/expected-output/conditional-expression.algo.ts
================================================
import type { uint64 } from '@algorandfoundation/algorand-typescript'

function test(x: uint64, y: uint64) {
  // @expect-error Expression of type `1 | 2` must be explicitly converted to an algo-ts type...
  const d: uint64 = (y % 2 ? 2 : 1) + (x < 4 ? x : y)
  // @expect-error Expression of type `1 | 2` must be explicitly converted to an algo-ts type...
  const f = (y % 2 ? 2 : 1) === (x < 4 ? x : y)
}



================================================
FILE: tests/expected-output/dynamic-imports.algo.ts
================================================
export function test() {
  // @expect-error Not Supported: Dynamic imports
  import('@algorandfoundation/algorand-typescript')
}



================================================
FILE: tests/expected-output/extract-bytes.algo.ts
================================================
import { assert, BaseContract, Bytes } from '@algorandfoundation/algorand-typescript'
import { extract } from '@algorandfoundation/algorand-typescript/op'

export class ExtractBytesAlgo extends BaseContract {
  approvalProgram(): boolean {
    this.test()
    return true
  }

  private test() {
    const b = Bytes('abcdefg')
    // @expect-error Extract with length=0 will always return an empty byte array. Omit length parameter to extract to the end of the sequence.
    assert(extract(b, 2, 0) === Bytes(''))
  }
}



================================================
FILE: tests/expected-output/global-state.algo.ts
================================================
import { Bytes, Contract, GlobalState, type uint64 } from '@algorandfoundation/algorand-typescript'

export class TestContract extends Contract {
  // @expect-error unknown is not a valid type for storage
  noInitial = GlobalState()

  // @expect-error Global state must have explicit key provided if not being assigned to a contract property
  incorrect = GlobalState<string>().hasValue

  // @expect-error Unsupported property type boolean. Only GlobalState, LocalState, and Box proxies can be stored on a contract.
  incorrect2 = GlobalState<string>({ key: 'abc' }).hasValue

  test() {
    // @expect-error Global state must have explicit key provided if not being assigned to a contract property
    const proxyNoKey = GlobalState<uint64>({})

    // @expect-error Global state can only have an initial value specified if being assigned to a contract property
    const proxyInvalidInitialValue = GlobalState<uint64>({ key: Bytes('abc'), initialValue: 1 })
  }
}



================================================
FILE: tests/expected-output/logic-sig.algo.ts
================================================
import { logicsig, LogicSig } from '@algorandfoundation/algorand-typescript'

@logicsig({ name: 'BadLogicSig' })
// @expect-error Only one decorator is allowed per logic signature.
@logicsig({ name: 'BadLogicSig' })
class BadLogicSig extends LogicSig {
  // @expect-error Property declarations are not supported in logic signature definitions
  static staticProp: string
  // @expect-error Class static block declarations are not supported in logic signature definitions
  static {
    this.staticProp = 'oh noes'
  }

  program(): boolean {
    return true
  }

  // @expect-error Constructor declarations are not supported in logic signature definitions
  constructor() {
    super()
  }

  // @expect-error Property declarations are not supported in logic signature definitions
  instanceProp: string = ''

  // @expect-error Property declarations are not supported in logic signature definitions
  get readAccessor() {
    return this.instanceProp
  }

  // @expect-error Property declarations are not supported in logic signature definitions
  set writeAccessor(val: string) {
    this.instanceProp = val
  }

  // @expect-error LogicSig classes may only contain a program implementation method named 'program'. Consider making 'someMethod' a free subroutine.
  public someMethod() {
    return this.instanceProp + BadLogicSig.staticProp
  }
}



================================================
FILE: tests/expected-output/multi-inheritance.algo.ts
================================================
import type { uint64 } from '@algorandfoundation/algorand-typescript'
import { Contract, GlobalState, Uint64 } from '@algorandfoundation/algorand-typescript'
import { classes } from 'polytype'

export class CommonBase extends Contract {
  stateCommon = GlobalState<uint64>({ initialValue: 123 })

  methodCommon() {
    return 'common'
  }

  b2CantOverride(): string {
    return 'common'
  }
}

export class BaseOne extends CommonBase {
  stateOne = GlobalState({ initialValue: Uint64(45) })
  methodOne() {
    return 'base-one'
  }
}

export class BaseTwo extends CommonBase {
  stateTwo = GlobalState({ initialValue: 'Hello' })
  methodTwo() {
    return 'base-two'
  }

  /**
   * Because CommonBase implements this method, and MRO for polytype is depth first; this method
   * should not be accessible from MultiBases as the MRO should be `BaseOne => CommonBase => BaseTwo => CommonBase`
   * and since CommonBase provides an implementation, this one should not be used
   */
  b2CantOverride(): string {
    return 'base-two'
  }
}

export class MultiBases extends classes(BaseOne, BaseTwo) {
  stateMulti = GlobalState({ initialValue: 'Hmmm' })

  methodMulti() {
    return 'multi-bases'
  }

  methodCallsSuper() {
    return super.methodTwo()
  }

  callB2CantOverride() {
    return super.class(BaseTwo).b2CantOverride()
  }

  callB2Common() {
    return super.class(BaseTwo).methodCommon()
  }

  dontWork() {
    // @expect-error Not Supported: Accessing properties of a specific base type. Instead just use `this.stateTwo`
    super.class(BaseTwo).stateTwo.value = ''
  }
}



================================================
FILE: tests/expected-output/mutating-tuples.algo.ts
================================================
import type { uint64 } from '@algorandfoundation/algorand-typescript'

function test(a: uint64) {
  const t1: [uint64, uint64, uint64] = [a, a, a]
  let t2 = { a, b: a, c: a }

  a *= 2

  // @expect-error Expression is not a valid assignment target - object is immutable
  t1[0] = a

  // @expect-error Expression is not a valid assignment target - object is immutable
  t2.a = a

  t2 = { ...t2, a }
}



================================================
FILE: tests/expected-output/not-supported.algo.ts
================================================
import type { uint64 } from '@algorandfoundation/algorand-typescript'
import { Contract, GlobalState, Uint64 } from '@algorandfoundation/algorand-typescript'

type uint = ReturnType<typeof Uint64>

// @expect-error Not Supported: The type typescript/lib/lib.es5.d.ts::Promise is not supported
function buildPromise() {
  // @expect-error Not Supported: void expression
  void test2(123)

  // @expect-error Unable to reflect constructor type
  return Promise.resolve()
}

// @expect-error Not Supported: The type typescript/lib/lib.es5.d.ts::Promise is not supported
async function test() {
  // @expect-error Not Supported: await keyword
  await buildPromise()
}

function test2(x: uint): uint {
  // @expect-error Not Supported: typeof expressions are only supported in type expressions
  if (typeof x === 'number') {
    return x * 10
  }

  // @expect-error Expected expression of type uint64, got never
  return x
}

function testDelete() {
  // @expect-error Union types are not valid as a variable, parameter, return, or property type. Expression type is uint64 | undefined
  const x = { a: 12312 as uint | undefined }

  // @expect-error Not Supported: Delete expressions
  delete x.a
}

class BadContract extends Contract {
  // @expect-error Unsupported property type uint64. Only GlobalState, LocalState, and Box proxies can be stored on a contract.
  #myState = Uint64(123)

  // @expect-error Static properties are not supported
  static staticState = GlobalState<boolean>()

  test() {
    // @expect-error Not Supported: Accessing member #myState on BadContract
    return this.#myState
  }

  // @expect-error Not Supported: get accessors
  get someValue() {
    // The following is an error, but we don't parse accessor statement bodies
    return this.#myState
  }
  // @expect-error Not Supported: set accessors
  set someValue(v: uint64) {
    // The following is an error, but we don't parse accessor statement bodies
    this.#myState = v
  }
}
// @expect-error Not Supported: function expressions...
const myFunc = function () {}

function notNull(): uint64 {
  // @expect-error Union types are not valid as a variable, parameter, return, or property type. Expression type is uint64 | undefined
  const x: uint64 | undefined = 123

  // @expect-error Not Supported: non null assertions
  return x!
}

// @expect-error Not Supported: The type typescript/lib/lib.es2015.generator.d.ts::Generator is not supported
function* generator() {
  // @expect-error Not Supported: yield expressions
  yield Uint64(1)
}



================================================
FILE: tests/expected-output/null-values.algo.ts
================================================
// @expect-error Not Supported: Null values
const a: null = null

// @expect-error Not Supported: The type null is not supported
export function test(): null {
  // @expect-error Not Supported: Null values
  return null
}



================================================
FILE: tests/expected-output/numeric-literal-expressions.algo.ts
================================================
import type { biguint } from '@algorandfoundation/algorand-typescript'

function test_uint64() {
  // @expect-error `number` is not valid as a variable, parameter, return, or property type. Please use an algo-ts type such as `biguint` or `uint64`
  const x = 4 * 100 + 10
}

function test_biguint() {
  // @expect-error `bigint` is not valid as a variable, parameter, return, or property type. Please use an algo-ts type such as `biguint` or `uint64`
  const x: bigint = 5n
  const y: biguint = 5n
  // @expect-error Not Supported: BigUint binary operator '**'
  const z: biguint = y ** 2n
}



================================================
FILE: tests/expected-output/object-destructuring.algo.ts
================================================
import type { biguint, bytes, uint64 } from '@algorandfoundation/algorand-typescript'
import { Bytes } from '@algorandfoundation/algorand-typescript'

function test() {
  // @expect-error Spread operator is not supported
  const { a: h, ...j } = produceItems()
  // @expect-error The target of an assignment must have the same type as the source...
  const x: { a: uint64; d: biguint } = produceItems()
}

function produceItems(): { a: uint64; b: bytes; c: boolean; d: biguint } {
  return {
    a: 1,
    b: Bytes(''),
    c: false,
    d: 999n,
  }
}



================================================
FILE: tests/expected-output/prefix-postfix-operators.algo.ts
================================================
import type { biguint, bytes, uint64 } from '@algorandfoundation/algorand-typescript'

function test_uint64(x: uint64, y: uint64) {
  // @expect-error Not Supported: Prefix Unary - op on uint64
  const a = -y
}
function test_biguint(x: biguint, y: biguint) {
  // @expect-error Not Supported: Prefix Unary - op on biguint
  const a = -y
  // @expect-error Bitwise inversion of biguint is not supported as the bit size is indeterminate
  y = ~y
  return !y
}
function test_bytes(x: bytes) {
  // @expect-error The '~' bytes operator coerces the target value to a number type. Use {bytes expression}.bitwiseInvert() instead
  const y: uint64 = ~x
}



================================================
FILE: tests/expected-output/teal-script-conventions.algo.ts
================================================
import type { bytes, uint64 } from '@algorandfoundation/algorand-typescript'
import { abimethod, baremethod, Contract, GlobalState } from '@algorandfoundation/algorand-typescript'
import type { ConventionalRouting } from '@algorandfoundation/algorand-typescript/arc4'

export class TealScriptConventionsAlgo extends Contract implements ConventionalRouting {
  global = GlobalState<bytes>()

  closeOutOfApplication(arg: uint64) {
    return arg
  }

  // @expect-error onCreate for conventional routing method 'createApplication' must be: require
  @abimethod({ onCreate: 'disallow' })
  createApplication(value: bytes) {
    this.global.value = value
  }

  deleteApplication() {}

  // @expect-error allowActions for conventional routing method 'optInToApplication' must be: OptIn
  @baremethod({ allowActions: ['UpdateApplication'] })
  optInToApplication() {}

  updateApplication() {}

  clearStateProgram(): boolean {
    return true
  }
}



================================================
FILE: tests/expected-output/template-var.algo.ts
================================================
import type { uint64 } from '@algorandfoundation/algorand-typescript'
import { TemplateVar } from '@algorandfoundation/algorand-typescript'

function test() {
  // @expect-error Invalid name. Template variable names must only contain capital letters A-Z, numbers 0-9, and underscores
  const invalidName = TemplateVar<uint64>('hmm')
}



================================================
FILE: tests/expected-output/uint64-expressions.algo.ts
================================================
import { Uint64 } from '@algorandfoundation/algorand-typescript'

/* eslint-disable no-loss-of-precision */

function test() {
  // @expect-error Arg 0 of Uint64 has an incorrect type of -1. Expected uint64 | boolean | string
  Uint64(-1)
  // @expect-error Arg 0 of Uint64 has an incorrect type of -1n. Expected uint64 | boolean | string
  Uint64(-1n)
  // @expect-error Cannot convert abc to an integer
  Uint64('abc')
  // @expect-error Cannot convert 0.1 to an integer
  Uint64('0.1')
  // @expect-error uint64 overflow or underflow: -1
  Uint64('-1')
  // @expect-error uint64 overflow or underflow...
  Uint64(18446744073709551617n)
  // @expect-error This number will lose precision...
  Uint64(1844674407370955161)
  // @expect-error uint64 overflow or underflow...
  Uint64('18446744073709551616')
}



================================================
FILE: tests/expected-output/unsupported-tokens.algo.ts
================================================
import type { bytes } from '@algorandfoundation/algorand-typescript'
import { assert, Contract } from '@algorandfoundation/algorand-typescript'

/* eslint-disable eqeqeq */

export class UnsupportedTokensAlgo extends Contract {
  bytes(b1: bytes, b2: bytes) {
    // @expect-error Loose equality operator '==' is not supported. Please use strict equality operator '==='
    assert(b1 == b2)

    // @expect-error Loose inequality operator '!=' is not supported. Please use strict inequality operator '!=='
    assert(b1 != b2)
  }
}



================================================
FILE: tests/onchain/abi-decorators.spec.ts
================================================
import { OnApplicationComplete } from 'algosdk'
import { describe } from 'vitest'
import { createArc4TestFixture } from './util/test-fixture'

describe('abi-decorators', () => {
  const test = createArc4TestFixture('tests/approvals/abi-decorators.algo.ts', {
    AbiDecorators: { deployParams: { createParams: { method: 'createMethod' } } },
    OverloadedMethods: {},
    BaseAbi: {},
    SubAbi: {},
    SubAbi2: {},
  })
  test('can be created', async ({ appFactoryAbiDecorators }) => {
    await appFactoryAbiDecorators.send.create({ method: 'createMethod' })
  })
  test('methods can be called', async ({ appClientAbiDecorators: appClient, expect }) => {
    await appClient.send.call({ method: 'justNoop' })
    await appClient.send.call({ method: 'allActions', onComplete: 1 })
    const { return: returnValue } = await appClient.send.call({ method: 'overrideReadonlyName' })
    expect(returnValue).toBe(5n)
  })

  test('overloaded methods can be called', async ({ appClientOverloadedMethods, expect }) => {
    const { return: retVal1 } = await appClientOverloadedMethods.send.call({ method: 'doThing(uint64)uint64', args: [100] })
    const { return: retVal2 } = await appClientOverloadedMethods.send.call({ method: 'doThing(uint64,uint64)uint64', args: [100, 200] })
    expect(retVal1).toBe(100n)
    expect(retVal2).toBe(200n * 100n)
  })

  test('overrided methods work as expected', async ({ appClientBaseAbi, appClientSubAbi, appClientSubAbi2, expect }) => {
    expect((await appClientBaseAbi.send.call({ method: 'someMethod', onComplete: OnApplicationComplete.OptInOC })).return).toBe(
      'base-abi:optin',
    )
    expect((await appClientSubAbi.send.call({ method: 'someMethod', onComplete: OnApplicationComplete.OptInOC })).return).toBe(
      'sub-abi:optin',
    )
    expect((await appClientSubAbi2.send.call({ method: 'someMethod', onComplete: OnApplicationComplete.NoOpOC })).return).toBe(
      'sub-abi-2:noop',
    )
  })
})



================================================
FILE: tests/onchain/accounts.spec.ts
================================================
import { microAlgo } from '@algorandfoundation/algokit-utils'
import { describe } from 'vitest'
import { createArc4TestFixture } from './util/test-fixture'

describe('accounts', () => {
  const test = createArc4TestFixture('tests/approvals/accounts.algo.ts', { AccountsContract: {} })

  test('returns account data', async ({ appClientAccountsContract: appClient, expect, assetFactory, testAccount }) => {
    const asset = await assetFactory({ assetName: 'Asset 1', sender: testAccount.addr, total: 1n })

    const result = await appClient.send.call({
      method: 'getAccountInfo',
      args: [testAccount.addr.publicKey, asset],
      extraFee: microAlgo(2000),
    })

    const returnValue = result.return as {
      bytes: number[]
      balance: bigint
      minBalance: bigint
      authAddress: number[]
      totalNumUint: bigint
      totalNumByteSlice: bigint
      totalExtraAppPages: bigint
      totalAppsCreated: bigint
      totalAppsOptedIn: bigint
      totalAssetsCreated: bigint
      totalAssets: bigint
      totalBoxes: bigint
      totalBoxBytes: bigint
      isOptInApp: boolean
      isOptInAsset: boolean
    }

    expect(returnValue.authAddress).toStrictEqual(new Array(32).fill(0))
    expect(returnValue.totalAppsCreated).toBeGreaterThan(0n)
  })
})



================================================
FILE: tests/onchain/arc-28-events.spec.ts
================================================
import { describe } from 'vitest'
import { uint8ArrayToHex, utf8ToUint8Array } from '../../src/util'
import { createArc4TestFixture } from './util/test-fixture'

describe('arc 28 events', () => {
  const test = createArc4TestFixture('tests/approvals/arc-28-events.algo.ts', { EventEmitter: {} })

  test('It works with struct types', async ({ appClientEventEmitter, expect }) => {
    const result = await appClientEventEmitter.send.call({ method: 'emitSwapped', args: [0, 255] })

    expect(result.confirmation.logs?.length).toBe(6)

    const [first, second, third, fourth, fifth, sixth] = result.confirmation.logs!.map(uint8ArrayToHex)

    // sha_512_256("Swapped(uint8,uint8)").slice(0, 4)
    const eventPrefixHex = '0b6325ed'
    // sha_512_256("SwappedArc4(uint8,uint8)").slice(0,4)
    const arc4EventPrefixHex = '441e2cd8'

    const swappedUint8 = 'ff00'
    expect(first).toEqual(`${eventPrefixHex}${swappedUint8}`)
    expect(second).toEqual(`${eventPrefixHex}${swappedUint8}`)
    expect(third).toEqual(`${arc4EventPrefixHex}${swappedUint8}`)
    expect(fourth).toEqual(`${eventPrefixHex}${swappedUint8}`)
    expect(fifth).toEqual(`${eventPrefixHex}${swappedUint8}`)

    // sha_512_256("Swapped((uint8,uint8),uint8)").slice(0, 4) => 388cc12d
    expect(sixth).toEqual(`388cc12dffff00`)
  })

  test('It works with dynamic bytes', async ({ appClientEventEmitter, expect }) => {
    const result = await appClientEventEmitter.send.call({
      method: 'emitDynamicBytes',
      args: [utf8ToUint8Array('abc'), utf8ToUint8Array('def')],
    })

    expect(result.confirmation.logs?.length).toBe(1)

    const [first] = result.confirmation.logs!.map(uint8ArrayToHex)

    const prefix = '4524e1dd'
    const abc = '616263'
    const def = '646566'
    expect(first).toEqual(`${prefix}000400090003${abc}0003${def}`)
  })
})



================================================
FILE: tests/onchain/arc4-hybrid.spec.ts
================================================
import { describe } from 'vitest'
import { uint8ArrayToUtf8 } from '../../src/util'
import { createArc4TestFixture } from './util/test-fixture'

describe('arc4-hybrid', () => {
  const test = createArc4TestFixture('tests/approvals/arc4-hybrid.algo.ts', { Arc4HybridAlgo: {} })
  test('works as expected', async ({ appClientArc4HybridAlgo, expect }) => {
    const result = await appClientArc4HybridAlgo.send.call({ method: 'someMethod' })
    const logs = result.confirmation.logs!.map(uint8ArrayToUtf8)

    expect(logs).toStrictEqual(['before', 'some method', 'after'])
  })
})



================================================
FILE: tests/onchain/arc4-method-selector.spec.ts
================================================
import { describe } from 'vitest'
import { createArc4TestFixture } from './util/test-fixture'

describe('arc4 method selector', () => {
  const test = createArc4TestFixture('tests/approvals/arc4-method-selector.algo.ts', { ContractOne: {}, ContractTwo: {} })

  test('It gets the correct method selector', async ({ appClientContractTwo, expect }) => {
    const result = await appClientContractTwo.send.call({ method: 'test', args: [] })

    expect(result.return).toEqual(true)
  })

  test('It gets the correct method selector when the method name is overridden in config', async ({ appClientContractOne, expect }) => {
    const result = await appClientContractOne.send.call({ method: 'test', args: [] })

    expect(result.return).toBe(true)
  })
})



================================================
FILE: tests/onchain/arc4-types.spec.ts
================================================
import { algos } from '@algorandfoundation/algokit-utils'
import { describe } from 'vitest'
import { bigIntToUint8Array, utf8ToUint8Array } from '../../src/util'
import { createArc4TestFixture, createBaseTestFixture } from './util/test-fixture'

describe('arc4-types', () => {
  const test = createBaseTestFixture('tests/approvals/arc4-types.algo.ts', ['Arc4TypesTestContract'])

  test('runs', async ({ Arc4TypesTestContractInvoker }) => {
    await Arc4TypesTestContractInvoker.send({ extraFee: algos(1) })
  })
})

describe('arc4-struct', () => {
  const test = createArc4TestFixture('tests/approvals/arc4-struct.algo.ts', { StructDemo: {} })

  test('testVectorCreationAndEquality', async ({ appClientStructDemo }) => {
    await appClientStructDemo.send.call({ method: 'testVectorCreationAndEquality' })
  })
  test('add vectors', async ({ appClientStructDemo, expect }) => {
    const v1 = { x: 100, y: 100 }
    const v2 = { x: 50, y: 50 }
    const result = await appClientStructDemo.send.call({ method: 'addVectors', args: [v1, v2] })
    expect(result.return).toStrictEqual({ x: 150n, y: 150n })
  })
  test('implicit casting and spreading', async ({ appClientStructDemo, expect }) => {
    const v1 = { x: 123, y: 456 }
    await appClientStructDemo.send.call({ method: 'implicitCastingAndSpreading', args: [v1] })
  })
  test('to native', async ({ appClientStructDemo, expect }) => {
    const v1 = { x: 100, y: 100 }
    const result = await appClientStructDemo.send.call({ method: 'toNative', args: [v1] })
    expect(result.return).toStrictEqual({ x: 100n, y: 100n })
  })
  test('mutate vector', async ({ appClientStructDemo, expect }) => {
    const v1 = { x: 100, y: 100 }
    const result = await appClientStructDemo.send.call({ method: 'mutateVector', args: [v1, 50, 50] })
    expect(result.return).toStrictEqual({ x: 50n, y: 50n })
  })
})
describe('arc4-encode-decode', () => {
  const test = createArc4TestFixture('tests/approvals/arc4-encode-decode.algo.ts', { Arc4EncodeDecode: {} })
  test('encoding', async ({ appClientArc4EncodeDecode, testAccount }) => {
    await appClientArc4EncodeDecode.send.call({
      method: 'testEncoding',
      args: [234234, true, 340943934n, new Uint8Array([1, 2, 3, 4, 5]), 'hello world', testAccount.addr.toString()],
      extraFee: algos(1),
    })
  })
  test('decoding', async ({ appClientArc4EncodeDecode, testAccount }) => {
    await appClientArc4EncodeDecode.send.call({
      method: 'testDecoding',
      args: [
        234234,
        bigIntToUint8Array(234234n, 8),
        true,
        bigIntToUint8Array(128n, 1),
        340943934n,
        bigIntToUint8Array(340943934n, 512 / 8),
        'hello world',
        new Uint8Array([...bigIntToUint8Array(BigInt('hello world'.length), 2), ...utf8ToUint8Array('hello world')]),
        { a: 50n, b: new Uint8Array([1, 2, 3, 4, 5]) },
        new Uint8Array([...bigIntToUint8Array(50n, 8), 0, 10, 0, 5, 1, 2, 3, 4, 5]),
        testAccount.addr.toString(),
        testAccount.addr.publicKey,
      ],
    })
  })
})



================================================
FILE: tests/onchain/array-destructuring.spec.ts
================================================
import { describe, expect } from 'vitest'
import { createArc4TestFixture } from './util/test-fixture'

describe('array destructuring', () => {
  const test = createArc4TestFixture('tests/approvals/array-destructuring.algo.ts', {
    ArrayDestructuringAlgo: {},
  })

  test('testNested', async ({ appClientArrayDestructuringAlgo }) => {
    const result = await appClientArrayDestructuringAlgo.send.call({
      method: 'testNested',
      args: [[1, [2, 3]]],
    })

    expect(result.return).toStrictEqual([1n, [2n, 3n], 1n, 2n])
  })

  test('test', async ({ appClientArrayDestructuringAlgo }) => {
    await appClientArrayDestructuringAlgo.send.call({
      method: 'test',
    })
  })

  test('testLiteralDestructuring', async ({ appClientArrayDestructuringAlgo }) => {
    await appClientArrayDestructuringAlgo.send.call({
      method: 'testLiteralDestructuring',
    })
  })
})



================================================
FILE: tests/onchain/assert-match.spec.ts
================================================
import { microAlgos } from '@algorandfoundation/algokit-utils'
import { describe } from 'vitest'
import { createArc4TestFixture } from './util/test-fixture'

describe('assert match', () => {
  const test = createArc4TestFixture('tests/approvals/assert-match.algo.ts', { AssertMatchContract: {} })

  test('it can be called', async ({ appClientAssertMatchContract, algorand, testAccount }) => {
    const payment = algorand.createTransaction.payment({
      receiver: appClientAssertMatchContract.appAddress,
      sender: testAccount.addr,
      amount: microAlgos(105000),
    })
    await appClientAssertMatchContract.send.call({ method: 'testPay', args: [payment] })
  })
})



================================================
FILE: tests/onchain/asset-proxy.spec.ts
================================================
import { describe } from 'vitest'
import { invariant, uint8ArrayToBase32, uint8ArrayToBigInt, uint8ArrayToHex, uint8ArrayToUtf8 } from '../../src/util'
import { createArc4TestFixture } from './util/test-fixture'

describe('asset proxy contract', () => {
  const test = createArc4TestFixture('tests/approvals/asset-proxy.algo.ts', {
    AssetProxyAlgo: {},
  })
  test('it runs', async ({ appClientAssetProxyAlgo, assetFactory, testAccount, expect }) => {
    const mdh = new Uint8Array(32)
    const asset = await assetFactory({
      assetName: 'test-asset',
      unitName: 'biggies',
      clawback: testAccount.addr,
      manager: testAccount.addr,
      reserve: testAccount.addr,
      freeze: testAccount.addr,
      total: 100n,
      decimals: 2,
      sender: testAccount.addr,
      defaultFrozen: false,
      url: 'abc',
      metadataHash: mdh,
    })

    const result = await appClientAssetProxyAlgo.send.call({ method: 'testAsset', args: [asset] })

    expect(result.confirmation.logs?.length).toBe(15)
    invariant(result.confirmation.logs, 'there are logs')
    const [
      id,
      total,
      decimals,
      defaultFrozen,
      unitName,
      name,
      url,
      metadataHash,
      manager,
      reserve,
      freeze,
      clawback,
      creator,
      balance,
      frozen,
    ] = result.confirmation.logs

    expect(uint8ArrayToBigInt(id)).toBe(asset)
    expect(uint8ArrayToBigInt(total)).toBe(100n)
    expect(uint8ArrayToBigInt(decimals)).toBe(2n)
    expect(uint8ArrayToBigInt(defaultFrozen)).toBe(0n)
    expect(uint8ArrayToUtf8(unitName)).toBe('biggies')
    expect(uint8ArrayToUtf8(name)).toBe('test-asset')
    expect(uint8ArrayToUtf8(url)).toBe('abc')
    expect(uint8ArrayToHex(metadataHash)).toBe(uint8ArrayToHex(mdh))
    expect(uint8ArrayToBase32(manager)).toBe(uint8ArrayToBase32(testAccount.addr.publicKey))
    expect(uint8ArrayToBase32(reserve)).toBe(uint8ArrayToBase32(testAccount.addr.publicKey))
    expect(uint8ArrayToBase32(freeze)).toBe(uint8ArrayToBase32(testAccount.addr.publicKey))
    expect(uint8ArrayToBase32(clawback)).toBe(uint8ArrayToBase32(testAccount.addr.publicKey))
    expect(uint8ArrayToBase32(creator)).toBe(uint8ArrayToBase32(testAccount.addr.publicKey))
    expect(uint8ArrayToBigInt(balance)).toBe(100n)
    expect(uint8ArrayToBigInt(frozen)).toBe(0n)
  })
})



================================================
FILE: tests/onchain/box-enum-contract.spec.ts
================================================
import { algo } from '@algorandfoundation/algokit-utils'
import { describe } from 'vitest'
import { createArc4TestFixture } from './util/test-fixture'

describe('box-enum-contract', () => {
  const test = createArc4TestFixture('tests/approvals/box-enum-contract.algo.ts', { BoxContract: {} })

  test('can store and load enums', async ({ appClientBoxContract, expect }) => {
    await appClientBoxContract.fundAppAccount({ amount: algo(1) })

    await appClientBoxContract.send.call({ method: 'store_enums', boxReferences: ['oca', 'txn'] })

    const result = await appClientBoxContract.send.call({ method: 'read_enums', boxReferences: ['oca', 'txn'] })

    expect(result.return).toStrictEqual([1n, 6n])
  })
})



================================================
FILE: tests/onchain/box-proxies.spec.ts
================================================
import { algos } from '@algorandfoundation/algokit-utils'
import { describe, expect } from 'vitest'
import { invariant, utf8ToUint8Array } from '../../src/util'
import { createArc4TestFixture, createBaseTestFixture } from './util/test-fixture'

describe('BoxProxies', () => {
  const test = createBaseTestFixture('tests/approvals/box-proxies.algo.ts', ['BoxContract', 'BoxNotExist'])

  test('Should run', async ({ BoxContractInvoker, algorand, testAccount }) => {
    const created = await BoxContractInvoker.send()

    invariant(created.confirmation.applicationIndex, 'There must be an application id')
    const appInfo = await algorand.app.getById(created.confirmation.applicationIndex)
    // Fund the app account
    await algorand.send.payment({
      receiver: appInfo.appAddress,
      sender: testAccount.addr,
      amount: algos(1),
    })
    await BoxContractInvoker.send({
      appId: created.confirmation.applicationIndex,
      boxReferences: ['A', 'one', 'abc', 'what?', 'twowhat?', 'three', 'what?x', 'twowhat?x'],
    })
  })

  test('Box that does not exist should fail when accessed', async ({ BoxNotExistInvoker, algorand, testAccount }) => {
    const created = await BoxNotExistInvoker.send()

    invariant(created.confirmation.applicationIndex, 'There must be an application id')
    const appInfo = await algorand.app.getById(created.confirmation.applicationIndex)
    // Fund the app account
    await algorand.send.payment({
      receiver: appInfo.appAddress,
      sender: testAccount.addr,
      amount: algos(1),
    })

    // Accessing box.value when the box doesn't exist fails
    await expect(
      BoxNotExistInvoker.send({
        appId: created.confirmation.applicationIndex,
        boxReferences: ['abc'],
        args: [utf8ToUint8Array('box')],
      }),
    ).rejects.toThrow(/assert failed/)
    await expect(
      BoxNotExistInvoker.send({
        appId: created.confirmation.applicationIndex,
        boxReferences: ['abc'],
        args: [utf8ToUint8Array('boxmap')],
      }),
    ).rejects.toThrow(/assert failed/)

    // Create the box
    await BoxNotExistInvoker.send({
      appId: created.confirmation.applicationIndex,
      boxReferences: ['abc'],
      args: [utf8ToUint8Array('createbox')],
    })

    // Should work fine now the box exists
    await BoxNotExistInvoker.send({
      appId: created.confirmation.applicationIndex,
      boxReferences: ['abc'],
      args: [utf8ToUint8Array('box')],
    })
    await BoxNotExistInvoker.send({
      appId: created.confirmation.applicationIndex,
      boxReferences: ['abc'],
      args: [utf8ToUint8Array('boxmap')],
    })
  })

  const it = createArc4TestFixture('tests/approvals/box-proxies.algo.ts', { BoxCreate: {} })
  it('creates boxes of the min size', async ({ appClientBoxCreate }) => {
    await appClientBoxCreate.fundAppAccount({ amount: algos(1) })
    await appClientBoxCreate.send.call({ method: 'createBoxes', boxReferences: ['bool', 'arc4b', 'a', 'b', 'c', 'd', 'e'] })
  })
})



================================================
FILE: tests/onchain/byte-expressions.spec.ts
================================================
import { describe } from 'vitest'
import { createArc4TestFixture } from './util/test-fixture'

describe('byte expressions', () => {
  const test = createArc4TestFixture('tests/approvals/byte-expressions.algo.ts', { DemoContract: {} })

  test('runs', async ({ appClientDemoContract }) => {
    await appClientDemoContract.send.call({ method: 'test' })
  })
})



================================================
FILE: tests/onchain/destructured-params.spec.ts
================================================
import { describe, expect } from 'vitest'
import { bigIntToUint8Array, hexToUint8Array, joinUint8Arrays, utf8ToUint8Array } from '../../src/util'
import { createArc4TestFixture } from './util/test-fixture'

describe('destructed params', () => {
  const test = createArc4TestFixture('tests/approvals/destructured-params.algo.ts', {
    DestructuredParamsAlgo: {},
  })
  test('Works from abi', async ({ appClientDestructuredParamsAlgo }) => {
    const result = await appClientDestructuredParamsAlgo.send.call({ method: 'test', args: [{ a: 1, b: hexToUint8Array('FF'), c: true }] })

    const [log] = result.confirmation.logs ?? []

    const a = bigIntToUint8Array(1n, 8)
    const b = hexToUint8Array('FF')
    const c = bigIntToUint8Array(1n, 8)
    expect(log).toStrictEqual(joinUint8Arrays(a, b, c))
  })

  test('Works internally', async ({ appClientDestructuredParamsAlgo }) => {
    const result = await appClientDestructuredParamsAlgo.send.call({ method: 'init', args: [] })

    const [log1, log2] = result.confirmation.logs ?? []

    expect(log1).toStrictEqual(joinUint8Arrays(bigIntToUint8Array(456n, 8), bigIntToUint8Array(0n, 8)))
    expect(log2).toStrictEqual(joinUint8Arrays(bigIntToUint8Array(2n, 8), utf8ToUint8Array('Hello'), bigIntToUint8Array(1n, 8)))
  })
})



================================================
FILE: tests/onchain/do-loops.spec.ts
================================================
import { describe } from 'vitest'
import { createArc4TestFixture } from './util/test-fixture'

describe('do loops', () => {
  const test = createArc4TestFixture('tests/approvals/do-loops.algo.ts', { DoLoopsAlgo: {} })

  test('testDo runs', async ({ appClientDoLoopsAlgo, expect }) => {
    const result = await appClientDoLoopsAlgo.send.call({ method: 'testDo', args: [10] })

    expect(result.return).toBe(10n)
  })
  test('testDoBreak runs', async ({ appClientDoLoopsAlgo, expect }) => {
    const result = await appClientDoLoopsAlgo.send.call({ method: 'testDoBreak', args: [10, 5] })

    expect(result.return).toBe(BigInt(1 + 2 + 3 + 4 + 5))
  })
  test('testDoContinue runs', async ({ appClientDoLoopsAlgo, expect }) => {
    const result = await appClientDoLoopsAlgo.send.call({ method: 'testDoContinue', args: [10, 3] })

    expect(result.return).toBe(BigInt(1 + 1 + 1 + 2 + 1 + 1 + 2 + 1 + 1 + 2))
  })
})



================================================
FILE: tests/onchain/extract-bytes.spec.ts
================================================
import { describe } from 'vitest'
import { createBaseTestFixture } from './util/test-fixture'

describe('Extract bytes contract', () => {
  const test = createBaseTestFixture('tests/approvals/extract-bytes.algo.ts', ['ExtractBytesAlgo'])

  test('runs', async ({ ExtractBytesAlgoInvoker }) => {
    await ExtractBytesAlgoInvoker.send()
  })
})



================================================
FILE: tests/onchain/for-loops.spec.ts
================================================
import { describe, expect } from 'vitest'
import { createArc4TestFixture } from './util/test-fixture'

describe('for loops', () => {
  const test = createArc4TestFixture('tests/approvals/for-loops.algo.ts', {
    ForLoopsAlgo: {},
  })

  test('basic', async ({ appClientForLoopsAlgo }) => {
    const r1 = await appClientForLoopsAlgo.send.call({ method: 'test_for_loop', args: [2, 10, 2] })
    expect(r1.return).toBe(2n + 4n + 6n + 8n)
    const r2 = await appClientForLoopsAlgo.send.call({ method: 'test_for_loop', args: [2, 11, 2] })
    expect(r2.return).toBe(2n + 4n + 6n + 8n + 10n)
  })
  test('break', async ({ appClientForLoopsAlgo }) => {
    const r1 = await appClientForLoopsAlgo.send.call({ method: 'test_for_loop_break', args: [2, 10, 2] })
    expect(r1.return).toBe(2n + 4n + 6n)
    const r2 = await appClientForLoopsAlgo.send.call({ method: 'test_for_loop_break', args: [2, 11, 3] })
    expect(r2.return).toBe(2n + 5n + 8n)
  })
  test('continue', async ({ appClientForLoopsAlgo }) => {
    const r1 = await appClientForLoopsAlgo.send.call({ method: 'test_for_loop_continue', args: [0, 20, 3] })
    expect(r1.return).toBe(3n + 6n + 9n + 12n + 18n)
    const r2 = await appClientForLoopsAlgo.send.call({ method: 'test_for_loop_continue', args: [0, 20, 5] })
    expect(r2.return).toBe(0n)
  })
  test('labelled break', async ({ appClientForLoopsAlgo }) => {
    const r1 = await appClientForLoopsAlgo.send.call({ method: 'test_for_loop_labelled', args: [0, 4, 1] })
    expect(r1.return).toBe(BigInt(1 + 2 + 3 + 1 + 2 + 3 + 4 + 2 + 3 + 4 + 5))
  })
})



================================================
FILE: tests/onchain/for-of-loops.spec.ts
================================================
import { describe, expect } from 'vitest'
import { createArc4TestFixture } from './util/test-fixture'

describe('for loops', () => {
  const test = createArc4TestFixture('tests/approvals/for-of-loops.algo.ts', {
    ForOfLoopsAlgo: {},
  })

  test('test_for_of_loop_tuple', async ({ appClientForOfLoopsAlgo }) => {
    const r1 = await appClientForOfLoopsAlgo.send.call({ method: 'test_for_of_loop_tuple', args: [[4, 8, 10]] })
    expect(r1.return).toBe(4n + 8n + 10n)
    const r2 = await appClientForOfLoopsAlgo.send.call({ method: 'test_for_of_loop_tuple', args: [[4, 42, 10]] })
    expect(r2.return).toBe(4n + 42n)
  })
  test('test_for_of_loop_arc4_dynamic_array', async ({ appClientForOfLoopsAlgo }) => {
    const r1 = await appClientForOfLoopsAlgo.send.call({ method: 'test_for_of_loop_arc4_dynamic_array', args: [[4, 8, 10]] })
    expect(r1.return).toBe(4n + 8n + 10n)
    const r2 = await appClientForOfLoopsAlgo.send.call({ method: 'test_for_of_loop_arc4_dynamic_array', args: [[4, 42, 6]] })
    expect(r2.return).toBe(4n + 42n)
  })
  test('test_for_of_loop_arc4_static_array', async ({ appClientForOfLoopsAlgo }) => {
    const r1 = await appClientForOfLoopsAlgo.send.call({ method: 'test_for_of_loop_arc4_static_array', args: [[4, 8, 10, 10, 10]] })
    expect(r1.return).toBe(4n + 8n + 10n + 10n + 10n)
    const r2 = await appClientForOfLoopsAlgo.send.call({ method: 'test_for_of_loop_arc4_static_array', args: [[4, 8, 10, 42, 10]] })
    expect(r2.return).toBe(4n + 8n + 10n + 42n)
  })
  test('test_for_of_loop_native_immutable_array', async ({ appClientForOfLoopsAlgo }) => {
    const r1 = await appClientForOfLoopsAlgo.send.call({ method: 'test_for_of_loop_native_immutable_array', args: [[4, 8, 10]] })
    expect(r1.return).toBe(4n + 8n + 10n)
    const r2 = await appClientForOfLoopsAlgo.send.call({ method: 'test_for_of_loop_native_immutable_array', args: [[42, 8, 10]] })
    expect(r2.return).toBe(42n)
  })
  test('test_for_of_loop_native_mutable_array', async ({ appClientForOfLoopsAlgo }) => {
    const r1 = await appClientForOfLoopsAlgo.send.call({ method: 'test_for_of_loop_native_mutable_array', args: [[4, 8, 10]] })
    expect(r1.return).toBe(4n + 8n + 10n)
    const r2 = await appClientForOfLoopsAlgo.send.call({ method: 'test_for_of_loop_native_mutable_array', args: [[4, 8, 42]] })
    expect(r2.return).toBe(4n + 8n + 42n)
  })
})



================================================
FILE: tests/onchain/global-state.spec.ts
================================================
import { describe } from 'vitest'
import { bigIntToUint8Array, invariant } from '../../src/util'
import { createArc4TestFixture, createBaseTestFixture } from './util/test-fixture'

describe('global state base', () => {
  const test = createBaseTestFixture('tests/approvals/global-state.algo.ts', ['TestContract'])

  test('test runs', async ({ TestContractInvoker, expect }) => {
    const result = await TestContractInvoker.send({
      schema: {
        globalInts: 3,
        globalByteSlices: 2,
      },
      args: [bigIntToUint8Array(123n, 8)],
    })
    const appId = result.confirmations[0].applicationIndex
    invariant(appId !== undefined, 'must have appId')
    const state = await TestContractInvoker.globalState(appId)

    expect(state['TESTSTATE'].value).toEqual(5n)
    expect(state['baseTestState'].value).toEqual('testing 123')
    expect(state['noInitialInt'].value).toEqual(144115188075855872n)
    expect(state['testState'].value).toEqual(123n)
    expect(state['noInitial'].value).toEqual('abc')
  })
})
describe('global state arc4', () => {
  const test = createArc4TestFixture('tests/approvals/global-state.algo.ts', { TestArc4: {} })

  test('arc4 runs', async ({ appClientTestArc4, expect }) => {
    await appClientTestArc4.send.call({ method: 'setState', args: ['key1', 123] })
    await appClientTestArc4.send.call({ method: 'setState', args: ['key2', 456] })
    await appClientTestArc4.send.call({ method: 'setState', args: ['key3', 789] })
    await appClientTestArc4.send.call({ method: 'setState', args: ['key4', 4] })
    await appClientTestArc4.send.call({ method: 'setState', args: ['key5', 5] })

    const state = await appClientTestArc4.getGlobalState()
    expect(state['key1'].value).toBe(123n)
    expect(state['key2'].value).toBe(456n)
    expect(state['key3'].value).toBe(789n)
    expect(state['key4'].value).toBe(4n)
    expect(state['key5'].value).toBe(5n)

    await expect(appClientTestArc4.send.call({ method: 'setState', args: ['key6', 6] })).rejects.toThrow(
      'store integer count 6 exceeds schema',
    )

    await appClientTestArc4.send.call({ method: 'deleteState', args: ['key5'] })
    await appClientTestArc4.send.call({ method: 'setState', args: ['key6', 6] })
  })
})



================================================
FILE: tests/onchain/gtxns.spec.ts
================================================
import { algos } from '@algorandfoundation/algokit-utils'
import { describe, expect } from 'vitest'
import { bigIntToUint8Array } from '../../src/util'
import { createArc4TestFixture } from './util/test-fixture'

describe('gtxns contract', () => {
  const test = createArc4TestFixture('tests/approvals/gtxns.algo.ts', { GtxnsAlgo: {} })
  test('it verifies the txn type', async ({ appClientGtxnsAlgo, algorand, testAccount }) => {
    const call = await appClientGtxnsAlgo.createTransaction.call({ method: 'test', args: [] })

    await algorand
      .newGroup()
      .addPayment({
        amount: algos(1),
        receiver: appClientGtxnsAlgo.appAddress,
        sender: testAccount,
      })
      .addTransaction(call.transactions[0])
      .send()

    await expect(appClientGtxnsAlgo.send.call({ method: 'test', args: [] }), 'If gtxn 0 is not pay, should throw').rejects.toThrow(
      /transaction type is pay/,
    )
  })

  test('it disambiguates union types', async ({ appClientGtxnsAlgo, algorand, testAccount }) => {
    const call = await appClientGtxnsAlgo.createTransaction.call({ method: 'test2', args: [] })

    const result = await algorand
      .newGroup()
      .addPayment({
        amount: algos(1),
        receiver: appClientGtxnsAlgo.appAddress,
        sender: testAccount,
      })
      .addAssetCreate({
        assetName: 'Testing',
        unitName: 'x',
        sender: testAccount,
        total: 1n,
      })
      .addTransaction(call.transactions[0])
      .send()
    expect(result.confirmations[2].logs).toStrictEqual([
      appClientGtxnsAlgo.appAddress.publicKey,
      bigIntToUint8Array(0n, 8),
      bigIntToUint8Array(appClientGtxnsAlgo.appId, 8),
    ])
  })

  test('oca is enum and can be compared to enum values', async ({ appClientGtxnsAlgo }) => {
    const callTest3 = await appClientGtxnsAlgo.createTransaction.call({ method: 'test3', args: [] })

    await appClientGtxnsAlgo.send.call({ method: 'test4', args: [callTest3.transactions[0]] })
  })
})



================================================
FILE: tests/onchain/implicit-create.spec.ts
================================================
import { describe, expect } from 'vitest'
import { createArc4TestFixture } from './util/test-fixture'

describe('implicit-create', () => {
  const test = createArc4TestFixture('tests/approvals/implicit-create.algo.ts', {
    NoBare: {},
    NoNoOp: {},
    ExplicitBareCreateFromBase: {},
    ExplicitAbiCreateFromBase: {},
  })
  test('NoBare can be created', async ({ appFactoryNoBare }) => {
    await appFactoryNoBare.send.bare.create()
  })
  test('NoNoOp can be created', async ({ appFactoryNoNoOp }) => {
    await appFactoryNoNoOp.send.bare.create()
  })
  test('ExplicitBareCreateFromBase can be created', async ({ appFactoryExplicitBareCreateFromBase }) => {
    await appFactoryExplicitBareCreateFromBase.send.bare.create()
  })
  test("ExplicitAbiCreateFromBase can't be created with bare", async ({ appFactoryExplicitAbiCreateFromBase }) => {
    await expect(() => appFactoryExplicitAbiCreateFromBase.send.bare.create()).rejects.toThrowError()
  })
  test('ExplicitAbiCreateFromBase can be created with abi', async ({ appFactoryExplicitAbiCreateFromBase }) => {
    await appFactoryExplicitAbiCreateFromBase.send.create({ method: 'create' })
  })
})



================================================
FILE: tests/onchain/inheritance.spec.ts
================================================
import { describe } from 'vitest'
import { bigIntToUint8Array } from '../../src/util'
import { decodeLogs } from './util/decode-logs'
import { createArc4TestFixture, createBaseTestFixture } from './util/test-fixture'

describe('inheritance', () => {
  describe('non arc4', () => {
    const test = createBaseTestFixture('tests/approvals/inheritance-b.algo.ts', ['ConcreteSimpleContract'])
    test('Simple contract can be created', async ({ ConcreteSimpleContractInvoker, expect }) => {
      const result = await ConcreteSimpleContractInvoker.send({
        args: [bigIntToUint8Array(10n), bigIntToUint8Array(2n)],
      })
      const [returnValue] = decodeLogs(result, ['i'])

      expect(returnValue).toBe(2n * 10n)
    })
  })
  describe('arc4', () => {
    const test = createArc4TestFixture('tests/approvals/inheritance-b.algo.ts', { ConcreteArc4Contract: {} })
    test('ARC4 contract can be created', async ({ appFactoryConcreteArc4Contract }) => {
      await appFactoryConcreteArc4Contract.send.bare.create()
    })
  })
})



================================================
FILE: tests/onchain/itxn.spec.ts
================================================
import { algos, microAlgos } from '@algorandfoundation/algokit-utils'
import { describe } from 'vitest'
import { createArc4TestFixture } from './util/test-fixture'

describe('itxn contract', () => {
  const test = createArc4TestFixture('tests/approvals/itxn.algo.ts', {
    ItxnDemoContract: { funding: algos(2) },
  })

  test('test1 runs', async ({ appClientItxnDemoContract }) => {
    await appClientItxnDemoContract.send.call({ method: 'test1', extraFee: microAlgos(17_000) })
  })

  test('test2 runs', async ({ appClientItxnDemoContract }) => {
    await appClientItxnDemoContract.send.call({ method: 'test2', extraFee: microAlgos(17_000) })
  })

  test('test3 runs', async ({ appClientItxnDemoContract }) => {
    await appClientItxnDemoContract.send.call({ method: 'test3', extraFee: microAlgos(17_000) })
  })

  test('test4 runs', async ({ appClientItxnDemoContract }) => {
    await appClientItxnDemoContract.send.call({ method: 'test4', extraFee: microAlgos(17_000) })
  })
})



================================================
FILE: tests/onchain/local-state.spec.ts
================================================
import { describe, expect } from 'vitest'
import { utf8ToUint8Array } from '../../src/util'
import { createArc4TestFixture } from './util/test-fixture'

describe('local state', () => {
  const test = createArc4TestFixture('tests/approvals/local-state.algo.ts', { LocalStateDemo: {} })

  test('it runs', async ({ appClientLocalStateDemo, appFactoryLocalStateDemo }) => {
    const testArray = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
    const testObj = { a: 123, b: utf8ToUint8Array('bb') }

    // Fails when not opted in
    await expect(appClientLocalStateDemo.send.call({ method: 'setState', args: [testObj, testArray] })).rejects.toThrow('cannot fetch key')

    await appClientLocalStateDemo.send.optIn({ method: 'optIn' })

    await appClientLocalStateDemo.send.call({ method: 'setState', args: [testObj, testArray] })

    const result = await appClientLocalStateDemo.send.call({ method: 'getState' })

    expect(result.return).toStrictEqual({
      localUint: 123n,
      localUint2: 123n,
      localBytes: [...utf8ToUint8Array('bb')],
      localBytes2: [...utf8ToUint8Array('bb')],
      localEncoded: [0n, 1n, 2n, 3n, 4n, 5n, 6n, 7n, 8n, 9n],
    })

    await appClientLocalStateDemo.send.call({ method: 'clearState' })

    await expect(appClientLocalStateDemo.send.call({ method: 'getState' })).rejects.toThrow('Runtime error when executing LocalStateDemo')
  })
})



================================================
FILE: tests/onchain/match-expr.spec.ts
================================================
import { describe } from 'vitest'
import { createArc4TestFixture } from './util/test-fixture'

describe('match expr', () => {
  const test = createArc4TestFixture('tests/approvals/match-expr.algo.ts', {
    MatchExprAlgo: {},
  })
  test('it runs', async ({ appClientMatchExprAlgo }) => {
    await appClientMatchExprAlgo.send.call({ method: 'testMatches', args: [5] })
  })
})



================================================
FILE: tests/onchain/module-constants.spec.ts
================================================
import { describe, expect } from 'vitest'
import { createArc4TestFixture } from './util/test-fixture'

describe('module constants', () => {
  const test = createArc4TestFixture('tests/approvals/module-constants.algo.ts', { ModuleConstantsAlgo: {} })

  test('bool constants work', async ({ appClientModuleConstantsAlgo }) => {
    const result = await appClientModuleConstantsAlgo.send.call({ method: 'getBoolConstants' })

    expect(result.return).toEqual([false, true])
  })
  test('uint64 constants work', async ({ appClientModuleConstantsAlgo }) => {
    const result = await appClientModuleConstantsAlgo.send.call({ method: 'getUintConstants' })

    expect(result.return).toEqual([12n, 8n, 20n, 5n, 0n, 100n, 40n, 2n, 10n, 8n, 2n])
  })
  test('biguint constants work', async ({ appClientModuleConstantsAlgo }) => {
    const result = await appClientModuleConstantsAlgo.send.call({ method: 'getBigUintConstants' })

    expect(result.return).toEqual([12n, 8n, 20n, 5n, 0n, 10n, 8n, 2n])
  })
  test('string constants work', async ({ appClientModuleConstantsAlgo }) => {
    const result = await appClientModuleConstantsAlgo.send.call({ method: 'getStringConstants' })

    expect(result.return).toEqual(['ab'])
  })
})



================================================
FILE: tests/onchain/multi-inheritance.spec.ts
================================================
import { describe, expect } from 'vitest'
import { createArc4TestFixture } from './util/test-fixture'

describe('multi-inheritance', () => {
  const test = createArc4TestFixture('tests/approvals/multi-inheritance.algo.ts', {
    CommonBase: {},
    BaseOne: {},
    BaseTwo: {},
    MultiBases: {},
  })

  test('CommonBase has all state', async ({ appClientCommonBase, expect }) => {
    const state = await appClientCommonBase.state.global.getAll()

    expect(state).toStrictEqual({
      stateCommon: 123n,
    })
  })

  test('BaseOne has all state', async ({ appClientBaseOne, expect }) => {
    const state = await appClientBaseOne.state.global.getAll()

    expect(state).toStrictEqual({
      stateCommon: 123n,
      stateOne: 45n,
    })
  })

  test('BaseTwo has all state', async ({ appClientBaseTwo, expect }) => {
    const state = await appClientBaseTwo.state.global.getAll()

    expect(state).toStrictEqual({
      stateCommon: 123n,
      stateTwo: 'Hello',
    })
  })

  test('Multibase has all state', async ({ appClientMultiBases, expect }) => {
    const state = await appClientMultiBases.state.global.getAll()

    expect(state).toStrictEqual({
      stateCommon: 123n,
      stateMulti: 'Hmmm',
      stateOne: 45n,
      stateTwo: 'Hello',
    })
  })

  test('Multibase methods can all be called', async ({ appClientMultiBases, expect }) => {
    expect((await appClientMultiBases.send.call({ method: 'methodCommon' })).return).toEqual('common')
    expect((await appClientMultiBases.send.call({ method: 'methodOne' })).return).toEqual('base-one')
    expect((await appClientMultiBases.send.call({ method: 'methodTwo' })).return).toEqual('base-two')
    expect((await appClientMultiBases.send.call({ method: 'methodMulti' })).return).toEqual('multi-bases')
  })

  test('MRO is depth first', async ({ appClientMultiBases, expect }) => {
    expect((await appClientMultiBases.send.call({ method: 'b2CantOverride' })).return).toEqual('common')
  })

  test('super.class(...) can be used to target a specific base type', async ({ appClientMultiBases, expect }) => {
    expect((await appClientMultiBases.send.call({ method: 'callB2CantOverride' })).return).toEqual('base-two')
    expect((await appClientMultiBases.send.call({ method: 'callB2Common' })).return).toEqual('common')
  })
})

describe('multi-inheritance 2', () => {
  const test = createArc4TestFixture('tests/approvals/multi-inheritance-2.algo.ts', {
    StoreBoth: {},
  })

  test('Both base functions can be resolved', async ({ appClientStoreBoth }) => {
    await appClientStoreBoth.send.call({ method: 'test', args: ['abc', 123] })

    const state = await appClientStoreBoth.getGlobalState()

    expect(state.stringStore.value).toEqual('abc')
    expect(state.uint64Store.value).toEqual(123n)
  })
})



================================================
FILE: tests/onchain/mutable-arrays.spec.ts
================================================
import { algos } from '@algorandfoundation/algokit-utils'
import { describe } from 'vitest'
import { createArc4TestFixture } from './util/test-fixture'

describe('mutable arrays', () => {
  const test = createArc4TestFixture('tests/approvals/mutable-arrays.algo.ts', {
    MutableArraysAlgo: {},
  })
  test('it runs', async ({ appClientMutableArraysAlgo }) => {
    await appClientMutableArraysAlgo.send.call({ method: 'test', args: [5], extraFee: algos(1) })
  })
})



================================================
FILE: tests/onchain/native-arrays.spec.ts
================================================
import { describe, expect } from 'vitest'
import { createArc4TestFixture } from './util/test-fixture'

describe('native arrays', () => {
  const test = createArc4TestFixture('tests/approvals/native-arrays.algo.ts', {
    NativeArraysAlgo: {},
  })
  test('it runs', async ({ appClientNativeArraysAlgo }) => {
    await appClientNativeArraysAlgo.send.call({ method: 'doThings', args: [] })
  })
  test('works with arc4 values', async ({ appClientNativeArraysAlgo }) => {
    await appClientNativeArraysAlgo.send.call({ method: 'arc4Interop', args: [] })
  })
  test('works with native structs', async ({ appClientNativeArraysAlgo }) => {
    const result = await appClientNativeArraysAlgo.send.call({ method: 'structs', args: [{ x: 5, y: 3 }] })
    expect(result.return).toStrictEqual([[5n, 3n]])
  })
  test('works with booleans', async ({ appClientNativeArraysAlgo }) => {
    expect((await appClientNativeArraysAlgo.send.call({ method: 'booleans' })).return).toStrictEqual([true, false, true])
    expect((await appClientNativeArraysAlgo.send.call({ method: 'booleansStatic' })).return).toStrictEqual([true, false, true])
    expect((await appClientNativeArraysAlgo.send.call({ method: 'arc4Booleans' })).return).toStrictEqual([true, false, true])
    expect((await appClientNativeArraysAlgo.send.call({ method: 'arc4BooleansStatic' })).return).toStrictEqual([true, false, true])
  })
})



================================================
FILE: tests/onchain/ops.spec.ts
================================================
import { describe } from 'vitest'
import { createArc4TestFixture } from './util/test-fixture'

describe('ops', () => {
  const test = createArc4TestFixture('tests/approvals/ops.algo.ts', { MyContract: {} })

  test('runs', async ({ appClientMyContract }) => {
    await appClientMyContract.send.call({ method: 'test' })
  })
})



================================================
FILE: tests/onchain/precompiled.spec.ts
================================================
import { algo } from '@algorandfoundation/algokit-utils'
import { describe } from 'vitest'
import { createArc4TestFixture } from './util/test-fixture'

describe('precompiled', () => {
  describe('un-typed', () => {
    const test = createArc4TestFixture('tests/approvals/precompiled-factory.algo.ts', { HelloFactory: {} })

    test('Hello contract can be deployed', async ({ appClientHelloFactory }) => {
      await appClientHelloFactory.send.call({ method: 'test_compile_contract', extraFee: algo(1) })
    })
    test('HelloTemplate contract can be deployed', async ({ appClientHelloFactory }) => {
      await appClientHelloFactory.send.call({ method: 'test_compile_contract_with_template', extraFee: algo(1) })
    })
    test('HelloTemplateCustomPrefix contract can be deployed', async ({ appClientHelloFactory }) => {
      await appClientHelloFactory.send.call({ method: 'test_compile_contract_with_template_and_custom_prefix', extraFee: algo(1) })
    })
    test('LargeProgram contract can be deployed', async ({ appClientHelloFactory }) => {
      await appClientHelloFactory.send.call({ method: 'test_compile_contract_large', extraFee: algo(1) })
    })
  })
  describe('typed', () => {
    const test = createArc4TestFixture('tests/approvals/precompiled-typed.algo.ts', { HelloFactory: { funding: algo(1) } })

    test('Hello contract can be deployed', async ({ appClientHelloFactory }) => {
      await appClientHelloFactory.send.call({ method: 'test_compile_contract', extraFee: algo(1) })
    })
    test('HelloTemplate contract can be deployed', async ({ appClientHelloFactory }) => {
      await appClientHelloFactory.send.call({ method: 'test_compile_contract_with_template', extraFee: algo(1) })
    })
    test('HelloTemplateCustomPrefix contract can be deployed', async ({ appClientHelloFactory }) => {
      await appClientHelloFactory.send.call({ method: 'test_compile_contract_with_template_and_custom_prefix', extraFee: algo(1) })
    })
    test('LargeProgram contract can be deployed', async ({ appClientHelloFactory }) => {
      await appClientHelloFactory.send.call({ method: 'test_compile_contract_large', extraFee: algo(1) })
    })
    test('Program with txn params can be called', async ({ appClientHelloFactory }) => {
      await appClientHelloFactory.send.call({ method: 'test_call_contract_with_transactions', extraFee: algo(1) })
    })
    test('Program with reference type params can be called', async ({ appClientHelloFactory }) => {
      await appClientHelloFactory.send.call({ method: 'test_call_contract_with_reference_types', extraFee: algo(1) })
    })
  })
})



================================================
FILE: tests/onchain/prefix-postfix-operators.spec.ts
================================================
import { describe } from 'vitest'
import { createArc4TestFixture } from './util/test-fixture'

describe('prefix postfix operators', () => {
  const test = createArc4TestFixture('tests/approvals/prefix-postfix-operators.algo.ts', ['DemoContract'])

  test('it runs', async ({ appClientDemoContract }) => {
    await appClientDemoContract.send.call({ method: 'test' })
  })
})



================================================
FILE: tests/onchain/primitives.spec.ts
================================================
import { describe } from 'vitest'
import { createArc4TestFixture, createBaseTestFixture } from './util/test-fixture'

describe('primitives', () => {
  describe('boolean', () => {
    const test = createBaseTestFixture('tests/approvals/boolean-conversions.algo.ts', ['BooleanConversionsAlgo'])

    test('it can be called', async ({ BooleanConversionsAlgoInvoker }) => {
      await BooleanConversionsAlgoInvoker.send()
    })
  })

  describe('uint64', () => {
    const test = createBaseTestFixture('tests/approvals/uint64-expressions.algo.ts', ['DemoContract'])
    test('can be created', async ({ DemoContractInvoker }) => {
      await DemoContractInvoker.send()
    })
  })
  describe('biguint', () => {
    const test = createBaseTestFixture('tests/approvals/biguint-expressions.algo.ts', ['DemoContract'])
    test('can be created', async ({ DemoContractInvoker }) => {
      await DemoContractInvoker.send()
    })
  })
  describe('bytes', () => {
    const test = createBaseTestFixture('tests/approvals/byte-expressions.algo.ts', ['DemoContract'])
    test('can be created', async ({ DemoContractInvoker }) => {
      await DemoContractInvoker.send()
    })
  })

  describe('strings', () => {
    const test = createArc4TestFixture('tests/approvals/strings.algo.ts', { StringContract: {} })

    test('can be joined', async ({ appClientStringContract, expect }) => {
      const result = await appClientStringContract.send.call({ method: 'join', args: ['hello', 'world'] })
      expect(result.return).toBe('helloworld')
    })
    test('can be interpolated', async ({ appClientStringContract, expect }) => {
      const result = await appClientStringContract.send.call({ method: 'interpolate', args: ['hello'] })
      expect(result.return).toBe('You interpolated hello')
    })
  })
})



================================================
FILE: tests/onchain/property-ordering.spec.ts
================================================
import { describe } from 'vitest'
import { createBaseTestFixture } from './util/test-fixture'

describe('Property ordering', () => {
  const test = createBaseTestFixture('tests/approvals/property-ordering.algo.ts', ['Demo'])

  test('it runs ', async ({ DemoInvoker }) => {
    await DemoInvoker.send()
  })
})



================================================
FILE: tests/onchain/reserve-scratch.spec.ts
================================================
import { describe } from 'vitest'
import { createBaseTestFixture } from './util/test-fixture'

describe('reserve scratch', () => {
  const test = createBaseTestFixture('tests/approvals/reserve-scratch.algo.ts', ['ReserveScratchAlgo', 'SubReserveScratchAlgo'])

  test('ReserveScratchAlgo works', async ({ ReserveScratchAlgoInvoker }) => {
    await ReserveScratchAlgoInvoker.send()
  })
  test('SubReserveScratchAlgo works', async ({ SubReserveScratchAlgoInvoker }) => {
    await SubReserveScratchAlgoInvoker.send()
  })
})



================================================
FILE: tests/onchain/shadowed-variables.spec.ts
================================================
import { describe } from 'vitest'
import { createBaseTestFixture } from './util/test-fixture'

describe('Shadowed variables', () => {
  const test = createBaseTestFixture('tests/approvals/shadowed-variables.algo.ts', ['ShadowedVariablesAlgo'])

  test('Should create and run', async ({ ShadowedVariablesAlgoInvoker }) => {
    await ShadowedVariablesAlgoInvoker.send()
  })
})



================================================
FILE: tests/onchain/single-eval.spec.ts
================================================
import { describe } from 'vitest'
import { createArc4TestFixture } from './util/test-fixture'

describe('single-eval', () => {
  const test = createArc4TestFixture('tests/approvals/single-eval.algo.ts', { SingleEvalAlgo: {} })

  test('Works as expected', async ({ appClientSingleEvalAlgo }) => {
    await appClientSingleEvalAlgo.send.call({ method: 'test' })
  })
})



================================================
FILE: tests/onchain/state-totals.spec.ts
================================================
import { OnApplicationComplete } from 'algosdk'
import { describe, expect } from 'vitest'
import { createArc4TestFixture } from './util/test-fixture'

describe('State totals', () => {
  const test = createArc4TestFixture('tests/approvals/state-totals.algo.ts', {
    ExtendsSubWithTotals: {},
    BaseWithState: {},
    SubClassWithState: {},
    SubClassWithExplicitTotals: {},
  })

  test('BaseWithState has correct totals', ({ appSpecBaseWithState }) => {
    expect(appSpecBaseWithState.state.schema.global.ints).toBe(2)
    expect(appSpecBaseWithState.state.schema.local.bytes).toBe(1)
  })
  test('BaseWithState runs', async ({ appClientBaseWithState }) => {
    await appClientBaseWithState.send.call({ method: 'setState', args: [123] })

    const state = await appClientBaseWithState.getGlobalState()
    expect(state['oneGlobal'].value).toBe(123n)
    expect(state['twoGlobal'].value).toBe(123n)
  })
  test('SubClassWithState has correct totals', ({ appSpecSubClassWithState }) => {
    expect(appSpecSubClassWithState.state.schema.global.ints).toBe(3)
    expect(appSpecSubClassWithState.state.schema.local.bytes).toBe(2)
  })
  test('SubClassWithState runs', async ({ appClientSubClassWithState }) => {
    await appClientSubClassWithState.send.call({ method: 'setState', args: [456] })

    const state = await appClientSubClassWithState.getGlobalState()
    expect(state['oneGlobal'].value).toBe(456n)
    expect(state['twoGlobal'].value).toBe(456n)
    expect(state['threeGlobal'].value).toBe(456n)
  })
  test('SubClassWithExplicitTotals has correct totals', ({ appSpecSubClassWithExplicitTotals }) => {
    expect(appSpecSubClassWithExplicitTotals.state.schema.global.ints).toBe(4)
    expect(appSpecSubClassWithExplicitTotals.state.schema.global.bytes).toBe(0)
    expect(appSpecSubClassWithExplicitTotals.state.schema.local.ints).toBe(0)
    expect(appSpecSubClassWithExplicitTotals.state.schema.local.bytes).toBe(1)
  })
  test('ExtendsSubWithTotals has correct totals', ({ appSpecExtendsSubWithTotals }) => {
    expect(appSpecExtendsSubWithTotals.state.schema.global.ints).toBe(2)
    expect(appSpecExtendsSubWithTotals.state.schema.local.ints).toBe(1)
    expect(appSpecExtendsSubWithTotals.state.schema.local.bytes).toBe(1)
  })
  test('ExtendsSubWithTotals runs', async ({ appClientExtendsSubWithTotals, testAccount }) => {
    await appClientExtendsSubWithTotals.send.call({ method: 'setState', args: [789], onComplete: OnApplicationComplete.OptInOC })

    const state = await appClientExtendsSubWithTotals.getGlobalState()
    expect(state['oneGlobal'].value).toBe(789n)
    expect(state['twoGlobal'].value).toBe(789n)
    const localState = await appClientExtendsSubWithTotals.getLocalState(testAccount)

    expect(localState['oneLocal'].value).toBe(789n)
  })
})



================================================
FILE: tests/onchain/super-calls.spec.ts
================================================
import { describe } from 'vitest'
import { createBaseTestFixture } from './util/test-fixture'

describe('super calls', () => {
  const test = createBaseTestFixture('tests/approvals/super-calls.algo.ts', [
    'SuperContract',
    'SubContract',
    'SubSubContract',
    'SubSubSubContract',
  ])

  test('super contract runs', async ({ SuperContractInvoker }) => {
    await SuperContractInvoker.send({ schema: { globalInts: 1 } })
  })
  test('sub contract runs', async ({ SubContractInvoker }) => {
    await SubContractInvoker.send({ schema: { globalInts: 2 } })
  })
  test('sub sub contract runs', async ({ SubSubContractInvoker }) => {
    await SubSubContractInvoker.send({ schema: { globalInts: 2 } })
  })
  test('sub sub contract runs', async ({ SubSubSubContractInvoker }) => {
    await SubSubSubContractInvoker.send({ schema: { globalInts: 3 } })
  })
})



================================================
FILE: tests/onchain/switch-statements.spec.ts
================================================
import { describe } from 'vitest'
import { createArc4TestFixture } from './util/test-fixture'

describe('switch statements', () => {
  const test = createArc4TestFixture('tests/approvals/switch-statements.algo.ts', { DemoContract: {} })

  test('runs', async ({ appClientDemoContract }) => {
    await appClientDemoContract.send.call({ method: 'run', args: [] })
  })

  test('test_side_effects', async ({ appClientDemoContract }) => {
    await appClientDemoContract.send.call({ method: 'test_side_effects', args: [5] })
  })
})



================================================
FILE: tests/onchain/teal-script-conventions.spec.ts
================================================
import algosdk from 'algosdk'
import { describe, expect } from 'vitest'
import { utf8ToUint8Array } from '../../src/util'
import { createArc4TestFixture } from './util/test-fixture'

describe('teal-script conventions', () => {
  const test = createArc4TestFixture('tests/approvals/teal-script-conventions.algo.ts', {
    TealScriptConventionsAlgo: {},
  })

  test('lifecycle methods are routed as expected', async ({ appFactoryTealScriptConventionsAlgo, testAccount }) => {
    const app = (await appFactoryTealScriptConventionsAlgo.send.create({ method: 'createApplication', args: [utf8ToUint8Array('Hello')] }))
      .appClient

    await app.send.optIn({ method: 'optInToApplication' })

    await app.send.call({ method: 'setLocal', args: ['bananas'] })

    const ls = await app.getLocalState(testAccount)

    expect(ls['local'].value).toBe('bananas')

    const res = await app.send.closeOut({ method: 'noMoreThanks', args: [34] })

    expect(res.return).toBe(34n)

    await expect(app.getLocalState(testAccount)).rejects.toThrow("Couldn't find local state")

    await app.send.bare.delete({})

    const app2 = (
      await appFactoryTealScriptConventionsAlgo.send.create({
        method: 'createApplication',
        args: [utf8ToUint8Array('Hello')],
        onComplete: algosdk.OnApplicationComplete.DeleteApplicationOC,
      })
    ).appClient

    await expect(app2.getGlobalState()).rejects.toThrow('application does not exist')
  })
})



================================================
FILE: tests/onchain/template-vars.spec.ts
================================================
import { Address } from 'algosdk'
import { describe, expect } from 'vitest'
import { hexToUint8Array } from '../../src/util'
import { createArc4TestFixture } from './util/test-fixture'

describe('template var', () => {
  const address = Address.fromString('A7NMWS3NT3IUDMLVO26ULGXGIIOUQ3ND2TXSER6EBGRZNOBOUIQXHIBGDE')

  const templateVars = {
    AN_INT: 356n,
    A_STRING: 'Hello world',
    SOME_BYTES: hexToUint8Array('FF0044'),
    AN_ADDRESS: address.publicKey,
  }
  const test = createArc4TestFixture('tests/approvals/template-var.algo.ts', {
    MyContract: {
      deployParams: {
        deployTimeParams: templateVars,
      },
    },
  })
  test('it runs', async ({ appClientMyContract, testAccount }) => {
    testAccount.addr
    const resultInt = await appClientMyContract.send.call({ method: 'getInt' })
    expect(resultInt.return).toBe(templateVars.AN_INT)
    const resultString = await appClientMyContract.send.call({ method: 'getString' })
    expect(resultString.return).toBe(templateVars.A_STRING)
    const resultBytes = await appClientMyContract.send.call({ method: 'getBytes' })
    expect(resultBytes.return).toStrictEqual(Array.from(templateVars.SOME_BYTES))
    const resultAddress = await appClientMyContract.send.call({ method: 'getAddress' })
    expect(resultAddress.return).toStrictEqual(address.toString())
  })
})



================================================
FILE: tests/onchain/urange.spec.ts
================================================
import { describe, expect } from 'vitest'
import { createArc4TestFixture } from './util/test-fixture'

describe('urange', () => {
  const test = createArc4TestFixture('tests/approvals/urange.algo.ts', { UrangeAlgo: {} })

  test('works with single arg', async ({ appClientUrangeAlgo }) => {
    const result = await appClientUrangeAlgo.send.call({ method: 'testSingleArg' })

    expect(result.return).toEqual([0n, 1n, 2n, 3n, 4n])
  })
  test('works with two arg', async ({ appClientUrangeAlgo }) => {
    const result = await appClientUrangeAlgo.send.call({ method: 'testTwoArg' })

    expect(result.return).toEqual([2n, 3n, 4n])
  })
  test('works with three arg', async ({ appClientUrangeAlgo }) => {
    const result = await appClientUrangeAlgo.send.call({ method: 'testThreeArg' })

    expect(result.return).toEqual([2n, 5n, 8n])
  })
})



================================================
FILE: tests/onchain/while-loops.spec.ts
================================================
import { describe } from 'vitest'
import { createArc4TestFixture } from './util/test-fixture'

describe('while loops', () => {
  const test = createArc4TestFixture('tests/approvals/while-loops.algo.ts', { DemoContract: {} })

  test('runs', async ({ appClientDemoContract, expect }) => {
    const result = await appClientDemoContract.send.call({ method: 'testWhile', args: [10] })

    expect(result.return).toBe(10n)
  })
})



================================================
FILE: tests/onchain/util/decode-logs.ts
================================================
import type { SendAppTransactionResult } from '@algorandfoundation/algokit-utils/types/app'
import { uint8ArrayToBigInt, uint8ArrayToUtf8 } from '../../../src/util'

export type LogDecoding = 'i' | 's' | 'b'

export type DecodedLog<T extends LogDecoding> = T extends 'i' ? bigint : T extends 's' ? string : Uint8Array
export type DecodedLogs<T extends [...LogDecoding[]]> = {
  [Index in keyof T]: DecodedLog<T[Index]>
} & { length: T['length'] }

export function decodeLogs<const T extends [...LogDecoding[]]>(txnResult: SendAppTransactionResult, decoding: T): DecodedLogs<T> {
  return decoding.map((decoding, i) => {
    const log = txnResult.confirmation.logs?.[i]
    if (log === undefined) {
      throw new Error(`Cannot find logs log ${i}`)
    }

    switch (decoding[i]) {
      case 'i':
        return uint8ArrayToBigInt(log)
      case 's':
        return uint8ArrayToUtf8(log)
      default:
        return log
    }
  }) as DecodedLogs<T>
}



================================================
FILE: tests/onchain/util/test-fixture.ts
================================================
import type { AlgorandClient } from '@algorandfoundation/algokit-utils'
import { Config, microAlgos } from '@algorandfoundation/algokit-utils'
import { algorandFixture } from '@algorandfoundation/algokit-utils/testing'
import type { AlgoAmount } from '@algorandfoundation/algokit-utils/types/amount'
import type { AppState, SendAppTransactionResult } from '@algorandfoundation/algokit-utils/types/app'
import type { Arc56Contract } from '@algorandfoundation/algokit-utils/types/app-arc56'
import type { AppClient } from '@algorandfoundation/algokit-utils/types/app-client'
import type { AppFactory, AppFactoryDeployParams } from '@algorandfoundation/algokit-utils/types/app-factory'
import type { AssetCreateParams } from '@algorandfoundation/algokit-utils/types/composer'
import { nullLogger } from '@algorandfoundation/algokit-utils/types/logging'
import type { AlgorandFixture } from '@algorandfoundation/algokit-utils/types/testing'
import type { Use } from '@vitest/runner/types'
import { OnApplicationComplete } from 'algosdk'
import fs from 'fs'
import type { ExpectStatic } from 'vitest'
import { test } from 'vitest'
import { compile, CompileOptions, processInputPaths } from '../../../src'
import { LoggingContext, LogLevel } from '../../../src/logger'
import type { DeliberateAny } from '../../../src/typescript-helpers'
import { invariant } from '../../../src/util'
import { generateTempDir } from '../../../src/util/generate-temp-file'

const algorandTestFixture = (localnetFixture: AlgorandFixture) =>
  test.extend<{
    localnet: AlgorandFixture
    algorand: AlgorandClient
    testAccount: AlgorandFixture['context']['testAccount']
    assetFactory: (assetCreateParams: AssetCreateParams) => Promise<bigint>
  }>({
    localnet: async ({ expect }, use) => {
      await localnetFixture.beforeEach()
      await use(localnetFixture)
    },
    testAccount: async ({ localnet }, use) => {
      await use(localnet.context.testAccount)
    },
    algorand: async ({ localnet }, use) => {
      await use(localnet.context.algorand)
    },
    assetFactory: async ({ localnet }, use) => {
      use(async (assetCreateParams: AssetCreateParams) => {
        const { assetId } = await localnet.algorand.send.assetCreate(assetCreateParams)
        return assetId
      })
    },
  })

function createLazyCompiler(path: string, options: { outputBytecode: boolean; outputArc56: boolean }) {
  let result: CompilationArtifacts | undefined = undefined
  return {
    async getCompileResult(expect: ExpectStatic) {
      if (!result) result = await compilePath(path, expect, options)
      return result
    },
  }
}
type AlgoClientAppCallParams = Parameters<AlgorandClient['send']['appCall']>[0]

type ProgramInvokeOptions = {
  appId?: bigint
  sender?: AlgoClientAppCallParams['sender']
  approvalProgram?: Uint8Array

  clearStateProgram?: Uint8Array
  onComplete?:
    | OnApplicationComplete.NoOpOC
    | OnApplicationComplete.OptInOC
    | OnApplicationComplete.CloseOutOC
    | OnApplicationComplete.ClearStateOC
    | OnApplicationComplete.UpdateApplicationOC
    | OnApplicationComplete.DeleteApplicationOC
  schema?: {
    /** The number of integers saved in global state. */
    globalInts?: number
    /** The number of byte slices saved in global state. */
    globalByteSlices?: number
    /** The number of integers saved in local state. */
    localInts?: number
    /** The number of byte slices saved in local state. */
    localByteSlices?: number
  }
} & Omit<AlgoClientAppCallParams, 'onComplete' | 'sender' | 'appId'>

type ProgramInvoker = {
  globalState(appId: bigint): Promise<AppState>
  send(options?: ProgramInvokeOptions): Promise<SendAppTransactionResult>
}

type BaseFixtureContextFor<T extends string> = {
  [key in T as `${key}Invoker`]: ProgramInvoker
}
export function createBaseTestFixture<TContracts extends string = ''>(path: string, contracts: TContracts[]) {
  const lazyCompile = createLazyCompiler(path, { outputArc56: false, outputBytecode: true })
  const localnet = algorandFixture({
    testAccountFunding: microAlgos(100_000_000_000),
  })

  Config.configure({
    logger: nullLogger,
  })

  const ctx: DeliberateAny = {}
  for (const contractName of contracts) {
    ctx[`${contractName}Invoker`] = async (
      { expect, localnet }: { expect: ExpectStatic; localnet: AlgorandFixture },
      use: Use<ProgramInvoker>,
    ) => {
      const compiled = await lazyCompile.getCompileResult(expect)

      const approvalProgram = compiled.approvalBinaries[contractName]
      const clearStateProgram = compiled.clearStateBinaries[contractName]
      invariant(approvalProgram, `No approval program found for ${contractName}`)
      invariant(clearStateProgram, `No clear state program found for ${contractName}`)

      use({
        async globalState(appId: bigint) {
          return localnet.algorand.app.getGlobalState(appId)
        },

        async send(options?: ProgramInvokeOptions) {
          const common = {
            ...options,
            appId: options?.appId ?? 0n,
            onComplete: options?.onComplete ?? OnApplicationComplete.NoOpOC,
            sender: options?.sender ?? localnet.context.testAccount.addr,
          }
          if (common.appId === 0n || common.onComplete === OnApplicationComplete.UpdateApplicationOC) {
            common.approvalProgram = approvalProgram
            common.clearStateProgram = clearStateProgram
          }
          const group = localnet.algorand.send.newGroup()
          group.addAppCall(common as DeliberateAny)

          // TODO: Add simulate call to gather trace

          const result = await group.send()
          return {
            ...result,
            confirmation: result.confirmations[0],
            transaction: result.transactions[0],
          }
        },
      })
    }
  }
  return algorandTestFixture(localnet).extend<BaseFixtureContextFor<TContracts>>(ctx)
}

type Arc4FixtureContextFor<T extends string> = {
  [key in T as `appFactory${key}`]: AppFactory
} & {
  [key in T as `appClient${key}`]: AppClient
} & {
  [key in T as `appSpec${key}`]: Arc56Contract
}

type ContractConfig = {
  deployParams?: AppFactoryDeployParams
  funding?: AlgoAmount
}

export function createArc4TestFixture<TContracts extends string = ''>(
  path: string,
  contracts: Record<TContracts, ContractConfig> | TContracts[],
) {
  const lazyCompile = createLazyCompiler(path, { outputArc56: true, outputBytecode: false })
  const localnet = algorandFixture({
    testAccountFunding: microAlgos(100_000_000_000),
  })

  Config.configure({
    logger: nullLogger,
  })

  async function getAppSpec(expect: ExpectStatic, contractName: string) {
    const appSpec = (await lazyCompile.getCompileResult(expect)).appSpecs.find((s) => s.name === contractName)
    if (appSpec === undefined) {
      expect.fail(`${path} does not contain an ARC4 contract "${contractName}"`)
    } else {
      return appSpec
    }
  }

  function* getContracts(): Iterable<[name: TContracts, config: ContractConfig]> {
    if (Array.isArray(contracts)) {
      for (const c of contracts) {
        yield [c, {}]
      }
    } else {
      for (const [c, cfg] of Object.entries(contracts) as Array<[TContracts, ContractConfig]>) {
        yield [c, cfg]
      }
    }
  }

  const ctx: DeliberateAny = {}
  for (const [contractName, config] of getContracts()) {
    ctx[`appSpec${contractName}`] = async ({ expect }: { expect: ExpectStatic }, use: Use<Arc56Contract>) => {
      await use(await getAppSpec(expect, contractName))
    }

    ctx[`appFactory${contractName}`] = async (
      { expect, localnet }: { expect: ExpectStatic; localnet: AlgorandFixture },
      use: Use<AppFactory>,
    ) => {
      const appSpec = await getAppSpec(expect, contractName)
      await use(
        localnet.algorand.client.getAppFactory({
          defaultSender: localnet.context.testAccount.addr,
          appSpec: appSpec!,
        }),
      )
    }
    ctx[`appClient${contractName}`] = async (
      { expect, localnet }: { expect: ExpectStatic; localnet: AlgorandFixture },
      use: Use<AppClient>,
    ) => {
      const appSpec = await getAppSpec(expect, contractName)
      const appFactory = localnet.algorand.client.getAppFactory({
        defaultSender: localnet.context.testAccount.addr,
        appSpec: appSpec!,
      })
      const { appClient } = await appFactory.deploy(config.deployParams ?? {})
      if (config.funding) await appClient.fundAppAccount({ amount: config.funding })
      await use(appClient)
    }
  }
  return algorandTestFixture(localnet).extend<Arc4FixtureContextFor<TContracts>>(ctx)
}

type CompilationArtifacts = {
  appSpecs: Arc56Contract[]
  approvalBinaries: Record<string, Uint8Array>
  clearStateBinaries: Record<string, Uint8Array>
}

async function compilePath(
  path: string,
  expect: ExpectStatic,
  options: { outputBytecode: boolean; outputArc56: boolean },
): Promise<CompilationArtifacts> {
  using tempDir = generateTempDir()
  const logCtx = LoggingContext.create()

  return await logCtx.run(async () => {
    const filePaths = processInputPaths({ paths: [path], outDir: tempDir.dirPath })
    await compile(
      new CompileOptions({
        filePaths,
        logLevel: LogLevel.Error,
        skipVersionCheck: true,
        outputArc32: false,
        outputTeal: false,
        outputSourceMap: true,
        optimizationLevel: 0,
        ...options,
      }),
    )
    for (const log of logCtx.logEvents) {
      switch (log.level) {
        case LogLevel.Error:
        case LogLevel.Critical:
          expect.fail(`Compilation error ${log.sourceLocation} [${log.level}]: ${log.message}`)
      }
    }

    const matchBinary = /(?<appName>[^\\/]+)\.(?<programName>(approval)|(clear))\.bin$/
    const appSpecs = new Array<Arc56Contract>()
    const approvalBinaries: Record<string, Uint8Array> = {}
    const clearStateBinaries: Record<string, Uint8Array> = {}
    for (const filePath of tempDir.files()) {
      if (filePath.endsWith('.arc56.json')) {
        appSpecs.push(JSON.parse(fs.readFileSync(filePath, 'utf-8')))
      } else {
        const m = matchBinary.exec(filePath)
        if (m?.groups) {
          const { appName, programName } = m.groups
          const binary = new Uint8Array(fs.readFileSync(filePath))
          if (programName === 'approval') {
            approvalBinaries[appName] = binary
          } else {
            clearStateBinaries[appName] = binary
          }
        }
      }
    }

    return {
      appSpecs,
      approvalBinaries,
      clearStateBinaries,
    }
  })
}



================================================
FILE: .github/dependabot.yml
================================================
# To get started with Dependabot version updates, you'll need to specify which
# package ecosystems to update and where the package manifests are located.
# Please see the documentation for all configuration options:
# https://docs.github.com/code-security/dependabot/dependabot-version-updates/configuration-options-for-the-dependabot.yml-file

version: 2
updates:
  - package-ecosystem: "npm"
    directory: "/"
    schedule:
      interval: "weekly"



================================================
FILE: .github/ISSUE_TEMPLATE/bug_report.md
================================================
---
name: "\U0001F41C Bug report"
about: Report a reproducible bug.
title: ''
labels: new-bug
assignees: ''
---

### Subject of the issue

<!-- Describe your issue here. -->

### Your environment

<!--
* Please provide the output of `algokit doctor` command response,
* This will give us a good idea about your environment
-->

### Steps to reproduce

1.
2.

### Expected behaviour

### Actual behaviour



================================================
FILE: .github/ISSUE_TEMPLATE/feature_request.md
================================================
---
name: "\U0001F514 Feature Request"
about: Suggestions for how we can improve the algorand platform.
title: ''
labels: new-feature-request
assignees: ''
---

## Problem

<!-- What is the problem that we’re trying to solve? -->

## Solution

<!-- Do you have a potential/suggested solution? Document more than one if possible. -->

### Proposal

<!-- Describe the solution you’d like in detail. -->

### Pros and Cons

<!-- What are the advantages and disadvantages of this solution? -->

## Dependencies

<!-- Does the solution have any team or design dependencies? -->



================================================
FILE: .github/workflows/ci-all.yml
================================================
on:
  workflow_call:
    inputs:
      run-commit-lint:
        required: false
        type: boolean
        default: false

jobs:
  ci-algo-ts:
    name: 'Build @algorandfoundation/algorand-typescript'
    uses: ./.github/workflows/node-ci.yml
    with:
      node-version: 22.x
      run-build: true
      audit-script: npm run audit
      working-directory: packages/algo-ts
      upload-artifact-name: algo-ts
      upload-artifact-path: ./packages/algo-ts/dist

  ci-puya-ts:
    name: 'Build @algorandfoundation/puya-ts'
    uses: ./.github/workflows/node-ci.yml
    needs:
      - ci-algo-ts
    with:
      download-artifact-pattern: algo-*
      download-artifact-path: ./packages-temp
      pre-run-script: mv packages-temp/algo-ts packages/algo-ts/dist
      node-version: 22.x
      run-build: true
      run-commit-lint: ${{ inputs.run-commit-lint }}
      build-script: npm run build
      audit-script: npm run audit
      upload-artifact-name: puya-ts
      upload-artifact-path: ./dist
      python-version: 3.12.6
      pre-test-script: |
        pipx install algokit --python 3.12.6
        algokit localnet reset --update
      test-script: npm run test:ci
      output-test-results: true



================================================
FILE: .github/workflows/gh-pages.yml
================================================
name: "Run typedoc and publish to pages"

on:
  push:
    branches:
      - main
jobs:
  build-and-publish-docs:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pages: write
      id-token: write
    steps:
      - name: Checkout source code
        uses: actions/checkout@v4

      - name: Use Node.js 21.x
        uses: actions/setup-node@v4
        with:
          node-version: 21.x

      - name: Npm install
        run: npm ci --ignore-scripts

      - name: Build doc
        run: npm run script:documentation

      - name: Upload to GitHub pages
        uses: actions/upload-pages-artifact@v3
        with:
          path: docs/_html

      - name: Deploy to GitHub Pages
        uses: actions/deploy-pages@v4



================================================
FILE: .github/workflows/node-ci.yml
================================================
on:
  workflow_call:
    inputs:
      node-version:
        required: false
        type: string
        default: 18.x
      python-version:
        required: false
        type: string
      working-directory:
        required: false
        type: string
        default: '.'
      lint-script:
        required: false
        type: string
        default: npm run lint --if-present
      compile-script:
        required: false
        type: string
        default: npm run check-types --if-present
      pre-test-script:
        required: false
        type: string
      test-script:
        required: false
        type: string
        default: npm run test --if-present
      test-environment-variables:
        required: false
        type: string
        default: '{}'
      output-test-results:
        required: false
        type: boolean
        default: false
      test-results-file-pattern:
        required: false
        type: string
        default: '**/test-results.xml'
      audit-script:
        required: false
        type: string
        default: npm audit
      build-script:
        required: false
        type: string
        default: npm run build
      post-build-script:
        required: false
        type: string
      run-build:
        required: false
        type: boolean
        default: false
      run-commit-lint:
        required: false
        type: boolean
        default: false
      commit-lint-script:
        required: false
        type: string
        default: npx commitlint --from ${{ github.event.pull_request.base.sha }} --to ${{ github.event.pull_request.head.sha }} --verbose
      pre-run-script:
        required: false
        type: string
      upload-artifact-name:
        required: false
        type: string
      upload-artifact-path:
        required: false
        description: The full path to the artifact directory, this path does not take working-directory into account
        type: string
        default: .

      download-artifact-name:
        required: false
        type: string
      download-artifact-pattern:
        required: false
        type: string
      download-artifact-path:
        required: false
        description: The full path to the artifact directory, this path does not take working-directory into account
        type: string
        default: .

    secrets:
      npm-auth-token:
        description: NPM auth token (don't pass in on a PR build on a public repository)
        required: false

jobs:
  node-ci:
    runs-on: ubuntu-latest

    defaults:
      run:
        shell: bash
        working-directory: ${{ inputs.working-directory }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      # setup node + private repo access
      - name: Use Node.js ${{ inputs.node-version }}
        uses: actions/setup-node@v4
        with:
          node-version: ${{ inputs.node-version }}
          registry-url: 'https://npm.pkg.github.com'
          scope: '@makerxstudio'
          cache: 'npm'
          cache-dependency-path: ${{ inputs.working-directory }}/package-lock.json

      - name: Set up Python
        if: ${{ inputs.python-version }}
        uses: actions/setup-python@v5
        with:
          python-version: ${{ inputs.python-version }}

      - name: Download artifacts
        if: ${{ inputs.download-artifact-name || inputs.download-artifact-pattern }}
        uses: actions/download-artifact@v4
        with:
          name: ${{ inputs.download-artifact-name }}
          pattern: ${{ inputs.download-artifact-pattern }}
          path: ${{ inputs.download-artifact-path }}

      - name: Pre-run
        if: ${{ inputs.pre-run-script }}
        run: ${{ inputs.pre-run-script }}

      # run npm ci preventing script access to npm auth token
      - run: npm ci --ignore-scripts
        env:
          NODE_AUTH_TOKEN: ${{ secrets.npm-auth-token || secrets.GITHUB_TOKEN }}
      # allow scripts to run without npm auth token
      - run: npm rebuild && npm run prepare --if-present

      # run all the CI scripts
      - name: 'Commit lint'
        if: ${{ inputs.run-commit-lint }}
        run: ${{ inputs.commit-lint-script }}

      - name: Lint
        run: ${{ inputs.lint-script }}

      - name: Compile
        run: ${{ inputs.compile-script }}

      - name: Pre-test
        if: ${{ inputs.pre-test-script }}
        run: ${{ inputs.pre-test-script }}

      - name: Test
        run: ${{ inputs.test-script }}
        env: ${{ fromJson(inputs.test-environment-variables) }}

        #Requires permissions.checks: write
      - name: Publish test results
        if: ${{ inputs.output-test-results && always() }}
        uses: phoenix-actions/test-reporting@v15
        with:
          name: Test results
          path: ${{ inputs.test-results-file-pattern }}
          reporter: jest-junit
          output-to: checks
          fail-on-error: false

      - name: Audit
        run: ${{ inputs.audit-script }}

      - name: Build
        if: ${{ inputs.run-build }}
        run: ${{ inputs.build-script }}
        # CDK infrastructure build calls npm ci on /infrastructure/build, which may fail without NODE_AUTH_TOKEN
        env:
          NODE_AUTH_TOKEN: ${{ secrets.npm-auth-token || secrets.GITHUB_TOKEN }}

      - name: Post build
        if: ${{ inputs.post-build-script }}
        run: ${{ inputs.post-build-script }}

      - name: Publish artifact
        if: ${{ inputs.upload-artifact-name }}
        uses: actions/upload-artifact@v4
        with:
          name: ${{ inputs.upload-artifact-name }}
          path: ${{ inputs.upload-artifact-path }}



================================================
FILE: .github/workflows/pr.yml
================================================
name: Pull Request

on:
  pull_request:
    branches:
      - main
      - alpha
    paths-ignore:
      - 'docs/**'
      - 'scripts/**'


permissions:
  contents: read
  checks: write

jobs:
  ci-all:
    name: 'Build and test all packages'
    uses: ./.github/workflows/ci-all.yml
    with:
      run-commit-lint: true



================================================
FILE: .github/workflows/release.yml
================================================
name: Publish

on:
  push:
    branches:
      - alpha
      - main
      - release
  workflow_dispatch:

concurrency: release

permissions:
  contents: write
  issues: write
  pull-requests: write
  checks: write

jobs:
  ci:
    name: Build and test
    uses: ./.github/workflows/ci-all.yml
    with:
      run-commit-lint: false

  release:
    name: Release
    needs: ci
    runs-on: ubuntu-latest
    steps:
      - name: Generate bot token
        uses: actions/create-github-app-token@v1
        id: app_token
        with:
          app-id: ${{ secrets.BOT_ID }}
          private-key: ${{ secrets.BOT_SK }}

      - name: Clone repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ steps.app_token.outputs.token }}

      - name: Use Node.js 22.x
        uses: actions/setup-node@v4
        with:
          node-version: 22.x

      - run: npm ci --ignore-scripts

      - name: Download package artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts

      - name: Generate semantic version for @algorandfoundation/puya-ts
        run: npx semantic-release
        env:
          GITHUB_TOKEN: ${{ steps.app_token.outputs.token }}

      - name: Copy puya-ts version to algo-ts
        run: |
          cd artifacts/puya-ts
          newVersion=$(npm view ./ version)
          npm pkg set dependencies.@algorandfoundation/algorand-typescript=$newVersion
          cd ../algo-ts
          npm pkg set version=$newVersion

      - name: Publish @algorandfoundation/algorand-typescript
        uses: JS-DevTools/npm-publish@v3
        id: publish-algo-ts
        with:
          token: ${{ secrets.NPM_TOKEN }}
          package: artifacts/algo-ts/package.json
          access: 'public'
          # Tagging 'main' branch with latest for now, even though it's beta because we don't have a non-beta
          tag: ${{ github.ref_name == 'alpha' && 'alpha' || github.ref_name == 'main' && 'latest' || github.ref_name == 'release' && 'latest' || 'pre-release' }}



      - name: Publish @algorandfoundation/puya-ts
        uses: JS-DevTools/npm-publish@v3
        id: publish-puya-ts
        with:
          token: ${{ secrets.NPM_TOKEN }}
          package: artifacts/puya-ts/package.json
          access: 'public'
          # Tagging 'main' branch with latest for now, even though it's beta because we don't have a non-beta
          tag: ${{ github.ref_name == 'alpha' && 'alpha' || github.ref_name == 'main' && 'latest' || github.ref_name == 'release' && 'latest' || 'pre-release' }}


