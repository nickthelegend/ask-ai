Directory structure:
└── algorand-pyteal/
    ├── README.md
    ├── CHANGELOG.md
    ├── CODE_OF_CONDUCT.md
    ├── CONTRIBUTING.md
    ├── docker-compose.yml
    ├── LICENSE
    ├── Makefile
    ├── mypy.ini
    ├── pytest.ini
    ├── release-process.md
    ├── requirements.txt
    ├── setup.py
    ├── .flake8
    ├── .readthedocs.yaml
    ├── docs/
    │   ├── README.md
    │   ├── accessing_transaction_field.rst
    │   ├── api.rst
    │   ├── arithmetic_expression.rst
    │   ├── assets.rst
    │   ├── byte_expression.rst
    │   ├── compiler_optimization.rst
    │   ├── conf.py
    │   ├── control_structures.rst
    │   ├── crypto.rst
    │   ├── data_type.rst
    │   ├── examples.rst
    │   ├── index.rst
    │   ├── installation.rst
    │   ├── loading_group_transaction.rst
    │   ├── make.bat
    │   ├── Makefile
    │   ├── opup.rst
    │   ├── overview.rst
    │   ├── requirements.txt
    │   ├── scratch.rst
    │   ├── sourcemap.rst
    │   ├── state.rst
    │   └── versions.rst
    ├── examples/
    │   ├── __init__.py
    │   ├── application/
    │   │   ├── __init__.py
    │   │   ├── asset.py
    │   │   ├── opup.py
    │   │   ├── security_token.py
    │   │   ├── sourcemap.py
    │   │   ├── vote.py
    │   │   ├── vote_deploy.py
    │   │   ├── abi/
    │   │   │   ├── __init__.py
    │   │   │   ├── algobank.json
    │   │   │   ├── algobank.py
    │   │   │   ├── algobank_approval.teal
    │   │   │   └── algobank_clear_state.teal
    │   │   └── teal/
    │   │       ├── sourcemap.teal
    │   │       └── sourcemap_annotated.teal
    │   └── signature/
    │       ├── __init__.py
    │       ├── atomic_swap.py
    │       ├── atomic_swap.teal
    │       ├── basic.py
    │       ├── basic.teal
    │       ├── dutch_auction.py
    │       ├── dutch_auction.teal
    │       ├── factorizer_game.py
    │       ├── periodic_payment.py
    │       ├── periodic_payment.teal
    │       ├── periodic_payment_deploy.py
    │       ├── recurring_swap.py
    │       ├── recurring_swap.teal
    │       ├── recurring_swap_deploy.py
    │       ├── split.py
    │       └── split.teal
    ├── feature_gates/
    │   └── __init__.py
    ├── pyteal/
    │   ├── __init__.py
    │   ├── __init__.pyi
    │   ├── config.py
    │   ├── errors.py
    │   ├── py.typed
    │   ├── stack_frame.py
    │   ├── stack_frame_test.py
    │   ├── types.py
    │   ├── types_test.py
    │   ├── util.py
    │   ├── ast/
    │   │   ├── __init__.py
    │   │   ├── abstractvar.py
    │   │   ├── acct.py
    │   │   ├── acct_test.py
    │   │   ├── addr.py
    │   │   ├── addr_test.py
    │   │   ├── app.py
    │   │   ├── app_test.py
    │   │   ├── arg.py
    │   │   ├── arg_test.py
    │   │   ├── array.py
    │   │   ├── assert_.py
    │   │   ├── assert_test.py
    │   │   ├── asset.py
    │   │   ├── asset_test.py
    │   │   ├── base64decode.py
    │   │   ├── base64decode_test.py
    │   │   ├── binaryexpr.py
    │   │   ├── binaryexpr_test.py
    │   │   ├── block.py
    │   │   ├── block_test.py
    │   │   ├── box.py
    │   │   ├── box_test.py
    │   │   ├── break_.py
    │   │   ├── break_test.py
    │   │   ├── bytes.py
    │   │   ├── bytes_test.py
    │   │   ├── comment.py
    │   │   ├── comment_test.py
    │   │   ├── cond.py
    │   │   ├── cond_test.py
    │   │   ├── continue_.py
    │   │   ├── continue_test.py
    │   │   ├── ec.py
    │   │   ├── ec_test.py
    │   │   ├── ecdsa.py
    │   │   ├── ecdsa_test.py
    │   │   ├── err.py
    │   │   ├── err_test.py
    │   │   ├── expr.py
    │   │   ├── for_.py
    │   │   ├── for_test.py
    │   │   ├── frame.py
    │   │   ├── frame_test.py
    │   │   ├── gaid.py
    │   │   ├── gaid_test.py
    │   │   ├── gitxn.py
    │   │   ├── gitxn_test.py
    │   │   ├── gload.py
    │   │   ├── gload_test.py
    │   │   ├── global_.py
    │   │   ├── global_test.py
    │   │   ├── gtxn.py
    │   │   ├── gtxn_test.py
    │   │   ├── if_.py
    │   │   ├── if_test.py
    │   │   ├── int.py
    │   │   ├── int_test.py
    │   │   ├── itxn.py
    │   │   ├── itxn_test.py
    │   │   ├── jsonref.py
    │   │   ├── jsonref_test.py
    │   │   ├── leafexpr.py
    │   │   ├── maybe.py
    │   │   ├── maybe_test.py
    │   │   ├── methodsig.py
    │   │   ├── methodsig_test.py
    │   │   ├── mimc.py
    │   │   ├── mimc_test.py
    │   │   ├── multi.py
    │   │   ├── multi_test.py
    │   │   ├── naryexpr.py
    │   │   ├── naryexpr_test.py
    │   │   ├── nonce.py
    │   │   ├── nonce_test.py
    │   │   ├── opup.py
    │   │   ├── opup_test.py
    │   │   ├── pragma.py
    │   │   ├── pragma_test.py
    │   │   ├── replace.py
    │   │   ├── replace_test.py
    │   │   ├── return_.py
    │   │   ├── return_test.py
    │   │   ├── router_test.py
    │   │   ├── scratch.py
    │   │   ├── scratch_test.py
    │   │   ├── scratchvar.py
    │   │   ├── scratchvar_test.py
    │   │   ├── seq.py
    │   │   ├── seq_test.py
    │   │   ├── stake.py
    │   │   ├── stake_test.py
    │   │   ├── subroutine.py
    │   │   ├── substring.py
    │   │   ├── substring_test.py
    │   │   ├── ternaryexpr.py
    │   │   ├── ternaryexpr_test.py
    │   │   ├── tmpl.py
    │   │   ├── tmpl_test.py
    │   │   ├── txn.py
    │   │   ├── txn_test.py
    │   │   ├── unaryexpr.py
    │   │   ├── unaryexpr_test.py
    │   │   ├── voter.py
    │   │   ├── voter_test.py
    │   │   ├── vrfverify.py
    │   │   ├── vrfverify_test.py
    │   │   ├── while_.py
    │   │   ├── while_test.py
    │   │   ├── widemath.py
    │   │   └── abi/
    │   │       ├── __init__.py
    │   │       ├── address.py
    │   │       ├── address_test.py
    │   │       ├── array_base.py
    │   │       ├── array_base_test.py
    │   │       ├── array_dynamic.py
    │   │       ├── array_dynamic_test.py
    │   │       ├── array_static.py
    │   │       ├── array_static_test.py
    │   │       ├── bool.py
    │   │       ├── bool_test.py
    │   │       ├── method_return.py
    │   │       ├── method_return_test.py
    │   │       ├── reference_type.py
    │   │       ├── reference_type_test.py
    │   │       ├── string.py
    │   │       ├── string_test.py
    │   │       ├── transaction.py
    │   │       ├── transaction_test.py
    │   │       ├── tuple.py
    │   │       ├── tuple_test.py
    │   │       ├── type.py
    │   │       ├── type_test.py
    │   │       ├── uint.py
    │   │       ├── uint_test.py
    │   │       ├── util.py
    │   │       └── util_test.py
    │   ├── compiler/
    │   │   ├── __init__.py
    │   │   ├── compiler.py
    │   │   ├── compiler_test.py
    │   │   ├── constants.py
    │   │   ├── constants_test.py
    │   │   ├── flatten.py
    │   │   ├── flatten_test.py
    │   │   ├── scratchslots.py
    │   │   ├── scratchslots_test.py
    │   │   ├── sort.py
    │   │   ├── sort_test.py
    │   │   ├── subroutines.py
    │   │   └── optimizer/
    │   │       ├── __init__.py
    │   │       ├── optimizer.py
    │   │       └── optimizer_test.py
    │   ├── ir/
    │   │   ├── __init__.py
    │   │   ├── labelref.py
    │   │   ├── ops.py
    │   │   ├── tealblock.py
    │   │   ├── tealblock_test.py
    │   │   ├── tealcomponent.py
    │   │   ├── tealcomponent_test.py
    │   │   ├── tealconditionalblock.py
    │   │   ├── tealconditionalblock_test.py
    │   │   ├── teallabel.py
    │   │   ├── tealop.py
    │   │   ├── tealpragma.py
    │   │   ├── tealpragma_test.py
    │   │   ├── tealsimpleblock.py
    │   │   └── tealsimpleblock_test.py
    │   └── pragma/
    │       ├── __init__.py
    │       ├── pragma.py
    │       └── pragma_test.py
    ├── scripts/
    │   └── generate_init.py
    ├── tests/
    │   ├── __init__.py
    │   ├── abi_roundtrip.py
    │   ├── blackbox.py
    │   ├── compile_asserts.py
    │   ├── mock_version.py
    │   ├── integration/
    │   │   ├── __init__.py
    │   │   ├── abi_roundtrip_test.py
    │   │   ├── abi_router_test.py
    │   │   ├── algod_test.py
    │   │   ├── ecdsa_test.py
    │   │   ├── graviton_abi_test.py
    │   │   ├── graviton_test.py
    │   │   ├── opup_test.py
    │   │   ├── pure_logicsig_test.py
    │   │   ├── sourcemap_monkey_integ_test.py
    │   │   └── teal/
    │   │       ├── annotated/
    │   │       │   ├── AlgoBank_h0_c0.tealf
    │   │       │   ├── AlgoBank_h0_c1.tealf
    │   │       │   ├── AlgoBank_h1_c0.tealf
    │   │       │   └── AlgoBank_h1_c1.tealf
    │   │       ├── roundtrip/
    │   │       │   ├── app_roundtrip_((uint64,byte[],uint64[1]))_v6.teal
    │   │       │   ├── app_roundtrip_((uint64,byte[],uint64[1]))_v8.teal
    │   │       │   ├── app_roundtrip_()_v6.teal
    │   │       │   ├── app_roundtrip_()_v8.teal
    │   │       │   ├── app_roundtrip_(bool)[10]_v6.teal
    │   │       │   ├── app_roundtrip_(bool)[10]_v8.teal
    │   │       │   ├── app_roundtrip_(bool)_v6.teal
    │   │       │   ├── app_roundtrip_(bool)_v8.teal
    │   │       │   ├── app_roundtrip_(bool,address,(uint64,bool),byte[10],bool[4],uint64)_v6.teal
    │   │       │   ├── app_roundtrip_(bool,address,(uint64,bool),byte[10],bool[4],uint64)_v8.teal
    │   │       │   ├── app_roundtrip_(bool,byte)_v6.teal
    │   │       │   ├── app_roundtrip_(bool,byte)_v8.teal
    │   │       │   ├── app_roundtrip_(bool,byte,address,string)_v6.teal
    │   │       │   ├── app_roundtrip_(bool,byte,address,string)_v8.teal
    │   │       │   ├── app_roundtrip_(bool,byte,address,string,(address,(uint32,string[],bool[2],(byte),uint8)[2],string,bool[]))[]_2_v6.teal
    │   │       │   ├── app_roundtrip_(bool,byte,address,string,(address,(uint32,string[],bool[2],(byte),uint8)[2],string,bool[]))[]_2_v8.teal
    │   │       │   ├── app_roundtrip_(bool,byte,address,string,uint64)_v6.teal
    │   │       │   ├── app_roundtrip_(bool,byte,address,string,uint64)_v8.teal
    │   │       │   ├── app_roundtrip_(bool,uint64,uint32)_v6.teal
    │   │       │   ├── app_roundtrip_(bool,uint64,uint32)_v8.teal
    │   │       │   ├── app_roundtrip_(byte)_v6.teal
    │   │       │   ├── app_roundtrip_(byte)_v8.teal
    │   │       │   ├── app_roundtrip_(byte,bool,uint64)_v6.teal
    │   │       │   ├── app_roundtrip_(byte,bool,uint64)_v8.teal
    │   │       │   ├── app_roundtrip_(byte[4],(bool,bool),uint64,address)[]_7_v6.teal
    │   │       │   ├── app_roundtrip_(byte[4],(bool,bool),uint64,address)[]_7_v8.teal
    │   │       │   ├── app_roundtrip_(byte[],byte[3])_v6.teal
    │   │       │   ├── app_roundtrip_(byte[],byte[3])_v8.teal
    │   │       │   ├── app_roundtrip_(uint16)_v6.teal
    │   │       │   ├── app_roundtrip_(uint16)_v8.teal
    │   │       │   ├── app_roundtrip_(uint16,uint8,byte)_v6.teal
    │   │       │   ├── app_roundtrip_(uint16,uint8,byte)_v8.teal
    │   │       │   ├── app_roundtrip_(uint32)_v6.teal
    │   │       │   ├── app_roundtrip_(uint32)_v8.teal
    │   │       │   ├── app_roundtrip_(uint32,uint16,uint8)_v6.teal
    │   │       │   ├── app_roundtrip_(uint32,uint16,uint8)_v8.teal
    │   │       │   ├── app_roundtrip_(uint64)_v6.teal
    │   │       │   ├── app_roundtrip_(uint64)_v8.teal
    │   │       │   ├── app_roundtrip_(uint64,uint32,uint16)_v6.teal
    │   │       │   ├── app_roundtrip_(uint64,uint32,uint16)_v8.teal
    │   │       │   ├── app_roundtrip_(uint8)_v6.teal
    │   │       │   ├── app_roundtrip_(uint8)_v8.teal
    │   │       │   ├── app_roundtrip_(uint8,byte,bool)_v6.teal
    │   │       │   ├── app_roundtrip_(uint8,byte,bool)_v8.teal
    │   │       │   ├── app_roundtrip_address[]_10_v6.teal
    │   │       │   ├── app_roundtrip_address[]_10_v8.teal
    │   │       │   ├── app_roundtrip_address_v6.teal
    │   │       │   ├── app_roundtrip_address_v8.teal
    │   │       │   ├── app_roundtrip_bool[1]_v6.teal
    │   │       │   ├── app_roundtrip_bool[1]_v8.teal
    │   │       │   ├── app_roundtrip_bool[3][]_11_v6.teal
    │   │       │   ├── app_roundtrip_bool[3][]_11_v8.teal
    │   │       │   ├── app_roundtrip_bool[42]_v6.teal
    │   │       │   ├── app_roundtrip_bool[42]_v8.teal
    │   │       │   ├── app_roundtrip_bool[]_0_v6.teal
    │   │       │   ├── app_roundtrip_bool[]_0_v8.teal
    │   │       │   ├── app_roundtrip_bool[]_1_v6.teal
    │   │       │   ├── app_roundtrip_bool[]_1_v8.teal
    │   │       │   ├── app_roundtrip_bool[]_42_v6.teal
    │   │       │   ├── app_roundtrip_bool[]_42_v8.teal
    │   │       │   ├── app_roundtrip_bool_v6.teal
    │   │       │   ├── app_roundtrip_bool_v8.teal
    │   │       │   ├── app_roundtrip_byte[16]_v6.teal
    │   │       │   ├── app_roundtrip_byte[16]_v8.teal
    │   │       │   ├── app_roundtrip_byte[]_36_v6.teal
    │   │       │   ├── app_roundtrip_byte[]_36_v8.teal
    │   │       │   ├── app_roundtrip_byte_v6.teal
    │   │       │   ├── app_roundtrip_byte_v8.teal
    │   │       │   ├── app_roundtrip_string_0_v6.teal
    │   │       │   ├── app_roundtrip_string_0_v8.teal
    │   │       │   ├── app_roundtrip_string_13_v6.teal
    │   │       │   ├── app_roundtrip_string_13_v8.teal
    │   │       │   ├── app_roundtrip_string_1_v6.teal
    │   │       │   ├── app_roundtrip_string_1_v8.teal
    │   │       │   ├── app_roundtrip_uint16_v6.teal
    │   │       │   ├── app_roundtrip_uint16_v8.teal
    │   │       │   ├── app_roundtrip_uint32_v6.teal
    │   │       │   ├── app_roundtrip_uint32_v8.teal
    │   │       │   ├── app_roundtrip_uint64[1]_v6.teal
    │   │       │   ├── app_roundtrip_uint64[1]_v8.teal
    │   │       │   ├── app_roundtrip_uint64[42]_v6.teal
    │   │       │   ├── app_roundtrip_uint64[42]_v8.teal
    │   │       │   ├── app_roundtrip_uint64[]_0_v6.teal
    │   │       │   ├── app_roundtrip_uint64[]_0_v8.teal
    │   │       │   ├── app_roundtrip_uint64[]_1_v6.teal
    │   │       │   ├── app_roundtrip_uint64[]_1_v8.teal
    │   │       │   ├── app_roundtrip_uint64[]_42_v6.teal
    │   │       │   ├── app_roundtrip_uint64[]_42_v8.teal
    │   │       │   ├── app_roundtrip_uint64_v6.teal
    │   │       │   ├── app_roundtrip_uint64_v8.teal
    │   │       │   ├── app_roundtrip_uint8_v6.teal
    │   │       │   └── app_roundtrip_uint8_v8.teal
    │   │       └── stability/
    │   │           ├── app_exp.teal
    │   │           ├── app_oldfac.teal
    │   │           ├── app_slow_fibonacci.teal
    │   │           ├── app_square.teal
    │   │           ├── app_square_byref.teal
    │   │           ├── app_string_mult.teal
    │   │           ├── app_swap.teal
    │   │           ├── lsig_exp.teal
    │   │           ├── lsig_oldfac.teal
    │   │           ├── lsig_slow_fibonacci.teal
    │   │           ├── lsig_square.teal
    │   │           ├── lsig_square_byref.teal
    │   │           ├── lsig_string_mult.teal
    │   │           └── lsig_swap.teal
    │   ├── teal/
    │   │   ├── __init__.py
    │   │   ├── rps.py
    │   │   ├── rps.teal
    │   │   ├── user_guide_snippet_dynamic_scratch_var.teal
    │   │   ├── user_guide_snippet_recursiveIsEven.teal
    │   │   └── router/
    │   │       ├── nontriv_clear_approval_v6.teal
    │   │       ├── nontriv_clear_approval_v8.teal
    │   │       ├── nontriv_clear_clear_v6.teal
    │   │       ├── nontriv_clear_clear_v8.teal
    │   │       ├── questionable_approval_v6.teal
    │   │       ├── questionable_clear_v6.teal
    │   │       ├── questionableFP_approval_v8.teal
    │   │       ├── questionableFP_clear_v8.teal
    │   │       ├── yacc_approval_v6.teal
    │   │       ├── yacc_clear_v6.teal
    │   │       ├── yaccFP_approval_v8.teal
    │   │       └── yaccFP_clear_v8.teal
    │   └── unit/
    │       ├── __init__.py
    │       ├── blackbox_test.py
    │       ├── compile_test.py
    │       ├── feature_gates_test.py
    │       ├── module_test.py
    │       ├── pass_by_ref_test.py
    │       ├── pre_v6_test.py
    │       ├── sourcemap_constructs_allpy_test.py
    │       ├── sourcemap_monkey_raises_test.py
    │       ├── sourcemap_monkey_unit_test.py
    │       ├── sourcemap_rps_test.py
    │       ├── sourcemap_test.py
    │       ├── user_guide_test.py
    │       └── teal/
    │           ├── abi/
    │           │   ├── app_fn_0arg_0ret.teal
    │           │   ├── app_fn_0arg_uint64_ret.teal
    │           │   ├── app_fn_1arg_0ret.teal
    │           │   ├── app_fn_1arg_1ret.teal
    │           │   ├── app_fn_1tt_arg_uint64_ret.teal
    │           │   ├── app_fn_2arg_0ret.teal
    │           │   ├── app_fn_2mixed_arg_1ret.teal
    │           │   ├── app_fn_3mixed_args_0ret.teal
    │           │   ├── lsig_fn_0arg_0ret.teal
    │           │   ├── lsig_fn_0arg_uint64_ret.teal
    │           │   ├── lsig_fn_1arg_0ret.teal
    │           │   ├── lsig_fn_1arg_1ret.teal
    │           │   ├── lsig_fn_1tt_arg_uint64_ret.teal
    │           │   ├── lsig_fn_2arg_0ret.teal
    │           │   ├── lsig_fn_2mixed_arg_1ret.teal
    │           │   └── lsig_fn_3mixed_args_0ret.teal
    │           ├── blackbox/
    │           │   ├── app_utest_any.teal
    │           │   ├── app_utest_any_args.teal
    │           │   ├── app_utest_bytes.teal
    │           │   ├── app_utest_bytes_args.teal
    │           │   ├── app_utest_int.teal
    │           │   ├── app_utest_int_args.teal
    │           │   ├── app_utest_noop.teal
    │           │   ├── app_utest_noop_args.teal
    │           │   ├── lsig_utest_any.teal
    │           │   ├── lsig_utest_any_args.teal
    │           │   ├── lsig_utest_bytes.teal
    │           │   ├── lsig_utest_bytes_args.teal
    │           │   ├── lsig_utest_int.teal
    │           │   ├── lsig_utest_int_args.teal
    │           │   ├── lsig_utest_noop.teal
    │           │   └── lsig_utest_noop_args.teal
    │           ├── pre_v6/
    │           │   ├── sub_even.teal
    │           │   ├── sub_fastfib.teal
    │           │   ├── sub_logcat.teal
    │           │   └── sub_slowfib.teal
    │           ├── unchanged/
    │           │   ├── empty_scratches.teal
    │           │   ├── lots_o_vars.teal
    │           │   ├── sub_logcat_dynamic.teal
    │           │   ├── sub_mixed.teal
    │           │   ├── swapper.teal
    │           │   └── wilt_the_stilt.teal
    │           └── user_guide/
    │               ├── user_guide_snippet_ABIReturnSubroutine.teal
    │               ├── user_guide_snippet_dynamic_scratch_var.teal
    │               └── user_guide_snippet_recursiveIsEven.teal
    └── .github/
        ├── ISSUE_TEMPLATE/
        │   ├── bug_report.md
        │   └── feature_request.md
        └── workflows/
            ├── build.yml
            └── nightly.yml

================================================
FILE: README.md
================================================
 <!-- markdownlint-disable-file MD041 -->

![PyTeal logo](https://github.com/algorand/pyteal/blob/master/docs/pyteal.png?raw=true)

# PyTeal: Algorand Smart Contracts in Python

[![Build Status](https://github.com/algorand/pyteal/actions/workflows/build.yml/badge.svg)](https://github.com/algorand/pyteal/actions)
[![PyPI version](https://badge.fury.io/py/pyteal.svg)](https://badge.fury.io/py/pyteal)
[![Documentation Status](https://readthedocs.org/projects/pyteal/badge/?version=latest)](https://pyteal.readthedocs.io/en/latest/?badge=latest)
[![Code style: black](https://img.shields.io/badge/code%20style-black-000000.svg)](https://github.com/psf/black)

PyTeal is a Python language binding for [Algorand Smart Contracts (ASC1s)](https://developer.algorand.org/docs/features/asc1/).

Algorand Smart Contracts are implemented using a new language that is stack-based,
called [Transaction Execution Approval Language (TEAL)](https://developer.algorand.org/docs/features/asc1/teal/).

However, TEAL is essentially an assembly language. With PyTeal, developers can express smart contract logic purely using Python.
PyTeal provides high level, functional programming style abstractions over TEAL and does type checking at construction time.

## Install

PyTeal requires Python version >= 3.10.

If your operating system (OS) Python version < 3.10, we recommend:
* Rather than override the OS Python version, install Python  >= 3.10 alongside the OS Python version.
* Use [pyenv](https://github.com/pyenv/pyenv#installation) or similar tooling to manage multiple Python versions.

### Recommended: Install from PyPi

Install the latest official release from PyPi:

* `pip install pyteal`

### Install Latest Commit

If needed, it's possible to install directly from the latest commit on master to use unreleased features:

> **WARNING:** Unreleased code is experimental and may not be backwards compatible or function properly. Use extreme caution when installing PyTeal this way.

* `pip install git+https://github.com/algorand/pyteal`

## Documentation

* [PyTeal Docs](https://pyteal.readthedocs.io/)
* `docs/` ([README](docs/README.md)) contains raw docs.

## Development Setup

Setup venv (one time):

* `python3 -m venv venv`

Active venv:

* `. venv/bin/activate` (if your shell is bash/zsh)
* `. venv/bin/activate.fish` (if your shell is fish)

Pip install PyTeal in editable state with dependencies:

* `make setup-development`
* OR if you don't have `make` installed:
  * `pip install -e . && pip install -r requirements.txt`

Format code:

* `black .`

Lint using flake8:

* `flake8 docs examples pyteal scripts tests *.py`

Type checking using mypy:

* `mypy pyteal scripts`

Run unit tests:

* `pytest pyteal tests/unit`

Run integration tests (assumes a developer-mode `algod` is available on port 4001):

* `pytest tests/integration`

Stand up developer-mode algod on ports 4001, 4002 and `tealdbg` on port 9392 (assumes [Docker](https://www.docker.com/) is available on your system):

* `docker-compose up -d`

Tear down and clean up resources for the developer-mode algod stood up above:

* `docker-compose down`



================================================
FILE: CHANGELOG.md
================================================
# Unreleased

## Added

## Fixed

## Changed

# v0.27.0

## Added

* Added new fields for global, acct_params_get, and block ([#722](https://github.com/algorand/pyteal/pull/722)))
  * Added new fields for global, acct_params_get, and block
  * online_state and voter_params_get
  * mimc opcode

## Changed

* Update recurring_swap.py ([#721](https://github.com/algorand/pyteal/pull/721))
* Bump setuptools from 69.0.2 to 70.0.0 ([#725](https://github.com/algorand/pyteal/pull/725))
* Upgrade Black to 24.8.0. ([#724](https://github.com/algorand/pyteal/pull/724))

# v0.26.1

## Fixed

* Correct `EcPairingCheck` & `EcSubgroupCheck` return types ([#717](https://github.com/algorand/pyteal/pull/717))

# v0.26.0

## Added

* Support for AVM v10 programs. ([#714](https://github.com/algorand/pyteal/pull/714))
  * New box operations:
    * `App.box_resize`
    * `App.box_splice`
  * New `Global` fields:
    * `Global.asset_create_min_balance()`
    * `Global.asset_opt_in_min_balance()`
    * `Global.genesis_hash()`
  * New elliptic curve operations:
    * `EcAdd`
    * `EcScalarMul`
    * `EcPairingCheck`
    * `EcMultiScalarMul`
    * `EcSubgroupCheck`
    * `EcMapTo`
* Support for Python 3.12. ([#713](https://github.com/algorand/pyteal/pull/713))

# v0.25.0

## Added

* Support for compiling AVM v9 programs. ([#707](https://github.com/algorand/pyteal/pull/707))

# v0.24.1

## Fixed

* Fixed sourcemap errors related to TMPL usage. ([#696](https://github.com/algorand/pyteal/pull/696))

## Changed

* Stop using slot indexes for assets and apps when accessing properties of ABI reference type arguments. ([#701](https://github.com/algorand/pyteal/pull/701))

# v0.24.0

## Added

* Clarify that `Approve` and `Reject` always exit in the documentation. ([#660](https://github.com/algorand/pyteal/pull/660))
* Added frame pointer support for router. ([#600](https://github.com/algorand/pyteal/pull/600))
  * NOTE: a backwards incompatable change was imposed in this PR: previous `build_program` method in `Router` was exported and public, now this method is hidden. Use `compile_program` only.
* Experimental source mapping capability. ([#650](https://github.com/algorand/pyteal/pull/650))

## Changed

* Enable source maps using the new `FeatureGate` class. See `examples/applications/sourcemap.py` for a usage example. ([#687](https://github.com/algorand/pyteal/pull/687))

# v0.23.0

## Added

* Improved error handling for tuple type mismatch: added information on position and expected type. ([#655](https://github.com/algorand/pyteal/pull/655))
* Added an `asdict()` method to `ast.router.BareCallActions`. ([#656](https://github.com/algorand/pyteal/pull/656))

## Fixed

* Fixed wrong encoding result in tuple get last item. ([#663](https://github.com/algorand/pyteal/pull/663))

# v0.22.0

## Changed
* Improved Router clear state program generation. ([#636](https://github.com/algorand/pyteal/pull/636))
  * NOTE: a backwards incompatable change was imposed in this PR: previous Clear State Program (CSP) can be constructed in router by registering ABI methods or bare app calls, now one has to use `clear_state` argument in `Router.__init__` to construct the CSP.

# v0.21.0

## Added
* Added frame pointer support for subroutine arguments, replacing the previous usage of scratch. ([#562](https://github.com/algorand/pyteal/pull/562))
* Added frame pointer support for local ABI variables in subroutine. ([#606](https://github.com/algorand/pyteal/pull/606))
* Added `frame_pointers` property in `OptimizeOptions` to optimize away scratch slots during subroutine calls. This defaults to frame pointer usage when not specified for AVM version 8+. ([#613](https://github.com/algorand/pyteal/pull/613))

## Fixed
* Allowing the `MethodCall` and `ExecuteMethodCall` to be passed `None` as app_id argument in the case of an app create transaction ([#592](https://github.com/algorand/pyteal/pull/592))
* No longer accidentally include additional package folders in release ([#610](https://github.com/algorand/pyteal/pull/610), [#614](https://github.com/algorand/pyteal/pull/614))
* Fixed mistakes in docs ([#612](https://github.com/algorand/pyteal/pull/612), [#625](https://github.com/algorand/pyteal/pull/625), [#627](https://github.com/algorand/pyteal/pull/627))

## Changed
* Introducing `AbstractVar` to abstract value access: store, load, and stack type. ([#584](https://github.com/algorand/pyteal/pull/584))
  * NOTE: a backwards incompatable change was imposed in this PR: previous ABI value's public member `stored_value` with type `ScratchVar`, is now changed to protected member `_stored_value` with type `AbstractVar`.
* Starting with program version 9, when `scratch_slots` flag isn't provided to `OptimizeOptions`, default to optimizing. For versions 8 and earlier the default is and remains to _not_ optimize. ([#613](https://github.com/algorand/pyteal/pull/613))
* Replaced the usage of `typing.NamedTuple` with `dataclass` for `class OpType` in the **ir** package in order to avoid [a regression coming in Python 3.11.1](https://github.com/python/cpython/issues/100098). ([#615](https://github.com/algorand/pyteal/pull/615))
* Upgrade mypy to v0.991. ([#618](https://github.com/algorand/pyteal/pull/618))
* Upgrade py-algorand-sdk to v2.0.0. ([#626](https://github.com/algorand/pyteal/pull/626))

# 0.20.1

## Added
* adding program page related ops ([#412](https://github.com/algorand/pyteal/pull/412))
* Add Replace ([#413](https://github.com/algorand/pyteal/pull/413))
* Add Block ([#415](https://github.com/algorand/pyteal/pull/415))
* Add JsonRef ([#417](https://github.com/algorand/pyteal/pull/417))
* Add Base64Decode ([#418](https://github.com/algorand/pyteal/pull/418))
* Support Secp256r1 curve ([#423](https://github.com/algorand/pyteal/pull/423))
* Add VrfVerify ([#419](https://github.com/algorand/pyteal/pull/419))
* Add Sha3_256 ([#425](https://github.com/algorand/pyteal/pull/425))
* Support FirstValidTime transaction field ([#424](https://github.com/algorand/pyteal/pull/424))
* Add Ed25519Verify_Bare ([#426](https://github.com/algorand/pyteal/pull/426))
* AVM Boxes Ops in Pyteal ([#438](https://github.com/algorand/pyteal/pull/438))
* Support new AVM 8 account parameters ([#555](https://github.com/algorand/pyteal/pull/555))

## Changed
* Changes to avm8 docs ([#546](https://github.com/algorand/pyteal/pull/546))

# 0.19.0

## Added
* Added option to `OpUp` utility to allow specification of source for fees ([#566](https://github.com/algorand/pyteal/pull/566))

## Fixed
* Erroring on constructing an odd length hex string. ([#539](https://github.com/algorand/pyteal/pull/539))
* Incorrect behavior when overriding a method name ([#550](https://github.com/algorand/pyteal/pull/550))
* Add missing `abi.NamedTupleTypeSpec` equality override, such that equality holds only when `instance_class` and `value_type_specs` match. ([#540](https://github.com/algorand/pyteal/pull/540))
* Prohibited instantiating `abi.NamedTuple` from inheriting subclasses of `abi.NamedTuple`, for fields in subclasses are not inherited. ([#540](https://github.com/algorand/pyteal/pull/540))
* Fixed bug in app arg tupling and detupling when a Txn argument is present ([#577](https://github.com/algorand/pyteal/pull/577))

## Changed
* Subroutines that take ABI type of Transaction now allow any Transaction type to be passed. ([#531](https://github.com/algorand/pyteal/pull/531))
* Relaxing exact type check in `InnerTxnFieldExpr.MethodCall` by applying `abi.type_spec_is_assignable_to`. ([#561](https://github.com/algorand/pyteal/pull/561))

# 0.18.1

## Fixed
* ABI methods without a docstring now have their arguments in the output Contract object. ([#524](https://github.com/algorand/pyteal/pull/524))

# 0.18.0

## Added

* ABI Methods will now parse the docstring for the method and set the description for any parameters that are described. ([#518](https://github.com/algorand/pyteal/pull/518))
  * Note: the docstring must adhere to one of google, rst, numpy , or epy formatting styles.

## Fixed
* Subroutines annotated with a `TupleX` class are now invoked with an instance of that exact class, instead of the more general `Tuple` class ([#519](https://github.com/algorand/pyteal/pull/519))

# 0.17.0

## Added
* Static and Dynamic Byte Array convenience classes ([#500](https://github.com/algorand/pyteal/pull/500), [#514](https://github.com/algorand/pyteal/pull/514))
* Add the ability to insert comments in TEAL source file with the `Comment` method ([#410](https://github.com/algorand/pyteal/pull/410))
* Add a `comment` keyword argument to the Assert expression that will place the comment immediately above the `assert` op in the resulting TEAL ([#510](https://github.com/algorand/pyteal/pull/510))

## Fixed
* Fix AST duplication bug in `String.set` when called with an `Expr` argument ([#508](https://github.com/algorand/pyteal/pull/508))

# 0.16.0

## Added
* Add the ability to pass foreign reference arrays directly into inner transactions ([#384](https://github.com/algorand/pyteal/pull/384))

* NamedTuple Implementation ([#473](https://github.com/algorand/pyteal/pull/473))

* ExecuteMethodCall helper ([#501](https://github.com/algorand/pyteal/pull/501))

## Fixed

* CI: Fail readthedocs build on warning ([#478](https://github.com/algorand/pyteal/pull/478))

* Windows Compatibility ([#499](https://github.com/algorand/pyteal/pull/499))

## Changed
* Update `Block` docs to match spec change ([#503](https://github.com/algorand/pyteal/pull/503))

# 0.15.0

## Added
* Support AVM 7 updates:
  * New opcodes:
    * `base64_decode` ([#418](https://github.com/algorand/pyteal/pull/418))
    * `block` ([#415](https://github.com/algorand/pyteal/pull/415))
    * `ed25519verify_bare` ([#426](https://github.com/algorand/pyteal/pull/426))
    * `json_ref` ([#417](https://github.com/algorand/pyteal/pull/417))
    * `replace2`, `replace3` ([#413](https://github.com/algorand/pyteal/pull/413))
    * `sha3_256` ([#425](https://github.com/algorand/pyteal/pull/425))
    * `vrf_verify` ([#419](https://github.com/algorand/pyteal/pull/419))
  * `Secp256r1` curve for ECDSA opcodes ([#423](https://github.com/algorand/pyteal/pull/423))
  * Program page transaction field access ([#412](https://github.com/algorand/pyteal/pull/412))

# 0.14.0

## Added
* Add [ARC-0004](https://github.com/algorandfoundation/ARCs/blob/main/ARCs/arc-0004.md) support for building and calling Apps.  See user guide for a walkthrough of capabilities and limitations ([#264](https://github.com/algorand/pyteal/pull/264)).
* Introduce ABI Router to simplify ARC-0004 App construction and JSON descriptor generation.  See user guide for a walkthrough ([#170](https://github.com/algorand/pyteal/pull/170)).
* Support declaring PyTeal version compatibility with a new pragma directive ([#429](https://github.com/algorand/pyteal/pull/429)).
* Add `Execute` method to simplify inner transaction creation and submission ([#444](https://github.com/algorand/pyteal/pull/444)).
* Add `py.typed` marker to allow downstream use of mypy with PyTeal ([#465](https://github.com/algorand/pyteal/pull/465)).

## Fixed
* Fix misspelled function names (`localNumUint`, `globalNumUint`) and corresponding internal field references ([#431](https://github.com/algorand/pyteal/pull/431)).
* Fix stale user guide references ([#359](https://github.com/algorand/pyteal/pull/359)).

## Changed
* Make PyTeal stack traces easier to debug ([#371](https://github.com/algorand/pyteal/pull/371)).
* Streamline multi-expression clause construction ([#442](https://github.com/algorand/pyteal/pull/442)).

# 0.13.0

## Added
* Add opcode support for ECDSA verify, decompress, and recover ([#307](https://github.com/algorand/pyteal/pull/307)).

## Fixed
* Fix bug where `Continue` skips `While` condition check ([#332](https://github.com/algorand/pyteal/pull/332)).
* Fix `If` construction using builder syntax ([#329](https://github.com/algorand/pyteal/pull/329)).

## Changed
* Correct multiple doc typos ([#324](https://github.com/algorand/pyteal/pull/324), [#330](https://github.com/algorand/pyteal/pull/330)).

# 0.12.1

## Fixed
* Resolve PyPi upload issue introduced in v0.12.0 ([#317](https://github.com/algorand/pyteal/pull/317)).

# 0.12.0

## Added
* Introduce a utility for increasing opcode budget referred to as OpUp ([#274](https://github.com/algorand/pyteal/pull/274)).
* Introduce dryrun testing facilities referred to as blackbox testing ([#249](https://github.com/algorand/pyteal/pull/249)). 

## Changed
* Make various user guide updates/corrections ([#291](https://github.com/algorand/pyteal/pull/291), [#295](https://github.com/algorand/pyteal/pull/295), [#301](https://github.com/algorand/pyteal/pull/301)).
* Install flake8 linter ([#273](https://github.com/algorand/pyteal/pull/273), [#283](https://github.com/algorand/pyteal/pull/283)).

# 0.11.1

## Fixed
* Fix readthedocs build issue introduced in v0.11.0 ([#276](https://github.com/algorand/pyteal/pull/276), [#279](https://github.com/algorand/pyteal/pull/279)).

# 0.11.0

## Added
* Introduce optional compiler optimization to remove redundant sequential `ScratchSlot` store/load invocations ([#247](https://github.com/algorand/pyteal/pull/247)).  The optimization is disabled by default.
* Expose `DynamicScratchVar` to reference arbitrary `ScratchVar` instances ([#198](https://github.com/algorand/pyteal/pull/198)). 

## Changed
* Bump minimum supported Python version to v3.10 ([#269](https://github.com/algorand/pyteal/pull/269)).
* Add `@Subroutine` support for `ScratchVar` parameters ([#198](https://github.com/algorand/pyteal/pull/198)).
* Make minor doc updates ([#248](https://github.com/algorand/pyteal/pull/248)) and ([#265](https://github.com/algorand/pyteal/pull/265)).
* Remove outdated Jupyter notebook demo ([#268](https://github.com/algorand/pyteal/pull/268)).
* Fix docs warning about multiple OptimizeOptions targets ([#271](https://github.com/algorand/pyteal/pull/271)).

# 0.10.1

## Fixed
* Fixed a bug which caused incorrect TEAL code to be produced for mutually recursive subroutines
  with different argument counts ([#234](https://github.com/algorand/pyteal/pull/234))
* Minor docs updates ([#211](https://github.com/algorand/pyteal/pull/211), [#210](https://github.com/algorand/pyteal/pull/210), [#229](https://github.com/algorand/pyteal/pull/229))

# 0.10.0

## Added
* Support for new TEAL 6 features:
  * Increase maximum TEAL version ([#146](https://github.com/algorand/pyteal/pull/146))
  * New `Gitxn` expression, inner transaction group creation with `InnerTxnBuilder.Next()`, inner
    transaction array field setting, and allow using dynamic slot IDs with `ImportScratchValue` ([#149](https://github.com/algorand/pyteal/pull/149))
  * New `BytesSqrt` expression ([#163](https://github.com/algorand/pyteal/pull/163))
  * New `Global` fields `opcode_budget`, `caller_app_id`, and `caller_app_address` ([#168](https://github.com/algorand/pyteal/pull/168))
  * New `AccountParam` expressions for getting information about accounts ([#165](https://github.com/algorand/pyteal/pull/165))
  * New `Divw` expression, new transaction fields `last_log` and `state_proof_pk`, and dynamic index
    support for `InnerTxn` array fields ([#174](https://github.com/algorand/pyteal/pull/174))
* Added a new `MethodSignature` expression ([#153](https://github.com/algorand/pyteal/pull/153))
* Added a new `Suffix` expression and optimized existing `Substring` and `Extract` expressions ([#126](https://github.com/algorand/pyteal/pull/126))
* Added the `MultiValue` class as an alternative to `MaybeValue` ([#196](https://github.com/algorand/pyteal/pull/196))

## Fixed
* Various documentation fixes ([#140](https://github.com/algorand/pyteal/pull/140), [#142](https://github.com/algorand/pyteal/pull/142), [#191](https://github.com/algorand/pyteal/pull/191), [#202](https://github.com/algorand/pyteal/pull/202), [#207](https://github.com/algorand/pyteal/pull/207))
* Clearer error messages when non-PyTeal expressions are present ([#151](https://github.com/algorand/pyteal/pull/151))

## Changed
* **WARNING**: Due to code generation improvements, programs compiled with this version will likely
  produce different TEAL code than previous versions, but their functionality will be the same. Be
  aware that even small differences in generated TEAL code will change the address associated with
  escrow LogicSig contracts.
* Optimized constant assembly for small integers ([#128](https://github.com/algorand/pyteal/pull/128))
* Generated TEAL code for subroutines is more human-readable ([#148](https://github.com/algorand/pyteal/pull/148))
* Subroutine argument and return type annotations, if present, **MUST** be `Expr` ([#182](https://github.com/algorand/pyteal/pull/182))
* Transaction field documentation now separates fields by transaction type ([#204](https://github.com/algorand/pyteal/pull/204))
* Added documentation about how to generate the documentation ([#205](https://github.com/algorand/pyteal/pull/205))

# 0.9.1

## Added
* Documentation for exponent operator ([#134](https://github.com/algorand/pyteal/pull/134))
* Documentation for using `Seq` with lists ([#135](https://github.com/algorand/pyteal/pull/135))

## Fixed
* Fixed use of wildcard import in Pylance ([#133](https://github.com/algorand/pyteal/pull/133))

# 0.9.0

## Added
* Support for new TEAL 5 features:
  * `AppParam` expressions ([#107](https://github.com/algorand/pyteal/pull/107), [#123](https://github.com/algorand/pyteal/pull/123))
  * New `nonparticipation` transaction field ([#106](https://github.com/algorand/pyteal/pull/106))
  * Inner transactions, zero-element `Seq` expressions, dynamic transaction array access ([#115](https://github.com/algorand/pyteal/pull/115))
  * Logs, dynamic LogicSig argument indexes, single-element `NaryExpr`s, and creating `Bytes` from `bytes` and `bytearray` ([#117](https://github.com/algorand/pyteal/pull/117))
  * Extract expressions ([#118](https://github.com/algorand/pyteal/pull/118))
  * More efficient implementation of recursive subroutines in TEAL 5+ ([#114](https://github.com/algorand/pyteal/pull/114))
* Add `WideRatio`, an expression which exposes `mulw` and `divmodw` ([#121](https://github.com/algorand/pyteal/pull/121), [#122](https://github.com/algorand/pyteal/pull/122))

## Changed
* **WARNING**: Due to code generation improvements, programs compiled with this version will likely
  produce different TEAL code than previous versions, but their functionality will be the same. Be
  aware that even small differences in generated TEAL code will change the address associated with
  escrow LogicSig contracts.
* Some unnecessary branch conditions have been removed ([#120](https://github.com/algorand/pyteal/pull/120))

# 0.8.0

## Added
* Support for new TEAL 4 features:
  * Basic ops ([#67](https://github.com/algorand/pyteal/pull/67))
  * Byteslice arithmetic ([#75](https://github.com/algorand/pyteal/pull/75))
  * Importing scratch slot values from previous app calls ([#79](https://github.com/algorand/pyteal/pull/79), [#83](https://github.com/algorand/pyteal/pull/83))
  * Direct reference support for applications/accounts/assets ([#90](https://github.com/algorand/pyteal/pull/90))
  * `While` and `For` loops ([#95](https://github.com/algorand/pyteal/pull/95))
  * Subroutines ([#99](https://github.com/algorand/pyteal/pull/99))
* New logo ([#88](https://github.com/algorand/pyteal/pull/88), [#91](https://github.com/algorand/pyteal/pull/91))
* Added the `assembleConstants` option to `compileTeal`. When enabled, the compiler will assemble
int and byte constants in the most efficient way to reduce program size ([#57](https://github.com/algorand/pyteal/pull/57), [#61](https://github.com/algorand/pyteal/pull/61), [#66](https://github.com/algorand/pyteal/pull/66)).
* Added an alternative syntax for constructing `If` statements ([#77](https://github.com/algorand/pyteal/pull/77), [#82](https://github.com/algorand/pyteal/pull/82)).
* Align `Seq` with the rest of the API ([#96](https://github.com/algorand/pyteal/pull/96)).

## Fixed
* Fixed `NaryExpr.__str__` method ([#102](https://github.com/algorand/pyteal/pull/102)).

## Changed
* **WARNING**: Due to code generation changes required to support TEAL 4 loops and subroutines,
  programs compiled with this version will likely produce different TEAL code than previous
  versions, but their functionality will be the same. Be aware that even small differences in
  generated TEAL code will change the address associated with escrow LogicSig contracts.
* Improved crypto cost docs ([#81](https://github.com/algorand/pyteal/pull/81)).
* Applied code formatter ([#100](https://github.com/algorand/pyteal/pull/100)).

# 0.7.0

## Added
* Support for new TEAL 3 features:
  * Bit/byte manipulation and new transaction and global fields ([#50](https://github.com/algorand/pyteal/pull/50)).
  * Dynamic `Gtxn` indexes ([#53](https://github.com/algorand/pyteal/pull/53)).
  * `MinBalance` expression ([#54](https://github.com/algorand/pyteal/pull/54)).
  * Documentation for new features ([#55](https://github.com/algorand/pyteal/pull/55)).
* Added the ability to specify the TEAL version target when using `compileTeal` ([#45](https://github.com/algorand/pyteal/pull/45)).
* Added `ScratchVar`, an interface for storing and loading values from scratch space ([#33](https://github.com/algorand/pyteal/pull/33)).
* Added a warning when scratch slots are loaded before anything has been stored ([#47](https://github.com/algorand/pyteal/pull/47)).

## Changed
* Rewrote internal code generation to produce smaller programs and make future optimization easier
([#26](https://github.com/algorand/pyteal/pull/26)). Programs compiled with this version will likely
produce different TEAL code than previous versions, but their functionality will be the same.

# 0.6.2

## Fixed
* Corrected documentation and examples that incorrectly used the `Txn.accounts` array ([#42](https://github.com/algorand/pyteal/pull/42)).
* Fixed improper base32 validation and allow the use of padding ([#34](https://github.com/algorand/pyteal/pull/34)
and [#37](https://github.com/algorand/pyteal/pull/37)).

# 0.6.1

## Added
* An application deployment example, `vote_deploy.py`.

## Fixed
* Internal modules no longer pollute the global namespace when importing with `from pyteal import *`
([#29](https://github.com/algorand/pyteal/pull/29)).
* Fixed several documentation typos.

## Changed
* Moved signature and application mode examples into separate folders.

# 0.6.0

## Added
* TEAL v2 `Txn` and `Gtxn` fields
* TEAL v2 `Global` fields
* `TxnType` enum
* `Pop` expression
* `Not` expression
* `BitwiseNot` expression
* `BitwiseAnd` expression
* `BitwiseOr` expression
* `BitwiseXor` expression
* `Neq` (not equal) expression
* `Assert` expression
* `AssetHolding` expressions
* `AssetParam` expressions
* State manipulation with `App` expressions
* `Concat` expression
* `Substring` expression
* `Bytes` constructor now accepts UTF-8 strings
* `If` expression now allows single branches

## Changed
* Compiling a PyTeal program must now be done with the `compileTeal(program, mode)` function. The `.teal()` method no longer exists.
* The API for group transactions has changed from `Gtxn.field(transaction_index)` to `Gtxn[transaction_index].field()`.
* `Tmpl` syntax has changed from `Type(Tmpl("TMPL_NAME"))` to `Tmpl.Type("TMPL_NAME")`.



================================================
FILE: CODE_OF_CONDUCT.md
================================================
# Contributor Covenant Code of Conduct

## Our Pledge

We as members, contributors, and leaders pledge to make participation in our
community a harassment-free experience for everyone, regardless of age, body
size, visible or invisible disability, ethnicity, sex characteristics, gender
identity and expression, level of experience, education, socio-economic status,
nationality, personal appearance, race, religion, or sexual identity
and orientation.

We pledge to act and interact in ways that contribute to an open, welcoming,
diverse, inclusive, and healthy community.

## Our Standards

Examples of behavior that contributes to a positive environment for our
community include:

* Demonstrating empathy and kindness toward other people
* Being respectful of differing opinions, viewpoints, and experiences
* Giving and gracefully accepting constructive feedback
* Accepting responsibility and apologizing to those affected by our mistakes,
  and learning from the experience
* Focusing on what is best not just for us as individuals, but for the
  overall community

Examples of unacceptable behavior include:

* The use of sexualized language or imagery, and sexual attention or
  advances of any kind
* Trolling, insulting or derogatory comments, and personal or political attacks
* Public or private harassment
* Publishing others' private information, such as a physical or email
  address, without their explicit permission
* Other conduct which could reasonably be considered inappropriate in a
  professional setting

## Enforcement Responsibilities

Community leaders are responsible for clarifying and enforcing our standards of
acceptable behavior and will take appropriate and fair corrective action in
response to any behavior that they deem inappropriate, threatening, offensive,
or harmful.

Community leaders have the right and responsibility to remove, edit, or reject
comments, commits, code, wiki edits, issues, and other contributions that are
not aligned to this Code of Conduct, and will communicate reasons for moderation
decisions when appropriate.

## Scope

This Code of Conduct applies within all community spaces, and also applies when
an individual is officially representing the community in public spaces.
Examples of representing our community include using an official e-mail address,
posting via an official social media account, or acting as an appointed
representative at an online or offline event.

## Enforcement

Instances of abusive, harassing, or otherwise unacceptable behavior may be
reported to the community leaders responsible for enforcement at
conduct@algorand.com.
All complaints will be reviewed and investigated promptly and fairly.

All community leaders are obligated to respect the privacy and security of the
reporter of any incident.

## Enforcement Guidelines

Community leaders will follow these Community Impact Guidelines in determining
the consequences for any action they deem in violation of this Code of Conduct:

### 1. Correction

**Community Impact**: Use of inappropriate language or other behavior deemed
unprofessional or unwelcome in the community.

**Consequence**: A private, written warning from community leaders, providing
clarity around the nature of the violation and an explanation of why the
behavior was inappropriate. A public apology may be requested.

### 2. Warning

**Community Impact**: A violation through a single incident or series
of actions.

**Consequence**: A warning with consequences for continued behavior. No
interaction with the people involved, including unsolicited interaction with
those enforcing the Code of Conduct, for a specified period of time. This
includes avoiding interactions in community spaces as well as external channels
like social media. Violating these terms may lead to a temporary or
permanent ban.

### 3. Temporary Ban

**Community Impact**: A serious violation of community standards, including
sustained inappropriate behavior.

**Consequence**: A temporary ban from any sort of interaction or public
communication with the community for a specified period of time. No public or
private interaction with the people involved, including unsolicited interaction
with those enforcing the Code of Conduct, is allowed during this period.
Violating these terms may lead to a permanent ban.

### 4. Permanent Ban

**Community Impact**: Demonstrating a pattern of violation of community
standards, including sustained inappropriate behavior,  harassment of an
individual, or aggression toward or disparagement of classes of individuals.

**Consequence**: A permanent ban from any sort of public interaction within
the community.

## Attribution

This Code of Conduct is adapted from the [Contributor Covenant][homepage],
version 2.0, available at
https://www.contributor-covenant.org/version/2/0/code_of_conduct.html.

Community Impact Guidelines were inspired by [Mozilla's code of conduct
enforcement ladder](https://github.com/mozilla/diversity).

[homepage]: https://www.contributor-covenant.org

For answers to common questions about this code of conduct, see the FAQ at
https://www.contributor-covenant.org/faq. Translations are available at
https://www.contributor-covenant.org/translations.



================================================
FILE: CONTRIBUTING.md
================================================
# Contribution Guide

If you are interested in contributing to the project, we welcome and thank you. We want to make the best decentralized and effective blockchain platform available and we appreciate your willingness to help us.

## Filing Issues

Did you discover a bug? Do you have a feature request? Filing issues is an easy way anyone can contribute and helps us improve PyTeal. We use GitHub Issues to track all known bugs and feature requests.

Before logging an issue be sure to check current issues, check the [open GitHub issues][issues_url] to see if your issue is described there.

If you’d like to contribute to any of the repositories, please file a [GitHub issue][issues_url] using the issues menu item. Make sure to specify whether you are describing a bug or a new enhancement using the **Bug report** or **Feature request** button.

See the GitHub help guide for more information on [filing an issue](https://help.github.com/en/articles/creating-an-issue).

## Contribution Model

For each of our repositories we use the same model for contributing code. Developers wanting to  contribute must create pull requests. This process is described in the GitHub [Creating a pull request from a fork](https://help.github.com/en/articles/creating-a-pull-request-from-a-fork) documentation. Each pull request should be initiated against the master branch in the PyTeal repository.  After a pull request is submitted the core development team will review the submission and communicate with the developer using the comments sections of the PR. After the submission is reviewed and approved, it will be merged into the master branch of the source. These changes will be merged to our release branch on the next viable release date.

## Code Guidelines

We make a best-effort attempt to adhere to [PEP 8 - Style Guide for Python Code](https://www.python.org/dev/peps/pep-0008/).  Keep the following context in mind:
* Our default stance is to run linter checks during the build process.
* Notable exception:  [naming conventions](https://peps.python.org/pep-0008/#naming-conventions).

### Naming Convention Guidelines
Since PyTeal aims for backwards compatibility, it's _not_ straightforward to change naming conventions in public APIs.  Consequently, the repo contains some deviations from PEP 8 naming conventions.

In order to retain a consistent style, we prefer to continue deviating from PEP 8 naming conventions in the following cases.  We try to balance minimizing exceptions against providing a consistent style for existing software.
* Enums - Define with lowercase camelcase.  Example:  https://github.com/algorand/pyteal/blob/7c953f600113abcb9a31df68165b61a2c897f591/pyteal/ast/txn.py#L37
* Factory methods - Define following [class name](https://peps.python.org/pep-0008/#class-names) conventions.  Example:  https://github.com/algorand/pyteal/blob/7c953f600113abcb9a31df68165b61a2c897f591/pyteal/ast/ternaryexpr.py#L63

Since it's challenging to enforce these exceptions with a linter, we rely on PR creators and reviewers to make a best-effort attempt to enforce agreed upon naming conventions.

### Module Guidelines

Every directory containing source code should be a Python module, meaning it should have an `__init__.py` file. This `__init__.py` file is responsible for exporting all public objects (i.e. classes, functions, and constants) for use outside of that module.

Modules may be created inside of other modules, in which case the deeper module is called a submodule or child module, and the module that contains it is called the parent module. For example, `pyteal` is the parent module to `pyteal.ast`.

A sibling module is defined as a different child module of the parent module. For example, `pyteal.ast` and `pyteal.ir` are sibling modules.

### Import Guidelines

#### In Runtime Code

When a runtime file in this codebase needs to import another module/file in this codebase, you should import the absolute path of the module/file, not the relative one, using the `from X import Y` method.

With regard to modules, there are two ways to import an object from this codebase:

* When importing an object from the same module or a parent module, you should import the full path of the source file that defines the object. For example:
    * (Import from same module): If `pyteal/ast/seq.py` needs to import `Expr` defined in `pyteal/ast/expr.py`, it should use `from pyteal.ast.expr import Expr`. **DO NOT** use `from pyteal.ast import Expr` or `from pyteal import Expr`, as this will cause an unnecessary circular dependency.
    * (Import from parent module): If `pyteal/ast/seq.py` needs to import `TealType` defined in `pyteal/types.py`, it should use `from pyteal.types import TealType`. **DO NOT** use `from pyteal import TealType`, as this will cause an unnecessary circular dependency.

* When importing an object from a child module or sibling module, you should import the entire module folder and access the desired object from there. Do not directly import the file that defines the object. For example:
    * (Import from child module): If `pyteal/compiler/compiler.py` needs to import `OptimizeOptions` from `pyteal/compiler/optimizer/optimizer.py`, it should use `from pyteal.compiler.optimizer import OptimizeOptions`. **DO NOT** use `from pyteal.compiler.optimizer.optimizer import OptimizeOptions`, as this will bypass the file `pyteal/compiler/optimizer/__init__.py`, which carefully defines the exports for the `pyteal.compiler.optimizer` module.
    * (Import from sibling module): If `pyteal/compiler/compiler.py` needs to import `Expr` defined in `pyteal/ast/expr.py`, it should use `from pyteal.ast import Expr`. **DO NOT** use `from pyteal import Expr`, as this will cause an unnecessary circular dependency, nor `from pyteal.ast.expr import Expr`, as this will bypass the file `pyteal/ast/__init__.py`, which carefully defines the
    exports for the `pyteal.ast` module.

When this approach is followed properly, circular dependencies can happen in two ways:
1. **Intra-module circular dependencies**, e.g. `m1/a.py` imports `m1/b.py` which imports `m1/a.py`. 
   When this happens, normally one of the files only needs to import the other to implement something,
   so the import statements can be moved from the top of the file to the body of the function that
   needs them. This breaks the import cycle.

2. **Inter-module circular dependencies**, e.g. `m1/a.py` imports module `m1/m2/__init__.py` which 
   imports `m1/m2/x.py` which imports `m1/a.py`. To avoid this, make sure that any objects/files in
   `m1` that need to be exposed to deeper modules do not rely on any objects from that deeper module.
   If that isn’t possible, then perhaps `m1/a.py` belongs in the `m1/m2/` module.

#### In Test Code

Test code is typically any file that ends with `_test.py` or is in the top-level `tests` folder. In
order to have a strong guarantee that we are testing in a similar environment to consumers of this
library, test code is encouraged to import _only_ the top-level PyTeal module, either with
`from pyteal import X, Y, Z` or `import pyteal as pt`.

This way we can be sure all objects that should be publicly exported are in fact accessible from the top-level module.

The only exception to this should be if the tests are for a non-exported object, in which case it is
necessary to import the object according to the runtime rules in the previous section.



================================================
FILE: docker-compose.yml
================================================
version: '3'

services:
  algod:
    image: algorand/algod:master
    platform: linux/amd64
    ports:
      - "4001:8080" # algod
      - "4160:4160" # gossip
      - "9100:9100" # prometheus
    environment:
      - DEV_MODE=1
      - PROFILE=development
        # Can remove ADMIN_TOKEN if the code stops passing an auth token. The development profile
        # enables the DisableAPIAuth config option, however an unfortunate side effect of this
        # option is that requests will error if *any* auth token is passed. Issue: https://github.com/algorand/go-algorand/issues/5883
      - ADMIN_TOKEN=aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
    healthcheck:
      test: curl -f http://localhost:8080/health
      interval: 2s
      retries: 30



================================================
FILE: LICENSE
================================================
MIT License

Copyright (c) 2020 Algorand

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.



================================================
FILE: Makefile
================================================
# ---- Setup ---- #

setup-development:
	pip install -e .
	pip install -r requirements.txt --upgrade

setup-docs:
	pip install -r docs/requirements.txt
	pip install doc2dash

setup-wheel:
	pip install wheel

generate-init:
	python -m scripts.generate_init

# ---- Docs and Distribution ---- #

bdist-wheel:
	python setup.py sdist bdist_wheel

bundle-docs-clean:
	rm -rf docs/pyteal.docset
	rm -rf docs/_build
	rm -f docs/pyteal.docset.tar.gz

bundle-docs: bundle-docs-clean
	cd docs && \
	make html SPHINXOPTS="-W --keep-going" && \
	doc2dash --name pyteal --index-page index.html --online-redirect-url https://pyteal.readthedocs.io/en/ _build/html && \
	tar -czvf pyteal.docset.tar.gz pyteal.docset

# ---- Code Quality ---- #

check-generate-init:
	python -m scripts.generate_init --check

ALLPY = docs examples feature_gates pyteal scripts tests *.py
black:
	black --check $(ALLPY)

flake8:
	flake8 $(ALLPY)

mypy:
	mypy

sdist-check:
	python setup.py check -s
	python setup.py check -s 2>&1 | (! grep -qEi 'error|warning')

lint: black flake8 mypy sdist-check

# ---- Unit Tests (no algod) ---- #

# Slow test which are fast enough on python 3.11+
test-unit-slow: 
	pytest tests/unit/sourcemap_constructs311_test.py -m serial

test-unit-very-slow: 
	pytest tests/unit/sourcemap_constructs_allpy_test.py -m serial

test-unit-async:
	pytest -n auto --durations=10 pyteal tests/unit -m "not slow" -m "not serial"

# Run tests w/ @pytest.mark.serial under ~/tests/unit each in its own proc:
test-unit-sync: test-unit-slow
	find tests/unit -name '*_test.py' | sort | xargs -t -I {} pytest --suppress-no-test-exit-code --dist=no --durations=10 {} -m serial -m "not slow"

test-unit: test-unit-async test-unit-sync

lint-and-test: check-generate-init lint test-unit

# ---- Integration Tests (algod required) ---- #

algod-start:
	docker compose --verbose up -d algod --wait

algod-version:
	docker compose exec algod goal --version

algod-start-report: algod-start algod-version

algod-stop:
	docker compose stop algod

test-integ-async:
	pytest -n auto --durations=10 tests/integration -m "not serial"

# Run tests w/ @pytest.mark.serial under ~/tests/integration each in its own proc:
test-integ-sync:
	find tests/integration -name '*_test.py' | sort | xargs -t -I {} pytest --suppress-no-test-exit-code --dist=no --durations=10 {} -m serial

test-integration: test-integ-async test-integ-sync

all-sync: test-unit-sync test-integ-sync

all-lint-unit-integ: lint-and-test test-integration

# ---- Github Actions 1-Liners ---- #

setup-build-test: setup-development lint-and-test

algod-integration: algod-start setup-development test-integration algod-stop

check-code-changes:
	git config --global --add safe.directory /__w/pyteal/pyteal
	[ -n "$$(git log --since='24 hours ago')" ] && (echo "should_run=true" >> $(GITHUB_ENV)) || (echo "should_run=false" >> $(GITHUB_ENV))

nightly-slow: test-unit-very-slow

# ---- Local Github Actions Simulation via `act` ---- #
# assumes act is installed, e.g. via `brew install act`

ACT_JOB = run-integration-tests
local-gh-job:
	act -j $(ACT_JOB)

local-gh-simulate:
	act

# ---- Extras ---- #

coverage:
	pytest --cov-report html --cov=pyteal

sourcemap-coverage:
	pytest --cov-report html --cov=pyteal.stack_frame --cov=pyteal.compiler.sourcemap --cov=pyteal.compiler.compiler --dist=no tests/unit/sourcemap_monkey_unit_test.py -m serial



================================================
FILE: mypy.ini
================================================
[mypy]
files = pyteal,scripts,tests
python_version = 3.10

[mypy-semantic_version.*]
ignore_missing_imports = True

[mypy-pytest.*]
ignore_missing_imports = True

[mypy-algosdk.*]
ignore_missing_imports = True



================================================
FILE: pytest.ini
================================================
[pytest]
markers =
    serial: marks tests requiring serial execution
    slow: marks tests which are slow



================================================
FILE: release-process.md
================================================
# PyTeal Release Process

This document contains information about how to issue a new PyTeal release.

## Release Steps

### 1. Prep files in repo 

In addition to the code changes that make up the release, a few files must be updated for each release we make.

Usually, both of these changes will happen in a "release PR." For example: https://github.com/algorand/pyteal/pull/637

#### a. Update `CHANGELOG.md`

The first section in `CHANGELOG.md` should be `Unreleased`. Ideally this section would be populated with all the changes since the last release and would have been updated with every PR. However, it's possible that some PRs may have forgotten to update the changelog. You should look at all the commits since the last release to see if anything that should be mentioned in the changelog is missing. If so, add it now.

Not _every_ PR needs to be reflected in the changelog. As a general rule, if and only if the PR makes a change that's visible to consumers of the PyTeal library (including documentation), then it should be included in the changelog. Changes to tests or development tools that do not affect library consumers should generally not be reported.

Once the `Unreleased` section is complete, change it to the version you are about to release, e.g. `v0.21.0`. If any subsections are empty, remove them.

At this point, add a new placeholder to the top of the file for future changelog additions, like so:

```
# Unreleased

## Added

## Changed

## Fixed
```

#### b. Bump version in `setup.py`

Update the `setup.py` file to contain the version you wish to release. For example:

```diff
--- a/setup.py
+++ b/setup.py
@@ -7,7 +7,7 @@
 
 setuptools.setup(
     name="pyteal",
-    version="0.20.1",
+    version="0.21.0",
     author="Algorand",
     author_email="pypiservice@algorand.com",
     description="Algorand Smart Contracts in Python",
```

### 2. Create a GitHub release & tag

Once the changes from step 1 have been committed to the repo, it's time to issue the release.

Navigate to GitHub's "Draft a new release" page: https://github.com/algorand/pyteal/releases/new. Fill out the fields like so:
* Tag: create a new tag with the version you're about to release, e.g. `v0.21.0`
* Title: the version you're about to release. This should be the same as the tag.
* Description: copy and paste the release notes from `CHANGELOG.md`. Do not include the section header with the release version, since it's redundant.

Press "Publish release" to submit. This was create a new git tag, which triggers a GitHub Actions job of ours to build and upload a release to PyPI.

### 3. Check outputs to ensure success

After you've kicked off a release as described in the previous section, you should monitor the process to ensure everything succeeds. Unfortunately we don't have any notifications if the release process fails, so it's important to perform these manual checks.

#### a. Ensure GitHub Actions job succeeds

Visit https://github.com/algorand/pyteal/actions to find the GitHub Actions job that's running the release. Open it and ensure it succeeds.

#### b. Check that PyPI receives the release

Visit https://pypi.org/project/pyteal/ to check that the latest release is listed in PyPI.

#### c. Ensure docs are updated

Issuing a git tag also triggers ReadTheDocs to generate new documentation.

Visit https://readthedocs.org/projects/pyteal/builds/ to ensure that the docs build for the release succeeds.

Then, visit https://pyteal.readthedocs.io/ to ensure that the latest release is present on our docs site. In the bottom left corner, there's a button that will display the current version of the docs, e.g. `v: stable`. Click this to see all versions that are available. Ensure that the just released version is there, and click it to bring up that specific version's docs. Manually inspect the site to ensure documentation was generated successfully.




================================================
FILE: requirements.txt
================================================
black==24.8.0
flake8==6.1.0
flake8-tidy-imports==4.10.0
graviton@git+https://github.com/algorand/graviton@v0.9.0
mypy==1.7.1
pytest==7.4.3
pytest-cov==3.0.0
pytest-custom-exit-code==0.3.0
pytest-timeout==2.1.0
pytest-xdist==3.0.2
setuptools==70.0.0
types-setuptools==70.0.0.20240524



================================================
FILE: setup.py
================================================
#!/usr/bin/env python3

import setuptools

with open("README.md", "r") as fh:
    long_description = fh.read()

setuptools.setup(
    name="pyteal",
    version="0.27.0",
    author="Algorand",
    author_email="pypiservice@algorand.com",
    description="Algorand Smart Contracts in Python",
    long_description=long_description,
    long_description_content_type="text/markdown",
    url="https://github.com/algorand/pyteal",
    packages=setuptools.find_packages(
        include=(
            "feature_gates",
            "pyteal",
            "pyteal.*",
        )
    ),
    install_requires=[
        # when changing this list, also update docs/requirements.txt
        "docstring-parser==0.14.1",
        "executing==2.0.1",
        "py-algorand-sdk>=2.0.0,<3.0.0",
        "semantic-version>=2.9.0,<3.0.0",
        "tabulate>=0.9.0,<0.10.0",
    ],
    classifiers=[
        "Programming Language :: Python :: 3",
        "License :: OSI Approved :: MIT License",
        "Operating System :: OS Independent",
    ],
    package_data={"pyteal": ["*.pyi", "py.typed"]},
    python_requires=">=3.10",
)



================================================
FILE: .flake8
================================================
[flake8]
ignore =
    E203,
    E241,
    E302,
    E501,
    E741,
    W291,
    W503,

per-file-ignores =
    examples/application/abi/algobank.py:           F403, F405
    examples/application/asset.py:                  F403, F405
    examples/application/opup.py:                   F403, F405
    examples/application/security_token.py:         F403, F405
    examples/application/vote.py:                   F403, F405
    examples/signature/atomic_swap.py:              F403, F405
    examples/signature/basic.py:                    F403, F405
    examples/signature/dutch_auction.py:            F403, F405
    examples/signature/periodic_payment_deploy.py:  F403, F405
    examples/signature/periodic_payment.py:         F403, F405
    examples/signature/recurring_swap_deploy.py:    F403, F405
    examples/signature/recurring_swap.py:           F403, F405
    examples/signature/split.py:                    F403, F405
    pyteal/__init__.py:                             F401, F403
    pyteal/ast/ec.py:                               E222
    pyteal/ast/seq.py:                              E704
    pyteal/compiler/flatten.py:                     F821
    pyteal/compiler/optimizer/__init__.py:          F401
    pyteal/ir/ops.py:                               E221
    pyteal/ir/tealconditionalblock.py:              F821
    pyteal/ir/tealsimpleblock.py:                   F821
    pyteal/stack_frame.py:                          F821
    tests/teal/rps.py:                              F401, F403, F405, I252
    tests/unit/module_test.py:                      F401, F403

# from flake8-tidy-imports
ban-relative-imports = true



================================================
FILE: .readthedocs.yaml
================================================
# .readthedocs.yaml
# Read the Docs configuration file
# See https://docs.readthedocs.io/en/stable/config-file/v2.html for details

# Required
version: 2

# Set the version of Python and other tools you might need
build:
  os: ubuntu-22.04
  tools:
    python: "3.10"
    # You can also specify other tool versions:
    # nodejs: "16"
    # rust: "1.55"
    # golang: "1.17"

# Build documentation in the docs/ directory with Sphinx
sphinx:
   configuration: docs/conf.py
   fail_on_warning: true

# If using Sphinx, optionally build your docs in additional formats such as PDF
# formats:
#    - pdf

# Optionally declare the Python requirements required to build your docs
python:
   install:
   - requirements: docs/requirements.txt



================================================
FILE: docs/README.md
================================================
# Docs

`docs/` contains end user documentation geared towards writing smart contracts with PyTeal.  The README explains how to edit docs.

## Local testing

Pyteal uses [Sphinx](https://github.com/sphinx-doc/sphinx) to generate HTML from RST files.  Test changes by generating HTML and viewing with a web browser.

Here's the process:
* Perform one-time environment setup:
  * Activate the top-level virtual environment.
  * Install dependencies: `pip install -r requirements.txt`.
* Generate HTML docs:  `make html`.
* If successful, generated HTML is available in `docs/_build/html`.

Additionally, each PR commit generates HTML docs via [Github Actions](../.github/workflows/build.yml).

## Releasing

Production docs live at https://pyteal.readthedocs.io/en/stable/.



================================================
FILE: docs/accessing_transaction_field.rst
================================================
.. _transaction-fields:

Transaction Fields and Global Parameters
========================================

PyTeal smart contracts can access properties of the current transaction and the state of the
blockchain when they are running.

Transaction Fields
--------------------------------------------

Information about the current transaction being evaluated can be obtained using the :any:`Txn` object using the PyTeal expressions shown below.

Since numerous transaction fields exist, the fields are logically organized into tables by transaction type.

Fields by Transaction Type
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Common Fields
.......................................................

================================================================================ ========================= ==================== ============================================================================
Operator                                                                         Type                      Min Program Version  Notes
================================================================================ ========================= ==================== ============================================================================
:any:`Txn.type() <TxnObject.type>`                                               :code:`TealType.bytes`    2
:any:`Txn.type_enum() <TxnObject.type_enum>`                                     :code:`TealType.uint64`   2                    see table below
:any:`Txn.sender() <TxnObject.sender>`                                           :code:`TealType.bytes`    2                    32 byte address
:any:`Txn.fee() <TxnObject.fee>`                                                 :code:`TealType.uint64`   2                    in microAlgos
:any:`Txn.first_valid() <TxnObject.first_valid>`                                 :code:`TealType.uint64`   2                    round number
:any:`Txn.first_valid_time() <TxnObject.first_valid_time>`                       :code:`TealType.uint64`   7                    UNIX timestamp of block before :code:`Txn.first_valid()`. Fails if negative
:any:`Txn.last_valid() <TxnObject.last_valid>`                                   :code:`TealType.uint64`   2                    round number
:any:`Txn.note() <TxnObject.note>`                                               :code:`TealType.bytes`    2                    transaction note in bytes
:any:`Txn.lease() <TxnObject.lease>`                                             :code:`TealType.bytes`    2                    transaction lease in bytes
:any:`Txn.group_index() <TxnObject.group_index>`                                 :code:`TealType.uint64`   2                    position of this transaction within a transaction group, starting at 0
:any:`Txn.tx_id() <TxnObject.tx_id>`                                             :code:`TealType.bytes`    2                    the computed ID for this transaction, 32 bytes
:any:`Txn.rekey_to() <TxnObject.rekey_to>`                                       :code:`TealType.bytes`    2                    32 byte address
================================================================================ ========================= ==================== ============================================================================

Application Call
.......................................................
==================================================================================== ========================= ==================== ============================================================================
Operator                                                                             Type                      Min Program Version  Notes
==================================================================================== ========================= ==================== ============================================================================
:any:`Txn.application_id() <TxnObject.application_id>`                               :code:`TealType.uint64`   2
:any:`Txn.on_completion() <TxnObject.on_completion>`                                 :code:`TealType.uint64`   2
:any:`Txn.approval_program() <TxnObject.approval_program>`                           :code:`TealType.bytes`    2
:any:`Txn.global_num_uints() <TxnObject.global_num_uints>`                           :code:`TealType.uint64`   3                    Maximum global integers in app schema
:any:`Txn.global_num_byte_slices() <TxnObject.global_num_byte_slices>`               :code:`TealType.uint64`   3                    Maximum global byte strings in app schema
:any:`Txn.local_num_uints() <TxnObject.local_num_uints>`                             :code:`TealType.uint64`   3                    Maximum local integers in app schema
:any:`Txn.local_num_byte_slices() <TxnObject.local_num_byte_slices>`                 :code:`TealType.uint64`   3                    Maximum local byte strings in app schema
:any:`Txn.accounts <TxnObject.accounts>`                                             :code:`TealType.bytes[]`  2                    Array of accounts available to the application
:any:`Txn.assets <TxnObject.assets>`                                                 :code:`TealType.uint64[]` 3                    Array of assets available to the application
:any:`Txn.applications <TxnObject.applications>`                                     :code:`TealType.uint64[]` 3                    Array of applications
:any:`Txn.clear_state_program() <TxnObject.clear_state_program>`                     :code:`TealType.bytes`    2
:any:`Txn.extra_program_pages() <TxnObject.extra_program_pages>`                     :code:`TealType.uint64`   4                    Number of extra program pages for app
:any:`Txn.application_args <TxnObject.application_args>`                             :code:`TealType.bytes[]`  2                    Array of application arguments
:any:`Txn.created_application_id() <TxnObject.created_application_id>`               :code:`TealType.uint64`   5                    The ID of the newly created application in this transaction. In v5, only valid on inner transactions. >= v6 works with top-level and inner transactions.
:any:`Txn.logs <TxnObject.logs>`                                                     :code:`TealType.bytes[]`  5                    Array of application logged items. In v5, only valid on inner transactions. >= v6 works with top-level and inner transactions.
:any:`Txn.last_log() <TxnObject.last_log>`                                           :code:`TealType.bytes`    6                    The last message emitted. Empty bytes if none were emitted. Application mode only.
:any:`Txn.approval_program_pages() <TxnObject.approval_program_pages>`               :code:`TealType.bytes[]`  7                    The pages of the approval program as an array
:any:`Txn.clear_state_program_pages() <TxnObject.clear_state_program_pages>`         :code:`TealType.bytes[]`  7                    The pages of a clear state program as an array
==================================================================================== ========================= ==================== ============================================================================

Asset Config
.......................................................
================================================================================ ========================= ==================== ============================================================================
Operator                                                                         Type                      Min Program Version  Notes
================================================================================ ========================= ==================== ============================================================================
:any:`Txn.config_asset() <TxnObject.config_asset>`                               :code:`TealType.uint64`   2                    ID of asset being configured
:any:`Txn.config_asset_total() <TxnObject.config_asset_total>`                   :code:`TealType.uint64`   2
:any:`Txn.config_asset_decimals() <TxnObject.config_asset_decimals>`             :code:`TealType.uint64`   2
:any:`Txn.config_asset_default_frozen() <TxnObject.config_asset_default_frozen>` :code:`TealType.uint64`   2
:any:`Txn.config_asset_unit_name() <TxnObject.config_asset_unit_name>`           :code:`TealType.bytes`    2
:any:`Txn.config_asset_name() <TxnObject.config_asset_name>`                     :code:`TealType.bytes`    2
:any:`Txn.config_asset_url() <TxnObject.config_asset_url>`                       :code:`TealType.bytes`    2
:any:`Txn.config_asset_metadata_hash() <TxnObject.config_asset_metadata_hash>`   :code:`TealType.bytes`    2
:any:`Txn.config_asset_manager() <TxnObject.config_asset_manager>`               :code:`TealType.bytes`    2                    32 byte address
:any:`Txn.config_asset_reserve() <TxnObject.config_asset_reserve>`               :code:`TealType.bytes`    2                    32 byte address
:any:`Txn.config_asset_freeze() <TxnObject.config_asset_freeze>`                 :code:`TealType.bytes`    2                    32 byte address
:any:`Txn.config_asset_clawback() <TxnObject.config_asset_clawback>`             :code:`TealType.bytes`    2                    32 byte address
:any:`Txn.created_asset_id() <TxnObject.created_asset_id>`                       :code:`TealType.uint64`   5                    The ID of the newly created asset in this transaction. In v5, only valid on inner transactions. >= v6 works with top-level and inner transactions.
================================================================================ ========================= ==================== ============================================================================

Asset Freeze
.......................................................
================================================================================ ========================= ==================== ============================================================================
Operator                                                                         Type                      Min Program Version  Notes
================================================================================ ========================= ==================== ============================================================================
:any:`Txn.freeze_asset() <TxnObject.freeze_asset>`                               :code:`TealType.uint64`   2
:any:`Txn.freeze_asset_account() <TxnObject.freeze_asset_account>`               :code:`TealType.bytes`    2                    32 byte address
:any:`Txn.freeze_asset_frozen() <TxnObject.freeze_asset_frozen>`                 :code:`TealType.uint64`   2
================================================================================ ========================= ==================== ============================================================================

Asset Transfer
.......................................................
================================================================================ ========================= ==================== ============================================================================
Operator                                                                         Type                      Min Program Version  Notes
================================================================================ ========================= ==================== ============================================================================
:any:`Txn.xfer_asset() <TxnObject.xfer_asset>`                                   :code:`TealType.uint64`   2                    ID of asset being transferred
:any:`Txn.asset_amount() <TxnObject.asset_amount>`                               :code:`TealType.uint64`   2                    value in Asset's units
:any:`Txn.asset_sender() <TxnObject.asset_sender>`                               :code:`TealType.bytes`    2                    32 byte address, causes clawback of all value if sender is the clawback
:any:`Txn.asset_receiver() <TxnObject.asset_receiver>`                           :code:`TealType.bytes`    2                    32 byte address
:any:`Txn.asset_close_to() <TxnObject.asset_close_to>`                           :code:`TealType.bytes`    2                    32 byte address
================================================================================ ========================= ==================== ============================================================================

Key Registration
.......................................................
================================================================================ ========================= ==================== ============================================================================
Operator                                                                         Type                      Min Program Version  Notes
================================================================================ ========================= ==================== ============================================================================
:any:`Txn.vote_pk() <TxnObject.vote_pk>`                                         :code:`TealType.bytes`    2                    32 byte address
:any:`Txn.selection_pk() <TxnObject.selection_pk>`                               :code:`TealType.bytes`    2                    32 byte address
:any:`Txn.state_proof_pk <TxnObject.state_proof_pk>`                             :code:`TealType.bytes`    6                    64 byte state proof public key commitment.
:any:`Txn.vote_first() <TxnObject.vote_first>`                                   :code:`TealType.uint64`   2
:any:`Txn.vote_last() <TxnObject.vote_last>`                                     :code:`TealType.uint64`   2
:any:`Txn.vote_key_dilution() <TxnObject.vote_key_dilution>`                     :code:`TealType.uint64`   2
:any:`Txn.nonparticipation() <TxnObject.nonparticipation>`                       :code:`TealType.uint64`   5                    Marks an account nonparticipating for rewards
================================================================================ ========================= ==================== ============================================================================

Payment
.......................................................
================================================================================ ========================= ==================== ============================================================================
Operator                                                                         Type                      Min Program Version  Notes
================================================================================ ========================= ==================== ============================================================================
:any:`Txn.receiver() <TxnObject.receiver>`                                       :code:`TealType.bytes`    2                    32 byte address
:any:`Txn.amount() <TxnObject.amount>`                                           :code:`TealType.uint64`   2                    in microAlgos
:any:`Txn.close_remainder_to() <TxnObject.close_remainder_to>`                   :code:`TealType.bytes`    2                    32 byte address
================================================================================ ========================= ==================== ============================================================================

Transaction Types
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The :any:`Txn.type_enum() <TxnObject.type_enum>` values can be checked using the :any:`TxnType` enum:

============================== =============== ============ =========================
Value                          Numerical Value Type String  Description
============================== =============== ============ =========================
:any:`TxnType.Unknown`         :code:`0`       unknown      unknown type, invalid
:any:`TxnType.Payment`         :code:`1`       pay          payment
:any:`TxnType.KeyRegistration` :code:`2`       keyreg       key registration
:any:`TxnType.AssetConfig`     :code:`3`       acfg         asset config
:any:`TxnType.AssetTransfer`   :code:`4`       axfer        asset transfer
:any:`TxnType.AssetFreeze`     :code:`5`       afrz         asset freeze
:any:`TxnType.ApplicationCall` :code:`6`       appl         application call
============================== =============== ============ =========================

Transaction Array Fields
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Some of the exposed transaction fields are arrays with the type :code:`TealType.uint64[]` or :code:`TealType.bytes[]`.
These fields are :code:`Txn.application_args`, :code:`Txn.assets`, :code:`Txn.accounts`, :code:`Txn.applications`,
and :code:`InnerTxn.logs`.

The length of these array fields can be found using the :code:`.length()` method, and individual
items can be accessed using bracket notation. For example:

.. code-block:: python

  Txn.application_args.length() # get the number of application arguments in the transaction
  Txn.application_args[0] # get the first application argument
  Txn.application_args[1] # get the second application argument

  # as of AVM v5, PyTeal expressions can be used to dynamically index into array properties as well
  Txn.application_args[Txn.application_args.length() - Int(1)] # get the last application argument

.. _txn_special_case_arrays:

Special case: :code:`Txn.accounts` and :code:`Txn.applications`
................................................................

The :code:`Txn.accounts` and :code:`Txn.applications` arrays are special cases. Normal arrays in
PyTeal are :code:`0`-indexed, but these are :code:`1`-indexed with special values at index :code:`0`.

For the accounts array, :code:`Txn.accounts[0]` is always equivalent to :code:`Txn.sender()`.

For the applications array, :code:`Txn.applications[0]` is always equivalent to :code:`Txn.application_id()`.

**IMPORTANT:** Since these arrays are :code:`1`-indexed, their lengths are handled differently.
For example, if :code:`Txn.accounts.length()` or :code:`Txn.applications.length()` is 2, then
indexes :code:`0`, :code:`1`, and :code:`2` will be present. In fact, the index :code:`0` will
always evaluate to the special values above, even when :code:`length()` is :code:`0`.

Atomic Transfer Groups
----------------------

`Atomic Transfers <https://developer.algorand.org/docs/features/atomic_transfers/>`_ are irreducible
batch transactions that allow groups of transactions to be submitted at one time. If any of the
transactions fail, then all the transactions will fail. PyTeal allows programs to access information
about the transactions in an atomic transfer group using the :any:`Gtxn` object. This object acts
like a list of :any:`TxnObject`, meaning all of the above transaction fields on :code:`Txn` are
available on the elements of :code:`Gtxn`. For example:

.. code-block:: python

  Gtxn[0].sender() # get the sender of the first transaction in the atomic transfer group
  Gtxn[1].receiver() # get the receiver of the second transaction in the atomic transfer group

  # as of AVM v3, PyTeal expressions can be used to dynamically index into Gtxn as well
  Gtxn[Txn.group_index() - Int(1)].sender() # get the sender of the previous transaction in the atomic transfer group

:code:`Gtxn` is zero-indexed and the maximum size of an atomic transfer group is 16. The size of the
current transaction group is available as :any:`Global.group_size()`. A standalone transaction will
have a group size of :code:`1`.

To find the current transaction's index in the transfer group, use :any:`Txn.group_index() <TxnObject.group_index>`. If the
current transaction is standalone, it's group index will be :code:`0`.

Inner Transactions
------------------

.. note::
    Inner transactions are only available in AVM version 5 or higher.

Inner transactions can be created and submitted with expressions from the :any:`InnerTxnBuilder` class.
The properties of the most recently submitted inner transaction can be accessed using the :any:`InnerTxn`
object. This object is an instance of :any:`TxnObject`, meaning all of the above transaction fields
on :code:`Txn` are available on :code:`InnerTxn` as well.

Global Parameters
-----------------

Information about the current state of the blockchain can be obtained using the following
:any:`Global` expressions:

=========================================== ======================= ==================== ===================================================================================================================
Operator                                    Type                    Min Program Version  Notes
=========================================== ======================= ==================== ===================================================================================================================
:any:`Global.min_txn_fee()`                 :code:`TealType.uint64` 2                    in microAlgos
:any:`Global.min_balance()`                 :code:`TealType.uint64` 2                    in microAlgos
:any:`Global.max_txn_life()`                :code:`TealType.uint64` 2                    number of rounds
:any:`Global.zero_address()`                :code:`TealType.bytes`  2                    32 byte address of all zero bytes
:any:`Global.group_size()`                  :code:`TealType.uint64` 2                    number of txns in this atomic transaction group, at least 1
:any:`Global.logic_sig_version()`           :code:`TealType.uint64` 2                    the maximum supported program version
:any:`Global.round()`                       :code:`TealType.uint64` 2                    the current round number
:any:`Global.latest_timestamp()`            :code:`TealType.uint64` 2                    the latest confirmed block UNIX timestamp
:any:`Global.current_application_id()`      :code:`TealType.uint64` 2                    the ID of the current application executing
:any:`Global.creator_address()`             :code:`TealType.bytes`  3                    32 byte address of the creator of the current application
:any:`Global.current_application_address()` :code:`TealType.bytes`  5                    32 byte address of the current application controlled account
:any:`Global.group_id()`                    :code:`TealType.bytes`  5                    32 byte ID of the current transaction group
:any:`Global.opcode_budget()`               :code:`TealType.uint64` 6                    The remaining cost that can be spent by opcodes in this program
:any:`Global.caller_app_id()`               :code:`TealType.uint64` 6                    The ID of the application that called the current application, or zero. Application mode only
:any:`Global.caller_app_address()`          :code:`TealType.bytes`  6                    32 byte address of the application that called the current application, or the zero address. Application mode only.
:any:`Global.asset_create_min_balance()`    :code:`TealType.uint64` 10                   The minimum balance required to create and opt into an asset
:any:`Global.asset_opt_in_min_balance()`    :code:`TealType.uint64` 10                   The minimum balance required to opt in to an asset
:any:`Global.genesis_hash()`                :code:`TealType.bytes`  10                   The genesis hash for the network
=========================================== ======================= ==================== ===================================================================================================================



================================================
FILE: docs/api.rst
================================================
.. _api:

PyTeal Package
==============

.. automodule:: pyteal
   :members:
   :undoc-members:
   :imported-members:
   :special-members: __getitem__
   :show-inheritance:

   .. data:: Txn
      :annotation: = <pyteal.TxnObject object>

      The current transaction being evaluated. This is an instance of :any:`TxnObject`.

   .. data:: Gtxn
      :annotation: = <pyteal.TxnGroup object>

      The current group of transactions being evaluated. This is an instance of :any:`TxnGroup`.

   .. data:: InnerTxn
      :annotation: = <pyteal.TxnObject object>

      The most recently submitted inner transaction. This is an instance of :any:`TxnObject`.

      If a transaction group was submitted most recently, then this will be the last transaction in that group.

   .. data:: Gitxn
      :annotation: = <pyteal.InnerTxnGroup object>

      The most recently submitted inner transaction group. This is an instance of :any:`InnerTxnGroup`.

      If a single transaction was submitted most recently, then this will be a group of size 1.

.. automodule:: pyteal.abi
   :members:
   :undoc-members:
   :imported-members:
   :special-members: __getitem__
   :show-inheritance:



================================================
FILE: docs/arithmetic_expression.rst
================================================
.. _arithmetic_expressions:

Arithmetic Operations
=====================

An arithmetic expression is an expression that results in a :code:`TealType.uint64` value.
In PyTeal, arithmetic expressions include integer and boolean operators (booleans are the integers
`0` or `1`). The table below summarized all arithmetic expressions in PyTeal.

=================================== ============== ================================================= ===========================
Operator                            Overloaded     Semantics                                         Example
=================================== ============== ================================================= ===========================
:any:`Lt(a, b) <Lt>`                :code:`a < b`  `1` if `a` is less than `b`, `0` otherwise        :code:`Int(1) < Int(5)`
:any:`Gt(a, b) <Gt>`                :code:`a > b`  `1` if `a` is greater than `b`, `0` otherwise     :code:`Int(1) > Int(5)`
:any:`Le(a, b) <Le>`                :code:`a <= b` `1` if `a` is no greater than `b`, `0` otherwise  :code:`Int(1) <= Int(5)`
:any:`Ge(a, b) <Ge>`                :code:`a >= b` `1` if `a` is no less than `b`, `0` otherwise     :code:`Int(1) >= Int(5)`
:any:`Add(a, b) <Add>`              :code:`a + b`  `a + b`, error (panic) if overflow                :code:`Int(1) + Int(5)`
:any:`Minus(a, b) <Minus>`          :code:`a - b`  `a - b`, error if underflow                       :code:`Int(5) - Int(1)`
:any:`Mul(a, b) <Mul>`              :code:`a * b`  `a * b`, error if overflow                        :code:`Int(2) * Int(3)`
:any:`Div(a, b) <Div>`              :code:`a / b`  `a / b`, error if divided by zero                 :code:`Int(3) / Int(2)`
:any:`Mod(a, b) <Mod>`              :code:`a % b`  `a % b`, modulo operation                         :code:`Int(7) % Int(3)`
:any:`Exp(a, b) <Exp>`              :code:`a ** b` `a ** b`, exponent operation                      :code:`Int(7) ** Int(3)`
:any:`Eq(a, b) <Eq>`                :code:`a == b` `1` if `a` equals `b`, `0` otherwise              :code:`Int(7) == Int(7)`
:any:`Neq(a, b) <Neq>`              :code:`a != b` `0` if `a` equals `b`, `1` otherwise              :code:`Int(7) != Int(7)`
:any:`And(a, b) <pyteal.And>`                      `1` if `a > 0 && b > 0`, `0` otherwise            :code:`And(Int(1), Int(1))`
:any:`Or(a, b) <pyteal.Or>`                        `1` if `a > 0 || b > 0`, `0` otherwise            :code:`Or(Int(1), Int(0))`
:any:`Not(a) <pyteal.Not>`                         `1` if `a` equals `0`, `0` otherwise              :code:`Not(Int(0))`
:any:`BitwiseAnd(a,b) <BitwiseAnd>` :code:`a & b`  `a & b`, bitwise and operation                    :code:`Int(1) & Int(3)`
:any:`BitwiseOr(a,b) <BitwiseOr>`   :code:`a | b`  `a | b`, bitwise or operation                     :code:`Int(2) | Int(5)`
:any:`BitwiseXor(a,b) <BitwiseXor>` :code:`a ^ b`  `a ^ b`, bitwise xor operation                    :code:`Int(3) ^ Int(7)`
:any:`BitwiseNot(a) <BitwiseNot>`   :code:`~a`     `~a`, bitwise complement operation                :code:`~Int(1)`
=================================== ============== ================================================= ===========================

Most of the above operations take two :code:`TealType.uint64` values as inputs.
In addition, :code:`Eq(a, b)` (:code:`==`) and :code:`Neq(a, b)` (:code:`!=`) also work for byte slices.
For example, :code:`Arg(0) == Arg(1)` and :code:`Arg(0) != Arg(1)` are valid PyTeal expressions.

Both :code:`And` and :code:`Or` also support more than 2 arguments when called as functions:

 * :code:`And(a, b, ...)`
 * :code:`Or(a, b, ...)`

The associativity and precedence of the overloaded Python arithmetic operators are the same as the
`original python operators <https://docs.python.org/3/reference/expressions.html#operator-precedence>`_ . For example:

 * :code:`Int(1) + Int(2) + Int(3)` is equivalent to :code:`Add(Add(Int(1), Int(2)), Int(3))`
 * :code:`Int(1) + Int(2) * Int(3)` is equivalent to :code:`Add(Int(1), Mul(Int(2), Int(3)))` 

Byteslice Arithmetic
--------------------

Byteslice arithmetic is available for AVM V4 and above. 
Byteslice arithmetic operators allow up to 512-bit arithmetic.
In PyTeal, byteslice arithmetic expressions include 
:code:`TealType.Bytes` values as arguments (with the exception of :code:`BytesZero`)
and must be 64 bytes or less.
The table below summarizes the byteslize arithmetic operations in PyTeal.

======================================= ======================= ====================================================================== ==================
Operator                                Return Type             Example                                                                Example Result
======================================= ======================= ====================================================================== ==================
:any:`BytesLt(a, b) <BytesLt>`          :code:`TealType.uint64` :code:`BytesLt(Bytes("base16", "0xFF"), Bytes("base16", "0xFE"))`      :code:`0`
:any:`BytesGt(a, b) <BytesGt>`          :code:`TealType.uint64` :code:`BytesGt(Bytes("base16", "0xFF"), Bytes("base16", "0xFE"))`      :code:`1`
:any:`BytesLe(a, b) <BytesLe>`          :code:`TealType.uint64` :code:`BytesLe(Bytes("base16", "0xFF"), Bytes("base16", "0xFE"))`      :code:`0`
:any:`BytesGe(a, b) <BytesGe>`          :code:`TealType.uint64` :code:`BytesGe(Bytes("base16", "0xFF"), Bytes("base16", "0xFE"))`      :code:`1`
:any:`BytesEq(a, b) <BytesEq>`          :code:`TealType.uint64` :code:`BytesEq(Bytes("base16", "0xFF"), Bytes("base16", "0xFF"))`      :code:`1`
:any:`BytesNeq(a, b) <BytesNeq>`        :code:`TealType.uint64` :code:`BytesNeq(Bytes("base16", "0xFF"), Bytes("base16", "0xFF"))`     :code:`0`
:any:`BytesAdd(a, b) <BytesAdd>`        :code:`TealType.Bytes`  :code:`BytesAdd(Bytes("base16", "0xFF"), Bytes("base16", "0xFE"))`     :code:`0x01FD`
:any:`BytesMinus(a, b) <BytesMinus>`    :code:`TealType.Bytes`  :code:`BytesMinus(Bytes("base16", "0xFF"), Bytes("base16", "0xFE"))`   :code:`0x01`
:any:`BytesMul(a, b) <BytesMul>`        :code:`TealType.Bytes`  :code:`BytesMul(Bytes("base16", "0xFF"), Bytes("base16", "0xFE"))`     :code:`0xFD02`
:any:`BytesDiv(a, b) <BytesDiv>`        :code:`TealType.Bytes`  :code:`BytesDiv(Bytes("base16", "0xFF"), Bytes("base16", "0x11"))`     :code:`0x0F`
:any:`BytesMod(a, b) <BytesMod>`        :code:`TealType.Bytes`  :code:`BytesMod(Bytes("base16", "0xFF"), Bytes("base16", "0x12"))`     :code:`0x03`
:any:`BytesAnd(a, b) <pyteal.BytesAnd>` :code:`TealType.Bytes`  :code:`BytesAnd(Bytes("base16", "0xBEEF"), Bytes("base16", "0x1337"))` :code:`0x1227`
:any:`BytesOr(a, b) <pyteal.BytesOr>`   :code:`TealType.Bytes`  :code:`BytesOr(Bytes("base16", "0xBEEF"), Bytes("base16", "0x1337"))`  :code:`0xBFFF`
:any:`BytesXor(a, b) <pyteal.BytesXor>` :code:`TealType.Bytes`  :code:`BytesXor(Bytes("base16", "0xBEEF"), Bytes("base16", "0x1337"))` :code:`0xADD8`
:any:`BytesNot(a) <pyteal.BytesNot>`    :code:`TealType.Bytes`  :code:`BytesNot(Bytes("base16", "0xFF00"))`                            :code:`0x00FF`
:any:`BytesZero(a) <pyteal.BytesZero>`  :code:`TealType.Bytes`  :code:`BytesZero(Int(4))`                                              :code:`0x00000000`
======================================= ======================= ====================================================================== ==================

Currently, byteslice arithmetic operations are not overloaded, and must be explicitly called.

.. _bit_and_byte_manipulation:

Bit and Byte Operations
-----------------------

In addition to the standard arithmetic operators above, PyTeal also supports operations that
manipulate the individual bits and bytes of PyTeal values.

To use these operations, you'll need to provide an index specifying which bit or byte to access.
These indexes have different meanings depending on whether you are manipulating integers or byte slices:

* For integers, bit indexing begins with low-order bits. For example, the bit at index 4 of the integer
  16 (:code:`000...0001000` in binary) is 1. Every other index has a bit value of 0. Any index less
  than 64 is valid, regardless of the integer's value.

  Byte indexing is not supported for integers.

* For byte strings, bit indexing begins at the first bit. For example, the bit at index 0 of the base16
  byte string :code:`0xf0` (:code:`11110000` in binary) is 1. Any index less than 4 has a bit
  value of 1, and any index 4 or greater has a bit value of 0. Any index less than 8 times the length
  of the byte string is valid.
  
  Likewise, byte indexing begins at the first byte of the string. For example, the byte at index 0 of
  that the base16 string :code:`0xff00` (:code:`1111111100000000` in binary) is 255 (:code:`111111111` in binary),
  and the byte at index 1 is 0. Any index less than the length of the byte string is valid.

Bit Manipulation
~~~~~~~~~~~~~~~~

The :any:`GetBit` expression can extract individual bit values from integers and byte strings. For example,

.. code-block:: python

    GetBit(Int(16), Int(0)) # get the 0th bit of 16, produces 0
    GetBit(Int(16), Int(4)) # get the 4th bit of 16, produces 1
    GetBit(Int(16), Int(63)) # get the 63rd bit of 16, produces 0
    GetBit(Int(16), Int(64)) # get the 64th bit of 16, invalid index

    GetBit(Bytes("base16", "0xf0"), Int(0)) # get the 0th bit of 0xf0, produces 1
    GetBit(Bytes("base16", "0xf0"), Int(7)) # get the 7th bit of 0xf0, produces 0
    GetBit(Bytes("base16", "0xf0"), Int(8)) # get the 8th bit of 0xf0, invalid index

Additionally, the :any:`SetBit` expression can modify individual bit values from integers and byte strings. For example,

.. code-block:: python

    SetBit(Int(0), Int(4), Int(1)) # set the 4th bit of 0 to 1, produces 16
    SetBit(Int(4), Int(0), Int(1)) # set the 0th bit of 4 to 1, produces 5
    SetBit(Int(4), Int(0), Int(0)) # set the 0th bit of 4 to 0, produces 4
    
    SetBit(Bytes("base16", "0x00"), Int(0), Int(1)) # set the 0th bit of 0x00 to 1, produces 0x80
    SetBit(Bytes("base16", "0x00"), Int(3), Int(1)) # set the 3rd bit of 0x00 to 1, produces 0x10
    SetBit(Bytes("base16", "0x00"), Int(7), Int(1)) # set the 7th bit of 0x00 to 1, produces 0x01

Byte Manipulation
~~~~~~~~~~~~~~~~~

In addition to manipulating bits, individual bytes in byte strings can be manipulated.

The :any:`GetByte` expression can extract individual bytes from byte strings. For example,

.. code-block:: python

    GetByte(Bytes("base16", "0xff00"), Int(0)) # get the 0th byte of 0xff00, produces 255
    GetByte(Bytes("base16", "0xff00"), Int(1)) # get the 1st byte of 0xff00, produces 0
    GetByte(Bytes("base16", "0xff00"), Int(2)) # get the 2nd byte of 0xff00, invalid index
    
    GetByte(Bytes("abc"), Int(0)) # get the 0th byte of "abc", produces 97 (ASCII 'a')
    GetByte(Bytes("abc"), Int(1)) # get the 1st byte of "abc", produces 98 (ASCII 'b')
    GetByte(Bytes("abc"), Int(2)) # get the 2nd byte of "abc", produces 99 (ASCII 'c')

Additionally, the :any:`SetByte` expression can modify individual bytes in byte strings. For example,

.. code-block:: python

    SetByte(Bytes("base16", "0xff00"), Int(0), Int(0)) # set the 0th byte of 0xff00 to 0, produces 0x0000
    SetByte(Bytes("base16", "0xff00"), Int(0), Int(128)) # set the 0th byte of 0xff00 to 128, produces 0x8000

    SetByte(Bytes("abc"), Int(0), Int(98)) # set the 0th byte of "abc" to 98 (ASCII 'b'), produces "bbc"
    SetByte(Bytes("abc"), Int(1), Int(66)) # set the 1st byte of "abc" to 66 (ASCII 'B'), produces "aBc"



================================================
FILE: docs/assets.rst
================================================
.. _assets:

Asset Information
=================

In addition to :ref:`manipulating state on the blockchain <state>`, stateful
smart contracts can also look up information about assets and account balances.

Algo Balances
-------------

The :any:`Balance` expression can be used to look up an account's balance in microAlgos (1 Algo = 1,000,000 microAlgos).
For example,

.. code-block:: python

    senderBalance = Balance(Txn.sender()) # get the balance of the sender
    account1Balance = Balance(Txn.accounts[1]) # get the balance of Txn.accounts[1]

The :any:`MinBalance` expression can be used to find an account's `minimum balance <https://developer.algorand.org/docs/features/accounts/#minimum-balance>`_.
This amount is also in microAlgos. For example,

.. code-block:: python

    senderMinBalance = MinBalance(Txn.sender()) # get the minimum balance of the sender by passing the account address (bytes)
    account1MinBalance = MinBalance(Txn.accounts[1]) # get the minimum balance of Txn.accounts[1] by passing the account address (bytes)

Additionally, :any:`Balance` and :any:`MinBalance` can be used together to calculate how many Algos
an account can spend without closing. For example,

.. code-block:: python

    senderSpendableBalance = Balance(Txn.sender()) - MinBalance(Txn.sender()) # calculate how many Algos the sender can spend
    account1SpendableBalance = Balance(Txn.accounts[1]) - MinBalance(Txn.accounts[1]) # calculate how many Algos Txn.accounts[1] can spend

Asset Holdings
--------------

In addition to Algos, the Algorand blockchain also supports additional on-chain assets called `Algorand Standard Assets (ASAs) <https://developer.algorand.org/docs/features/asa/>`_.
The :any:`AssetHolding` group of expressions can be used to look up information about the ASAs that
an account holds.

Similar to :ref:`external state expressions <external_state>`, these expression return a :any:`MaybeValue`.
This value cannot be used directly, but has methods :any:`MaybeValue.hasValue()` and :any:`MaybeValue.value()`.

If the account has opted into the asset being looked up, :code:`hasValue()` will return :code:`1`
and :code:`value()` will return the value being looked up (either the asset's balance or frozen status).
Otherwise, :code:`hasValue()` and :code:`value()` will return :code:`0`.

Balances
~~~~~~~~

The :any:`AssetHolding.balance` expression can be used to look up how many units of an asset an
account holds. For example,

.. code-block:: python

    # get the balance of the sender for asset `Txn.assets[0]`
    # if the account is not opted into that asset, returns 0
    senderAssetBalance = AssetHolding.balance(Txn.sender(), Txn.assets[0])
    program = Seq([
        senderAssetBalance,
        senderAssetBalance.value()
    ])

    # get the balance of Txn.accounts[1] for asset `Txn.assets[1]`
    # if the account is not opted into that asset, exit with an error
    account1AssetBalance = AssetHolding.balance(Txn.accounts[1], Txn.assets[1])
    program = Seq([
        account1AssetBalance,
        Assert(account1AssetBalance.hasValue()),
        account1AssetBalance.value()
    ])

Frozen
~~~~~~

The :any:`AssetHolding.frozen` expression can be used to check if an asset is frozen for an account.
A value of :code:`1` indicates frozen and :code:`0` indicates not frozen. For example,

.. code-block:: python

    # get the frozen status of the sender for asset `Txn.assets[0]`
    # if the account is not opted into that asset, returns 0
    senderAssetFrozen = AssetHolding.frozen(Txn.sender(), Txn.assets[0])
    program = Seq([
        senderAssetFrozen,
        senderAssetFrozen.value()
    ])

    # get the frozen status of Txn.accounts[1] for asset `Txn.assets[1]`
    # if the account is not opted into that asset, exit with an error
    account1AssetFrozen = AssetHolding.frozen(Txn.accounts[1], Txn.assets[1])
    program = Seq([
        account1AssetFrozen,
        Assert(account1AssetFrozen.hasValue()),
        account1AssetFrozen.value()
    ])

Asset Parameters
----------------

Every ASA has parameters that contain information about the asset and how it behaves. These
parameters can be read by TEAL applications for any asset in the :any:`Txn.assets <TxnObject.assets>`
array.

The :any:`AssetParam` group of expressions are used to access asset parameters. Like :code:`AssetHolding`,
these expressions return a :any:`MaybeValue`.

The :code:`hasValue()` method will return :code:`0` only if the asset being looked up does not exist
(i.e. the ID in :code:`Txn.assets` does not represent an asset).

For optional parameters that are not set, :code:`hasValue()` will still return :code:`1` and :code:`value()`
will return a zero-length byte string (all optional parameters are :code:`TealType.bytes`).

The different parameters that can be accessed are summarized by the table below. More information
about each parameter can be found on the `Algorand developer website <https://developer.algorand.org/docs/features/asa/#asset-parameters>`_.

================================= ======================= ==========================================================
Expression                        Type                    Description
================================= ======================= ==========================================================
:any:`AssetParam.total()`         :code:`TealType.uint64` The total number of units of the asset.
:any:`AssetParam.decimals()`      :code:`TealType.uint64` The number of decimals the asset should be formatted with.
:any:`AssetParam.defaultFrozen()` :code:`TealType.uint64` Whether the asset is frozen by default.
:any:`AssetParam.unitName()`      :code:`TealType.bytes`  The name of the asset's units.
:any:`AssetParam.name()`          :code:`TealType.bytes`  The name of the asset.
:any:`AssetParam.url()`           :code:`TealType.bytes`  A URL associated with the asset.
:any:`AssetParam.metadataHash()`  :code:`TealType.bytes`  A 32-byte hash associated with the asset.
:any:`AssetParam.creator()`       :code:`TealType.bytes`  The address of the asset's creator account.
:any:`AssetParam.manager()`       :code:`TealType.bytes`  The address of the asset's manager account.
:any:`AssetParam.reserve()`       :code:`TealType.bytes`  The address of the asset's reserve account.
:any:`AssetParam.freeze()`        :code:`TealType.bytes`  The address of the asset's freeze account.
:any:`AssetParam.clawback()`      :code:`TealType.bytes`  The address of the asset's clawback account.
================================= ======================= ==========================================================

Here's an example that uses an asset parameter:

.. code-block:: python

    # get the total number of units for asset `Txn.assets[0]`
    # if the asset is invalid, exit with an error
    assetTotal = AssetParam.total(Txn.assets[0])

    program = Seq([
        assetTotal,
        Assert(assetTotal.hasValue()),
        assetTotal.value()
    ])



================================================
FILE: docs/byte_expression.rst
================================================
.. _byte_expressions:

Byte Operators
====================

TEAL byte slices are similar to strings and can be manipulated in the same way.

Length
------

The length of a byte slice can be obtained using the :any:`Len` expression. For example:

.. code-block:: python

    Len(Bytes("")) # will produce 0
    Len(Bytes("algorand")) # will produce 8

Concatenation
-------------

Byte slices can be combined using the :any:`Concat` expression. This expression takes at least
two arguments and produces a new byte slice consisting of each argument, one after another. For
example:

.. code-block:: python

    Concat(Bytes("a"), Bytes("b"), Bytes("c")) # will produce "abc"

Substring Extraction
--------------------

Byte slices can be extracted from other byte slices using the :any:`Substring` and :any:`Extract`
expressions. These expressions are extremely similar, except one specifies a substring by start and
end indexes, while the other uses a start index and length. Use whichever makes sense for your
application.

Substring
~~~~~~~~~

The :any:`Substring` expression can extract part of a byte slice given start and end indices. For
example:

.. code-block:: python

    Substring(Bytes("algorand"), Int(2), Int(8)) # will produce "gorand"

Extract
~~~~~~~

.. note::
    :code:`Extract` is only available in program version 5 or higher.

The :any:`Extract` expression can extract part of a byte slice given the start index and length. For
example:

.. code-block:: python

    Extract(Bytes("algorand"), Int(2), Int(6)) # will produce "gorand"

Manipulating Individual Bits and Bytes
--------------------------------------

The individual bits and bytes in a byte string can be extracted and changed. See :ref:`bit_and_byte_manipulation`
for more information.



================================================
FILE: docs/compiler_optimization.rst
================================================
.. _compiler_optimization:

Compiler Optimization
========================

The optimizer is a tool for improving performance and reducing resource consumption. In this context,
the terms *performance* and *resource* can apply across multiple dimensions, including but not limited
to: compiled code size, scratch slot usage, opcode cost, etc. 

Optimizer Usage
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The compiler determines which optimizations to apply based on the provided :any:`OptimizeOptions` object as
shown in the code block below. Both :any:`compileTeal` as well as the :any:`Router.compile_program` method
can receive an :code:`optimize` parameter of type :any:`OptimizeOptions`.


.. code-block:: python

    # optimize scratch slots for all program versions (shown is version 4)
    optimize_options = OptimizeOptions(scratch_slots=True)
    compileTeal(approval_program(), mode=Mode.Application, version=4, optimize=optimize_options)

============================== ================================================================================ ===========================
Optimization Flag              Description                                                                      Default
============================== ================================================================================ ===========================
:code:`scratch_slots`          A boolean describing whether or not scratch slot optimization should be applied. :code:`False`
============================== ================================================================================ ===========================

Default Behavior
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The :any:`OptimizeOptions` constructor receives keyword arguments representing flags for particular optimizations.
If an argument is not provided to the constructor of :any:`OptimizeOptions`, a default program version dependent 
optimization behavior is used in its place according to the table below. 


.. list-table::
   :widths: 25 25 25 25 25
   :header-rows: 1

   * - Optimization Flag
     - Value
     - Interpretation
     - Program Version
     - Behavior
   * - :code:`scratch_slots`
     - :code:`None`
     - Default
     - ≥ 9
     - Scratch slot optimization is applied
   * -
     - :code:`None`
     - Default
     - ≤ 8
     - Scratch slot optimization is *not* applied
   * -
     - :code:`True`
     - Enable
     - *any*
     - Scratch slot optimization is applied
   * -
     - :code:`False`
     - Disable
     - *any*
     - Scratch slot optimization is *not* applied
   * - :code:`frame_pointers`
     - :code:`None`
     - Default
     - ≥ 8
     - Frame pointers available and are therefore applied
   * -
     - :code:`None`
     - Default
     - ≤ 7
     - Frame pointers not available and not applied
   * -
     - :code:`True`
     - Enable
     - ≥ 8
     - Frame pointers available and applied
   * -
     - :code:`True`
     - *attempt*
     - ≤ 7
     - An error occurs when attempting to compile as frame pointers are not available
   * -
     - :code:`False`
     - Disable
     - *any*
     - Frame pointers not applied
   

When the :code:`optimize` parameter is omitted in :any:`compileTeal` 
or :any:`Router.compile_program`, all parameters conform to program version dependent defaults
as defined in the above table. For example:

.. code-block:: python

    # apply default optimization behavior by NOT providing `OptimizeOptions`
    # for version 9 as shown next, this is equivalent to passing in 
    # optimize=OptimizeOptions(scratch_slots=True, frame_pointers=True)

    compileTeal(approval_program(), mode=Mode.Application, version=9)

    # for version 8 as shown next, this is equivalent to passing in 
    # optimize=OptimizeOptions(scratch_slots=False, frame_pointers=True)

    compileTeal(approval_program(), mode=Mode.Application, version=8)



================================================
FILE: docs/conf.py
================================================
# Configuration file for the Sphinx documentation builder.
#
# This file only contains a selection of the most common options. For a full
# list see the documentation:
# https://www.sphinx-doc.org/en/master/usage/configuration.html

# -- Path setup --------------------------------------------------------------

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.

import os
import sys

sys.path.insert(0, os.path.abspath(".."))


# -- Project information -----------------------------------------------------

project = "PyTeal"
copyright = "2022, Algorand"
author = "Algorand"


# -- General configuration ---------------------------------------------------

# Add any Sphinx extension module names here, as strings. They can be
# extensions coming with Sphinx (named 'sphinx.ext.*') or your custom
# ones.
extensions = ["sphinx.ext.autodoc", "sphinx.ext.napoleon"]
source_suffix = [".rst"]
master_doc = "index"

napoleon_include_init_with_doc = True

# Add any paths that contain templates here, relative to this directory.
templates_path = ["_templates"]

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
# This pattern also affects html_static_path and html_extra_path.
exclude_patterns = ["_build", "Thumbs.db", ".DS_Store"]


# -- Options for HTML output -------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
#
html_theme = "sphinx_rtd_theme"

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
# html_static_path = ["_static"]



================================================
FILE: docs/control_structures.rst
================================================
.. _control_flow:

Control Flow
============

PyTeal provides several control flow expressions to create programs.

.. _return_expr:

Exiting the Program: :code:`Approve` and :code:`Reject`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. note::
    The :code:`Approve` and :code:`Reject` expressions are only available in program version 4 or higher.
    Prior to this, :code:`Return(Int(1))` is equivalent to :code:`Approve()` and :code:`Return(Int(0))`
    is equivalent to :code:`Reject()`.

The :any:`Approve` and :any:`Reject` expressions cause the program to immediately exit. If :code:`Approve`
is used, then the execution is marked as successful, and if :code:`Reject` is used, then the execution
is marked as unsuccessful.

These expressions also work inside :ref:`subroutines <subroutine_expr>`. When used inside subroutines, they
also cause the program to immediately exit, contrary to :code:`Return(...)` which just returns from the subroutine.

.. _seq_expr:

Chaining Expressions: :code:`Seq`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The :any:`Seq` expression can be used to create a sequence of multiple expressions.  It's arguments are the 
expressions to include in the sequence, either as a variable number of arguments, or as a single list

For example:

.. code-block:: python

    Seq(
        App.globalPut(Bytes("creator"), Txn.sender()),
        Return(Int(1))
    )

A :code:`Seq` expression will take on the value of its last expression. Additionally, all
expressions in a :code:`Seq` expression, except the last one, must not return anything (e.g.
evaluate to :any:`TealType.none`). This restriction is in place because intermediate values must not
add things to the TEAL stack. As a result, the following is an invalid sequence:

.. code-block:: python
    :caption: Invalid Seq expression

    Seq(
        Txn.sender(),
        Return(Int(1))
    )


If you must include an operation that returns a value in the earlier
part of a sequence, you can wrap the value in a :any:`Pop` expression to discard it. For example,

.. code-block:: python

    Seq(
        Pop(Txn.sender()),
        Return(Int(1))
    )

.. _if_expr:

Simple Branching: :code:`If`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

In an :any:`If` expression,

.. code-block:: racket

    If(test-expr, then-expr, else-expr)

the :code:`test-expr` is always evaluated and needs to be typed :code:`TealType.uint64`.
If it results in a value greater than `0`, then the :code:`then-expr` is evaluated.
Otherwise, :code:`else-expr` is evaluated. Note that :code:`then-expr` and :code:`else-expr` must
evaluate to the same type (e.g. both :code:`TealType.uint64`).

You may also invoke an :any:`If` expression without an :code:`else-expr`:

.. code-block:: racket

    If(test-expr, then-expr)

In this case, :code:`then-expr` must be typed :code:`TealType.none`.

There is also an alternate way to write an :any:`If` expression that makes reading
complex statements easier to read.

.. code-block:: racket

    If(test-expr)
    .Then(then-expr)
    .ElseIf(test-expr)
    .Then(then-expr)
    .Else(else-expr)

.. _assert_expr:

Checking Conditions: :code:`Assert`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The :any:`Assert` expression can be used to ensure that conditions are met before continuing the
program. The syntax for :code:`Assert` is:

.. code-block:: racket

    Assert(test-expr)

If :code:`test-expr` is always evaluated and must be typed :code:`TealType.uint64`. If
:code:`test-expr` results in a value greater than `0`, the program continues. Otherwise, the program
immediately exits and indicates that it encountered an error.

Example:

.. code-block:: python

        Assert(Txn.type_enum() == TxnType.Payment)

The above example will cause the program to immediately fail with an error if the transaction type
is not a payment.

.. _cond_expr:

Chaining Tests: :code:`Cond`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

A :any:`Cond` expression chains a series of tests to select a result expression.
The syntax of `Cond` is:

.. code-block:: racket

    Cond([test-expr-1, body-1],
         [test-expr-2, body-2],
         . . . )

Each :code:`test-expr` is evaluated in order. If it produces `0`, the paired :code:`body`
is ignored, and evaluation proceeds to the next :code:`test-expr`.
As soon as a :code:`test-expr` produces a true value (`> 0`),
its :code:`body` is evaluated to produce the value for this :code:`Cond` expression.
If none of :code:`test-expr` s evaluates to a true value, the :code:`Cond` expression will
be evaluated to :code:`err`, a TEAL opcode that causes the runtime panic.

In a :code:`Cond` expression, each :code:`test-expr` needs to be typed :code:`TealType.uint64`.
A :code:`body` could be typed either :code:`TealType.uint64` or :code:`TealType.bytes`. However, all
:code:`body` s must have the same data type. Otherwise, a :code:`TealTypeError` is triggered.

Example:



.. code-block:: python

        Cond([Global.group_size() == Int(5), bid],
             [Global.group_size() == Int(4), redeem],
             [Global.group_size() == Int(1), wrapup])


This PyTeal code branches on the size of the atomic transaction group.

.. _loop_while_expr:

Looping: :code:`While`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. note::
    This expression is only available in program version 4 or higher.

The :any:`While` expression can be used to create simple loops in PyTeal. The syntax of :code:`While` is:

.. code-block:: racket

    While(loop-condition).Do(loop-body)

The :code:`loop-condition` expression must evaluate to :code:`TealType.uint64`, and the :code:`loop-body`
expression must evaluate to :code:`TealType.none`.

The :code:`loop-body` expression will continue to execute as long as :code:`loop-condition` produces
a true value (`> 0`).

For example, the following code uses :any:`ScratchVar` to iterate through every transaction in the
current group and sum up all of their fees.

.. code-block:: python

        totalFees = ScratchVar(TealType.uint64)
        i = ScratchVar(TealType.uint64)

        Seq([
            i.store(Int(0)),
            totalFees.store(Int(0)),
            While(i.load() < Global.group_size()).Do(
                totalFees.store(totalFees.load() + Gtxn[i.load()].fee()),
                i.store(i.load() + Int(1))
            )
        ])

.. _loop_for_expr:

Looping: :code:`For`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. note::
    This expression is only available in program version 4 or higher.

Similar to :code:`While`, the :any:`For` expression can also be used to create loops in PyTeal. The
syntax of :code:`For` is:

.. code-block:: racket

    For(loop-start, loop-condition, loop-step).Do(loop-body)

The :code:`loop-start`, :code:`loop-step`, and :code:`loop-body` expressions must evaluate to
:code:`TealType.none`, and the the :code:`loop-condition` expression must evaluate to :code:`TealType.uint64`.

When a :code:`For` expression is executed, :code:`loop-start` is executed first. Then the
expressions :code:`loop-condition`, :code:`loop-body`, and :code:`loop-step` will continue to
execute in order as long as :code:`loop-condition` produces a true value (`> 0`).

For example, the following code uses :any:`ScratchVar` to iterate through every transaction in the
current group and sum up all of their fees. The code here is functionally equivalent to the
:code:`While` loop example above.

.. code-block:: python

        totalFees = ScratchVar(TealType.uint64)
        i = ScratchVar(TealType.uint64)

        Seq([
            totalFees.store(Int(0)),
            For(i.store(Int(0)), i.load() < Global.group_size(), i.store(i.load() + Int(1))).Do(
                totalFees.store(totalFees.load() + Gtxn[i.load()].fee())
            )
        ])

.. _loop_exit_expr:

Exiting Loops: :code:`Continue` and :code:`Break`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The expressions :any:`Continue` and :any:`Break` can be used to exit :code:`While` and :code:`For`
loops in different ways.

When :code:`Continue` is present in the loop body, it instructs the program to skip the remainder
of the loop body. The loop may continue to execute as long as its condition remains true.

For example, the code below iterates though every transaction in the current group and counts how
many are payments, using the :code:`Continue` expression.

.. code-block:: python

        numPayments = ScratchVar(TealType.uint64)
        i = ScratchVar(TealType.uint64)

        Seq([
            numPayments.store(Int(0)),
            For(i.store(Int(0)), i.load() < Global.group_size(), i.store(i.load() + Int(1))).Do(
                If(Gtxn[i.load()].type_enum() != TxnType.Payment)
                .Then(Continue()),
                numPayments.store(numPayments.load() + Int(1))
            )
        ])

When :code:`Break` is present in the loop body, it instructs the program to completely exit the
current loop. The loop will not continue to execute, even if its condition remains true.

For example, the code below finds the index of the first payment transaction in the current group,
using the :code:`Break` expression.

.. code-block:: python

        firstPaymentIndex = ScratchVar(TealType.uint64)
        i = ScratchVar(TealType.uint64)

        Seq([
            # store a default value in case no payment transactions are found
            firstPaymentIndex.store(Global.group_size()),
            For(i.store(Int(0)), i.load() < Global.group_size(), i.store(i.load() + Int(1))).Do(
                If(Gtxn[i.load()].type_enum() == TxnType.Payment)
                .Then(
                    firstPaymentIndex.store(i.load()),
                    Break()
                )
            ),
            # assert that a payment was found
            Assert(firstPaymentIndex.load() < Global.group_size())
        ])

.. _subroutine_expr:

Subroutines
~~~~~~~~~~~

.. note::
    Subroutines are only available in program version 4 or higher.

A subroutine is section of code that can be called multiple times from within a program. Subroutines are PyTeal's equivalent to functions.  Subroutine constraints include:

* Subroutines accept any number of arguments.
* Subroutine argument types can be any `Expr` (PyTeal expression) or strictly `ScratchVar` (no subclasses allowed).  PyTeal applies pass-by-value semantics to `Expr` and pass-by-reference to `ScratchVar`.
* Subroutines return a single value, or no value.

Creating Subroutines
--------------------

To create a subroutine, apply the :any:`Subroutine` function decorator to a Python function which
implements the subroutine. This decorator takes one argument, which is the return type of the subroutine.
:any:`TealType.none` indicates that the subroutine does not return a value, and any other type
(e.g. :any:`TealType.uint64` or :any:`TealType.bytes`) indicates the return type of the single value
the subroutine returns.

For example,

.. code-block:: python

        @Subroutine(TealType.uint64)
        def isEven(i):
            return i % Int(2) == Int(0)

PyTeal applies these parameter type annotation constraints when compiling subroutine definitions:

* :any:`ScratchVar` parameters *require* a type annotation.
* :any:`Expr` parameters do *not* require a type annotation.  PyTeal implicitly declares unannotated parameter types as :any:`Expr`.

Here's an example illustrating `ScratchVar` parameter declaration with parameter type annotations:

.. code-block:: python

    @Subroutine(TealType.none)
    def swap(x: ScratchVar, y: ScratchVar):
        z = ScratchVar(TealType.anytype)
        return Seq(
            z.store(x.load()),
            x.store(y.load()),
            y.store(z.load()),
        )

Calling Subroutines
-------------------

To call a subroutine, simply call it like a normal Python function and pass in its arguments. For example,

.. code-block:: python

        App.globalPut(Bytes("value_is_even"), isEven(Int(10)))

Recursion
---------

Recursion with subroutines is also possible. For example, the subroutine below also checks if its
argument is even, but uses recursion to do so.

.. code-block:: python

        @Subroutine(TealType.uint64)
        def recursiveIsEven(i):
            return (
                If(i == Int(0))
                .Then(Int(1))
                .ElseIf(i == Int(1))
                .Then(Int(0))
                .Else(recursiveIsEven(i - Int(2)))
            )

Recursion and `ScratchVar`'s
----------------------------

Recursion with parameters of type `ScratchVar` is disallowed. For example, the following
subroutine is considered illegal and attempting compilation will result in a `TealInputError`:

.. code-block:: python

        @Subroutine(TealType.none)
        def ILLEGAL_recursion(i: ScratchVar):
            return (
                If(i.load() == Int(0))
                .Then(i.store(Int(1)))
                .ElseIf(i.load() == Int(1))
                .Then(i.store(Int(0)))
                .Else(i.store(i.load() - Int(2)), ILLEGAL_recursion(i))
            )




Exiting Subroutines
-------------------

The :any:`Return` expression can be used to explicitly return from a subroutine.

If the subroutine does not return a value, :code:`Return` should be called with no arguments. For
example, the subroutine below asserts that the first payment transaction in the current group has a
fee of 0:

.. code-block:: python

        @Subroutine(TealType.none)
        def assertFirstPaymentHasZeroFee():
            i = ScratchVar(TealType.uint64)

            return Seq([
                For(i.store(Int(0)), i.load() < Global.group_size(), i.store(i.load() + Int(1))).Do(
                    If(Gtxn[i.load()].type_enum() == TxnType.Payment)
                    .Then(
                        Assert(Gtxn[i.load()].fee() == Int(0)),
                        Return()
                    )
                ),
                # no payments found
                Err()
            ])

Otherwise if the subroutine does return a value, that value should be the argument to the :code:`Return`
expression. For example, the subroutine below checks whether the current group contains a payment
transaction:

.. code-block:: python

        @Subroutine(TealType.uint64)
        def hasPayment():
            i = ScratchVar(TealType.uint64)

            return Seq([
                For(i.store(Int(0)), i.load() < Global.group_size(), i.store(i.load() + Int(1))).Do(
                    If(Gtxn[i.load()].type_enum() == TxnType.Payment)
                    .Then(Return(Int(1)))
                ),
                Return(Int(0))
            ])

:code:`Return` can also be called from the main program. In this case, a single integer argument
should be provided, which is the success value for the current execution. A true value (`> 0`)
is equivalent to :any:`Approve`, and a false value is equivalent to :any:`Reject`.



================================================
FILE: docs/crypto.rst
================================================
.. _crypto:

Cryptographic Primitives
========================

Algorand Smart Contracts support the set of cryptographic primitives described in the table below.
Each of these cryptographic primitives is associated with a cost, which is a number indicating its
relative performance overhead compared with simple TEAL operations such as addition and substraction.
Simple TEAL opcodes have cost `1`, and more advanced cryptographic operations have a larger cost.
Below is how you express cryptographic primitives in PyTeal:


==================================== =========== ==================================================================================================================
Operator                             Cost        Description
==================================== =========== ==================================================================================================================
:code:`Sha256(e)`                    `35`        `SHA-256` hash function, produces 32 bytes
:code:`Sha3_256(e)`                  `130`       `SHA3-256` hash function, produces 32 bytes
:code:`Keccak256(e)`                 `130`       `Keccak-256` hash funciton, produces 32 bytes
:code:`Sha512_256(e)`                `45`        `SHA-512/256` hash function, produces 32 bytes
:code:`MiMC(e)`                      `10+550/32` `MiMC` hash function, produces 32 bytes
:code:`Ed25519Verify(d, s, p)`       `1900`\*    `1` if :code:`s` is the signature of the concatenation :code:`("ProgData" + hash_of_current_program + d)` signed by the private key corresponding to the public key :code:`p`, else `0`
:code:`Ed25519Verify_Bare(d, s, p)`  `1900`      `1` if :code:`s` is the signature of :code:`d` signed by the private key corresponding to the public key :code:`p`, else `0`
:code:`EcdsaVerify(c, d, r, s, pk)`  `1700`      `1` if :code:`(r, s)` is the signature of :code:`d` by private key corresponding to public key :code:`pk`, else 0
:code:`EcdsaDecompress(c, short_pk)` `650`       produces the decompressed public key associated with the compressed public key :code:`short_pk`
:code:`EcdsaRecover(c, d, id, r, s)` `2000`      produces the public key associated with the signature :code:`(r, s)` and recovery id :code:`id`
==================================== =========== ==================================================================================================================

\* :code:`Ed25519Verify` is only available in signature mode up to version 4 of AVM. From version 5 upwards, `Ed25519Verify` can be used in any mode.

Note the cost amount is accurate for version 2 of AVM and higher. The parameter :code:`c` in the ECDSA expressions defined above represents the elliptic curve
specification to be used (for example, :code:`Secp256k1`).

These cryptographic primitives cover the most used ones in blockchains and cryptocurrencies. For example, Bitcoin uses `SHA-256` for creating Bitcoin addresses;
Algorand uses `ed25519` signature scheme for authorization and uses `SHA-512/256` hash function for
creating contract account addresses from TEAL bytecode.



================================================
FILE: docs/data_type.rst
================================================
.. _data-type:

Data Types and Constants
========================

A PyTeal expression has one of the following two data types:

 * :any:`TealType.uint64`, 64 bit unsigned integer
 * :any:`TealType.bytes`, a slice of bytes

For example, all the transaction arguments (e.g. :code:`Arg(0)`) are of type :any:`TealType.bytes`.
The first valid round of current transaction (:any:`Txn.first_valid() <TxnObject.first_valid()>`) is typed :any:`TealType.uint64`.

Integers
--------

:code:`Int(n)` creates a :code:`TealType.uint64` constant, where :code:`n >= 0 and n < 2 ** 64`.

Bytes
-----

A byte slice is a binary string. There are several ways to encode a byte slice in PyTeal:

UTF-8
~~~~~

Byte slices can be created from UTF-8 encoded strings. For example:

.. code-block:: Python

    Bytes("hello world")

Base16
~~~~~~

Byte slices can be created from a :rfc:`4648#section-8` base16 encoded
binary string, e.g. :code:`"0xA21212EF"` or :code:`"A21212EF"`. For example:

.. code-block:: Python

    Bytes("base16", "0xA21212EF")
    Bytes("base16", "A21212EF") # "0x" is optional

Base32
~~~~~~

Byte slices can be created from a :rfc:`4648#section-6` base32 encoded
binary string with or without padding, e.g. :code:`"7Z5PWO2C6LFNQFGHWKSK5H47IQP5OJW2M3HA2QPXTY3WTNP5NU2MHBW27M"`.

.. code-block:: Python

    Bytes("base32", "7Z5PWO2C6LFNQFGHWKSK5H47IQP5OJW2M3HA2QPXTY3WTNP5NU2MHBW27M")

Base64
~~~~~~

Byte slices can be created from a :rfc:`4648#section-4` base64 encoded
binary string, e.g. :code:`"Zm9vYmE="`.

.. code-block:: Python

    Bytes("base64", "Zm9vYmE=")

Type Checking
-------------

All PyTeal expressions are type checked at construction time, for example, running
the following code triggers a :code:`TealTypeError`:  ::

  Int(0) < Arg(0)

Since :code:`<` (overloaded Python operator, see :ref:`arithmetic_expressions` for more details)
requires both operands of type :code:`TealType.uint64`,
while :code:`Arg(0)` is of type :code:`TealType.bytes`.

Conversion
----------

Converting a value to its corresponding value in the other data type is supported by the following two operators:

 * :any:`Itob(n) <Itob>`: generate a :code:`TealType.bytes` value from a :code:`TealType.uint64` value :code:`n`
 * :any:`Btoi(b) <Btoi>`: generate a :code:`TealType.uint64` value from a :code:`TealType.bytes` value :code:`b`

**Note:** These operations are **not** meant to convert between human-readable strings and numbers.
:code:`Itob` produces a big-endian 8-byte encoding of an unsigned integer, not a human readable
string. For example, :code:`Itob(Int(1))` will produce the string :code:`"\x00\x00\x00\x00\x00\x00\x00\x01"`
not the string :code:`"1"`.



================================================
FILE: docs/examples.rst
================================================
.. _examples:

PyTeal Examples
===============

Here are some additional PyTeal example programs:

Signature Mode
--------------

Atomic Swap
~~~~~~~~~~~~~~~

*Atomic Swap* allows the transfer of Algos from a buyer to a seller in exchange for a good or
service. This is done using a *Hashed Time Locked Contract*. In this scheme, the buyer funds a
TEAL account with the sale price. The buyer also picks a secret value and encodes a secure hash of
this value in the TEAL program. The TEAL program will transfer its balance to the seller if the
seller is able to provide the secret value that corresponds to the hash in the program. When the
seller renders the good or service to the buyer, the buyer discloses the secret from the program.
The seller can immediately verify the secret and withdraw the payment.

.. literalinclude:: ../examples/signature/atomic_swap.py
    :language: python

Split Payment
~~~~~~~~~~~~~

*Split Payment* splits payment between :code:`tmpl_rcv1` and :code:`tmpl_rcv2` on the ratio of
:code:`tmpl_ratn / tmpl_ratd`.

.. literalinclude:: ../examples/signature/split.py
    :language: python

Periodic Payment
~~~~~~~~~~~~~~~~

*Periodic Payment* allows some account to execute periodic withdrawal of funds. This PyTeal program
creates an contract account that allows :code:`tmpl_rcv` to withdraw :code:`tmpl_amt` every
:code:`tmpl_period` rounds for :code:`tmpl_dur` after every multiple of :code:`tmpl_period`.

After :code:`tmpl_timeout`, all remaining funds in the escrow are available to :code:`tmpl_rcv`.

.. literalinclude:: ../examples/signature/periodic_payment.py
    :language: python

Application Mode
----------------

Voting
~~~~~~

*Voting* allows accounts to register and vote for arbitrary choices. Here a *choice* is any byte
slice and anyone is allowed to register to vote.

This example has a configurable *registration period* defined by the global state :code:`RegBegin`
and :code:`RegEnd` which restrict when accounts can register to vote. There is also a separate
configurable *voting period* defined by the global state :code:`VotingBegin` and :code:`VotingEnd`
which restrict when voting can take place.

An account must register in order to vote. Accounts cannot vote more than once, and if an account
opts out of the application before the voting period has concluded, their vote is discarded. The
results are visible in the global state of the application, and the winner is the candidate with the
highest number of votes.

.. literalinclude:: ../examples/application/vote.py
    :language: python

A reference script that deploys the voting application is below:

.. literalinclude:: ../examples/application/vote_deploy.py
    :language: python

Example output for deployment would be:

.. code-block:: bash

    Registration rounds: 592 to 602
    Vote rounds: 603 to 613
    Waiting for confirmation...
    Transaction KXJHR6J4QSCAHO36L77DPJ53CLZBCCSPSBAOGTGQDRA7WECDXUEA confirmed in round 584.
    Created new app-id: 29
    Global state: {'RegEnd': 602, 'VoteBegin': 603, 'VoteEnd': 613, 'Creator': '49y8gDrKSnM77cgRyFzYdlkw18SDVNKhhOiS6NVVH8U=', 'RegBegin': 592}
    Waiting for round 592
    Round 585
    Round 586
    Round 587
    Round 588
    Round 589
    Round 590
    Round 591
    Round 592
    OptIn from account:  FVQEFNOSD25TDBTTTIU2I5KW5DHR6PADYMZESTOCQ2O3ME4OWXEI7OHVRY
    Waiting for confirmation...
    Transaction YWXOAREFSUYID6QLWQHANTXK3NR2XOVTIQYKMD27F3VXJKP7CMYQ confirmed in round 595.
    OptIn to app-id: 29
    Waiting for round 603
    Round 596
    Round 597
    Round 598
    Round 599
    Round 600
    Round 601
    Round 602
    Round 603
    Call from account: FVQEFNOSD25TDBTTTIU2I5KW5DHR6PADYMZESTOCQ2O3ME4OWXEI7OHVRY
    Waiting for confirmation...
    Transaction WNV4DTPEMVGUXNRZHMWNSCUU7AQJOCFTBKJT6NV2KN6THT4QGKNQ confirmed in round 606.
    Local state: {'voted': 'choiceA'}
    Waiting for round 613
    Round 607
    Round 608
    Round 609
    Round 610
    Round 611
    Round 612
    Round 613
    Global state: {'RegBegin': 592, 'RegEnd': 602, 'VoteBegin': 603, 'VoteEnd': 613, 'choiceA': 1, 'Creator': '49y8gDrKSnM77cgRyFzYdlkw18SDVNKhhOiS6NVVH8U='}
    The winner is: choiceA
    Waiting for confirmation...
    Transaction 535KBWJ7RQX4ISV763IUUICQWI6VERYBJ7J6X7HPMAMFNKJPSNPQ confirmed in round 616.
    Deleted app-id: 29
    Waiting for confirmation...
    Transaction Z56HDAJYARUC4PWGWQLCBA6TZYQOOLNOXY5XRM3IYUEEUCT5DRMA confirmed in round 618.
    Cleared app-id: 29

Asset
~~~~~

*Asset* is an implementation of a custom asset type using smart contracts. While Algorand has
`ASAs <https://developer.algorand.org/docs/features/asa/>`_, in some blockchains the only way to
create a custom asset is through smart contracts.

At creation, the creator specifies the total supply of the asset. Initially this supply is placed in
a reserve and the creator is made an admin. Any admin can move funds from the reserve into the
balance of any account that has opted into the application using the *mint* argument. Additionally,
any admin can move funds from any account's balance into the reserve using the *burn* argument.

Accounts are free to transfer funds in their balance to any other account that has opted into the
application. When an account opts out of the application, their balance is added to the reserve.

.. literalinclude:: ../examples/application/asset.py
    :language: python

Security Token
~~~~~~~~~~~~~~

*Security Token* is an extension of the *Asset* example with more features and restrictions. There
are two types of admins, *contract admins* and *transfer admins*.

Contract admins can delete the smart contract if the entire supply is in the reserve. They can
promote accounts to transfer or contract admins. They can also *mint* and *burn* funds.

Transfer admins can impose maximum balance limitations on accounts, temporarily lock accounts,
assign accounts to transfer groups, and impose transaction restrictions between transaction groups.

Both contract and transfer admins can pause trading of funds and freeze individual accounts.

Accounts can only transfer funds if trading is not paused, both the sender and receive accounts are
not frozen or temporarily locked, transfer group restrictions are not in place between them, and the
receiver's account does not have a maximum balance restriction that would be invalidated.

.. literalinclude:: ../examples/application/security_token.py
    :language: python



================================================
FILE: docs/index.rst
================================================
.. PyTeal documentation master file, created by
   sphinx-quickstart on Fri Jan 31 14:27:13 2020.
   You can adapt this file completely to your liking, but it should at least
   contain the root `toctree` directive.

PyTeal: Algorand Smart Contracts in Python
==========================================

PyTeal is a Python language binding for `Algorand Smart Contracts (ASC1s) <https://developer.algorand.org/docs/asc>`_. 

Algorand Smart Contracts are implemented using a new language that is stack-based, 
called `Transaction Execution Approval Language (TEAL) <https://developer.algorand.org/docs/teal>`_. 

However, TEAL is essentially an assembly language.
With PyTeal, developers can express smart contract logic purely using Python. 
PyTeal provides high level, functional programming style abstactions over TEAL
and does type checking at construction time.

The :doc:`User Guide </data_type>` describes many useful features in PyTeal, and the complete documentation for every expression and operation can be found in the :doc:`PyTeal Package API documentation </api>`.

PyTeal **hasn't been security audited**. Use it at your own risk.

.. toctree::
   :maxdepth: 1
   :caption: Getting Started

   overview
   installation
   examples

.. toctree::
   :maxdepth: 1
   :caption: User Guide

   data_type
   arithmetic_expression
   byte_expression
   accessing_transaction_field
   crypto
   scratch
   loading_group_transaction
   control_structures
   state
   assets
   versions
   compiler_optimization
   sourcemap
   opup
   abi

.. toctree::
   :maxdepth: 3
   :caption: API

   api

Indices and tables
==================

* :ref:`genindex`



================================================
FILE: docs/installation.rst
================================================
Install PyTeal
==============

PyTeal requires Python version >= 3.10.

If your operating system (OS) Python version < 3.10, we recommend:

* Rather than override the OS Python version, install Python  >= 3.10 alongside the OS Python version.
* Use `pyenv <https://github.com/pyenv/pyenv#installation>`_ or similar tooling to manage multiple Python versions.

The easiest way of installing PyTeal is using :code:`pip` : ::

  $ pip3 install pyteal

Alternatively, choose a `distribution file <https://pypi.org/project/pyteal/#files>`_, and run ::

  $ pip3 install [file name]






================================================
FILE: docs/loading_group_transaction.rst
================================================
.. _loading_group_transaction:

Loading Values from Group Transactions
======================================

Since program version 4 and above, programs can load values from transactions within an atomic 
group transaction. For instance, you can import values from the scratch space of another 
application call, and you can access the generated ID of a new application or asset.
These operations are only permitted in application mode.

Accessing IDs of New Apps and Assets
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The generated ID of an asset or application from a creation transaction in the current atomic group
can be accessed using the :code:`GeneratedID` expression. The specified transaction index 
may be a Python int or a PyTeal expression that must be evaluated to a uint64 at runtime. 
The transaction index must be less than the index of the current transaction and the 
maximum allowed group size (16).

For example:

.. code-block:: python

    GeneratedID(0) # retrieves the ID from the 0th transaction in current group
    GeneratedID(Int(10)) # retrieves the ID from the 10th transaction in group

Note that if the index is a Python int, it is interpreted as an immediate value (uint8) 
and will be translated to a TEAL :code:`gaid` op. Otherwise, it will be translated 
to a TEAL :code:`gaids` op.

Loading Scratch Slots
~~~~~~~~~~~~~~~~~~~~~

The scratch value from another transaction in the current atomic group can be accessed
using the :code:`ImportScratchValue` expression. The transaction index may be a Python int 
or a PyTeal expression that must be evaluated to a uint64 at runtime, and the scratch slot
ID to load from must be a Python int. 
The transaction index must be less than the index of the current transaction and the 
maximum allowed group size (16), and the slot ID must be less than the maximum number of
scratch slots (256). 

For example, assume an atomic transaction group contains app calls to the following applications,
where App A is called from the first transaction (index 0) and App B is called from the second 
or later transaction. Then the greeting value will be successfully passed between the two contracts.

App A:

.. code-block:: python

    # App is called at transaction index 0
    greeting = ScratchVar(TealType.bytes, 20) # this variable will live in scratch slot 20
    program = Seq([
        If(Txn.sender() == App.globalGet(Bytes("creator")))
        .Then(greeting.store(Bytes("hi creator!")))
        .Else(greeting.store(Bytes("hi user!"))),
        Return(Int(1))
    ])

App B:

.. code-block:: python

    greetingFromPreviousApp = ImportScratchValue(0, 20) # loading scratch slot 20 from the transaction at index 0
    program = Seq([
        # not shown: make sure that the transaction at index 0 is an app call to App A
        App.globalPut(Bytes("greeting from prev app"), greetingFromPreviousApp),
        Return(Int(1))
    ]) 

Note that if the index is a Python int, it is interpreted as an immediate value (uint8) 
and will be translated to a TEAL :code:`gload` op. Otherwise, it will be translated 
to a TEAL :code:`gloads` op.



================================================
FILE: docs/make.bat
================================================
@ECHO OFF

pushd %~dp0

REM Command file for Sphinx documentation

if "%SPHINXBUILD%" == "" (
	set SPHINXBUILD=sphinx-build
)
set SOURCEDIR=.
set BUILDDIR=_build

if "%1" == "" goto help

%SPHINXBUILD% >NUL 2>NUL
if errorlevel 9009 (
	echo.
	echo.The 'sphinx-build' command was not found. Make sure you have Sphinx
	echo.installed, then set the SPHINXBUILD environment variable to point
	echo.to the full path of the 'sphinx-build' executable. Alternatively you
	echo.may add the Sphinx directory to PATH.
	echo.
	echo.If you don't have Sphinx installed, grab it from
	echo.http://sphinx-doc.org/
	exit /b 1
)

%SPHINXBUILD% -M %1 %SOURCEDIR% %BUILDDIR% %SPHINXOPTS% %O%
goto end

:help
%SPHINXBUILD% -M help %SOURCEDIR% %BUILDDIR% %SPHINXOPTS% %O%

:end
popd



================================================
FILE: docs/Makefile
================================================
# Minimal makefile for Sphinx documentation
#

# You can set these variables from the command line, and also
# from the environment for the first two.
SPHINXOPTS    ?=
SPHINXBUILD   ?= sphinx-build
SOURCEDIR     = .
BUILDDIR      = _build

# Put it first so that "make" without argument is like "make help".
help:
	@$(SPHINXBUILD) -M help "$(SOURCEDIR)" "$(BUILDDIR)" $(SPHINXOPTS) $(O)

.PHONY: help Makefile

# Catch-all target: route all unknown targets to Sphinx using the new
# "make mode" option.  $(O) is meant as a shortcut for $(SPHINXOPTS).
%: Makefile
	@$(SPHINXBUILD) -M $@ "$(SOURCEDIR)" "$(BUILDDIR)" $(SPHINXOPTS) $(O)



================================================
FILE: docs/opup.rst
================================================
.. _opup:

OpUp:  Budget Increase Utility
=================================

Some opcode budget is consumed during execution of every Algorand Smart Contract because every TEAL
instruction has a corresponding cost. In order for the evaluation to succeed, the budget consumed must not
exceed the budget provided. This constraint may introduce a problem for expensive contracts that quickly
consume the initial budget of 700. The OpUp budget increase utility provides a workaround using NoOp inner
transactions that increase the transaction group's pooled compute budget. The funding for issuing the inner
transactions is provided by the contract doing the issuing, not the user calling the contract, so the
contract must have enough funds for this purpose. Note that there is a context specific limit to the number
of inner transactions issued in a transaction group so budget cannot be increased arbitrarily. The available
budget when using the OpUp utility will need to be high enough to execute the TEAL code that issues the inner
transactions. A budget of ~20 is enough for most use cases. 

The default behavior for fees on Inner Transactions is to first take any excess fee credit from overpayment of fees
in the group transaction and, if necessary, draw the remainder of fees from the application account. 
This behavior can be changed by specifying the source that should be used to cover fees by passing a fee source argument. 


Usage
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Mode
----

The :any:`pyteal.OpUp` utility is available in two modes: :any:`Explicit` and :any:`OnCall`:

================= ===================================================================================
OpUp Mode         Description
================= ===================================================================================
:code:`Explicit`  Calls a user provided external app when more budget is requested.
:code:`OnCall`    Creates and immediately deletes the app to be called when more budget is requested.
================= ===================================================================================


:any:`Explicit` has the benefit of constructing more lightweight inner transactions, but requires the
target app ID to be provided in the foreign apps array field of the transaction and the :any:`pyteal.OpUp`
constructor in order for it to be accessible. :any:`OnCall` is easier to use, but has slightly more overhead
because the target app must be created and deleted during the evaluation of an app call.

Fee Source
----------

The source of fees to cover the Inner Transactions for the :any:`pyteal.OpUp` utility can be specified by passing the appropriate
argument for the fee source.

==================== ========================================================================================
OpUp Fee Source      Description
==================== ========================================================================================
:code:`GroupCredit`  Only take from the group transaction excess fees
:code:`AppAccount`   Always pay out of the app accounts algo balance
:code:`Any`          Default behavior. First take from GroupCredit then, if necessary, take from App Account.
==================== ========================================================================================


Ensure Budget
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

:any:`pyteal.OpUp.ensure_budget` attempts to ensure that the available budget is at least the budget requested by
the caller. If there aren't enough funds for issuing the inner transactions or the inner transaction limit
is exceeded, the evaluation will fail. The typical usage pattern is to insert the :any:`pyteal.OpUp.ensure_budget`
call just before a particularly heavyweight subroutine or expression. Keep in mind that the required budget
expression will be evaluated before the inner transactions are issued so it may be prudent to avoid expensive
expressions, which may exhaust the budget before it can be increased.

In the example below, the :py:meth:`pyteal.Ed25519Verify` expression is used, which costs 1,900.

.. code-block:: python

    # The application id to be called when more budget is requested. This should be
    # replaced with an id provided by the developer.
    target_app_id = Int(1)

    # OnCall mode works the exact same way, just omit the target_app_id
    opup = OpUp(OpUpMode.Explicit, target_app_id)
    program = Seq(
        If(Txn.application_id() != Int(0)).Then(
            Seq(
                opup.ensure_budget(Int(2000)),
                Assert(Ed25519Verify(args[0], args[1], args[2])),
            )
        ),
        Approve(),
    )

Maximize Budget
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

:any:`pyteal.OpUp.maximize_budget` attempts to issue as many inner transactions as possible with the given fee.
This essentially maximizes the available budget while putting a ceiling on the amount of fee spent. Just
as with :any:`pyteal.OpUp.ensure_budget`, the evaluation will fail if there aren't enough funds for issuing the
inner transactions or the inner transaction limit is exceeded. This method may be preferred to
:any:`pyteal.OpUp.ensure_budget` when the fee spent on increasing budget needs to be capped or if the developer
would rather just maximize the available budget instead of doing in depth cost analysis on the program.

In the example below, the fee is capped at 3,000 microAlgos for increasing the budget. This works out to 3 inner
transactions being issued, each increasing the available budget by ~700.

.. code-block:: python

    target_app_id = Int(1) # the application id to be called when more budget is requested

    # OnCall mode works the exact same way, just omit the target_app_id
    opup = OpUp(OpUpMode.Explicit, target_app_id)
    program = Seq(
        If(Txn.application_id() != Int(0)).Then(
            Seq(
                opup.maximize_budget(Int(3000)),
                Assert(Ed25519Verify(args[0], args[1], args[2])),
            )
        ),
        Approve(),
    )

If budget increase requests appear multiple times in the program, it may be a good idea to wrap the
invocation in a PyTeal Subroutine to improve code reuse and reduce the size of the compiled program.


================================================
FILE: docs/overview.rst
================================================
Overview
========

With PyTeal, developers can easily write `Algorand Smart Contracts (ASC1s) <https://developer.algorand.org/docs/features/asc1/>`_ in Python.
PyTeal supports both stateless and stateful smart contracts.

Below is an example of writing a basic stateless smart contract that allows a specific receiver to withdraw funds from an account.

.. literalinclude:: ../examples/signature/basic.py
    :language: python

As shown in this example, the logic of smart contract is expressed using PyTeal expressions constructed in Python. PyTeal overloads Python's arithmetic operators 
such as :code:`<` and :code:`==` (more overloaded operators can be found in :ref:`arithmetic_expressions`), allowing Python developers express smart contract logic more naturally.

Lastly, :any:`compileTeal` is called to convert a PyTeal expression
to a TEAL program, consisting of a sequence of TEAL opcodes.
The output of the above example is:

.. literalinclude:: ../examples/signature/basic.teal



================================================
FILE: docs/requirements.txt
================================================
sphinx==5.1.1
sphinx-rtd-theme==1.0.0
# dependencies from setup.py
docstring-parser==0.14.1
executing==2.0.1
py-algorand-sdk>=2.0.0,<3.0.0
semantic-version>=2.9.0,<3.0.0
tabulate>=0.9.0,<0.10.0



================================================
FILE: docs/scratch.rst
================================================
.. _scratch:

Scratch Space
========================

`Scratch space <https://developer.algorand.org/docs/reference/teal/specification/#scratch-space>`_
is a temporary place to store values for later use in your program. It is temporary because any
changes to scratch space do not persist beyond the current transaction. Scratch space can be used
in both Application and Signature mode.

Scratch space consists of 256 scratch slots, each capable of storing one integer or byte slice. When
using the :any:`ScratchVar` class to work with scratch space, a slot is automatically assigned to
each variable.

ScratchVar:  Writing and Reading to/from Scratch Space
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

To write to scratch space, first create a :any:`ScratchVar` object and pass in the :any:`TealType`
of the values that you will store there. It is possible to create a :any:`ScratchVar` that can store
both integers and byte slices by passing no arguments to the :any:`ScratchVar` constructor, but note
that no type checking takes places in this situation. It is also possible to manually specify which 
slot ID the compiler should assign the scratch slot to in the TEAL code. If no slot ID is specified,
the compiler will assign it to any available slot. 

To write or read values, use the corresponding :any:`ScratchVar.store` or :any:`ScratchVar.load` methods.  :any:`ScratchVar.store` *must* be invoked before invoking :any:`ScratchVar.load`.

For example:

.. code-block:: python

    myvar = ScratchVar(TealType.uint64) # assign a scratch slot in any available slot
    program = Seq([
        myvar.store(Int(5)),
        Assert(myvar.load() == Int(5))
    ])
    anotherVar = ScratchVar(TealType.bytes, 4) # assign this scratch slot to slot #4

DynamicScratchVar:  Referencing a ScratchVar
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

:any:`DynamicScratchVar` functions as a pointer to a :any:`ScratchVar` instance.

Reference a :any:`ScratchVar` instance by invoking :any:`DynamicScratchVar.set_index`.  :any:`DynamicScratchVar.set_index` *must* be invoked before using :any:`DynamicScratchVar.load` and :any:`DynamicScratchVar.store`.

Here's an example to motivate usage.  The example shows how a :any:`DynamicScratchVar` updates the *value* of a referenced :any:`ScratchVar` from 7 to 10.

.. code-block:: python

    s = ScratchVar(TealType.uint64)
    d = DynamicScratchVar(TealType.uint64)

    return Seq(
        d.set_index(s),
        s.store(Int(7)),
        d.store(d.load() + Int(3)),
        Assert(s.load() == Int(10)),
        Int(1),
    )



================================================
FILE: docs/sourcemap.rst
================================================
====================
Source Mapping HowTo
====================

Below, we illustrate how to enable source mapping and print out an *annotated* TEAL version of the program which includes the original PyTeal in the comments.

Executive Summary
-----------------

0. Author your PyTeal script as usual and make other preparations.
1. Enable the source mapper by turning on its feature gate.
2. Use a source-mappable compile instruction.
3. Grab the annotated TEAL out of the compile's result.
4. Run the script as before.

0. Preparation
--------------

Go ahead and author your PyTeal dapp as you normally would. No modifications to PyTeal expressions are necessary to make your program source-mappable.

Consider the `AlgoBank example <https://github.com/algorand/pyteal/blob/67089381fcd9bf096c0b9118244709d145e90646/examples/application/abi/algobank.py>`_.
It was authored long before the source mapper became available, but below we'll see how to tweak it to be source-mappable.

You may need to upgrade your pyteal dependency to a version that includes source mapping as well as feature gating.
In particular, :code:`pip install pyteal` will install the :code:`feature_gates` package alongside :code:`pyteal`.

(Optional)  **AlgodClient**
------------------------------

If you intend to add the bytecode's program counters to the source map, you'll need to ensure that an :code:`AlgodClient` is available.
If it's running on port 4001 (the default Sandbox port for Algod) then everything should just work automatically. 
However, if Algod is running on a different port, you'll need to create a separate :code:`AlgodClient` in your script which you will then supply 
as an argument to the compile instruction.

NOTE: In this example *we're going to assume* that an :code:`AlgodClient` is running on port 4001.


1. Enable the source map feature gate
-------------------------------------

This is as simple as adding the two lines to the top of `algobank.py`:

.. code-block:: python

    from feature_gates import FeatureGates
    FeatureGates.set_sourcemap_enabled(True)

    # previously-existing imports:
    from pyteal import *  # noqa: E402
    import json # noqa: E402

    # rest of the file
    ...

The code importing :code:`FeatureGates` and enabling the feature **must come before** any pyteal imports.
That's because as a side effect, pyteal imports actually create expressions that can end up in the PyTeal program, and we want these to be properly source mapped.

In this example, we also added **flake8** lint ignore comments :code:`# noqa: E402` because in python 
it's preferred to conclude all imports before running any code.

2. Modify the compile instruction
---------------------------------

In the :code:`algobank.py` example, the compile instruction looks like :code:`router.compile_program(...)`. 
This traditional expression, along with its analog for non-ABI programs, :code:`compileTeal(...)`,
*don't support* source mapping. However, the newer :code:`compile(...)` methods do suport it:

- Compiler: :any:`Compilation.compile`. Source map specific parameters:

  * :code:`with_sourcemap`
  * :code:`teal_filename`
  * :code:`pcs_in_sourcemap`
  * :code:`algod_client`
  * :code:`annotate_teal`
  * :code:`annotate_teal_headers`
  * :code:`annotate_teal_concise`

- ABI Router: :any:`Router.compile`. Source map specific parameters:

  * :code:`with_sourcemaps`
  * :code:`approval_filename`
  * :code:`clear_filename`
  * :code:`pcs_in_sourcemap`
  * :code:`algod_client`
  * :code:`annotate_teal`
  * :code:`annotate_teal_headers`
  * :code:`annotate_teal_concise`


Please follow the links above to the :code:`compile(...)` methods
for the details of each parameter.

For our purposes, let's get a *full* source map annotation
while letting PyTeal bootstrap its own Algod. Modify the 
`snippet between lines 116 and 118 <https://github.com/algorand/pyteal/blob/67089381fcd9bf096c0b9118244709d145e90646/examples/application/abi/algobank.py#L116-L127>`_
to look like:

.. code-block:: python

    # Compile the program
    results = router.compile(
        version=6,
        optimize=OptimizeOptions(scratch_slots=True),
        with_sourcemaps=True,
        annotate_teal=True,
        pcs_in_sourcemap=True,
        annotate_teal_headers=True,
        annotate_teal_concise=False,
    )

Here we are enabling the source map and requesting annotated TEAL by
setting :code:`with_sourcemaps=True` and :code:`annotate_teal=True`.
:code:`pcs_in_sourcemap=True` will add the program counters to the source map.
Finally, we customize the annotated TEAL to have a header row with column names,
and get as many columns as available by specifying :code:`annotate_teal_headers=True`
and :code:`annotate_teal_concise=False`.

3. Grab annotated TEAL from result
----------------------------------

The newer :code:`compile(...)` methods return objects that contain source map information:

- Compiler: :any:`Compilation.compile`. Returns a :any:`CompileResults` object which has a :code:`sourcemap` field of type :any:`PyTealSourceMap`.
- ABI Router: :any:`Router.compile`. Returns a :any:`RouterResults` object which has :code:`approval_sourcemap` and :code:`clear_sourcemap` fields of type :any:`PyTealSourceMap`.

We modified ``algobank.py`` to call :any:`Router.compile` and
received a ``results`` object of type :any:`RouterResults`. 
Let's simply print out the resulting annotated approval program:

.. code-block:: python

    # Print the results
    print(results.approval_sourcemap.annotated_teal)

4. Run the script
-----------------

.. code-block:: none
  
    ❯ python examples/application/abi/algobank.py
    // GENERATED TEAL                      //    PC     PYTEAL PATH                           LINE    PYTEAL
    #pragma version 6                      //    (0)    examples/application/abi/algobank.py  137     router.compile(version=6, optimize=OptimizeOptions(scratch_slots=True), with_sourcemaps=True, annotate_teal=True, pcs_in_sourcemap=True, annotate_teal_headers=True, annotate_teal_concise=False)
    txn NumAppArgs                         //    (20)                                         27      BareCallActions(no_op=OnCompleteAction(action=Approve(), call_config=CallConfig.CREATE), opt_in=OnCompleteAction(action=Approve(), call_config=CallConfig.ALL), close_out=OnCompleteAction(action=transfer_balance_to_lost, call_config=CallConfig.CALL), update_application=OnCompleteAction(action=assert_sender_is_creator, call_config=CallConfig.CALL), delete_application=OnCompleteAction(action=assert_sender_is_creator, call_config=CallConfig.CALL))
    int 0                                  //    (22)
    ... continues ...

About the Output
----------------

The resulting annotated TEAL assembles down to the same bytecode
as the unadorned program in :code:`results.approval_program`.

Each line's comments also provide:

- (``PC``) - the *beginning* program counter of the assembled bytecode for the TEAL instruction
- (``PYTEAL PATH``) - the PyTeal file which generated the TEAL instruction
- (``LINE``) - the line *number* of the PyTeal source
- (``PYTEAL``) - the PyTeal code that generated the TEAL instruction

When a value -such as a line number- is omitted, it means that it is the same as the previous.

Typically, the PyTeal compiler adds expressions to a user's program to make various
constructs work. Consequently, not every TEAL instruction will have a corresponding
PyTeal expression that was explicity written by the program author. 
In such cases, the source mapper will attempt to find a reasonable user-attributable substitute.
For example, if a program includes a :any:`Subroutine` definition, the compiler will add
boilerplate for adding arguments to the stack before the subroutine is called, and then
more boilerplate to read the arguments from the stack at the beginning of the subroutine's
execution. The source mapper will attribute these boilerplate expressions to the subroutine's
python definition.

Sometimes, the source mapper doesn't succeed to find a user attribution
and resorts to a attributing to the entry point into pyteal - the line
that called the compiler. In the example above, the first line of the
annotated TEAL is attributed to the line that called the compiler:

.. code-block:: none

  examples/application/abi/algobank.py  137     router.compile(version=6, ...)
  
This is the line that would get mapped to in the case of such source map "misses".



================================================
FILE: docs/state.rst
================================================
.. _state:

State Access and Manipulation
=============================

PyTeal can be used to write `Stateful Algorand Smart Contracts <https://developer.algorand.org/docs/features/asc1/stateful/>`_
as well. Stateful contracts, also known as applications, can access and manipulate state on the
Algorand blockchain.

There are multiple types of state that an application can use.
State consists of key-value pairs, where keys are byte slices and values vary by type of state.

=================== ===================== ===============================================
Type of State       Type of Key           Type of Value
=================== ===================== ===============================================
Global State        :any:`TealType.bytes` :any:`TealType.uint64` or :any:`TealType.bytes`
Local State         :any:`TealType.bytes` :any:`TealType.uint64` or :any:`TealType.bytes`
Boxes               :any:`TealType.bytes` :any:`TealType.bytes`
=================== ===================== ===============================================

State Operation Table
---------------------

================== ======================= ======================== ======================== ===================== =======================
Context            Create                  Write                    Read                     Delete                Check If Exists
================== ======================= ======================== ======================== ===================== =======================
Current App Global                         :any:`App.globalPut`     :any:`App.globalGet`     :any:`App.globalDel`  :any:`App.globalGetEx`
Current App Local                          :any:`App.localPut`      :any:`App.localGet`      :any:`App.localDel`   :any:`App.localGetEx`
Other App Global                                                    :any:`App.globalGetEx`                         :any:`App.globalGetEx`
Other App Local                                                     :any:`App.localGetEx`                          :any:`App.localGetEx`
Current App Boxes  :any:`App.box_create`   :any:`App.box_put`       :any:`App.box_extract`   :any:`App.box_delete` :any:`App.box_length`
                   :any:`App.box_put`      :any:`App.box_replace`   :any:`App.box_get`                             :any:`App.box_get`
                                           :any:`App.box_splice`
                                           :any:`App.box_resize`
================== ======================= ======================== ======================== ===================== =======================

Global State
------------

Global state consists of key-value pairs that are stored in the application's global context. It can be
manipulated as follows:

Writing Global State
~~~~~~~~~~~~~~~~~~~~

To write to global state, use the :any:`App.globalPut` function. The first argument is the key to
write to, and the second argument is the value to write. For example:

.. code-block:: python

    App.globalPut(Bytes("status"), Bytes("active")) # write a byte slice
    App.globalPut(Bytes("total supply"), Int(100)) # write a uint64

Reading Global State
~~~~~~~~~~~~~~~~~~~~

To read from global state, use the :any:`App.globalGet` function. The only argument it takes is the
key to read from. For example:

.. code-block:: python

    App.globalGet(Bytes("status"))
    App.globalGet(Bytes("total supply"))

If you try to read from a key that does not exist in your app's global state, the integer `0` is
returned.

Deleting Global State
~~~~~~~~~~~~~~~~~~~~~

To delete a key from global state, use the :any:`App.globalDel` function. The only argument it takes
is the key to delete. For example:

.. code-block:: python

    App.globalDel(Bytes("status"))
    App.globalDel(Bytes("total supply"))

If you try to delete a key that does not exist in your app's global state, nothing happens.

Local State
-----------

Local state consists of key-value pairs that are stored in a unique context for each account that
has opted into your application. As a result, you will need to specify an account when manipulating
local state. This is done by passing in the address of an account. In order to read or manipulate
an account's local state, that account must be presented in the
:any:`Txn.accounts <TxnObject.accounts>` array.

**Note:** The :code:`Txn.accounts` array does not behave like a normal array. It's actually a
:code:`1`-indexed array with a special value at index :code:`0`, the sender's account.
See :ref:`txn_special_case_arrays` for more details.

Writing Local State
~~~~~~~~~~~~~~~~~~~

To write to the local state of an account, use the :any:`App.localPut` function. The first argument
is the address of the account to write to, the second argument is the key to write to, and the
third argument is the value to write. For example:

.. code-block:: python

    App.localPut(Txn.sender(), Bytes("role"), Bytes("admin")) # write a byte slice to the sender's account
    App.localPut(Txn.sender(), Bytes("balance"), Int(10)) # write a uint64 to the sender's account
    App.localPut(Txn.accounts[1], Bytes("balance"), Int(10)) # write a uint64 to Txn.account[1]

**Note:** It is only possible to write to the local state of an account if that account has opted
into your application. If the account has not opted in, the program will fail with an error. The
function :any:`App.optedIn` can be used to check if an account has opted into an app.

Reading Local State
~~~~~~~~~~~~~~~~~~~

To read from the local state of an account, use the :any:`App.localGet` function. The first argument
is the address of the account to read from, and the second argument is the key to read. For example:

.. code-block:: python

    App.localGet(Txn.sender(), Bytes("role")) # read from the sender's account
    App.localGet(Txn.sender(), Bytes("balance")) # read from the sender's account
    App.localGet(Txn.accounts[1], Bytes("balance")) # read from Txn.accounts[1]

If you try to read from a key that does not exist in the account's local state, the integer :code:`0`
is returned.

Deleting Local State
~~~~~~~~~~~~~~~~~~~~

To delete a key from local state of an account, use the :any:`App.localDel` function. The first
argument is the address of the corresponding account, and the second argument is the key to delete.
For example:

.. code-block:: python

    App.localDel(Txn.sender(), Bytes("role")) # delete "role" from the sender's account
    App.localDel(Txn.sender(), Bytes("balance")) # delete "balance" from the sender's account
    App.localDel(Txn.accounts[1], Bytes("balance")) # delete "balance" from Txn.accounts[1]

If you try to delete a key that does not exist in the account's local state, nothing happens.

.. _external_state:

External State
--------------

The above functions allow an app to read and write state in its own context. Additionally, it's
possible for applications to read state written by other applications. This is possible using the
:any:`App.globalGetEx` and :any:`App.localGetEx` functions.

Unlike the other state access functions, :any:`App.globalGetEx` and :any:`App.localGetEx` return a
:any:`MaybeValue`. This value cannot be used directly, but has methods :any:`MaybeValue.hasValue()`
and :any:`MaybeValue.value()`. If the key being accessed exists in the context of the app
being read, :code:`hasValue()` will return :code:`1` and :code:`value()` will return its value. Otherwise,
:code:`hasValue()` and :code:`value()` will return :code:`0`.

**Note:** Even though the :any:`MaybeValue` returned by :any:`App.globalGetEx` and
:any:`App.localGetEx` cannot be used directly, it **must** be included in the application before
:code:`hasValue()` and :code:`value()` are called on it. You will probably want to use :any:`Seq` to
do this.

Since these functions are the only way to check whether a key exists, it can be useful to use them
in the current application's context too.

External Global
~~~~~~~~~~~~~~~

To read a value from the global state of another application, use the :any:`App.globalGetEx`
function.

In order to use this function you need to pass in an integer that represents an application to
read from. This integer corresponds to an actual application ID that appears in the
:any:`Txn.applications <TxnObject.applications>` array.

**Note:** The :code:`Txn.applications` array does not behave like a normal array. It's actually a
:code:`1`-indexed array with a special value at index :code:`0`, the current application's ID.
See :ref:`txn_special_case_arrays` for more details.

Now that you have an integer that represents an application to read from, pass this as the first
argument to :any:`App.globalGetEx`, and pass the key to read as the second argument. For example:

.. code-block:: python

    # get "status" from the global context of Txn.applications[0] (the current app)
    # if "status" has not been set, returns "none"
    myStatus = App.globalGetEx(Txn.applications[0], Bytes("status"))

    program = Seq([
        myStatus,
        If(myStatus.hasValue(), myStatus.value(), Bytes("none"))
    ])

    # get "status" from the global context of Txn.applications[1]
    # if "status" has not been set, returns "none"
    otherStatus = App.globalGetEx(Txn.applications[1], Bytes("status"))
    program = Seq([
        otherStatus,
        If(otherStatus.hasValue(), otherStatus.value(), Bytes("none"))
    ])

    # get "total supply" from the global context of Txn.applications[1]
    # if "total supply" has not been set, returns the default value of 0
    otherSupply = App.globalGetEx(Txn.applications[1], Bytes("total supply"))
    program = Seq([
        otherSupply,
        otherSupply.value()
    ])

External Local
~~~~~~~~~~~~~~

To read a value from an account's local state for another application, use the :any:`App.localGetEx`
function.

The first argument is the address of the account to read from (in the same format as
:any:`App.localGet`), the second argument is the ID of the application to read from, and the third
argument is the key to read.

**Note:** The second argument is the actual ID of the application to read from, not an index into
:code:`Txn.applications`. This means that you can read from any application that the account has opted
into, not just applications included in :code:`Txn.applications`. The ID :code:`0` is still a special
value that refers to the ID of the current application, but you could also use :any:`Global.current_application_id()`
or :any:`Txn.application_id() <TxnObject.application_id>` to refer to the current application.

For example:

.. code-block:: python

    # get "role" from the local state of Txn.accounts[0] (the sender) for the current app
    # if "role" has not been set, returns "none"
    myAppSenderRole = App.localGetEx(Txn.accounts[0], Int(0), Bytes("role"))
    program = Seq([
        myAppSenderRole,
        If(myAppSenderRole.hasValue(), myAppSenderRole.value(), Bytes("none"))
    ])

    # get "role" from the local state of Txn.accounts[1] for the current app
    # if "role" has not been set, returns "none"
    myAppOtherAccountRole = App.localGetEx(Txn.accounts[1], Int(0), Bytes("role"))
    program = Seq([
        myAppOtherAccountRole,
        If(myAppOtherAccountRole.hasValue(), myAppOtherAccountRole.value(), Bytes("none"))
    ])

    # get "role" from the local state of Txn.accounts[0] (the sender) for the app with ID 31
    # if "role" has not been set, returns "none"
    otherAppSenderRole = App.localGetEx(Txn.accounts[0], Int(31), Bytes("role"))
    program = Seq([
        otherAppSenderRole,
        If(otherAppSenderRole.hasValue(), otherAppSenderRole.value(), Bytes("none"))
    ])

    # get "role" from the local state of Txn.accounts[1] for the app with ID 31
    # if "role" has not been set, returns "none"
    otherAppOtherAccountRole = App.localGetEx(Txn.accounts[1], Int(31), Bytes("role"))
    program = Seq([
        otherAppOtherAccountRole,
        If(otherAppOtherAccountRole.hasValue(), otherAppOtherAccountRole.value(), Bytes("none"))
    ])

Box Storage
-----------

Box storage consists of key-value pairs that are stored in an application's local context.

The app account's minimum balance requirement (MBR) is increased with each additional box, and each additional byte in the box's name and allocated size.

.. warning::

   If one deletes an application with outstanding boxes, the MBR is not recoverable from the deleted app account.
   It is recommended that *before* app deletion, all box storage be deleted, and funds previously allocated to the MBR be withdrawn.

Boxes are only visible to the application itself; in other words, an application cannot read from or write to another application's boxes on-chain.

Boxes are fixed-length structures, though they can be resized with the :any:`App.box_resize` method (or by deleting and recreating the box).

The following sections explain how to work with boxes.

.. _Creating Boxes:

Creating Boxes
~~~~~~~~~~~~~~

To create a box, use :any:`App.box_create`, or :any:`App.box_put` method.

For :any:`App.box_create`, the first argument is the box name, and the second argument is the byte size to be allocated.

:any:`App.box_create` creates a new box with the specified name and byte length. New boxes will contain a byte string of all zeros. Performing this operation on a box that already exists will not change its contents.

If successful, :any:`App.box_create` will return :code:`0` if the box already existed, otherwise it will return :code:`1`. A failure will occur if you attempt to create a box that already exists with a different size.

For example:

.. code-block:: python

    # Allocate a box called "BoxA" of byte size 100 and ignore the return value
    Pop(App.box_create(Bytes("BoxA"), Int(100)))

    # Allocate a box called "BoxB" of byte size 90, asserting that it didn't exist before.
    Assert(App.box_create(Bytes("BoxB"), Int(90))

For :any:`App.box_put`, the first argument is the box name to create or to write to, and the second argument is the bytes to write.

.. note::

   If the box exists, then :any:`App.box_put` will write the contents to the box
   (fails when the content length is **not identical** to the existing box's byte size);
   otherwise, it will create a box containing exactly the same input bytes.

.. code-block:: python

    # create a 42 bytes length box called `poemLine` with content
    App.box_put(Bytes("poemLine"), Bytes("Of that colossal wreck, boundless and bare"))

    # write to box `poemLine` with new value
    App.box_put(Bytes("poemLine"), Bytes("The lone and level sands stretch far away."))

Resizing Boxes
~~~~~~~~~~~~~~

Boxes that already exist can be resized using the :any:`App.box_resize` method. This is the only way to resize a box, besides deleting it and recreating it.

For :any:`App.box_resize`, the first argument is the box name to resize, and the second argument is the new byte size to be allocated.

.. note::
    If the new size is smaller than the existing box's byte size, then the box will lose the bytes at the end.
    If the new size is larger than the existing box's byte size, then the box will be padded with zeros at the end.

    For all size changes, the app account's minimum balance requirement (MBR) will be updated accordingly.

For example:

.. code-block:: python

    # resize a box called "BoxA" to byte size 200
    App.box_resize(Bytes("BoxA"), Int(200))

Writing to a Box
~~~~~~~~~~~~~~~~

To write to a box, use :any:`App.box_replace`, :any:`App.box_splice` , or :any:`App.box_put` method.

:any:`App.box_replace` replaces a range of bytes in a box.
The first argument is the box name to write into, the second argument is the starting index to write,
and the third argument is the replacement bytes. For example:

.. code-block:: python

   # Assume the box named "wordleBox" initially contains the bytes "cones"

   # Replace 2 bytes starting from index 1 with "ap" in the box named "wordleBox"
   App.box_replace(Bytes("wordleBox"), Int(1), Bytes("ap"))
  
   # The result is that the box named "wordleBox" now contains the bytes "capes"

:any:`App.box_splice` is a more general version of :any:`App.box_replace`. This operation takes an
additional argument, which is the length of the bytes in the box to be replaced. By specifying a
different length than the bytes you are inserting, you can shift contents of the box instead of just
replacing a range of bytes.

For example:

.. code-block:: python
   
   # Assume the box named "flavors" initially contains the bytes "banana_apple_cherry_______"

   # Insert "grape_" at index 7 in the box named "flavors". By specifying a length of 0, the
   # following bytes will be shifted to the right.
   App.box_splice(Bytes("flavors"), Int(7), Int(0), Bytes("grape_"))
   
   # The result is that the box named "flavors" now contains the bytes "banana_grape_apple_cherry_"

   # If we want to zero the box, we can replace the entire contents with an empty string.
   App.box_splice(Bytes("flavors"), Int(0), Int(26), Bytes(""))
   # The "flavors" box now contains "00000000000000000000000000". Ready for reuse!

Recall that boxes are fixed length, so shifting bytes can cause the box to truncate or pad with zeros.
More information is available in the docstring for :any:`App.box_splice`.

:any:`App.box_put` writes the full contents to a pre-existing box, as is mentioned in `Creating Boxes`_.

.. _Reading from a Box:

Reading from a Box
~~~~~~~~~~~~~~~~~~

To read from a box, use :any:`App.box_extract`, or :any:`App.box_get` method.

:any:`App.box_extract` reads bytes of a certain length from a start index in a Box.
The first argument is the box name to read from, the second argument is the starting index to read,
and the third argument is the length of bytes to extract. For example:

.. code-block:: python

   # extract a segment of length 10 starting at the 5th byte in a box named `NoteBook`
   App.box_extract(Bytes("NoteBook"), Int(5), Int(10))

:any:`App.box_get` gets the full contents of a box.
The only argument is the box name, and it returns a :any:`MaybeValue` containing:

- a boolean value indicating if the box exists
- the full contents of the box.

For example:

.. code-block:: python

   # get the full contents from a box named `NoteBook`, asserting that it exists
   Seq(
       contents := App.box_get(Bytes("NoteBook")),
       Assert(contents.hasValue()),
       contents.value()
   )

Deleting a Box
~~~~~~~~~~~~~~

To delete a box, use :any:`App.box_delete` method. The only argument is the box name.

:any:`App.box_delete` will return :code:`1` if the box already existed, otherwise it will return :code:`0`. Deleting a nonexistent box is allowed, but has no effect.

For example:

.. code-block:: python

    # delete the box `boxToRemove`, asserting that it existed prior to this
    Assert(App.box_delete(Bytes("boxToRemove")))

    # delete the box `mightExist` and ignore the return value
    Pop(App.box_delete(Bytes("mightExist")))

Checking if a Box Exists and Reads its Length
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

To check the existence of a box, use the :any:`App.box_length` method.
The only argument is the box name, and it returns a :any:`MaybeValue` containing:

- a boolean value indicating if the box exists
- the actual byte size of the box.

For example:

.. code-block:: python

   # get the length of the box `someBox`, and assert that the box exists
   Seq(
       length := App.box_length(Bytes("someBox")),
       Assert(length.hasValue()),
       length.value()
   )

.. note::

   :any:`App.box_get` can also check the existence of a box as mentioned in `Reading from a Box`_.



================================================
FILE: docs/versions.rst
================================================
.. _versions:

Versions
=============

Each version of PyTeal compiles contracts for a specific AVM version. Newer versions of the AVM
introduce new opcodes and transaction fields, so PyTeal must be updated to support these new
features. Below is a table which shows the relationship between AVM and PyTeal versions.

============ ==============
AVM Version  PyTeal Version
============ ==============
1            <= 0.5.4
2            >= 0.6.0
3            >= 0.7.0
4            >= 0.8.0
5            >= 0.9.0
6            >= 0.10.0
7            >= 0.15.0
8            >= 0.20.0
9            >= 0.25.0
10           >= 0.26.0
============ ==============

.. _version pragmas:

Version Pragmas
----------------

When writing a PyTeal smart contract, it's important to target a specific AVM version and to compile
with a single PyTeal version. This will ensure your compiled program remains consistent and has the
exact same behavior no matter when you compile it.

The :any:`pragma` function can be used to assert that the current PyTeal version matches a constraint
of your choosing. This can help strengthen the dependency your source code has on the PyTeal package
version you used when writing it.

If you are writing code for others to consume, or if your codebase has different PyTeal version
dependencies in different places, the :any:`Pragma` expression can be used to apply a pragma
constraint to only a section of the AST.

PyTeal v0.5.4 and Below
-----------------------

In order to support AVM v2, PyTeal v0.6.0 breaks backward compatibility with v0.5.4. PyTeal
programs written for PyTeal version 0.5.4 and below will not compile properly and most likely will
display an error of the form :code:`AttributeError: * object has no attribute 'teal'`.

.. warning::
    If you are updating from a v1 AVM program, make
    sure your program abides by the `TEAL safety guidelines <https://developer.algorand.org/docs/reference/teal/guidelines/>`_.
    Changing a v1 AVM program to a v2 AVM program without any code changes is insecure because v2
    AVM programs allow rekeying. Specifically, you must add a check that the :code:`RekeyTo` property
    of any transaction is set to the zero address when updating an older PyTeal program from v0.5.4 and
    below.



================================================
FILE: examples/__init__.py
================================================
[Empty file]


================================================
FILE: examples/application/__init__.py
================================================
[Empty file]


================================================
FILE: examples/application/asset.py
================================================
# This example is provided for informational purposes only and has not been audited for security.

from pyteal import *


def approval_program():
    on_creation = Seq(
        [
            Assert(Txn.application_args.length() == Int(1)),
            App.globalPut(Bytes("total supply"), Btoi(Txn.application_args[0])),
            App.globalPut(Bytes("reserve"), Btoi(Txn.application_args[0])),
            App.localPut(Int(0), Bytes("admin"), Int(1)),
            App.localPut(Int(0), Bytes("balance"), Int(0)),
            Return(Int(1)),
        ]
    )

    is_admin = App.localGet(Int(0), Bytes("admin"))

    on_closeout = Seq(
        [
            App.globalPut(
                Bytes("reserve"),
                App.globalGet(Bytes("reserve"))
                + App.localGet(Int(0), Bytes("balance")),
            ),
            Return(Int(1)),
        ]
    )

    register = Seq([App.localPut(Int(0), Bytes("balance"), Int(0)), Return(Int(1))])

    # configure the admin status of the account Txn.accounts[1]
    # sender must be admin
    new_admin_status = Btoi(Txn.application_args[1])
    set_admin = Seq(
        [
            Assert(And(is_admin, Txn.application_args.length() == Int(2))),
            App.localPut(Int(1), Bytes("admin"), new_admin_status),
            Return(Int(1)),
        ]
    )
    # NOTE: The above set_admin code is carefully constructed. If instead we used the following code:
    # Seq([
    #     Assert(Txn.application_args.length() == Int(2)),
    #     App.localPut(Int(1), Bytes("admin"), new_admin_status),
    #     Return(is_admin)
    # ])
    # It would be vulnerable to the following attack: a sender passes in their own address as
    # Txn.accounts[1], so then the line App.localPut(Int(1), Bytes("admin"), new_admin_status)
    # changes the sender's admin status, meaning the final Return(is_admin) can return anything the
    # sender wants. This allows anyone to become an admin!

    # move assets from the reserve to Txn.accounts[1]
    # sender must be admin
    mint_amount = Btoi(Txn.application_args[1])
    mint = Seq(
        [
            Assert(Txn.application_args.length() == Int(2)),
            Assert(mint_amount <= App.globalGet(Bytes("reserve"))),
            App.globalPut(
                Bytes("reserve"), App.globalGet(Bytes("reserve")) - mint_amount
            ),
            App.localPut(
                Int(1),
                Bytes("balance"),
                App.localGet(Int(1), Bytes("balance")) + mint_amount,
            ),
            Return(is_admin),
        ]
    )

    # transfer assets from the sender to Txn.accounts[1]
    transfer_amount = Btoi(Txn.application_args[1])
    transfer = Seq(
        [
            Assert(Txn.application_args.length() == Int(2)),
            Assert(transfer_amount <= App.localGet(Int(0), Bytes("balance"))),
            App.localPut(
                Int(0),
                Bytes("balance"),
                App.localGet(Int(0), Bytes("balance")) - transfer_amount,
            ),
            App.localPut(
                Int(1),
                Bytes("balance"),
                App.localGet(Int(1), Bytes("balance")) + transfer_amount,
            ),
            Return(Int(1)),
        ]
    )

    program = Cond(
        [Txn.application_id() == Int(0), on_creation],
        [Txn.on_completion() == OnComplete.DeleteApplication, Return(is_admin)],
        [Txn.on_completion() == OnComplete.UpdateApplication, Return(is_admin)],
        [Txn.on_completion() == OnComplete.CloseOut, on_closeout],
        [Txn.on_completion() == OnComplete.OptIn, register],
        [Txn.application_args[0] == Bytes("set admin"), set_admin],
        [Txn.application_args[0] == Bytes("mint"), mint],
        [Txn.application_args[0] == Bytes("transfer"), transfer],
    )

    return program


def clear_state_program():
    program = Seq(
        [
            App.globalPut(
                Bytes("reserve"),
                App.globalGet(Bytes("reserve"))
                + App.localGet(Int(0), Bytes("balance")),
            ),
            Return(Int(1)),
        ]
    )

    return program


if __name__ == "__main__":
    with open("asset_approval.teal", "w") as f:
        compiled = compileTeal(approval_program(), mode=Mode.Application, version=2)
        f.write(compiled)

    with open("asset_clear_state.teal", "w") as f:
        compiled = compileTeal(clear_state_program(), mode=Mode.Application, version=2)
        f.write(compiled)



================================================
FILE: examples/application/opup.py
================================================
# This example is provided for informational purposes only and has not been audited for security.

from pyteal import *


def approval_program_explicit_ensure():
    args = [
        Bytes("base64", "iZWMx72KvU6Bw6sPAWQFL96YH+VMrBA0XKWD9XbZOZI="),
        Bytes(
            "base64",
            "if8ooA+32YZc4SQBvIDDY8tgTatPoq4IZ8Kr+We1t38LR2RuURmaVu9D4shbi4VvND87PUqq5/0vsNFEGIIEDA==",
        ),
        Addr("7JOPVEP3ABJUW5YZ5WFIONLPWTZ5MYX5HFK4K7JLGSIAG7RRB42MNLQ224"),
    ]
    opup = OpUp(OpUpMode.Explicit, Int(1))
    return Seq(
        If(Txn.application_id() != Int(0)).Then(
            Seq(
                opup.ensure_budget(Int(2000)),
                Pop(Ed25519Verify(args[0], args[1], args[2])),
            )
        ),
        Approve(),
    )


def approval_program_oncall_ensure():
    args = [
        Bytes("base64", "iZWMx72KvU6Bw6sPAWQFL96YH+VMrBA0XKWD9XbZOZI="),
        Bytes(
            "base64",
            "if8ooA+32YZc4SQBvIDDY8tgTatPoq4IZ8Kr+We1t38LR2RuURmaVu9D4shbi4VvND87PUqq5/0vsNFEGIIEDA==",
        ),
        Addr("7JOPVEP3ABJUW5YZ5WFIONLPWTZ5MYX5HFK4K7JLGSIAG7RRB42MNLQ224"),
    ]
    opup = OpUp(OpUpMode.OnCall)
    return Seq(
        If(Txn.application_id() != Int(0)).Then(
            Seq(
                opup.ensure_budget(Int(2000)),
                Pop(Ed25519Verify(args[0], args[1], args[2])),
            )
        ),
        Approve(),
    )


def approval_program_explicit_maximize():
    args = [
        Bytes("base64", "iZWMx72KvU6Bw6sPAWQFL96YH+VMrBA0XKWD9XbZOZI="),
        Bytes(
            "base64",
            "if8ooA+32YZc4SQBvIDDY8tgTatPoq4IZ8Kr+We1t38LR2RuURmaVu9D4shbi4VvND87PUqq5/0vsNFEGIIEDA==",
        ),
        Addr("7JOPVEP3ABJUW5YZ5WFIONLPWTZ5MYX5HFK4K7JLGSIAG7RRB42MNLQ224"),
    ]
    opup = OpUp(OpUpMode.Explicit, Int(1))
    return Seq(
        If(Txn.application_id() != Int(0)).Then(
            Seq(
                opup.maximize_budget(Int(3000)),
                Pop(Ed25519Verify(args[0], args[1], args[2])),
            )
        ),
        Approve(),
    )


def approval_program_oncall_maximize():
    args = [
        Bytes("base64", "iZWMx72KvU6Bw6sPAWQFL96YH+VMrBA0XKWD9XbZOZI="),
        Bytes(
            "base64",
            "if8ooA+32YZc4SQBvIDDY8tgTatPoq4IZ8Kr+We1t38LR2RuURmaVu9D4shbi4VvND87PUqq5/0vsNFEGIIEDA==",
        ),
        Addr("7JOPVEP3ABJUW5YZ5WFIONLPWTZ5MYX5HFK4K7JLGSIAG7RRB42MNLQ224"),
    ]
    opup = OpUp(OpUpMode.OnCall)
    return Seq(
        If(Txn.application_id() != Int(0)).Then(
            Seq(
                opup.maximize_budget(Int(3000)),
                Pop(Ed25519Verify(args[0], args[1], args[2])),
            )
        ),
        Approve(),
    )


if __name__ == "__main__":
    with open("program.teal", "w") as f:
        compiled = compileTeal(
            approval_program_oncall_maximize(), mode=Mode.Application, version=6
        )
        f.write(compiled)



================================================
FILE: examples/application/security_token.py
================================================
# This example is provided for informational purposes only and has not been audited for security.

from pyteal import *


def approval_program():
    on_creation = Seq(
        [
            Assert(Txn.application_args.length() == Int(1)),
            App.globalPut(Bytes("total supply"), Btoi(Txn.application_args[0])),
            App.globalPut(Bytes("reserve"), Btoi(Txn.application_args[0])),
            App.globalPut(Bytes("paused"), Int(0)),
            App.localPut(Int(0), Bytes("contract admin"), Int(1)),
            App.localPut(Int(0), Bytes("transfer admin"), Int(1)),
            App.localPut(Int(0), Bytes("balance"), Int(0)),
            Return(Int(1)),
        ]
    )

    is_contract_admin = App.localGet(Int(0), Bytes("contract admin"))
    is_transfer_admin = App.localGet(Int(0), Bytes("transfer admin"))
    is_any_admin = is_contract_admin.Or(is_transfer_admin)

    can_delete = And(
        is_contract_admin,
        App.globalGet(Bytes("total supply")) == App.globalGet(Bytes("reserve")),
    )

    on_closeout = Seq(
        [
            App.globalPut(
                Bytes("reserve"),
                App.globalGet(Bytes("reserve"))
                + App.localGet(Int(0), Bytes("balance")),
            ),
            Return(Int(1)),
        ]
    )

    register = Seq([App.localPut(Int(0), Bytes("balance"), Int(0)), Return(Int(1))])

    # pause all transfers
    # sender must be any admin
    new_pause_value = Btoi(Txn.application_args[1])
    pause = Seq(
        [
            Assert(Txn.application_args.length() == Int(2)),
            App.globalPut(Bytes("paused"), new_pause_value),
            Return(is_any_admin),
        ]
    )

    # configure the admin status of the account Txn.accounts[1]
    # sender must be contract admin
    new_admin_type = Txn.application_args[1]
    new_admin_status = Btoi(Txn.application_args[2])
    set_admin = Seq(
        [
            Assert(
                And(
                    is_contract_admin,
                    Txn.application_args.length() == Int(3),
                    Or(
                        new_admin_type == Bytes("contract admin"),
                        new_admin_type == Bytes("transfer admin"),
                    ),
                    Txn.accounts.length() == Int(1),
                )
            ),
            App.localPut(Int(1), new_admin_type, new_admin_status),
            Return(Int(1)),
        ]
    )
    # NOTE: The above set_admin code is carefully constructed. If instead we used the following code:
    # Seq([
    #     Assert(And(
    #         Txn.application_args.length() == Int(3),
    #         Or(new_admin_type == Bytes("contract admin"), new_admin_type == Bytes("transfer admin")),
    #         Txn.accounts.length() == Int(1)
    #     )),
    #     App.localPut(Int(1), new_admin_type, new_admin_status),
    #     Return(is_contract_admin)
    # ])
    # It would be vulnerable to the following attack: a sender passes in their own address as
    # Txn.accounts[1], so then the line App.localPut(Int(1), new_admin_type, new_admin_status)
    # changes the sender's admin status, meaning the final Return(is_contract_admin) can return
    # anything the sender wants. This allows anyone to become an admin!

    # freeze Txn.accounts[1]
    # sender must be any admin
    new_freeze_value = Btoi(Txn.application_args[1])
    freeze = Seq(
        [
            Assert(
                And(
                    Txn.application_args.length() == Int(2),
                    Txn.accounts.length() == Int(1),
                )
            ),
            App.localPut(Int(1), Bytes("frozen"), new_freeze_value),
            Return(is_any_admin),
        ]
    )

    # modify the max balance of Txn.accounts[1]
    # if max_balance_value is 0, will delete the existing max balance limitation on the account
    # sender must be transfer admin
    max_balance_value = Btoi(Txn.application_args[1])
    max_balance = Seq(
        [
            Assert(
                And(
                    Txn.application_args.length() == Int(2),
                    Txn.accounts.length() == Int(1),
                )
            ),
            If(
                max_balance_value == Int(0),
                App.localDel(Int(1), Bytes("max balance")),
                App.localPut(Int(1), Bytes("max balance"), max_balance_value),
            ),
            Return(is_transfer_admin),
        ]
    )

    # lock Txn.accounts[1] until a UNIX timestamp
    # sender must be transfer admin
    lock_until_value = Btoi(Txn.application_args[1])
    lock_until = Seq(
        [
            Assert(
                And(
                    Txn.application_args.length() == Int(2),
                    Txn.accounts.length() == Int(1),
                )
            ),
            If(
                lock_until_value == Int(0),
                App.localDel(Int(1), Bytes("lock until")),
                App.localPut(Int(1), Bytes("lock until"), lock_until_value),
            ),
            Return(is_transfer_admin),
        ]
    )

    set_transfer_group = Seq(
        [
            Assert(
                And(
                    Txn.application_args.length() == Int(3),
                    Txn.accounts.length() == Int(1),
                )
            ),
            App.localPut(
                Int(1), Bytes("transfer group"), Btoi(Txn.application_args[2])
            ),
        ]
    )

    def getRuleKey(sendGroup, receiveGroup):
        return Concat(Bytes("rule"), Itob(sendGroup), Itob(receiveGroup))

    lock_transfer_key = getRuleKey(
        Btoi(Txn.application_args[2]), Btoi(Txn.application_args[3])
    )
    lock_transfer_until = Btoi(Txn.application_args[4])
    lock_transfer_group = Seq(
        [
            Assert(Txn.application_args.length() == Int(5)),
            If(
                lock_transfer_until == Int(0),
                App.globalDel(lock_transfer_key),
                App.globalPut(lock_transfer_key, lock_transfer_until),
            ),
        ]
    )

    # sender must be transfer admin
    transfer_group = Seq(
        [
            Assert(Txn.application_args.length() > Int(2)),
            Cond(
                [Txn.application_args[1] == Bytes("set"), set_transfer_group],
                [Txn.application_args[1] == Bytes("lock"), lock_transfer_group],
            ),
            Return(is_transfer_admin),
        ]
    )

    # move assets from the reserve to Txn.accounts[1]
    # sender must be contract admin
    mint_amount = Btoi(Txn.application_args[1])
    mint = Seq(
        [
            Assert(
                And(
                    Txn.application_args.length() == Int(2),
                    Txn.accounts.length() == Int(1),
                    mint_amount <= App.globalGet(Bytes("reserve")),
                )
            ),
            App.globalPut(
                Bytes("reserve"), App.globalGet(Bytes("reserve")) - mint_amount
            ),
            App.localPut(
                Int(1),
                Bytes("balance"),
                App.localGet(Int(1), Bytes("balance")) + mint_amount,
            ),
            Return(is_contract_admin),
        ]
    )

    # move assets from Txn.accounts[1] to the reserve
    # sender must be contract admin
    burn_amount = Btoi(Txn.application_args[1])
    burn = Seq(
        [
            Assert(
                And(
                    Txn.application_args.length() == Int(2),
                    Txn.accounts.length() == Int(1),
                    burn_amount <= App.localGet(Int(1), Bytes("balance")),
                )
            ),
            App.globalPut(
                Bytes("reserve"), App.globalGet(Bytes("reserve")) + burn_amount
            ),
            App.localPut(
                Int(1),
                Bytes("balance"),
                App.localGet(Int(1), Bytes("balance")) - burn_amount,
            ),
            Return(is_contract_admin),
        ]
    )

    # transfer assets from the sender to Txn.accounts[1]
    transfer_amount = Btoi(Txn.application_args[1])
    receiver_max_balance = App.localGetEx(Int(1), App.id(), Bytes("max balance"))
    transfer = Seq(
        [
            Assert(
                And(
                    Txn.application_args.length() == Int(2),
                    Txn.accounts.length() == Int(1),
                    transfer_amount <= App.localGet(Int(0), Bytes("balance")),
                )
            ),
            receiver_max_balance,
            If(
                Or(
                    App.globalGet(Bytes("paused")),
                    App.localGet(Int(0), Bytes("frozen")),
                    App.localGet(Int(1), Bytes("frozen")),
                    App.localGet(Int(0), Bytes("lock until"))
                    >= Global.latest_timestamp(),
                    App.localGet(Int(1), Bytes("lock until"))
                    >= Global.latest_timestamp(),
                    App.globalGet(
                        getRuleKey(
                            App.localGet(Int(0), Bytes("transfer group")),
                            App.localGet(Int(1), Bytes("transfer group")),
                        )
                    )
                    >= Global.latest_timestamp(),
                    And(
                        receiver_max_balance.hasValue(),
                        receiver_max_balance.value()
                        < App.localGet(Int(1), Bytes("balance")) + transfer_amount,
                    ),
                ),
                Return(Int(0)),
            ),
            App.localPut(
                Int(0),
                Bytes("balance"),
                App.localGet(Int(0), Bytes("balance")) - transfer_amount,
            ),
            App.localPut(
                Int(1),
                Bytes("balance"),
                App.localGet(Int(1), Bytes("balance")) + transfer_amount,
            ),
            Return(Int(1)),
        ]
    )

    program = Cond(
        [Txn.application_id() == Int(0), on_creation],
        [Txn.on_completion() == OnComplete.DeleteApplication, Return(can_delete)],
        [
            Txn.on_completion() == OnComplete.UpdateApplication,
            Return(is_contract_admin),
        ],
        [Txn.on_completion() == OnComplete.CloseOut, on_closeout],
        [Txn.on_completion() == OnComplete.OptIn, register],
        [Txn.application_args[0] == Bytes("pause"), pause],
        [Txn.application_args[0] == Bytes("set admin"), set_admin],
        [Txn.application_args[0] == Bytes("freeze"), freeze],
        [Txn.application_args[0] == Bytes("max balance"), max_balance],
        [Txn.application_args[0] == Bytes("lock until"), lock_until],
        [Txn.application_args[0] == Bytes("transfer group"), transfer_group],
        [Txn.application_args[0] == Bytes("mint"), mint],
        [Txn.application_args[0] == Bytes("burn"), burn],
        [Txn.application_args[0] == Bytes("transfer"), transfer],
    )

    return program


def clear_state_program():
    program = Seq(
        [
            App.globalPut(
                Bytes("reserve"),
                App.globalGet(Bytes("reserve"))
                + App.localGet(Int(0), Bytes("balance")),
            ),
            Return(Int(1)),
        ]
    )

    return program


if __name__ == "__main__":
    with open("security_token_approval.teal", "w") as f:
        compiled = compileTeal(approval_program(), mode=Mode.Application, version=2)
        f.write(compiled)

    with open("security_token_clear_state.teal", "w") as f:
        compiled = compileTeal(clear_state_program(), mode=Mode.Application, version=2)
        f.write(compiled)



================================================
FILE: examples/application/sourcemap.py
================================================
"""
This example shows how to use the source map feature to for a PyTeal program.

To enable the source mapping (at the time of this writing 3/14/2023)
one must import `FeatureGate` from `feature_gates` and call `FeatureGate.set_sourcemap_enabled(True)`.
This import must occur before any object from PyTeal is imported, as PyTeal will
default to its own sourcemap configuration if not set beforehand, and PyTeal imports have
the side effect of importing expressions that the sourcemapper needs to be aware of.
"""

from feature_gates import FeatureGates

FeatureGates.set("sourcemap_enabled", True)

# INTENTIONALLY importing pyteal and objects _AFTER_ enabling the sourcemap feature
import pyteal as pt  # noqa: E402
from pyteal import Compilation, Mode  # noqa: E402


def program():
    @pt.Subroutine(pt.TealType.uint64)
    def is_even(i):
        return (
            pt.If(i == pt.Int(0))
            .Then(pt.Int(1))
            .ElseIf(i == pt.Int(1))
            .Then(pt.Int(0))
            .Else(is_even(i - pt.Int(2)))
        )

    n = pt.Btoi(arg0 := pt.Txn.application_args[0])

    return pt.Seq(
        pt.Log(pt.Bytes("n:")),
        pt.Log(arg0),
        pt.Log(pt.Bytes("is_even(n):")),
        pt.Log(pt.Itob(is_even(n))),
        pt.Int(1),
    )


if __name__ == "__main__":
    # This assumes running as follows:
    # cd examples/application
    # python sourcemap.py
    approval_program = program()

    results = Compilation(approval_program, mode=Mode.Application, version=8).compile(
        with_sourcemap=True, annotate_teal=True, annotate_teal_headers=True
    )

    teal = "teal/sourcemap.teal"
    annotated = "teal/sourcemap_annotated.teal"

    with open(teal, "w") as f:
        f.write(results.teal)

    with open(annotated, "w") as f:
        assert isinstance(results.sourcemap, pt.PyTealSourceMap)
        assert isinstance(results.sourcemap.annotated_teal, str)
        f.write(results.sourcemap.annotated_teal)

    print(f"SUCCESS!!! Please check out {teal} and {annotated}")



================================================
FILE: examples/application/vote.py
================================================
# This example is provided for informational purposes only and has not been audited for security.

from pyteal import *


def approval_program():
    on_creation = Seq(
        [
            App.globalPut(Bytes("Creator"), Txn.sender()),
            Assert(Txn.application_args.length() == Int(4)),
            App.globalPut(Bytes("RegBegin"), Btoi(Txn.application_args[0])),
            App.globalPut(Bytes("RegEnd"), Btoi(Txn.application_args[1])),
            App.globalPut(Bytes("VoteBegin"), Btoi(Txn.application_args[2])),
            App.globalPut(Bytes("VoteEnd"), Btoi(Txn.application_args[3])),
            Return(Int(1)),
        ]
    )

    is_creator = Txn.sender() == App.globalGet(Bytes("Creator"))

    get_vote_of_sender = App.localGetEx(Int(0), App.id(), Bytes("voted"))

    on_closeout = Seq(
        [
            get_vote_of_sender,
            If(
                And(
                    Global.round() <= App.globalGet(Bytes("VoteEnd")),
                    get_vote_of_sender.hasValue(),
                ),
                App.globalPut(
                    get_vote_of_sender.value(),
                    App.globalGet(get_vote_of_sender.value()) - Int(1),
                ),
            ),
            Return(Int(1)),
        ]
    )

    on_register = Return(
        And(
            Global.round() >= App.globalGet(Bytes("RegBegin")),
            Global.round() <= App.globalGet(Bytes("RegEnd")),
        )
    )

    choice = Txn.application_args[1]
    choice_tally = App.globalGet(choice)
    on_vote = Seq(
        [
            Assert(
                And(
                    Global.round() >= App.globalGet(Bytes("VoteBegin")),
                    Global.round() <= App.globalGet(Bytes("VoteEnd")),
                )
            ),
            get_vote_of_sender,
            If(get_vote_of_sender.hasValue(), Return(Int(0))),
            App.globalPut(choice, choice_tally + Int(1)),
            App.localPut(Int(0), Bytes("voted"), choice),
            Return(Int(1)),
        ]
    )

    program = Cond(
        [Txn.application_id() == Int(0), on_creation],
        [Txn.on_completion() == OnComplete.DeleteApplication, Return(is_creator)],
        [Txn.on_completion() == OnComplete.UpdateApplication, Return(is_creator)],
        [Txn.on_completion() == OnComplete.CloseOut, on_closeout],
        [Txn.on_completion() == OnComplete.OptIn, on_register],
        [Txn.application_args[0] == Bytes("vote"), on_vote],
    )

    return program


def clear_state_program():
    get_vote_of_sender = App.localGetEx(Int(0), App.id(), Bytes("voted"))
    program = Seq(
        [
            get_vote_of_sender,
            If(
                And(
                    Global.round() <= App.globalGet(Bytes("VoteEnd")),
                    get_vote_of_sender.hasValue(),
                ),
                App.globalPut(
                    get_vote_of_sender.value(),
                    App.globalGet(get_vote_of_sender.value()) - Int(1),
                ),
            ),
            Return(Int(1)),
        ]
    )

    return program


if __name__ == "__main__":
    with open("vote_approval.teal", "w") as f:
        compiled = compileTeal(approval_program(), mode=Mode.Application, version=2)
        f.write(compiled)

    with open("vote_clear_state.teal", "w") as f:
        compiled = compileTeal(clear_state_program(), mode=Mode.Application, version=2)
        f.write(compiled)



================================================
FILE: examples/application/vote_deploy.py
================================================
# based off https://github.com/algorand/docs/blob/cdf11d48a4b1168752e6ccaf77c8b9e8e599713a/examples/smart_contracts/v2/python/stateful_smart_contracts.py

import base64

from algosdk.future import transaction
from algosdk import account, mnemonic
from algosdk.v2client import algod
from pyteal import compileTeal, Mode
from vote import approval_program, clear_state_program

# user declared account mnemonics
creator_mnemonic = "Your 25-word mnemonic goes here"
user_mnemonic = "A second distinct 25-word mnemonic goes here"

# user declared algod connection parameters. Node must have EnableDeveloperAPI set to true in its config
algod_address = "http://localhost:4001"
algod_token = "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"


# helper function to compile program source
def compile_program(client, source_code):
    compile_response = client.compile(source_code)
    return base64.b64decode(compile_response["result"])


# helper function that converts a mnemonic passphrase into a private signing key
def get_private_key_from_mnemonic(mn):
    private_key = mnemonic.to_private_key(mn)
    return private_key


# helper function that waits for a given txid to be confirmed by the network
def wait_for_confirmation(client, txid):
    last_round = client.status().get("last-round")
    txinfo = client.pending_transaction_info(txid)
    while not (txinfo.get("confirmed-round") and txinfo.get("confirmed-round") > 0):
        print("Waiting for confirmation...")
        last_round += 1
        client.status_after_block(last_round)
        txinfo = client.pending_transaction_info(txid)
    print(
        "Transaction {} confirmed in round {}.".format(
            txid, txinfo.get("confirmed-round")
        )
    )
    return txinfo


def wait_for_round(client, round):
    last_round = client.status().get("last-round")
    print(f"Waiting for round {round}")
    while last_round < round:
        last_round += 1
        client.status_after_block(last_round)
        print(f"Round {last_round}")


# create new application
def create_app(
    client,
    private_key,
    approval_program,
    clear_program,
    global_schema,
    local_schema,
    app_args,
):
    # define sender as creator
    sender = account.address_from_private_key(private_key)

    # declare on_complete as NoOp
    on_complete = transaction.OnComplete.NoOpOC.real

    # get node suggested parameters
    params = client.suggested_params()
    # comment out the next two (2) lines to use suggested fees
    params.flat_fee = True
    params.fee = 1000

    # create unsigned transaction
    txn = transaction.ApplicationCreateTxn(
        sender,
        params,
        on_complete,
        approval_program,
        clear_program,
        global_schema,
        local_schema,
        app_args,
    )

    # sign transaction
    signed_txn = txn.sign(private_key)
    tx_id = signed_txn.transaction.get_txid()

    # send transaction
    client.send_transactions([signed_txn])

    # await confirmation
    wait_for_confirmation(client, tx_id)

    # display results
    transaction_response = client.pending_transaction_info(tx_id)
    app_id = transaction_response["application-index"]
    print("Created new app-id:", app_id)

    return app_id


# opt-in to application
def opt_in_app(client, private_key, index):
    # declare sender
    sender = account.address_from_private_key(private_key)
    print("OptIn from account: ", sender)

    # get node suggested parameters
    params = client.suggested_params()
    # comment out the next two (2) lines to use suggested fees
    params.flat_fee = True
    params.fee = 1000

    # create unsigned transaction
    txn = transaction.ApplicationOptInTxn(sender, params, index)

    # sign transaction
    signed_txn = txn.sign(private_key)
    tx_id = signed_txn.transaction.get_txid()

    # send transaction
    client.send_transactions([signed_txn])

    # await confirmation
    wait_for_confirmation(client, tx_id)

    # display results
    transaction_response = client.pending_transaction_info(tx_id)
    print("OptIn to app-id:", transaction_response["txn"]["txn"]["apid"])


# call application
def call_app(client, private_key, index, app_args):
    # declare sender
    sender = account.address_from_private_key(private_key)
    print("Call from account:", sender)

    # get node suggested parameters
    params = client.suggested_params()
    # comment out the next two (2) lines to use suggested fees
    params.flat_fee = True
    params.fee = 1000

    # create unsigned transaction
    txn = transaction.ApplicationNoOpTxn(sender, params, index, app_args)

    # sign transaction
    signed_txn = txn.sign(private_key)
    tx_id = signed_txn.transaction.get_txid()

    # send transaction
    client.send_transactions([signed_txn])

    # await confirmation
    wait_for_confirmation(client, tx_id)


def format_state(state):
    formatted = {}
    for item in state:
        key = item["key"]
        value = item["value"]
        formatted_key = base64.b64decode(key).decode("utf-8")
        if value["type"] == 1:
            # byte string
            if formatted_key == "voted":
                formatted_value = base64.b64decode(value["bytes"]).decode("utf-8")
            else:
                formatted_value = value["bytes"]
            formatted[formatted_key] = formatted_value
        else:
            # integer
            formatted[formatted_key] = value["uint"]
    return formatted


# read user local state
def read_local_state(client, addr, app_id):
    results = client.account_info(addr)
    for local_state in results["apps-local-state"]:
        if local_state["id"] == app_id:
            if "key-value" not in local_state:
                return {}
            return format_state(local_state["key-value"])
    return {}


# read app global state
def read_global_state(client, addr, app_id):
    results = client.account_info(addr)
    apps_created = results["created-apps"]
    for app in apps_created:
        if app["id"] == app_id:
            return format_state(app["params"]["global-state"])
    return {}


# delete application
def delete_app(client, private_key, index):
    # declare sender
    sender = account.address_from_private_key(private_key)

    # get node suggested parameters
    params = client.suggested_params()
    # comment out the next two (2) lines to use suggested fees
    params.flat_fee = True
    params.fee = 1000

    # create unsigned transaction
    txn = transaction.ApplicationDeleteTxn(sender, params, index)

    # sign transaction
    signed_txn = txn.sign(private_key)
    tx_id = signed_txn.transaction.get_txid()

    # send transaction
    client.send_transactions([signed_txn])

    # await confirmation
    wait_for_confirmation(client, tx_id)

    # display results
    transaction_response = client.pending_transaction_info(tx_id)
    print("Deleted app-id:", transaction_response["txn"]["txn"]["apid"])


# close out from application
def close_out_app(client, private_key, index):
    # declare sender
    sender = account.address_from_private_key(private_key)

    # get node suggested parameters
    params = client.suggested_params()
    # comment out the next two (2) lines to use suggested fees
    params.flat_fee = True
    params.fee = 1000

    # create unsigned transaction
    txn = transaction.ApplicationCloseOutTxn(sender, params, index)

    # sign transaction
    signed_txn = txn.sign(private_key)
    tx_id = signed_txn.transaction.get_txid()

    # send transaction
    client.send_transactions([signed_txn])

    # await confirmation
    wait_for_confirmation(client, tx_id)

    # display results
    transaction_response = client.pending_transaction_info(tx_id)
    print("Closed out from app-id: ", transaction_response["txn"]["txn"]["apid"])


# clear application
def clear_app(client, private_key, index):
    # declare sender
    sender = account.address_from_private_key(private_key)

    # get node suggested parameters
    params = client.suggested_params()
    # comment out the next two (2) lines to use suggested fees
    params.flat_fee = True
    params.fee = 1000

    # create unsigned transaction
    txn = transaction.ApplicationClearStateTxn(sender, params, index)

    # sign transaction
    signed_txn = txn.sign(private_key)
    tx_id = signed_txn.transaction.get_txid()

    # send transaction
    client.send_transactions([signed_txn])

    # await confirmation
    wait_for_confirmation(client, tx_id)

    # display results
    transaction_response = client.pending_transaction_info(tx_id)
    print("Cleared app-id:", transaction_response["txn"]["txn"]["apid"])


# convert 64 bit integer i to byte string
def intToBytes(i):
    return i.to_bytes(8, "big")


def main():
    # initialize an algodClient
    algod_client = algod.AlgodClient(algod_token, algod_address)

    # define private keys
    creator_private_key = get_private_key_from_mnemonic(creator_mnemonic)
    user_private_key = get_private_key_from_mnemonic(user_mnemonic)

    # declare application state storage (immutable)
    local_ints = 0
    local_bytes = 1
    global_ints = (
        24  # 4 for setup + 20 for choices. Use a larger number for more choices.
    )
    global_bytes = 1
    global_schema = transaction.StateSchema(global_ints, global_bytes)
    local_schema = transaction.StateSchema(local_ints, local_bytes)

    # get PyTeal approval program
    approval_program_ast = approval_program()
    # compile program to TEAL assembly
    approval_program_teal = compileTeal(
        approval_program_ast, mode=Mode.Application, version=2
    )
    # compile program to binary
    approval_program_compiled = compile_program(algod_client, approval_program_teal)

    # get PyTeal clear state program
    clear_state_program_ast = clear_state_program()
    # compile program to TEAL assembly
    clear_state_program_teal = compileTeal(
        clear_state_program_ast, mode=Mode.Application, version=2
    )
    # compile program to binary
    clear_state_program_compiled = compile_program(
        algod_client, clear_state_program_teal
    )

    # configure registration and voting period
    status = algod_client.status()
    regBegin = status["last-round"] + 10
    regEnd = regBegin + 10
    voteBegin = regEnd + 1
    voteEnd = voteBegin + 10

    print(f"Registration rounds: {regBegin} to {regEnd}")
    print(f"Vote rounds: {voteBegin} to {voteEnd}")

    # create list of bytes for app args
    app_args = [
        intToBytes(regBegin),
        intToBytes(regEnd),
        intToBytes(voteBegin),
        intToBytes(voteEnd),
    ]

    # create new application
    app_id = create_app(
        algod_client,
        creator_private_key,
        approval_program_compiled,
        clear_state_program_compiled,
        global_schema,
        local_schema,
        app_args,
    )

    # read global state of application
    print(
        "Global state:",
        read_global_state(
            algod_client, account.address_from_private_key(creator_private_key), app_id
        ),
    )

    # wait for registration period to start
    wait_for_round(algod_client, regBegin)

    # opt-in to application
    opt_in_app(algod_client, user_private_key, app_id)

    wait_for_round(algod_client, voteBegin)

    # call application without arguments
    call_app(algod_client, user_private_key, app_id, [b"vote", b"choiceA"])

    # read local state of application from user account
    print(
        "Local state:",
        read_local_state(
            algod_client, account.address_from_private_key(user_private_key), app_id
        ),
    )

    # wait for registration period to start
    wait_for_round(algod_client, voteEnd)

    # read global state of application
    global_state = read_global_state(
        algod_client, account.address_from_private_key(creator_private_key), app_id
    )
    print("Global state:", global_state)

    max_votes = 0
    max_votes_choice = None
    for key, value in global_state.items():
        if key not in (
            "RegBegin",
            "RegEnd",
            "VoteBegin",
            "VoteEnd",
            "Creator",
        ) and isinstance(value, int):
            if value > max_votes:
                max_votes = value
                max_votes_choice = key

    print("The winner is:", max_votes_choice)

    # delete application
    delete_app(algod_client, creator_private_key, app_id)

    # clear application from user account
    clear_app(algod_client, user_private_key, app_id)


if __name__ == "__main__":
    main()



================================================
FILE: examples/application/abi/__init__.py
================================================
[Empty file]


================================================
FILE: examples/application/abi/algobank.json
================================================
{
    "name": "AlgoBank",
    "methods": [
        {
            "name": "deposit",
            "args": [
                {
                    "type": "pay",
                    "name": "payment",
                    "desc": "A payment transaction containing the amount of Algos the user wishes to deposit. The receiver of this transaction must be this app's escrow account."
                },
                {
                    "type": "account",
                    "name": "sender",
                    "desc": "An account that is opted into this app (or will opt in during this method call). The deposited funds will be recorded in this account's local state. This account must be the same as the sender of the `payment` transaction."
                }
            ],
            "returns": {
                "type": "void"
            },
            "desc": "This method receives a payment from an account opted into this app and records it as a deposit.\nThe caller may opt into this app during this call."
        },
        {
            "name": "getBalance",
            "args": [
                {
                    "type": "account",
                    "name": "user",
                    "desc": "The user whose balance you wish to look up. This user must be opted into this app."
                }
            ],
            "returns": {
                "type": "uint64",
                "desc": "The balance corresponding to the given user, in microAlgos."
            },
            "desc": "Lookup the balance of a user held by this app."
        },
        {
            "name": "withdraw",
            "args": [
                {
                    "type": "uint64",
                    "name": "amount",
                    "desc": "The amount of Algos requested to be withdraw, in microAlgos. This method will fail if this amount exceeds the amount of Algos held by this app for the method call sender."
                },
                {
                    "type": "account",
                    "name": "recipient",
                    "desc": "An account who will receive the withdrawn Algos. This may or may not be the same as the method call sender."
                }
            ],
            "returns": {
                "type": "void"
            },
            "desc": "Withdraw an amount of Algos held by this app.\nThe sender of this method call will be the source of the Algos, and the destination will be the `recipient` argument.\nThe Algos will be transferred to the recipient using an inner transaction whose fee is set to 0, meaning the caller's transaction must include a surplus fee to cover the inner transaction."
        }
    ],
    "networks": {}
}


================================================
FILE: examples/application/abi/algobank.py
================================================
# This example is provided for informational purposes only and has not been audited for security.
from pyteal import *
import json


@Subroutine(TealType.none)
def assert_sender_is_creator() -> Expr:
    return Assert(Txn.sender() == Global.creator_address())


# move any balance that the user has into the "lost" amount when they close out or clear state
transfer_balance_to_lost = App.globalPut(
    Bytes("lost"),
    App.globalGet(Bytes("lost")) + App.localGet(Txn.sender(), Bytes("balance")),
)

router = Router(
    name="AlgoBank",
    bare_calls=BareCallActions(
        # approve a creation no-op call
        no_op=OnCompleteAction(action=Approve(), call_config=CallConfig.CREATE),
        # approve opt-in calls during normal usage, and during creation as a convenience for the creator
        opt_in=OnCompleteAction(action=Approve(), call_config=CallConfig.ALL),
        # move any balance that the user has into the "lost" amount when they close out or clear state
        close_out=OnCompleteAction(
            action=transfer_balance_to_lost, call_config=CallConfig.CALL
        ),
        # only the creator can update or delete the app
        update_application=OnCompleteAction(
            action=assert_sender_is_creator, call_config=CallConfig.CALL
        ),
        delete_application=OnCompleteAction(
            action=assert_sender_is_creator, call_config=CallConfig.CALL
        ),
    ),
    clear_state=transfer_balance_to_lost,
)


@router.method(no_op=CallConfig.CALL, opt_in=CallConfig.CALL)
def deposit(payment: abi.PaymentTransaction, sender: abi.Account) -> Expr:
    """This method receives a payment from an account opted into this app and records it as a deposit.

    The caller may opt into this app during this call.

    Args:
        payment: A payment transaction containing the amount of Algos the user wishes to deposit.
            The receiver of this transaction must be this app's escrow account.
        sender: An account that is opted into this app (or will opt in during this method call).
            The deposited funds will be recorded in this account's local state. This account must
            be the same as the sender of the `payment` transaction.
    """
    return Seq(
        Assert(payment.get().sender() == sender.address()),
        Assert(payment.get().receiver() == Global.current_application_address()),
        App.localPut(
            sender.address(),
            Bytes("balance"),
            App.localGet(sender.address(), Bytes("balance")) + payment.get().amount(),
        ),
    )


@router.method
def getBalance(user: abi.Account, *, output: abi.Uint64) -> Expr:
    """Lookup the balance of a user held by this app.

    Args:
        user: The user whose balance you wish to look up. This user must be opted into this app.

    Returns:
        The balance corresponding to the given user, in microAlgos.
    """
    return output.set(App.localGet(user.address(), Bytes("balance")))


@router.method
def withdraw(amount: abi.Uint64, recipient: abi.Account) -> Expr:
    """Withdraw an amount of Algos held by this app.

    The sender of this method call will be the source of the Algos, and the destination will be
    the `recipient` argument.

    The Algos will be transferred to the recipient using an inner transaction whose fee is set
    to 0, meaning the caller's transaction must include a surplus fee to cover the inner
    transaction.

    Args:
        amount: The amount of Algos requested to be withdraw, in microAlgos. This method will fail
            if this amount exceeds the amount of Algos held by this app for the method call sender.
        recipient: An account who will receive the withdrawn Algos. This may or may not be the same
            as the method call sender.
    """
    return Seq(
        # if amount is larger than App.localGet(Txn.sender(), Bytes("balance")), the subtraction
        # will underflow and fail this method call
        App.localPut(
            Txn.sender(),
            Bytes("balance"),
            App.localGet(Txn.sender(), Bytes("balance")) - amount.get(),
        ),
        InnerTxnBuilder.Begin(),
        InnerTxnBuilder.SetFields(
            {
                TxnField.type_enum: TxnType.Payment,
                TxnField.receiver: recipient.address(),
                TxnField.amount: amount.get(),
                TxnField.fee: Int(0),
            }
        ),
        InnerTxnBuilder.Submit(),
    )


if __name__ == "__main__":
    approval_program, clear_state_program, contract = router.compile_program(
        version=6, optimize=OptimizeOptions(scratch_slots=True)
    )

    with open("algobank_approval.teal", "w") as f:
        f.write(approval_program)

    with open("algobank_clear_state.teal", "w") as f:
        f.write(clear_state_program)

    with open("algobank.json", "w") as f:
        f.write(json.dumps(contract.dictify(), indent=4))



================================================
FILE: examples/application/abi/algobank_approval.teal
================================================
#pragma version 6
txn NumAppArgs
int 0
==
bnz main_l8
txna ApplicationArgs 0
method "deposit(pay,account)void"
==
bnz main_l7
txna ApplicationArgs 0
method "getBalance(account)uint64"
==
bnz main_l6
txna ApplicationArgs 0
method "withdraw(uint64,account)void"
==
bnz main_l5
err
main_l5:
txn OnCompletion
int NoOp
==
txn ApplicationID
int 0
!=
&&
assert
txna ApplicationArgs 1
btoi
store 3
txna ApplicationArgs 2
int 0
getbyte
store 4
load 3
load 4
callsub withdraw_3
int 1
return
main_l6:
txn OnCompletion
int NoOp
==
txn ApplicationID
int 0
!=
&&
assert
txna ApplicationArgs 1
int 0
getbyte
callsub getBalance_2
store 2
byte 0x151f7c75
load 2
itob
concat
log
int 1
return
main_l7:
txn OnCompletion
int NoOp
==
txn ApplicationID
int 0
!=
&&
txn OnCompletion
int OptIn
==
txn ApplicationID
int 0
!=
&&
||
assert
txna ApplicationArgs 1
int 0
getbyte
store 1
txn GroupIndex
int 1
-
store 0
load 0
gtxns TypeEnum
int pay
==
assert
load 0
load 1
callsub deposit_1
int 1
return
main_l8:
txn OnCompletion
int NoOp
==
bnz main_l18
txn OnCompletion
int OptIn
==
bnz main_l17
txn OnCompletion
int CloseOut
==
bnz main_l16
txn OnCompletion
int UpdateApplication
==
bnz main_l15
txn OnCompletion
int DeleteApplication
==
bnz main_l14
err
main_l14:
txn ApplicationID
int 0
!=
assert
callsub assertsenderiscreator_0
int 1
return
main_l15:
txn ApplicationID
int 0
!=
assert
callsub assertsenderiscreator_0
int 1
return
main_l16:
txn ApplicationID
int 0
!=
assert
byte "lost"
byte "lost"
app_global_get
txn Sender
byte "balance"
app_local_get
+
app_global_put
int 1
return
main_l17:
int 1
return
main_l18:
txn ApplicationID
int 0
==
assert
int 1
return

// assert_sender_is_creator
assertsenderiscreator_0:
txn Sender
global CreatorAddress
==
assert
retsub

// deposit
deposit_1:
store 6
store 5
load 5
gtxns Sender
load 6
txnas Accounts
==
assert
load 5
gtxns Receiver
global CurrentApplicationAddress
==
assert
load 6
txnas Accounts
byte "balance"
load 6
txnas Accounts
byte "balance"
app_local_get
load 5
gtxns Amount
+
app_local_put
retsub

// getBalance
getBalance_2:
txnas Accounts
byte "balance"
app_local_get
retsub

// withdraw
withdraw_3:
store 8
store 7
txn Sender
byte "balance"
txn Sender
byte "balance"
app_local_get
load 7
-
app_local_put
itxn_begin
int pay
itxn_field TypeEnum
load 8
txnas Accounts
itxn_field Receiver
load 7
itxn_field Amount
int 0
itxn_field Fee
itxn_submit
retsub


================================================
FILE: examples/application/abi/algobank_clear_state.teal
================================================
#pragma version 6
byte "lost"
byte "lost"
app_global_get
txn Sender
byte "balance"
app_local_get
+
app_global_put
int 1
return


================================================
FILE: examples/application/teal/sourcemap.teal
================================================
#pragma version 8
byte "n:"
log
txna ApplicationArgs 0
log
byte "is_even(n):"
log
txna ApplicationArgs 0
btoi
callsub iseven_0
itob
log
int 1
return

// is_even
iseven_0:
proto 1 1
frame_dig -1
int 0
==
bnz iseven_0_l4
frame_dig -1
int 1
==
bnz iseven_0_l3
frame_dig -1
int 2
-
callsub iseven_0
b iseven_0_l5
iseven_0_l3:
int 0
b iseven_0_l5
iseven_0_l4:
int 1
iseven_0_l5:
retsub


================================================
FILE: examples/application/teal/sourcemap_annotated.teal
================================================
// GENERATED TEAL       //    PYTEAL PATH    LINE    PYTEAL
#pragma version 8       //    sourcemap.py   48      Compilation(approval_program, mode=Mode.Application, version=8).compile(with_sourcemap=True, annotate_teal=True, annotate_teal_headers=True)
byte "n:"               //                   34      pt.Bytes('n:')
log                     //                           pt.Log(pt.Bytes('n:'))
txna ApplicationArgs 0  //                   31      pt.Txn.application_args[0]
log                     //                   35      pt.Log(arg0)
byte "is_even(n):"      //                   36      pt.Bytes('is_even(n):')
log                     //                           pt.Log(pt.Bytes('is_even(n):'))
txna ApplicationArgs 0  //                   31      pt.Txn.application_args[0]
btoi                    //                           pt.Btoi((arg0 := pt.Txn.application_args[0]))
callsub iseven_0        //                   37      is_even(n)
itob                    //                           pt.Itob(is_even(n))
log                     //                           pt.Log(pt.Itob(is_even(n)))
int 1                   //                   38      pt.Int(1)
return                  //                   48      Compilation(approval_program, mode=Mode.Application, version=8).compile(with_sourcemap=True, annotate_teal=True, annotate_teal_headers=True)
                        //                   22      def is_even(i):
// is_even              //
iseven_0:               //
proto 1 1               //
frame_dig -1            //                   48      Compilation(approval_program, mode=Mode.Application, version=8).compile(with_sourcemap=True, annotate_teal=True, annotate_teal_headers=True)
int 0                   //                   24      pt.Int(0)
==                      //                           i == pt.Int(0)
bnz iseven_0_l4         //                           pt.If(i == pt.Int(0))
frame_dig -1            //                   48      Compilation(approval_program, mode=Mode.Application, version=8).compile(with_sourcemap=True, annotate_teal=True, annotate_teal_headers=True)
int 1                   //                   26      pt.Int(1)
==                      //                           i == pt.Int(1)
bnz iseven_0_l3         //
frame_dig -1            //                   48      Compilation(approval_program, mode=Mode.Application, version=8).compile(with_sourcemap=True, annotate_teal=True, annotate_teal_headers=True)
int 2                   //                   28      pt.Int(2)
-                       //                           i - pt.Int(2)
callsub iseven_0        //                           is_even(i - pt.Int(2))
b iseven_0_l5           //                   26      pt.If(i == pt.Int(0)).Then(pt.Int(1)).ElseIf(i == pt.Int(1))
iseven_0_l3:            //                           i == pt.Int(1)
int 0                   //                   27      pt.Int(0)
b iseven_0_l5           //                   48      Compilation(approval_program, mode=Mode.Application, version=8).compile(with_sourcemap=True, annotate_teal=True, annotate_teal_headers=True)
iseven_0_l4:            //                   24      pt.If(i == pt.Int(0))
int 1                   //                   25      pt.Int(1)
iseven_0_l5:            //                   26      pt.If(i == pt.Int(0)).Then(pt.Int(1)).ElseIf(i == pt.Int(1))
retsub                  //                   22      def is_even(i):


================================================
FILE: examples/signature/__init__.py
================================================
[Empty file]


================================================
FILE: examples/signature/atomic_swap.py
================================================
# This example is provided for informational purposes only and has not been audited for security.

from pyteal import *

"""Atomic Swap"""

alice = Addr("6ZHGHH5Z5CTPCF5WCESXMGRSVK7QJETR63M3NY5FJCUYDHO57VTCMJOBGY")
bob = Addr("7Z5PWO2C6LFNQFGHWKSK5H47IQP5OJW2M3HA2QPXTY3WTNP5NU2MHBW27M")
secret = Bytes("base32", "2323232323232323")
timeout = 3000


def htlc(
    tmpl_seller=alice,
    tmpl_buyer=bob,
    tmpl_fee=1000,
    tmpl_secret=secret,
    tmpl_hash_fn=Sha256,
    tmpl_timeout=timeout,
):
    fee_cond = Txn.fee() < Int(tmpl_fee)
    safety_cond = And(
        Txn.type_enum() == TxnType.Payment,
        Txn.close_remainder_to() == Global.zero_address(),
        Txn.rekey_to() == Global.zero_address(),
    )

    recv_cond = And(Txn.receiver() == tmpl_seller, tmpl_hash_fn(Arg(0)) == tmpl_secret)

    esc_cond = And(Txn.receiver() == tmpl_buyer, Txn.first_valid() > Int(tmpl_timeout))

    return And(fee_cond, safety_cond, Or(recv_cond, esc_cond))


if __name__ == "__main__":
    print(compileTeal(htlc(), mode=Mode.Signature, version=2))



================================================
FILE: examples/signature/atomic_swap.teal
================================================
#pragma version 2
txn Fee
int 1000
<
txn TypeEnum
int pay
==
txn CloseRemainderTo
global ZeroAddress
==
&&
txn RekeyTo
global ZeroAddress
==
&&
&&
txn Receiver
addr 6ZHGHH5Z5CTPCF5WCESXMGRSVK7QJETR63M3NY5FJCUYDHO57VTCMJOBGY
==
arg 0
sha256
byte base32(2323232323232323)
==
&&
txn Receiver
addr 7Z5PWO2C6LFNQFGHWKSK5H47IQP5OJW2M3HA2QPXTY3WTNP5NU2MHBW27M
==
txn FirstValid
int 3000
>
&&
||
&&
return



================================================
FILE: examples/signature/basic.py
================================================
# This example is provided for informational purposes only and has not been audited for security.

from pyteal import *

"""Basic Bank"""


def bank_for_account(receiver):
    """Only allow receiver to withdraw funds from this contract account.

    Args:
        receiver (str): Base 32 Algorand address of the receiver.
    """

    is_payment = Txn.type_enum() == TxnType.Payment
    is_single_tx = Global.group_size() == Int(1)
    is_correct_receiver = Txn.receiver() == Addr(receiver)
    no_close_out_addr = Txn.close_remainder_to() == Global.zero_address()
    no_rekey_addr = Txn.rekey_to() == Global.zero_address()
    acceptable_fee = Txn.fee() <= Int(1000)

    return And(
        is_payment,
        is_single_tx,
        is_correct_receiver,
        no_close_out_addr,
        no_rekey_addr,
        acceptable_fee,
    )


if __name__ == "__main__":
    program = bank_for_account(
        "ZZAF5ARA4MEC5PVDOP64JM5O5MQST63Q2KOY2FLYFLXXD3PFSNJJBYAFZM"
    )
    print(compileTeal(program, mode=Mode.Signature, version=3))



================================================
FILE: examples/signature/basic.teal
================================================
#pragma version 3
txn TypeEnum
int pay
==
global GroupSize
int 1
==
&&
txn Receiver
addr ZZAF5ARA4MEC5PVDOP64JM5O5MQST63Q2KOY2FLYFLXXD3PFSNJJBYAFZM
==
&&
txn CloseRemainderTo
global ZeroAddress
==
&&
txn RekeyTo
global ZeroAddress
==
&&
txn Fee
int 1000
<=
&&
return



================================================
FILE: examples/signature/dutch_auction.py
================================================
# This example is provided for informational purposes only and has not been audited for security.
from pathlib import Path

from feature_gates import FeatureGates

FeatureGates.set("sourcemap_enabled", True)


from pyteal import *  # noqa: E402


""" Template for layer 1 dutch auction (from Fabrice and Shai)
"""

tmpl_start_round = Tmpl.Int("TMPL_START_ROUND")
tmpl_start_price = Tmpl.Int("TMPL_START_PRICE")
tmpl_supply = Tmpl.Int("TMPL_N")
tmpl_price_decrement = Tmpl.Int("TMPL_PRICE_INCREMENT")
tmpl_period = Tmpl.Int("TMPL_PERIOD")
tmpl_asset_a = Tmpl.Int("TMPL_ASSET_A")
tmpl_asset_b = Tmpl.Int("TMPL_ASSET_B")
tmpl_asset_c = Tmpl.Int("TMPL_ASSET_C")
tmpl_asset_d = Tmpl.Int("TMPL_ASSET_D")
tmpl_receiver = Tmpl.Addr("TMPL_RECEIVER")
tmpl_algo_sink = Tmpl.Addr("TMPL_ALGO_ZERO")
tmpl_asset_a_sink = Tmpl.Addr("TMPL_A_ZERO")
tmpl_asset_b_sink = Tmpl.Addr("TMPL_B_ZERO")
tmpl_asset_c_sink = Tmpl.Addr("TMPL_C_ZERO")
tmpl_asset_d_sink = Tmpl.Addr("TMPL_D_ZERO")
tmpl_redeem_round = Tmpl.Int("TMPL_REDEEM_ROUND")
tmpl_wrapup_time = Tmpl.Int("TMPL_WRAPUP_ROUND")


def dutch_auction(
    start_round=tmpl_start_round,
    start_price=tmpl_start_price,
    supply=tmpl_supply,
    price_decrement=tmpl_price_decrement,
    period=tmpl_period,
    asset_a=tmpl_asset_a,
    asset_b=tmpl_asset_b,
    asset_c=tmpl_asset_c,
    asset_d=tmpl_asset_d,
    receiver=tmpl_receiver,
    algo_sink=tmpl_algo_sink,
    asset_a_sink=tmpl_asset_a_sink,
    asset_b_sink=tmpl_asset_b_sink,
    asset_c_sink=tmpl_asset_c_sink,
    asset_d_sink=tmpl_asset_d_sink,
    redeem_round=tmpl_redeem_round,
    wrapup_time=tmpl_wrapup_time,
):
    # the definition of i simplifies the original desgin by only constraining last_valid here
    i_upper = (Gtxn[0].last_valid() - start_round) / period

    bid = And(
        Gtxn[0].rekey_to() == Global.zero_address(),
        Gtxn[1].rekey_to() == Global.zero_address(),
        Gtxn[2].rekey_to() == Global.zero_address(),
        Gtxn[3].rekey_to() == Global.zero_address(),
        Gtxn[4].rekey_to() == Global.zero_address(),
        Gtxn[0].last_valid() == Gtxn[1].last_valid(),
        Gtxn[1].last_valid() == Gtxn[2].last_valid(),
        Gtxn[2].last_valid() == Gtxn[3].last_valid(),
        Gtxn[3].last_valid() == Gtxn[4].last_valid(),
        Gtxn[4].last_valid() < (start_round + i_upper * period),
        Gtxn[0].type_enum() == TxnType.AssetTransfer,
        Gtxn[0].xfer_asset() == asset_d,
        Gtxn[0].receiver() == receiver,
        Gtxn[1].type_enum() == TxnType.AssetTransfer,
        Gtxn[1].xfer_asset() == asset_b,
        Gtxn[2].type_enum() == TxnType.AssetTransfer,
        Gtxn[2].xfer_asset() == asset_c,
        Gtxn[3].type_enum() == TxnType.AssetTransfer,
        Gtxn[4].xfer_asset() == asset_c,
        Gtxn[4].type_enum() == TxnType.Payment,
        Gtxn[4].amount()
        == (Gtxn[1].fee() + Gtxn[2].fee() + Gtxn[3].fee()),  # ? why only 1, 2, 3
        Gtxn[0].asset_amount() == Gtxn[1].asset_amount(),
        Gtxn[1].asset_amount() == Gtxn[2].asset_amount(),
        Gtxn[3].asset_amount() == i_upper * supply * price_decrement,
        Gtxn[0].sender() == Gtxn[1].receiver(),
        Gtxn[2].receiver() == asset_c_sink,
        Gtxn[1].sender() == Gtxn[2].sender(),
        Gtxn[2].sender() == Gtxn[3].sender(),
        Gtxn[3].sender() == Gtxn[3].receiver(),
        Gtxn[3].receiver() == Gtxn[4].receiver(),
    )

    redeem = And(
        Gtxn[0].rekey_to() == Global.zero_address(),
        Gtxn[1].rekey_to() == Global.zero_address(),
        Gtxn[2].rekey_to() == Global.zero_address(),
        Gtxn[3].rekey_to() == Global.zero_address(),
        Gtxn[0].first_valid() == Gtxn[1].first_valid(),
        Gtxn[1].first_valid() == Gtxn[2].first_valid(),
        Gtxn[2].first_valid() == Gtxn[3].first_valid(),
        Gtxn[3].first_valid() >= redeem_round,
        Gtxn[0].type_enum() == TxnType.AssetTransfer,
        Gtxn[0].xfer_asset() == asset_b,
        Gtxn[1].type_enum() == TxnType.AssetTransfer,
        Gtxn[1].xfer_asset() == asset_a,
        Gtxn[2].type_enum() == TxnType.AssetTransfer,
        Gtxn[2].xfer_asset() == asset_c,
        Gtxn[2].asset_amount() == redeem_round * supply * price_decrement,
        Gtxn[3].type_enum() == TxnType.Payment,
        Gtxn[3].amount() == Gtxn[1].fee() + Gtxn[2].fee(),
        Gtxn[1].asset_amount()
        == Gtxn[0].asset_amount() * (start_price - price_decrement * Btoi(Arg(0))),
        Gtxn[0].sender() == Gtxn[1].receiver(),
        Gtxn[0].receiver() == Gtxn[1].sender(),
        Gtxn[1].sender() == Gtxn[2].sender(),
        Gtxn[2].sender() == Gtxn[2].receiver(),
        Gtxn[2].receiver() == Gtxn[3].receiver(),
    )

    wrapup = And(
        Txn.rekey_to() == Global.zero_address(),
        Txn.first_valid() >= start_round + wrapup_time,
        Or(
            And(
                Txn.type_enum() == TxnType.Payment,
                Txn.amount() == Int(0),
                Txn.close_remainder_to() == receiver,
            ),
            And(
                Txn.type_enum() == TxnType.AssetTransfer,
                Txn.asset_amount() == Int(0),
                Txn.asset_close_to() == receiver,
                Txn.xfer_asset() == asset_a,
            ),
        ),
    )

    dutch = Cond(
        [Global.group_size() == Int(5), bid],
        [Global.group_size() == Int(4), redeem],
        [Global.group_size() == Int(1), wrapup],
    )

    return dutch


if __name__ == "__main__":
    # to recreate files, run this script from the root of the repo
    results = Compilation(dutch_auction(), mode=Mode.Signature, version=2).compile(
        with_sourcemap=True,
        pcs_in_sourcemap=True,
        annotate_teal=True,
        annotate_teal_headers=True,
        annotate_teal_concise=False,
    )

    EXAMPLES = Path.cwd() / "examples" / "signature"

    with open(EXAMPLES / "dutch_auction.teal", "w") as f:
        f.write(results.teal)

    with open(EXAMPLES / "dutch_auction_annotated.teal", "w") as f:
        assert isinstance(results.sourcemap, PyTealSourceMap)
        assert isinstance(results.sourcemap.annotated_teal, str)
        f.write(results.sourcemap.annotated_teal)



================================================
FILE: examples/signature/dutch_auction.teal
================================================
#pragma version 2
global GroupSize
int 5
==
bnz main_l6
global GroupSize
int 4
==
bnz main_l5
global GroupSize
int 1
==
bnz main_l4
err
main_l4:
txn RekeyTo
global ZeroAddress
==
txn FirstValid
int TMPL_START_ROUND
int TMPL_WRAPUP_ROUND
+
>=
&&
txn TypeEnum
int pay
==
txn Amount
int 0
==
&&
txn CloseRemainderTo
addr TMPL_RECEIVER
==
&&
txn TypeEnum
int axfer
==
txn AssetAmount
int 0
==
&&
txn AssetCloseTo
addr TMPL_RECEIVER
==
&&
txn XferAsset
int TMPL_ASSET_A
==
&&
||
&&
b main_l7
main_l5:
gtxn 0 RekeyTo
global ZeroAddress
==
gtxn 1 RekeyTo
global ZeroAddress
==
&&
gtxn 2 RekeyTo
global ZeroAddress
==
&&
gtxn 3 RekeyTo
global ZeroAddress
==
&&
gtxn 0 FirstValid
gtxn 1 FirstValid
==
&&
gtxn 1 FirstValid
gtxn 2 FirstValid
==
&&
gtxn 2 FirstValid
gtxn 3 FirstValid
==
&&
gtxn 3 FirstValid
int TMPL_REDEEM_ROUND
>=
&&
gtxn 0 TypeEnum
int axfer
==
&&
gtxn 0 XferAsset
int TMPL_ASSET_B
==
&&
gtxn 1 TypeEnum
int axfer
==
&&
gtxn 1 XferAsset
int TMPL_ASSET_A
==
&&
gtxn 2 TypeEnum
int axfer
==
&&
gtxn 2 XferAsset
int TMPL_ASSET_C
==
&&
gtxn 2 AssetAmount
int TMPL_REDEEM_ROUND
int TMPL_N
*
int TMPL_PRICE_INCREMENT
*
==
&&
gtxn 3 TypeEnum
int pay
==
&&
gtxn 3 Amount
gtxn 1 Fee
gtxn 2 Fee
+
==
&&
gtxn 1 AssetAmount
gtxn 0 AssetAmount
int TMPL_START_PRICE
int TMPL_PRICE_INCREMENT
arg 0
btoi
*
-
*
==
&&
gtxn 0 Sender
gtxn 1 Receiver
==
&&
gtxn 0 Receiver
gtxn 1 Sender
==
&&
gtxn 1 Sender
gtxn 2 Sender
==
&&
gtxn 2 Sender
gtxn 2 Receiver
==
&&
gtxn 2 Receiver
gtxn 3 Receiver
==
&&
b main_l7
main_l6:
gtxn 0 RekeyTo
global ZeroAddress
==
gtxn 1 RekeyTo
global ZeroAddress
==
&&
gtxn 2 RekeyTo
global ZeroAddress
==
&&
gtxn 3 RekeyTo
global ZeroAddress
==
&&
gtxn 4 RekeyTo
global ZeroAddress
==
&&
gtxn 0 LastValid
gtxn 1 LastValid
==
&&
gtxn 1 LastValid
gtxn 2 LastValid
==
&&
gtxn 2 LastValid
gtxn 3 LastValid
==
&&
gtxn 3 LastValid
gtxn 4 LastValid
==
&&
gtxn 4 LastValid
int TMPL_START_ROUND
gtxn 0 LastValid
int TMPL_START_ROUND
-
int TMPL_PERIOD
/
int TMPL_PERIOD
*
+
<
&&
gtxn 0 TypeEnum
int axfer
==
&&
gtxn 0 XferAsset
int TMPL_ASSET_D
==
&&
gtxn 0 Receiver
addr TMPL_RECEIVER
==
&&
gtxn 1 TypeEnum
int axfer
==
&&
gtxn 1 XferAsset
int TMPL_ASSET_B
==
&&
gtxn 2 TypeEnum
int axfer
==
&&
gtxn 2 XferAsset
int TMPL_ASSET_C
==
&&
gtxn 3 TypeEnum
int axfer
==
&&
gtxn 4 XferAsset
int TMPL_ASSET_C
==
&&
gtxn 4 TypeEnum
int pay
==
&&
gtxn 4 Amount
gtxn 1 Fee
gtxn 2 Fee
+
gtxn 3 Fee
+
==
&&
gtxn 0 AssetAmount
gtxn 1 AssetAmount
==
&&
gtxn 1 AssetAmount
gtxn 2 AssetAmount
==
&&
gtxn 3 AssetAmount
gtxn 0 LastValid
int TMPL_START_ROUND
-
int TMPL_PERIOD
/
int TMPL_N
*
int TMPL_PRICE_INCREMENT
*
==
&&
gtxn 0 Sender
gtxn 1 Receiver
==
&&
gtxn 2 Receiver
addr TMPL_C_ZERO
==
&&
gtxn 1 Sender
gtxn 2 Sender
==
&&
gtxn 2 Sender
gtxn 3 Sender
==
&&
gtxn 3 Sender
gtxn 3 Receiver
==
&&
gtxn 3 Receiver
gtxn 4 Receiver
==
&&
main_l7:
return


================================================
FILE: examples/signature/factorizer_game.py
================================================
# WARNING: this logic sig is for demo purposes only

from pyteal import (
    And,
    Arg,
    Btoi,
    Bytes,
    Expr,
    Global,
    If,
    Int,
    Pop,
    ScratchVar,
    Seq,
    Subroutine,
    TealType,
    Txn,
    TxnType,
)

ONE_ALGO = Int(1_000_000)


@Subroutine(TealType.uint64)
def root_closeness(A, B, C, X):
    left = ScratchVar(TealType.uint64)
    right = ScratchVar(TealType.uint64)
    return Seq(
        left.store(A * X * X + C),
        right.store(B * X),
        If(left.load() < right.load())
        .Then(right.load() - left.load())
        .Else(left.load() - right.load()),
    )


@Subroutine(TealType.uint64)
def calculate_prize(closeness):
    return (
        If(closeness + Int(1) < Int(20))
        .Then(ONE_ALGO * (Int(10) - (closeness + Int(1)) / Int(2)))
        .Else(Int(0))
    )


def logicsig(a: int, p: int, q: int) -> Expr:
    """
    Choices
    * (a, p, q) = (1, 5, 7)
    * compiling on program version 5 and
    * with assembleConstants = True
    results in Logic-Sig Contract Account Address:
    WO3TQD3WBSDKB6WEHUMSEBFH53GZVVXYGPWYDWKUZCKEXTVCDNDHJGG6II
    """
    assert all(
        isinstance(x, int) and p < q and a > 0 and x >= 0 for x in (a, p, q)
    ), f"require non-negative ints a, p, q with p < q but got {a, p, q}"

    b, c = a * (p + q), a * p * q
    msg = Bytes(f"Can you factor {a} * x^2 - {b} * x + {c} ?")

    A, B, C = Int(a), Int(b), Int(c)
    X1 = Btoi(Arg(0))
    X2 = Btoi(Arg(1))
    C1 = ScratchVar(TealType.uint64)
    C2 = ScratchVar(TealType.uint64)
    SUM = ScratchVar(TealType.uint64)
    PRIZE = ScratchVar(TealType.uint64)
    return Seq(
        Pop(msg),
        C1.store(root_closeness(A, B, C, X1)),
        C2.store(root_closeness(A, B, C, X2)),
        SUM.store(C1.load() + C2.load()),
        PRIZE.store(calculate_prize(SUM.load())),
        And(
            Txn.type_enum() == TxnType.Payment,
            Txn.close_remainder_to() == Global.zero_address(),
            X1 != X2,
            PRIZE.load(),
            Txn.amount() == PRIZE.load(),
        ),
    )


def create(a, b, c):
    return logicsig(*map(lambda x: int(x), (a, b, c)))



================================================
FILE: examples/signature/periodic_payment.py
================================================
# This example is provided for informational purposes only and has not been audited for security.

from pyteal import *

"""Periodic Payment"""

tmpl_fee = Int(1000)
tmpl_period = Int(50)
tmpl_dur = Int(5000)
tmpl_lease = Bytes("base64", "023sdDE2")
tmpl_amt = Int(2000)
tmpl_rcv = Addr("6ZHGHH5Z5CTPCF5WCESXMGRSVK7QJETR63M3NY5FJCUYDHO57VTCMJOBGY")
tmpl_timeout = Int(30000)


def periodic_payment(
    tmpl_fee=tmpl_fee,
    tmpl_period=tmpl_period,
    tmpl_dur=tmpl_dur,
    tmpl_lease=tmpl_lease,
    tmpl_amt=tmpl_amt,
    tmpl_rcv=tmpl_rcv,
    tmpl_timeout=tmpl_timeout,
):
    periodic_pay_core = And(
        Txn.type_enum() == TxnType.Payment,
        Txn.fee() < tmpl_fee,
        Txn.first_valid() % tmpl_period == Int(0),
        Txn.last_valid() == tmpl_dur + Txn.first_valid(),
        Txn.lease() == tmpl_lease,
    )

    periodic_pay_transfer = And(
        Txn.close_remainder_to() == Global.zero_address(),
        Txn.rekey_to() == Global.zero_address(),
        Txn.receiver() == tmpl_rcv,
        Txn.amount() == tmpl_amt,
    )

    periodic_pay_close = And(
        Txn.close_remainder_to() == tmpl_rcv,
        Txn.rekey_to() == Global.zero_address(),
        Txn.receiver() == Global.zero_address(),
        Txn.first_valid() == tmpl_timeout,
        Txn.amount() == Int(0),
    )

    periodic_pay_escrow = periodic_pay_core.And(
        periodic_pay_transfer.Or(periodic_pay_close)
    )

    return periodic_pay_escrow


if __name__ == "__main__":
    print(compileTeal(periodic_payment(), mode=Mode.Signature, version=2))



================================================
FILE: examples/signature/periodic_payment.teal
================================================
#pragma version 2
txn TypeEnum
int pay
==
txn Fee
int 1000
<
&&
txn FirstValid
int 50
%
int 0
==
&&
txn LastValid
int 5000
txn FirstValid
+
==
&&
txn Lease
byte base64(023sdDE2)
==
&&
txn CloseRemainderTo
global ZeroAddress
==
txn RekeyTo
global ZeroAddress
==
&&
txn Receiver
addr 6ZHGHH5Z5CTPCF5WCESXMGRSVK7QJETR63M3NY5FJCUYDHO57VTCMJOBGY
==
&&
txn Amount
int 2000
==
&&
txn CloseRemainderTo
addr 6ZHGHH5Z5CTPCF5WCESXMGRSVK7QJETR63M3NY5FJCUYDHO57VTCMJOBGY
==
txn RekeyTo
global ZeroAddress
==
&&
txn Receiver
global ZeroAddress
==
&&
txn FirstValid
int 30000
==
&&
txn Amount
int 0
==
&&
||
&&
return



================================================
FILE: examples/signature/periodic_payment_deploy.py
================================================
#!/usr/bin/env python3

import base64
import params
import uuid

from algosdk import algod, transaction, account, mnemonic
from periodic_payment import periodic_payment

from pyteal import *

# --------- compile & send transaction using Goal and Python SDK ----------

teal_source = compileTeal(periodic_payment(), mode=Mode.Signature, version=2)

# compile teal
teal_file = str(uuid.uuid4()) + ".teal"
with open(teal_file, "w+") as f:
    f.write(teal_source)
lsig_fname = str(uuid.uuid4()) + ".tealc"

stdout, stderr = execute(["goal", "clerk", "compile", "-o", lsig_fname, teal_file])

if stderr != "":
    print(stderr)
    raise
elif len(stdout) < 59:
    print("error in compile teal")
    raise

with open(lsig_fname, "rb") as f:
    teal_bytes = f.read()
lsig = transaction.LogicSig(teal_bytes)

# create algod clients
acl = algod.AlgodClient(params.algod_token, params.algod_address)

# Recover the account that is wanting to delegate signature
passphrase = "patrol crawl rule faculty enemy sick reveal embody trumpet win shy zero ill draw swim excuse tongue under exact baby moral kite spring absent double"
sk = mnemonic.to_private_key(passphrase)
addr = account.address_from_private_key(sk)
print("Dispense at least 201000 microAlgo to {}".format(addr))
input("Make sure you did that. Press Enter to continue...")

# sign the logic signature with an account sk
lsig.sign(sk)

# get suggested parameters
params = acl.suggested_params()
gen = params["genesisID"]
gh = params["genesishashb64"]
startRound = params["lastRound"] - (params["lastRound"] % 1000)
endRound = startRound + 1000
fee = 1000
amount = 200000
receiver = "ZZAF5ARA4MEC5PVDOP64JM5O5MQST63Q2KOY2FLYFLXXD3PFSNJJBYAFZM"
lease = base64.b64decode("y9OJ5MRLCHQj8GqbikAUKMBI7hom+SOj8dlopNdNHXI=")

# create a transaction
txn = transaction.PaymentTxn(
    addr, fee, startRound, endRound, gh, receiver, amount, flat_fee=True, lease=lease
)

# Create the LogicSigTransaction with contract account LogicSig
lstx = transaction.LogicSigTransaction(txn, lsig)

# write to file
txns = [lstx]
transaction.write_to_file(txns, "p_pay.stxn")

# send raw LogicSigTransaction to network
txid = acl.send_transaction(lstx)
print("Transaction ID: " + txid)
# except Exception as e:
#     print(e)

# send raw LogicSigTransaction again to network
txid = acl.send_transaction(lstx)
print("Transaction ID: " + txid)



================================================
FILE: examples/signature/recurring_swap.py
================================================
# This example is provided for informational purposes only and has not been audited for security.

from pyteal import *

""" Recurring Swap

This is a recurring swap contract. This contract can be set as an escrow 
and sending tmpl_amount recurringly to tmpl_provider as long as the transaction is authoried
by the provider.

Use scenarios:
A buyer (an insurer, for example) set up this escrow contract and funded with Algos. 
Whenever a service provider (a hospital, for example) authorize a payment,
it submits a transaction with its signature of first_valid in the arguement and with
the first_valid in the lease to prevent replay attacks.

The hospital may add some extra information about the transaction in the note 
field for audit purpose.

After timeout, the buyer can claw the remaining balance back.
tmpl_buyer: buyer who receives the service
tmpl_provider: provider of the service
tmpl_ppk: public key of the provider
tmpl_amount: the amount of microAlgo charged per service
tmpl_fee: maximum transaction fee allowed
tmpl_timeout: the timeout round, after which the buyer can reclaim her Algos
"""

tmpl_buyer = Addr("6ZHGHH5Z5CTPCF5WCESXMGRSVK7QJETR63M3NY5FJCUYDHO57VTCMJOBGY")
tmpl_provider = Addr("7Z5PWO2C6LFNQFGHWKSK5H47IQP5OJW2M3HA2QPXTY3WTNP5NU2MHBW27M")
tmpl_amount = Int(100000)
tmpl_fee = Int(1000)
tmpl_timeout = Int(100000)


def recurring_swap(
    tmpl_buyer=tmpl_buyer,
    tmpl_provider=tmpl_provider,
    tmpl_amount=tmpl_amount,
    tmpl_fee=tmpl_fee,
    tmpl_timeout=tmpl_timeout,
):
    fee_cond = Txn.fee() <= tmpl_fee
    type_cond = And(Txn.type_enum() == Int(1), Txn.rekey_to() == Global.zero_address())
    recv_cond = And(
        Txn.close_remainder_to() == Global.zero_address(),
        Txn.receiver() == tmpl_provider,
        Txn.amount() == tmpl_amount,
        Ed25519Verify(Itob(Txn.first_valid()), Arg(0), tmpl_provider),
        Txn.lease() == Sha256(Itob(Txn.first_valid())),
    )

    close_cond = And(
        Txn.close_remainder_to() == tmpl_buyer,
        Txn.amount() == Int(0),
        Txn.first_valid() >= tmpl_timeout,
    )

    program = And(fee_cond, type_cond, Or(recv_cond, close_cond))

    return program


if __name__ == "__main__":
    print(compileTeal(recurring_swap(), mode=Mode.Signature, version=2))



================================================
FILE: examples/signature/recurring_swap.teal
================================================
#pragma version 2
txn Fee
int 1000
<=
txn TypeEnum
int 1
==
txn RekeyTo
global ZeroAddress
==
&&
&&
txn CloseRemainderTo
global ZeroAddress
==
txn Receiver
addr 7Z5PWO2C6LFNQFGHWKSK5H47IQP5OJW2M3HA2QPXTY3WTNP5NU2MHBW27M
==
&&
txn Amount
int 100000
==
&&
txn FirstValid
itob
arg 0
addr 7Z5PWO2C6LFNQFGHWKSK5H47IQP5OJW2M3HA2QPXTY3WTNP5NU2MHBW27M
ed25519verify
&&
txn Lease
txn FirstValid
itob
sha256
==
&&
txn CloseRemainderTo
addr 6ZHGHH5Z5CTPCF5WCESXMGRSVK7QJETR63M3NY5FJCUYDHO57VTCMJOBGY
==
txn Amount
int 0
==
&&
txn FirstValid
int 100000
>=
&&
||
&&
return



================================================
FILE: examples/signature/recurring_swap_deploy.py
================================================
#!/usr/bin/env python3

import base64
from nacl import encoding, hash
import re
import subprocess
import time
import uuid

from algosdk import algod
from algosdk.future import transaction

from pyteal import *

from recurring_swap import recurring_swap

algod_address = "http://localhost:4001"
algod_token = "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"


def execute(cmd: list[str]) -> tuple[str, str]:
    print("running: {}".format(" ".join(cmd)))
    p = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    stdout, stderr = p.communicate()
    return stdout.decode("utf-8"), stderr.decode("utf-8")


# ------- generate provider's account -----------------------------------------------
key_fn = str(uuid.uuid4()) + ".key"
execute(["algokey", "generate", "-f", key_fn])
stdout, stderr = execute(["algokey", "export", "-f", key_fn])
print("generated key file {}".format(key_fn))

if stderr != "":
    print(stderr)
    raise

result = re.search(r"key: \w+", stdout)
provider_addr = result.group(0)[5:]
print("provider addr: {}".format(provider_addr))

# ------- instantiate template, compile teal source, get escrow address -------------

program = recurring_swap(tmpl_provider=Addr(provider_addr))
teal_source = compileTeal(program, mode=Mode.Signature, version=2)
print(
    f"""---------- teal source ----------
{teal_source}
---------------------------------"""
)


# compile teal
teal_base = str(uuid.uuid4())
teal_file = teal_base + ".teal"
with open(teal_file, "w+") as f:
    f.write(teal_source)
lsig_fname = teal_base + ".tealc"

stdout, stderr = execute(["goal", "clerk", "compile", "-o", lsig_fname, teal_file])

if stderr != "":
    print(stderr)
    raise
elif len(stdout) < 59:
    print("error in compile teal")
    raise

result = re.search(r": \w+", stdout)
escrow_addr = result.group(0)[2:]
print("Dispense at least 202000 microAlgo to {}".format(escrow_addr))
input("Make sure you did that. Press Enter to continue...")

# now, as a provider, you can withdraw Algo from the escrow if you sign the first valid
acl = algod.AlgodClient(algod_token, algod_address)

sp = acl.suggested_params_as_object()
first_valid = sp.first
data = first_valid.to_bytes(8, byteorder="big")
lease = hash.sha256(data)
lease_bytes = encoding.HexEncoder.decode(lease)
print("first valid: {}".format(first_valid))

txn = transaction.PaymentTxn(escrow_addr, sp, provider_addr, 100000, lease=lease_bytes)

with open(lsig_fname, "rb") as f:
    teal_bytes = f.read()
lsig = transaction.LogicSig(teal_bytes)
lstx = transaction.LogicSigTransaction(txn, lsig)

assert lstx.verify()

# send LogicSigTransaction to network
transaction.write_to_file([lstx], "r_s_1.txn")

stdout, stderr = execute(
    [
        "goal",
        "clerk",
        "tealsign",
        "--data-b64",
        base64.b64encode(data).decode(),
        "--lsig-txn",
        "r_s_1.txn",
        "--keyfile",
        key_fn,
        "--set-lsig-arg-idx",
        "0",
    ]
)
if stderr != "":
    print(stderr)
    raise

print(stdout)

lstx = transaction.retrieve_from_file("r_s_1.txn")
txid = acl.send_transactions(lstx)

print("1st withdraw Succesfull! txid:{}".format(txid))

# at least sleep to the next round
time.sleep(6)

sp = acl.suggested_params_as_object()
first_valid = sp.first
data = first_valid.to_bytes(8, byteorder="big")
lease = hash.sha256(data)
lease_bytes = encoding.HexEncoder.decode(lease)

print("first valid: {}".format(first_valid))

txn = transaction.PaymentTxn(escrow_addr, sp, provider_addr, 100000, lease=lease_bytes)

with open(lsig_fname, "rb") as f:
    teal_bytes = f.read()
lsig = transaction.LogicSig(teal_bytes)
lstx = transaction.LogicSigTransaction(txn, lsig)

assert lstx.verify()

# send LogicSigTransaction to network
transaction.write_to_file([lstx], "r_s_2.txn")

stdout, stderr = execute(
    [
        "goal",
        "clerk",
        "tealsign",
        "--data-b64",
        base64.b64encode(data).decode(),
        "--lsig-txn",
        "r_s_2.txn",
        "--keyfile",
        key_fn,
        "--set-lsig-arg-idx",
        "0",
    ]
)
if stderr != "":
    print(stderr)
    raise

print(stdout)

lstx = transaction.retrieve_from_file("r_s_2.txn")
txid = acl.send_transactions(lstx)
print("2nd withraw Succesfull! txid:{}".format(txid))



================================================
FILE: examples/signature/split.py
================================================
# This example is provided for informational purposes only and has not been audited for security.

from pyteal import *

"""Split Payment"""

tmpl_fee = Int(1000)
tmpl_rcv1 = Addr("6ZHGHH5Z5CTPCF5WCESXMGRSVK7QJETR63M3NY5FJCUYDHO57VTCMJOBGY")
tmpl_rcv2 = Addr("7Z5PWO2C6LFNQFGHWKSK5H47IQP5OJW2M3HA2QPXTY3WTNP5NU2MHBW27M")
tmpl_own = Addr("5MK5NGBRT5RL6IGUSYDIX5P7TNNZKRVXKT6FGVI6UVK6IZAWTYQGE4RZIQ")
tmpl_ratn = Int(1)
tmpl_ratd = Int(3)
tmpl_min_pay = Int(1000)
tmpl_timeout = Int(3000)


def split(
    tmpl_fee=tmpl_fee,
    tmpl_rcv1=tmpl_rcv1,
    tmpl_rcv2=tmpl_rcv2,
    tmpl_own=tmpl_own,
    tmpl_ratn=tmpl_ratn,
    tmpl_ratd=tmpl_ratd,
    tmpl_min_pay=tmpl_min_pay,
    tmpl_timeout=tmpl_timeout,
):
    split_core = And(
        Txn.type_enum() == TxnType.Payment,
        Txn.fee() < tmpl_fee,
        Txn.rekey_to() == Global.zero_address(),
    )

    split_transfer = And(
        Gtxn[0].sender() == Gtxn[1].sender(),
        Txn.close_remainder_to() == Global.zero_address(),
        Gtxn[0].receiver() == tmpl_rcv1,
        Gtxn[1].receiver() == tmpl_rcv2,
        Gtxn[0].amount()
        == ((Gtxn[0].amount() + Gtxn[1].amount()) * tmpl_ratn) / tmpl_ratd,
        Gtxn[0].amount() == tmpl_min_pay,
    )

    split_close = And(
        Txn.close_remainder_to() == tmpl_own,
        Txn.receiver() == Global.zero_address(),
        Txn.amount() == Int(0),
        Txn.first_valid() > tmpl_timeout,
    )

    split_program = And(
        split_core, If(Global.group_size() == Int(2), split_transfer, split_close)
    )

    return split_program


if __name__ == "__main__":
    print(compileTeal(split(), mode=Mode.Signature, version=2))



================================================
FILE: examples/signature/split.teal
================================================
#pragma version 2
txn TypeEnum
int pay
==
txn Fee
int 1000
<
&&
txn RekeyTo
global ZeroAddress
==
&&
global GroupSize
int 2
==
bnz main_l2
txn CloseRemainderTo
addr 5MK5NGBRT5RL6IGUSYDIX5P7TNNZKRVXKT6FGVI6UVK6IZAWTYQGE4RZIQ
==
txn Receiver
global ZeroAddress
==
&&
txn Amount
int 0
==
&&
txn FirstValid
int 3000
>
&&
b main_l3
main_l2:
gtxn 0 Sender
gtxn 1 Sender
==
txn CloseRemainderTo
global ZeroAddress
==
&&
gtxn 0 Receiver
addr 6ZHGHH5Z5CTPCF5WCESXMGRSVK7QJETR63M3NY5FJCUYDHO57VTCMJOBGY
==
&&
gtxn 1 Receiver
addr 7Z5PWO2C6LFNQFGHWKSK5H47IQP5OJW2M3HA2QPXTY3WTNP5NU2MHBW27M
==
&&
gtxn 0 Amount
gtxn 0 Amount
gtxn 1 Amount
+
int 1
*
int 3
/
==
&&
gtxn 0 Amount
int 1000
==
&&
main_l3:
&&
return


================================================
FILE: feature_gates/__init__.py
================================================
from dataclasses import dataclass
from typing import Final


@dataclass
class _FeatureGatesConfig:
    """
    Configuration for feature gates.

    We follow the following convention:

    feature_property: True/False
    """

    sourcemap_enabled: bool
    sourcemap_debug: bool


class FeatureGates:
    """
    Feature gates work as follows:
    1. Add a new feature gate to the _FeatureGatesConfig dataclass
    2. Set the default value for the feature gate in the _gates field below

    Automagically, a new setter and getter will be available for the feature gate.
    For example, given feature `foo_on` by adding _FeatureGatesConfig.foo_on,
    the following methods will be available:
    * FeatureGates.foo_on() -> bool
    * FeatureGates.set_foo_on(gate: bool)
    """

    # default values for feature gates:
    _gates: _FeatureGatesConfig = _FeatureGatesConfig(
        sourcemap_enabled=False,
        sourcemap_debug=False,
    )
    _features: Final[set[str]] = set(vars(_gates).keys())

    @classmethod
    def _make_feature(cls, feature: str):
        setattr(cls, feature, classmethod(lambda cls: cls.get(feature)))
        setattr(
            cls, f"set_{feature}", classmethod(lambda cls, gate: cls.set(feature, gate))
        )

    @classmethod
    def get(cls, feature: str) -> bool | None:
        if feature not in cls._features:
            raise ValueError(
                f"Unknown {feature=} (available features: {cls._features}))"
            )

        return getattr(cls._gates, feature)

    @classmethod
    def set(cls, feature: str, gate: bool) -> None:
        if feature not in cls._features:
            raise ValueError(
                f"Cannot set unknown {feature=} (available features: {cls._features}))"
            )
        setattr(cls._gates, feature, gate)


for feature in FeatureGates._features:
    FeatureGates._make_feature(feature)



================================================
FILE: pyteal/__init__.py
================================================
from pyteal.ast import *
from pyteal.ast import __all__ as ast_all
from pyteal.compiler import (
    DEFAULT_PROGRAM_VERSION,
    DEFAULT_TEAL_VERSION,
    MAX_PROGRAM_VERSION,
    MAX_TEAL_VERSION,
    MIN_PROGRAM_VERSION,
    MIN_TEAL_VERSION,
    Compilation,
    CompileOptions,
    CompileResults,
    OptimizeOptions,
    PyTealSourceMap,
    R3SourceMap,
    compileTeal,
)
from pyteal.config import (
    MAX_GROUP_SIZE,
    METHOD_ARG_NUM_CUTOFF,
    NUM_SLOTS,
    RETURN_HASH_PREFIX,
)
from pyteal.errors import (
    AlgodClientError,
    SourceMapDisabledError,
    TealCompileError,
    TealInputError,
    TealInternalError,
    TealPragmaError,
    TealSeqError,
    TealTypeError,
)
from pyteal.ir import *
from pyteal.ir import __all__ as ir_all
from pyteal.pragma import pragma
from pyteal.types import TealType

# begin __all__
__all__ = (
    ast_all
    + ir_all
    + [
        "AlgodClientError",
        "Compilation",
        "CompileOptions",
        "CompileResults",
        "compileTeal",
        "DEFAULT_PROGRAM_VERSION",
        "DEFAULT_TEAL_VERSION",
        "MAX_GROUP_SIZE",
        "MAX_PROGRAM_VERSION",
        "MAX_TEAL_VERSION",
        "METHOD_ARG_NUM_CUTOFF",
        "MIN_PROGRAM_VERSION",
        "MIN_TEAL_VERSION",
        "NUM_SLOTS",
        "OptimizeOptions",
        "pragma",
        "PyTealSourceMap",
        "R3SourceMap",
        "RETURN_HASH_PREFIX",
        "SourceMapDisabledError",
        "TealCompileError",
        "TealInputError",
        "TealInternalError",
        "TealPragmaError",
        "TealSeqError",
        "TealType",
        "TealTypeError",
    ]
)
# end __all__



================================================
FILE: pyteal/__init__.pyi
================================================
## File generated from scripts/generate_init.py.
## DO NOT EDIT DIRECTLY

from pyteal.ast import *
from pyteal.ast import __all__ as ast_all
from pyteal.compiler import (
    DEFAULT_PROGRAM_VERSION,
    DEFAULT_TEAL_VERSION,
    MAX_PROGRAM_VERSION,
    MAX_TEAL_VERSION,
    MIN_PROGRAM_VERSION,
    MIN_TEAL_VERSION,
    Compilation,
    CompileOptions,
    CompileResults,
    OptimizeOptions,
    PyTealSourceMap,
    R3SourceMap,
    compileTeal,
)
from pyteal.config import (
    MAX_GROUP_SIZE,
    METHOD_ARG_NUM_CUTOFF,
    NUM_SLOTS,
    RETURN_HASH_PREFIX,
)
from pyteal.errors import (
    AlgodClientError,
    SourceMapDisabledError,
    TealCompileError,
    TealInputError,
    TealInternalError,
    TealPragmaError,
    TealSeqError,
    TealTypeError,
)
from pyteal.ir import *
from pyteal.ir import __all__ as ir_all
from pyteal.pragma import pragma
from pyteal.types import TealType

__all__ = [
    "ABIReturnSubroutine",
    "AccountParam",
    "AccountParamObject",
    "Add",
    "Addr",
    "AlgodClientError",
    "And",
    "App",
    "AppField",
    "AppParam",
    "AppParamObject",
    "Approve",
    "Arg",
    "Array",
    "Assert",
    "AssetHolding",
    "AssetHoldingObject",
    "AssetParam",
    "AssetParamObject",
    "Balance",
    "BareCallActions",
    "Base64Decode",
    "BinaryExpr",
    "BitLen",
    "BitwiseAnd",
    "BitwiseNot",
    "BitwiseOr",
    "BitwiseXor",
    "Block",
    "BoxCreate",
    "BoxDelete",
    "BoxExtract",
    "BoxGet",
    "BoxLen",
    "BoxPut",
    "BoxReplace",
    "BoxResize",
    "BoxSplice",
    "Break",
    "Btoi",
    "Bytes",
    "BytesAdd",
    "BytesAnd",
    "BytesDiv",
    "BytesEq",
    "BytesGe",
    "BytesGt",
    "BytesLe",
    "BytesLt",
    "BytesMinus",
    "BytesMod",
    "BytesMul",
    "BytesNeq",
    "BytesNot",
    "BytesOr",
    "BytesSqrt",
    "BytesXor",
    "BytesZero",
    "CallConfig",
    "Comment",
    "Compilation",
    "CompileOptions",
    "CompileResults",
    "Concat",
    "Cond",
    "Continue",
    "DEFAULT_PROGRAM_VERSION",
    "DEFAULT_TEAL_VERSION",
    "Div",
    "Divw",
    "DynamicScratchVar",
    "EcAdd",
    "EcMapTo",
    "EcMultiScalarMul",
    "EcPairingCheck",
    "EcScalarMul",
    "EcSubgroupCheck",
    "EcdsaCurve",
    "EcdsaDecompress",
    "EcdsaRecover",
    "EcdsaVerify",
    "Ed25519Verify",
    "Ed25519Verify_Bare",
    "EllipticCurve",
    "EnumInt",
    "Eq",
    "Err",
    "Exp",
    "Expr",
    "Extract",
    "ExtractUint16",
    "ExtractUint32",
    "ExtractUint64",
    "For",
    "Ge",
    "GeneratedID",
    "GetBit",
    "GetByte",
    "Gitxn",
    "GitxnExpr",
    "GitxnaExpr",
    "Global",
    "GlobalField",
    "Gt",
    "Gtxn",
    "GtxnExpr",
    "GtxnaExpr",
    "If",
    "ImportScratchValue",
    "InnerTxn",
    "InnerTxnAction",
    "InnerTxnBuilder",
    "InnerTxnGroup",
    "Int",
    "Itob",
    "JsonRef",
    "Keccak256",
    "LabelReference",
    "Le",
    "LeafExpr",
    "Len",
    "Log",
    "Lt",
    "MAX_GROUP_SIZE",
    "MAX_PROGRAM_VERSION",
    "MAX_TEAL_VERSION",
    "METHOD_ARG_NUM_CUTOFF",
    "MIN_PROGRAM_VERSION",
    "MIN_TEAL_VERSION",
    "MaybeValue",
    "MethodConfig",
    "MethodSignature",
    "MiMC",
    "MinBalance",
    "Minus",
    "Mod",
    "Mode",
    "Mul",
    "MultiValue",
    "NUM_SLOTS",
    "NaryExpr",
    "Neq",
    "Nonce",
    "Not",
    "OnComplete",
    "OnCompleteAction",
    "OnlineStake",
    "Op",
    "OpUp",
    "OpUpFeeSource",
    "OpUpMode",
    "OptimizeOptions",
    "Or",
    "Pop",
    "Pragma",
    "PyTealSourceMap",
    "R3SourceMap",
    "RETURN_HASH_PREFIX",
    "Reject",
    "Replace",
    "Return",
    "Router",
    "RouterResults",
    "ScratchIndex",
    "ScratchLoad",
    "ScratchSlot",
    "ScratchStackStore",
    "ScratchStore",
    "ScratchVar",
    "Seq",
    "SetBit",
    "SetByte",
    "Sha256",
    "Sha3_256",
    "Sha512_256",
    "ShiftLeft",
    "ShiftRight",
    "SourceMapDisabledError",
    "Sqrt",
    "Subroutine",
    "SubroutineCall",
    "SubroutineDeclaration",
    "SubroutineDefinition",
    "SubroutineFnWrapper",
    "Substring",
    "Suffix",
    "TealBlock",
    "TealCompileError",
    "TealComponent",
    "TealConditionalBlock",
    "TealInputError",
    "TealInternalError",
    "TealLabel",
    "TealOp",
    "TealPragma",
    "TealPragmaError",
    "TealSeqError",
    "TealSimpleBlock",
    "TealType",
    "TealTypeError",
    "Tmpl",
    "Txn",
    "TxnArray",
    "TxnExpr",
    "TxnField",
    "TxnGroup",
    "TxnObject",
    "TxnType",
    "TxnaExpr",
    "UnaryExpr",
    "VoterParam",
    "VoterParamObject",
    "VrfVerify",
    "While",
    "WideRatio",
    "abi",
    "compileTeal",
    "pragma",
]



================================================
FILE: pyteal/config.py
================================================
from algosdk.atomic_transaction_composer import ABI_RETURN_HASH


# Maximum size of an atomic transaction group.
MAX_GROUP_SIZE = 16

# Number of scratch space slots available.
NUM_SLOTS = 256

# Method return selector in base16
RETURN_HASH_PREFIX = ABI_RETURN_HASH

# Method argument number limit
METHOD_ARG_NUM_CUTOFF = 15



================================================
FILE: pyteal/errors.py
================================================
from typing import Any, Optional, TYPE_CHECKING

if TYPE_CHECKING:
    from pyteal.ast import Expr


class TealInternalError(Exception):
    def __init__(self, message: str) -> None:
        self.message = message

    def __str__(self):
        return self.message


TealInternalError.__module__ = "pyteal"


class TealTypeError(Exception):
    def __init__(self, actual, expected) -> None:
        self.message = "{} while expected {} ".format(actual, expected)

    def __str__(self) -> str:
        return self.message


TealTypeError.__module__ = "pyteal"


class TealSeqError(TealTypeError):
    def __init__(self, message: str) -> None:
        self.message = message

    def __str__(self):
        return self.message


TealSeqError.__module__ = "pyteal"


class TealInputError(Exception):
    def __init__(self, msg: str) -> None:
        self.message = msg

    def __str__(self) -> str:
        return self.message

    def __eq__(self, other: Any) -> bool:
        return type(other) is TealInputError and self.message == other.message


TealInputError.__module__ = "pyteal"


class TealCompileError(Exception):
    def __init__(self, msg: str, sourceExpr: Optional["Expr"]) -> None:
        self.msg = msg
        self.sourceExpr = sourceExpr

    def __str__(self) -> str:
        if self.sourceExpr is None:
            return self.msg
        trace = self.sourceExpr.getDefinitionTrace()
        return (
            self.msg
            + "\nTraceback of origin expression (most recent call last):\n"
            + "".join(trace)
        )

    def __eq__(self, other) -> bool:
        if not isinstance(other, TealCompileError):
            return False
        return self.msg == other.msg and self.sourceExpr is other.sourceExpr


TealCompileError.__module__ = "pyteal"


class TealPragmaError(Exception):
    def __init__(self, message: str) -> None:
        self.message = message

    def __str__(self):
        return self.message


TealPragmaError.__module__ = "pyteal"


class AlgodClientError(Exception):
    def __init__(self, message: str) -> None:
        self.message = message

    def __str__(self):
        return self.message


AlgodClientError.__module__ = "pyteal"


class SourceMapDisabledError(RuntimeError):
    msg = (
        value
    ) = """
    Cannot calculate Teal to PyTeal source map because stack frame discovery is turned off.

    To enable source maps: import `from feature_gates import FeatureGates` and call `FeatureGates.set_sourcemap_enabled(True)`.
    """

    def __str__(self):
        return self.msg


SourceMapDisabledError.__module__ = "pyteal"


def verifyProgramVersion(minVersion: int, version: int, msg: str):
    if minVersion > version:
        msg = "{}. Minimum version needed is {}, but current version being compiled is {}".format(
            msg, minVersion, version
        )
        raise TealInputError(msg)


def verifyFieldVersion(fieldName: str, fieldMinVersion: int, version: int):
    verifyProgramVersion(
        fieldMinVersion,
        version,
        "Program version too low to use field {}".format(fieldName),
    )



================================================
FILE: pyteal/py.typed
================================================
[Empty file]


================================================
FILE: pyteal/stack_frame.py
================================================
from feature_gates import FeatureGates

from ast import AST, FunctionDef, unparse
from contextlib import contextmanager
from dataclasses import dataclass
from enum import IntEnum
from inspect import FrameInfo, stack
from typing import Callable, Final, cast
import os
import re

from executing import Source


class SourceMapStackFramesError(RuntimeError):
    def __init__(self, msg: str):
        self.msg = msg

    def __str__(self):
        return self.msg


@dataclass(frozen=True)
class StackFrame:
    """
    StackFrame is an _internal_ PyTeal class and is
    the first ancestor in the following linear class hierarchy:
                        StackFrame
                            |
                        PyTealFrame
                            |
    compiler.sourcemap.TealMapItem

    Somewhat confusingly, NatalStackFrame is _NOT_ in this hierarchy
    so not "is-a" StackFrame, but it pretends to be and "has-a" list of StackFrame's.

    Its most important members are:
        * frame_info of type inspect.FrameInfo
        * node of type ast.AST
    The first is a python representation of a stack frame, and the
    second represents a python AST node. The imported package `executing`
    features the method `Source.executing` which when run shortly after
    the frame_info's creation, _usually_ succeeds in recovering the
    associated AST node.

    In the current usage, there is a `creator` member which is a `NatalStackFrame`
    object -usually belonging to a PyTeal Expr- and which is assumed to have called
    the private constructor `_init_or_drop()`.

    It is not recommended that this class be accessed directly.

    Of special note, is the class variable `_internal_paths`.
    This is a whitelist of file patterns which signal to the logic
    of method `_frame_info_is_pyteal()` that a particular
    frame was _NOT_ created by the user.

    QUIRKS:
    * Unfortunately, this means that if a user created file satisfies the above pattern,
    the performance of the source mapper will degrade.
    * User generated code that includes the pattern `NatalStackFrame` may produce degraded results
    """

    frame_info: FrameInfo
    node: AST | None
    creator: "NatalStackFrame"

    # for debugging purposes:
    full_stack: list[FrameInfo] | None = None

    @classmethod
    def _init_or_drop(
        cls, creator: "NatalStackFrame", f: FrameInfo, full_stack: list[FrameInfo]
    ) -> "StackFrame | None":
        """
        Attempt to create a StackFrame object.
        However, if the resulting is considered "Python Crud" abandon and return None.
        When debugging, also persist the full_stack that was provided.
        """
        node = cast(AST | None, Source.executing(f.frame).node)
        frame = StackFrame(
            f, node, creator, full_stack if NatalStackFrame._debugging() else None
        )
        return frame if frame._not_py_crud() else None

    # TODO: when a source mapper is instantiated, it ought to survey
    # the user's project files and warn in the case that some file
    # matches the _internal_paths pattern
    _internal_paths = [
        "beaker/__init__.py",
        "beaker/application.py",
        "beaker/consts.py",
        "beaker/decorators.py",
        "beaker/state.py",
        "pyteal/__init__.py",
        "pyteal/ast",
        "pyteal/compiler",
        "pyteal/ir",
        "pyteal/pragma",
        "pyteal/stack_frame.py",
        "tests/abi_roundtrip.py",
        "tests/blackbox.py",
        "tests/compile_asserts.py",
        "tests/mock_version.py",
    ]
    _internal_paths_re = re.compile("|".join(_internal_paths))

    def as_pyteal_frame(self) -> "PyTealFrame":
        """
        Downcast one level in the class hierarchy
        """
        return PyTealFrame(
            frame_info=self.frame_info,
            node=self.node,
            creator=self.creator,
            full_stack=self.full_stack,
            rel_paths=True,
            parent=None,
        )

    @classmethod
    def _frame_info_is_right_before_core(cls, f: FrameInfo) -> bool:
        # We keep this method around to be used in a test . Originally,
        # it was actually used in the __init__ method of StackFrame
        # to calculate `last_drop_idx`. However, as -at the time of writing-
        # last_drop_idx =ALWAYS= 1, the logic was simplified and
        # this method was removed from the live calculation.
        return bool(code := f.code_context or []) and "NatalStackFrame" in "".join(code)

    def _is_pyteal(self) -> bool:
        return self._frame_info_is_pyteal(self.frame_info)

    @classmethod
    def _frame_info_is_pyteal(cls, f: FrameInfo) -> bool:
        return bool(cls._internal_paths_re.search(f.filename))

    @classmethod
    def _frame_info_is_pyteal_import(cls, f: FrameInfo) -> bool:
        """
        This method is used to determine if a FrameInfo is associated to a pyteal import.
        It does so by splitting its joined code context on whitespace and periods.
        For example, the following joined code context
            'from pyteal.ast.abi import Uint64 as Positive'
        becomes
            ['from', 'pyteal', 'ast', 'abi', 'import', 'Uint64', 'as', 'Positive']
        and we can verify that this is a pyteal import by checking that
        'pyteal' and 'import' are both in the list.
        This works for other imports such as
            'import pyteal.ast.abi as my_abi'
            'import pyteal as pt'
            'from pyteal import *'
        """
        cc = f.code_context
        if not cc:
            return False

        code = re.split(r"\s|\.", " ".join(cc))
        return "import" in code and "pyteal" in code

    def _not_py_crud(self) -> bool:
        return self._frame_info_not_py_crud(self.frame_info)

    @classmethod
    def _frame_info_not_py_crud(cls, f: FrameInfo) -> bool:
        return bool(f.code_context) or not f.filename.startswith("<")

    def __repr__(self) -> str:
        node = unparse(n) if (n := self.node) else None
        context = "".join(cc) if (cc := (fi := self.frame_info).code_context) else None
        return f"{node=}; {context=}; frame_info={fi}"

    def compiler_generated(self) -> bool | None:
        return self._frame_info_compiler_generated(self.frame_info)

    @classmethod
    def _frame_info_compiler_generated(cls, f: FrameInfo) -> bool | None:
        if not (cc := f.code_context):
            return None  # we don't know / NA

        return "# T2PT" in "".join(cc)

    _compilation_gateways = {
        "_compile_impl": "pyteal/compiler/compiler.py",
        "_build_program": "pyteal/ast/router.py",
    }

    @classmethod
    def _is_compilation_gateway(cls, f: FrameInfo) -> bool:
        return (k := f.function) in cls._compilation_gateways and f.filename.endswith(
            cls._compilation_gateways[k]
        )


@contextmanager
def sourcemapping_off_context():
    """Context manager that turns off sourcemapping for the duration of the context"""
    from feature_gates import FeatureGates

    _sourcemap_before = FeatureGates.sourcemap_enabled()
    _sourcemap_debug_before = FeatureGates.sourcemap_debug()
    FeatureGates.set_sourcemap_enabled(False)
    FeatureGates.set_sourcemap_debug(False)
    assert (
        NatalStackFrame.sourcemapping_is_off()
    ), "Unexpected error. Please report to PyTeal team."
    assert (
        not NatalStackFrame._debugging()
    ), "Unexpected error. Please report to PyTeal team."

    try:
        yield

    finally:
        FeatureGates.set_sourcemap_debug(_sourcemap_debug_before)
        FeatureGates.set_sourcemap_enabled(_sourcemap_before)
        assert (
            NatalStackFrame.sourcemapping_is_off() is not _sourcemap_before
        ), "Unexpected error. Please report to PyTeal team."
        assert (
            NatalStackFrame._debugging() is _sourcemap_debug_before
        ), "Unexpected error. Please report to PyTeal team."


class NatalStackFrame:
    """
    PyTeal's source mapper deduces the code-location of a user's Expr
    via a NatalStackFrame object that is associated with the Expr object.

    When source mapping is disabled (cf. `pyteal.ini`), NatalStackFrame'
    constructor is a no-op.

    When source mapping is enabled, it wraps a list of StackFrame's.

    Under normal operations, only the "best" frame is kept in the list, so
    the name is misleading.
    """

    _keep_all_debugging = False

    @staticmethod
    def sourcemapping_is_off() -> bool:
        return not FeatureGates.sourcemap_enabled()  # type: ignore[attr-defined]

    @staticmethod
    def _debugging() -> bool:
        return FeatureGates.sourcemap_debug()  # type: ignore[attr-defined]

    def __init__(
        self,
    ):
        self._pyteal_gen: bool = False
        self._frames: list[StackFrame] = []

        if self.sourcemapping_is_off():
            return

        # 1. get the full stack trace
        full_stack = stack()

        # 2. discard frames whose filename begins with "<"
        frame_infos = list(filter(StackFrame._frame_info_not_py_crud, full_stack))

        def _make_stack_frames(fis):
            return [
                frame
                for f in fis
                if (frame := StackFrame._init_or_drop(self, f, full_stack))
            ]

        if self._keep_all_debugging or len(frame_infos) <= 1:
            self._frames = _make_stack_frames(frame_infos)
            return

        # 3. start the best frame search right after where NatalStackFrame() was constructed
        # For more details see the unit test:
        # tests/unit/sourcemap_monkey_unit_test.py::test_frame_info_is_right_before_core_last_drop_idx
        i = 2  # formerly this was `last_drop_idx = 1; i = last_drop_idx + 1`

        # 4. fast forward the right bound until we're out of pyteal-library code
        # This sets last_keep_idx to the first frame index which isn't pyteal
        while i < len(frame_infos) and StackFrame._frame_info_is_pyteal(frame_infos[i]):
            i += 1
        last_keep_idx = i

        # 5. back up looking for a compiler gateway and so signal that the expression was generated by pyteal itself
        for i in range(last_keep_idx, -1, -1):
            if StackFrame._is_compilation_gateway(frame_infos[i]):
                self._pyteal_gen = True
                break

        # 6. if the pyteal-library exit point was an import, the expression was
        # generated by pyteal itself. So let's back up and look for a "# T2PT*" comment
        # which will give us a clue for what to do with this expression
        if StackFrame._frame_info_is_pyteal_import(frame_infos[last_keep_idx]):
            found = False
            i = -1
            for i in range(last_keep_idx - 1, -1, -1):
                if StackFrame._frame_info_compiler_generated(frame_infos[i]):
                    found = True
                    break

            if found and i >= 0:
                last_keep_idx = i

        # 7. Keep only the last frame in the list. We maintain _as_ a list
        # since in the case of `self._debug == True`, we'd like access to the full list.
        # TODO: this is likely obsolete since full_stack is available on the PyTealFrame object when debugging
        frame_infos = frame_infos[last_keep_idx : last_keep_idx + 1]

        # 8. we finish by constructing a list[StackFrame] from our one remaining frame_info
        self._frames = _make_stack_frames(frame_infos)

    def user_defined(self) -> bool:
        return not self._pyteal_gen

    def __len__(self) -> int:
        return len(self._frames)

    def _best_frame(self) -> StackFrame:
        """
        Return the best guess as to the user-authored birthplace of the associated StackFrame's.
        If self._frames is non-empty return the last frame in the stack trace.
        Otherwise, raise a SourceMapStackFramesError.
        """
        if not self._frames:
            raise SourceMapStackFramesError(
                f"expected to have some frames but currently {self._frames=}"
            )

        return self._frames[-1]

    def _best_frame_as_pyteal_frame(self) -> "PyTealFrame | None":
        """
        Return the best frame converted to a PyTealFrame, or None if there was an error.
        """
        try:
            return self._best_frame().as_pyteal_frame()
        except SourceMapStackFramesError as smsfe:
            print(
                f"""-------------------
WARNING: Error retrieving the best frame for source mapping.
This may occur because FeatureGates was imported and `FeatureGates.set_sourcemap_enabled(True)` called _AFTER_ pyteal was imported.
error: {smsfe}
"""
            )
        return None

    def __repr__(self) -> str:
        return f"NatalStackFrame({self._frames=})"

    def nodes(self) -> list[AST | None]:
        return [f.node for f in self._frames]

    @classmethod
    def _walk_asts(
        cls,
        func: "Callable[[Expr], bool]",  # type: ignore[name-defined]
        *exprs: "Expr",  # type: ignore[name-defined]
        skipping: bool = False,
    ) -> None:
        """
        General purpose, recursive Expr-AST visitor that applies logic to each visited Expr.

        When skipping is False, apply `func` to each Expr and recurse to its children
            as defined by the pattern-match.

        When skipping is True:
            * if the Expr is user defined, skip it and its children.
            * if not user defined, apply `func` to the Expr. Based on the output of `func`:
                * if True, skip the Expr and its children.
                * if False, visit the Expr's children as defined by the pattern-match.

        Args:
            func: the vistor function to apply.
            *exprs: Expr's to recursively visit.
            skipping: see the logic above.
        """
        from pyteal.ast import (
            Assert,
            BinaryExpr,
            Cond,
            Expr,
            Int,
            MethodSignature,
            Return,
            ScratchStackStore,
            ScratchStore,
            Seq,
            SubroutineCall,
            SubroutineDeclaration,
            TxnaExpr,
            UnaryExpr,
        )

        from pyteal.ast.frame import Proto
        from pyteal.ast.return_ import ExitProgram

        for e in exprs:
            expr = cast(Expr, e)

            if skipping:
                if e.stack_frames.user_defined() or func(expr):
                    continue
            else:
                func(expr)

            walker_args: list[Expr] = []
            match expr:
                case Assert():
                    walker_args = expr.cond
                case BinaryExpr():
                    walker_args = [expr.argLeft, expr.argRight]
                case Cond():
                    walker_args = [y for x in expr.args for y in x]
                case ExitProgram():
                    walker_args = [expr.success]
                case Proto():
                    walker_args = [expr.mem_layout]
                case Seq():
                    walker_args = cast(list[Expr], expr.args)
                case Return():
                    if expr.value:
                        walker_args = [expr.value]
                case SubroutineDeclaration():
                    walker_args = [expr.body]
                case ScratchStore():
                    walker_args = [expr.value]
                    if expr.index_expression:
                        walker_args.append(expr.index_expression)
                case SubroutineCall():
                    subdef = expr.subroutine.get_declaration_by_option(False)
                    if subdef:
                        walker_args.append(subdef)
                    subdef = expr.subroutine.get_declaration_by_option(True)
                    if subdef:
                        walker_args.append(subdef)
                case UnaryExpr():
                    walker_args = [expr.arg]
                case Int(), MethodSignature(), ScratchStackStore(), TxnaExpr():
                    pass
                case _:
                    pass

            if walker_args:
                cls._walk_asts(func, *walker_args, skipping=skipping)

    @classmethod
    def _debug_asts(cls, *exprs: "Expr") -> None:  # type: ignore
        """
        For deubgging purposes only!
        """
        from pyteal.ast import Expr

        if cls.sourcemapping_is_off():
            return

        def dbg(e: Expr) -> bool:
            try:
                finfo = e.stack_frames._best_frame().as_pyteal_frame().hybrid_unparsed()
            except SourceMapStackFramesError as smsfe:
                finfo = str(smsfe)
            print(type(e), ": ", finfo)
            return False

        cls._walk_asts(dbg, *exprs)

    def reframe(self, *exprs: "Expr") -> None:  # type: ignore
        """
        Re-frame the given ASTs to this NatalStackFrame.
        """
        self._reframe_asts(self, *exprs)

    @classmethod
    def _reframe_asts(cls, stack_frames: "NatalStackFrame", *exprs: "Expr") -> None:  # type: ignore
        """
        Recursively traverse a PyTeal AST starting from the given Exprs
        and re-frame each Expr to the given `stack_frames` object.
        Exit the traversal when we encounter a user-defined Expr or when we encounter an Expr
        that has already been re-framed. By exiting when a re-frame would have occured, we
        avoid an infinite loop.
        """
        from pyteal.ast import Expr

        if cls.sourcemapping_is_off():
            return

        def set_frames(e: Expr) -> bool:
            if e.stack_frames == stack_frames:
                return True
            e.stack_frames = stack_frames
            return False

        cls._walk_asts(set_frames, *exprs, skipping=True)

    @classmethod
    def reframe_ops_in_blocks(cls, root_expr: "Expr", start: "TealBlock") -> None:  # type: ignore
        start._sframes_container = root_expr
        for op in start.ops:
            op._sframes_container = root_expr

        if nxt := start.nextBlock:
            cls.reframe_ops_in_blocks(root_expr, nxt)


class PT_GENERATED:
    PRAGMA = "PyTeal generated pragma"
    SUBR_LABEL = "PyTeal generated subroutine label"
    RETURN_NONE = "PyTeal generated return for TealType.none"
    RETURN_VALUE = "PyTeal generated return for non-null TealType"
    SUBR_PARAM = "PyTeal generated subroutine parameter handler instruction"
    BRANCH = "PyTeal generated branching"
    BRANCH_LABEL = "PyTeal generated branching label"
    TYPE_ENUM_TXN = "PyTeal generated transaction Type Enum"
    TYPE_ENUM_ONCOMPLETE = "PyTeal generated OnComplete Type Enum"


_PT_GEN = {
    "# T2PT0": PT_GENERATED.PRAGMA,
    "# T2PT1": PT_GENERATED.SUBR_LABEL,
    "# T2PT2": PT_GENERATED.RETURN_NONE,
    "# T2PT3": PT_GENERATED.RETURN_VALUE,
    "# T2PT4": PT_GENERATED.SUBR_PARAM,
    "# T2PT5": PT_GENERATED.BRANCH,
    "# T2PT6": PT_GENERATED.BRANCH_LABEL,
    "# T2PT7": PT_GENERATED.TYPE_ENUM_TXN,
    "# T2PT8": PT_GENERATED.TYPE_ENUM_ONCOMPLETE,
}


class PyTealFrameStatus(IntEnum):
    """integer values indicate 'confidence' on a scale of 0 - 10"""

    MISSING = 0
    MISSING_AST = 1
    MISSING_CODE = 2
    PYTEAL_GENERATED = 3
    PATCHED_BY_PREV_OVERRIDE_NEXT = 4
    PATCHED_BY_NEXT_OVERRIDE_PREV = 5
    PATCHED_BY_PREV = 6
    PATCHED_BY_NEXT = 7
    PATCHED_BY_PREV_AND_NEXT = 8
    COPACETIC = 9  # currently, 90% confident is as good as it gets

    def human(self) -> str:
        match self:
            case self.MISSING:
                return "sourcemapping line: total failure"
            case self.MISSING_AST:
                return "unreliable as missing AST"
            case self.MISSING_CODE:
                return "unreliable as couldn't retrieve source"
            case self.PYTEAL_GENERATED:
                return "INCOMPLETE"  # "incomplete as source not user generated"
            case self.PATCHED_BY_PREV_OVERRIDE_NEXT:
                return "previously INCOMPLETE- patched to previous frame (ambiguous)"
            case self.PATCHED_BY_NEXT_OVERRIDE_PREV:
                return "previously INCOMPLETE- patched to next frame (ambiguous)"
            case self.PATCHED_BY_PREV:
                return "previously INCOMPLETE- patched to previous frame"
            case self.PATCHED_BY_NEXT:
                return "previously INCOMPLETE- patched to next frame"
            case self.PATCHED_BY_PREV_AND_NEXT:
                return "previously INCOMPLETE- patched"
            case self.COPACETIC:
                return "COPACETIC"

        raise Exception(f"unrecognized {type(self)} - THIS SHOULD NEVER HAPPEN!")


class PyTealFrame(StackFrame):
    """
    PyTealFrame is the middle generation in the StackFrame class hierarchy.

    It adds a richer and more polished set of methods to learn about the PyTeal source.
    """

    def __init__(
        self,
        frame_info: FrameInfo,
        node: AST | None,
        creator: NatalStackFrame,
        full_stack: list[FrameInfo] | None,
        rel_paths: bool = True,
        parent: "PyTealFrame | None" = None,
    ):
        super().__init__(frame_info, node, creator, full_stack)
        self.rel_paths: Final[bool] = rel_paths
        self.parent: "Final[PyTealFrame | None]" = parent

        self._raw_code: str | None = None
        self._status: PyTealFrameStatus | None = None
        self._file: str | None = None
        self._root: str | None = None

    def __repr__(self) -> str:
        """
        This repr isn't compliant, but keeping as it's useful for debugging in VSCode
        """
        return self._str_impl(verbose=False)

    def __eq__(self, other: object) -> bool:
        """We don't care about parents here. TODO: this comment is too rude"""
        if not isinstance(other, PyTealFrame):
            return False

        return all(
            [
                self.frame_info == other.frame_info,
                self.node == other.node,
                self.rel_paths == other.rel_paths,
            ]
        )

    def clone(self, status: PyTealFrameStatus) -> "PyTealFrame":
        ptf = PyTealFrame(
            frame_info=self.frame_info,
            node=self.node,
            creator=self.creator,
            full_stack=self.full_stack,
            rel_paths=self.rel_paths,
        )
        ptf._status = status

        return ptf

    def location(self) -> str:
        return f"{self.file()}:{self.lineno()}" if self.frame_info else ""

    def file(self) -> str:
        if self._file is None:
            if not self.frame_info:
                self._file = ""
            else:
                path = self.frame_info.filename
                self._file = os.path.relpath(path) if self.rel_paths else path

        return self._file

    def root(self) -> str:
        if self._root is None:
            self._root = os.getcwd()

        return self._root

    def code_qualname(self) -> str:
        return (
            Source.executing(self.frame_info.frame).code_qualname()
            if self.frame_info
            else ""
        )

    def lineno(self) -> int | None:
        naive_lineno = self.frame_info.lineno if self.frame_info else None
        if naive_lineno is None:
            return naive_lineno

        hybrid_line, offset = self._hybrid_w_offset()
        if hybrid_line.startswith(self.raw_code()):
            return naive_lineno

        return naive_lineno + offset

    def column(self) -> int:
        """Provide accurate 0-indexed column offset when available. Or 0 when not."""
        return self.node_col_offset() or 0

    def compiler_generated_reason(self) -> str | None:
        """
        None indicates either "unkown" or "not compiler generated".
        To distinguish between these two usages, call `compiler_generated()` first.
        """
        if not self.compiler_generated():
            return None

        for k, v in _PT_GEN.items():
            if k in self.raw_code():
                return v

        raise AssertionError(
            "This should never happen as the call to self.compiler_generated() should have prevented this case."
        )

    # VARIATIONS ON THE THEME OF SOURCE CODE:

    def raw_code(self) -> str:
        if self._raw_code is None:
            self._raw_code = (
                ("".join(self.frame_info.code_context)).strip()
                if self.frame_info and self.frame_info.code_context
                else ""
            )

        return self._raw_code

    def hybrid_unparsed(self) -> str:
        """
        Attempt to unparse the node and return the most apropos line
        """
        return self._hybrid_w_offset()[0]

    def _hybrid_w_offset(self) -> tuple[str, int]:
        """
        Attempt to unparse the node and return the most apropos line,
        together with its offset in comparison with its raw code.
        """
        raw_code = self.raw_code()
        node = self.node
        pt_chunk = self.node_source()
        return self._hybrid_impl(raw_code, node, pt_chunk)

    @classmethod
    def _hybrid_impl(
        cls, code: str, node: AST | None, pt_chunk: str
    ) -> tuple[str, int]:
        """
        Given a chunk of PyTeal `pt_chunk` represending a node's source,
        and `code` representing a FrameInfo's code_context,
        return information about the most appropriate code to use in
        the source map.
        When the node source isn't available, return `code`
        and an offset of 0.
        When the node source is a single line, return `pt_chunk`
        and an offset of 0.
        When the node source is a multi-line chunk, in the case of
        a non-FunctionDef node, we assume that the offset is 0.
        Finally, in the case of a FunctionDef node, find the offset
        by finding where the prefix `def` appears in the chunk.
        """
        if pt_chunk:
            pt_lines = pt_chunk.splitlines()
            if len(pt_lines) == 1:
                return pt_chunk, 0

            offset = i = 0
            if pt_lines and isinstance(node, FunctionDef):
                code_idx = -1
                for i, line in enumerate(pt_lines):
                    if line.startswith(code):
                        code_idx = i
                    if line.startswith("def"):
                        if code_idx >= 0:
                            offset = i - code_idx
                        return pt_lines[i], offset
                if code_idx >= 0:
                    return pt_lines[code_idx], 0

        return code, 0

    # END OF VARIATIONS ON A THEME OF CODE
    def failed_ast(self) -> bool:
        return not self.node

    def status_code(self) -> PyTealFrameStatus:
        if self._status is not None:
            return self._status

        if self.frame_info is None:
            return PyTealFrameStatus.MISSING

        if self.node is None:
            return PyTealFrameStatus.MISSING_AST

        if self.compiler_generated():
            return PyTealFrameStatus.PYTEAL_GENERATED

        if not self.raw_code():
            return PyTealFrameStatus.MISSING_CODE

        return PyTealFrameStatus.COPACETIC

    def status(self) -> str:
        return self.status_code().human()

    def node_source(self) -> str:
        return unparse(self.node) if self.node else ""

    def node_lineno(self) -> int | None:
        return getattr(self.node, "lineno", None) if self.node else None

    def node_col_offset(self) -> int | None:
        """0-indexed BEGINNING column offset"""
        return getattr(self.node, "col_offset", None) if self.node else None

    def node_end_lineno(self) -> int | None:
        return getattr(self.node, "end_lineno", None) if self.node else None

    def node_end_col_offset(self) -> int | None:
        """0-indexed ENDING column offset"""
        return getattr(self.node, "end_col_offset", None) if self.node else None

    def node_source_window(self) -> str:
        boundaries = (
            self.node_lineno(),
            self.node_col_offset(),
            self.node_end_lineno(),
            self.node_end_col_offset(),
        )
        if not all(b is not None for b in boundaries):
            return ""
        return "L{}:{}-L{}:{}".format(*boundaries)

    def __str__(self) -> str:
        return self._str_impl(verbose=True)

    def _str_impl(self, verbose: bool = True) -> str:
        if not self.frame_info:
            return "None"

        spaces = "\n\t\t\t"
        short = f"<{self.raw_code()}>{spaces}@{self.location()}"
        if not verbose:
            return short

        return f"""{short}
{self.frame_info.index=}
{self.frame_info.function=}
{self.frame_info.frame=}"""



================================================
FILE: pyteal/stack_frame_test.py
================================================
from copy import deepcopy
from unittest.mock import Mock, patch

import pytest

from pyteal.stack_frame import NatalStackFrame, PyTealFrame, StackFrame


@pytest.mark.serial
def test_is_pyteal():
    FrameInfo = Mock()
    FrameInfo.return_value = Mock()

    FrameInfo.return_value.filename = "not_pyteal.py"
    sf = StackFrame(FrameInfo(), None, NatalStackFrame())
    assert not sf._is_pyteal()

    FrameInfo.return_value.filename = "blahblah/pyteal/ir/blah"
    sf = StackFrame(FrameInfo(), None, NatalStackFrame())
    assert sf._is_pyteal()

    FrameInfo.return_value.filename = "blahblah/pyteal/not_really..."
    sf = StackFrame(FrameInfo(), None, NatalStackFrame())
    assert not sf._is_pyteal()


@pytest.mark.serial
def test_frame_info_is_pyteal_import_and_is_pyteal_static_and_is_user_gen():
    FrameInfo = Mock()
    FrameInfo.return_value = Mock()

    nsf = NatalStackFrame()
    nsf._frames = []

    def mock_nsf(fi):
        ret_nsf = deepcopy(nsf)
        ret_nsf._frames = [StackFrame(fi, None, ret_nsf)]
        return ret_nsf

    FrameInfo.return_value.code_context = ["something random"]
    assert not StackFrame._frame_info_is_pyteal_import(fi := FrameInfo())
    # assert not mock_nsf(fi).is_pyteal_static()

    FrameInfo.return_value.code_context = ["from pyteal import something"]
    assert StackFrame._frame_info_is_pyteal_import(fi := FrameInfo())
    # assert mock_nsf(fi).is_pyteal_static()

    FrameInfo.return_value.code_context = [
        "from pyteal import something, something_else"
    ]
    assert StackFrame._frame_info_is_pyteal_import(fi := FrameInfo())
    # assert mock_nsf(fi).is_pyteal_static()

    FrameInfo.return_value.code_context = [
        "from pyteal.something import something_else"
    ]
    assert StackFrame._frame_info_is_pyteal_import(fi := FrameInfo())
    # assert mock_nsf(fi).is_pyteal_static()

    FrameInfo.return_value.code_context = ["import pyteal.something"]
    assert StackFrame._frame_info_is_pyteal_import(fi := FrameInfo())
    # assert mock_nsf(fi).is_pyteal_static()

    FrameInfo.return_value.code_context = ["import pyteal as pt"]
    assert StackFrame._frame_info_is_pyteal_import(fi := FrameInfo())
    # assert mock_nsf(fi).is_pyteal_static()

    FrameInfo.return_value.code_context = ["foo = pyteal.Expr()"]
    assert not StackFrame._frame_info_is_pyteal_import(fi := FrameInfo())
    # assert not mock_nsf(fi).is_pyteal_static()

    FrameInfo.return_value.code_context = [
        "from pyteal import (",
        "    something",
        "    something_else",
        ")",
    ]
    assert StackFrame._frame_info_is_pyteal_import(fi := FrameInfo())  # noqa: F841
    # assert mock_nsf(fi).is_pyteal_static()


def test_not_py_crud():
    # testing StackFrame._is_py_crud:
    FrameInfo = Mock()
    FrameInfo.return_value = Mock()

    FrameInfo.return_value.code_context = ["something random"]
    FrameInfo.return_value.filename = "not_pycrud.py"
    assert StackFrame._frame_info_not_py_crud(FrameInfo())

    FrameInfo.return_value.code_context = []
    FrameInfo.return_value.filename = "not_pycrud.py"
    assert StackFrame._frame_info_not_py_crud(FrameInfo())

    FrameInfo.return_value.code_context = ["something random"]
    FrameInfo.return_value.filename = "<pycrud.py>"
    assert StackFrame._frame_info_not_py_crud(FrameInfo())

    FrameInfo.return_value.code_context = []
    FrameInfo.return_value.filename = "<pycrud.py>"
    assert not StackFrame._frame_info_not_py_crud(FrameInfo())

    FrameInfo.return_value.code_context = None
    FrameInfo.return_value.filename = "<pycrud.py>"
    assert not StackFrame._frame_info_not_py_crud(FrameInfo())


@pytest.mark.serial
def test_file():
    FrameInfo = Mock()
    FrameInfo.return_value = Mock()

    FrameInfo.return_value.filename = "not_pyteal.py"
    ptf = PyTealFrame(FrameInfo(), None, NatalStackFrame(), None)
    assert ptf._file is None
    assert ptf.file() == "not_pyteal.py"
    assert ptf._file == "not_pyteal.py"

    from_root = "/Users/AMAZINGalgodev/github/algorand/beaker/beaker/"
    FrameInfo.return_value.filename = from_root + "client/application_client.py"
    ptf = PyTealFrame(FrameInfo(), None, NatalStackFrame(), None)
    assert ptf._file is None
    ending = (
        "../AMAZINGalgodev/github/algorand/beaker/beaker/client/application_client.py"
    )
    assert ptf.file().endswith(ending)
    assert ptf._file == ptf.file()

    with patch("os.path.relpath", return_value="FOOFOO"):
        FrameInfo.return_value.filename = from_root + "client/application_client.py"
        ptf = PyTealFrame(FrameInfo(), None, NatalStackFrame(), None)
        assert ptf._file is None
        assert ptf.file() == "FOOFOO"
        assert ptf._file == "FOOFOO"


@pytest.mark.serial
def test_root():
    FrameInfo = Mock()
    FrameInfo.return_value = Mock()
    ptf = PyTealFrame(FrameInfo(), None, NatalStackFrame(), None)

    assert ptf._root is None
    with patch("os.getcwd", return_value="FOOFOO"):
        assert ptf.root() == "FOOFOO"
        assert ptf._root == "FOOFOO"



================================================
FILE: pyteal/types.py
================================================
import re
from enum import Enum
from typing import Any

from pyteal.errors import TealTypeError, TealInputError


class TealType(Enum):
    """Teal type enum."""

    """Unsigned 64 bit integer type."""
    uint64 = 0

    """Byte string type."""
    bytes = 1

    """Any type that is not none."""
    anytype = 2

    """Represents no value."""
    none = 3


TealType.__module__ = "pyteal"


def require_type(input: Any, expected: TealType):
    try:
        actual = input.type_of()
    except AttributeError:
        raise TypeError(f"Expected a {expected} object, but got a {type(input)}")

    if actual != expected and (
        expected == TealType.none
        or actual == TealType.none
        or (actual != TealType.anytype and expected != TealType.anytype)
    ):
        raise TealTypeError(actual, expected)


def types_match(type1: TealType, type2: TealType) -> bool:
    if (type1 == TealType.none or type2 == TealType.none) and type1 != type2:
        return False

    if type1 == TealType.anytype or type2 == TealType.anytype:
        return True

    return type1 == type2


def valid_address(address: str):
    """check if address is a valid address with checksum"""
    if type(address) is not str:
        raise TealInputError("An address needs to be a string")

    if len(address) != 58:
        raise TealInputError(
            "Address length is not correct. Should "
            + "be a base 32 string encoded 32 bytes public key + 4 bytes checksum"
        )

    valid_base32(address)


def valid_base32(s: str):
    """check if s is a valid base32 encoding string"""
    pattern = re.compile(
        r"^(?:[A-Z2-7]{8})*(?:([A-Z2-7]{2}([=]{6})?)|([A-Z2-7]{4}([=]{4})?)|([A-Z2-7]{5}([=]{3})?)|([A-Z2-7]{7}([=]{1})?))?"
    )

    if pattern.fullmatch(s) is None:
        raise TealInputError("{} is not a valid RFC 4648 base 32 string".format(s))


def valid_base64(s: str):
    """check if s is a valid base64 encoding string"""
    pattern = re.compile(
        r"^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$"
    )

    if pattern.fullmatch(s) is None:
        raise TealInputError("{} is not a valid RFC 4648 base 64 string".format(s))


def valid_base16(s: str):
    """check if s is a valid hex encoding string"""
    if len(s) % 2:
        raise TealInputError(
            f"{s} is of odd length, not a valid RFC 4648 base16 string"
        )

    pattern = re.compile(r"[0-9A-Fa-f]*")

    if pattern.fullmatch(s) is None:
        raise TealInputError("{} is not a valid RFC 4648 base 16 string".format(s))


def valid_tmpl(s: str):
    """check if s is valid template name"""
    pattern = re.compile(r"TMPL_[A-Z0-9_]+")

    if pattern.fullmatch(s) is None:
        raise TealInputError("{} is not a valid template variable".format(s))



================================================
FILE: pyteal/types_test.py
================================================
import pytest

import pyteal as pt
from pyteal.types import require_type


def test_require_type():
    require_type(pt.Bytes("str"), pt.TealType.bytes)
    assert True


def test_require_type_invalid():
    with pytest.raises(TypeError):
        pt.App.globalGet(["This is certainly invalid"])



================================================
FILE: pyteal/util.py
================================================
from algosdk.v2client import algod

from pyteal.errors import AlgodClientError, TealInternalError


def algod_with_assertion(
    client: algod.AlgodClient | None = None, msg: str = ""
) -> algod.AlgodClient:
    def wrap(e, msg):
        raise AlgodClientError(f"{msg}: {e}" if msg else str(e))

    if not client:
        try:
            client = _algod_client()
        except Exception as e:
            wrap(e, msg)

    assert client
    try:
        if not client.status():
            wrap("algod.status() did not produce any results", msg)

    except Exception as e:
        wrap(e, msg)

    return client


def _algod_client(
    algod_address="http://localhost:4001", algod_token="a" * 64
) -> algod.AlgodClient:
    """Instantiate and return Algod client object."""
    return algod.AlgodClient(algod_token, algod_address)


def escapeStr(s: str) -> str:
    """Escape a UTF-8 string for use in TEAL assembly.

    Args:
        s: A UTF-8 string to escape.

    Returns:
        An escaped version of the input string. This version will be surrounded in double quotes,
        all special characters (such as \\n) will be escaped with additional backslashes, and all
        Unicode characters beyond the latin-1 encoding will be encoded in hex escapes (e.g. \\xf0).
    """
    # The point of this conversion is to escape all special characters and turn all Unicode
    # characters into hex-escaped characters in the input string.
    #
    # The first step breaks up large Unicode characters into multiple UTF-8 hex characters:
    #     s_1 = s.encode("utf-8").decode("latin-1"), e.g. "\n 😀" => "\n ð\x9f\x98\x80"
    #
    # The next step escapes all special characters:
    #     s_1.encode("unicode-escape").decode("latin-1"), e.g. "\n ð\x9f\x98\x80" => "\\n \\xf0\\x9f\\x98\\x80"
    #
    # If we skipped the first step we would end up with Unicode codepoints instead of hex escaped
    # characters, which TEAL assembly cannot process:
    #     s.encode("unicode-escape").decode("latin-1"), e.g. "\n 😀" => "\\n \\U0001f600'"
    s = s.encode("utf-8").decode("latin-1").encode("unicode-escape").decode("latin-1")

    # Escape double quote characters (not covered by unicode-escape) but leave in single quotes
    s = s.replace('"', '\\"')

    # Surround string in double quotes
    return '"' + s + '"'


def unescapeStr(s: str) -> str:
    if len(s) < 2 or s[0] != '"' or s[-1] != '"':
        raise ValueError("Escaped string if of the wrong format")
    s = s[1:-1]
    s = s.replace('\\"', '"')
    s = s.encode("latin-1").decode("unicode-escape").encode("latin-1").decode("utf-8")
    return s


def correctBase32Padding(s: str) -> str:
    content = s.split("=")[0]
    trailing = len(content) % 8

    if trailing == 2:
        content += "=" * 6
    elif trailing == 4:
        content += "=" * 4
    elif trailing == 5:
        content += "=" * 3
    elif trailing == 7:
        content += "="
    elif trailing != 0:
        raise TealInternalError("Invalid base32 content")

    return content



================================================
FILE: pyteal/ast/__init__.py
================================================
# abstract types
from pyteal.ast.expr import Expr

# basic types
from pyteal.ast.leafexpr import LeafExpr
from pyteal.ast.addr import Addr
from pyteal.ast.bytes import Bytes
from pyteal.ast.int import Int, EnumInt
from pyteal.ast.methodsig import MethodSignature

# properties
from pyteal.ast.arg import Arg
from pyteal.ast.txn import (
    TxnType,
    TxnField,
    TxnExpr,
    TxnaExpr,
    TxnArray,
    TxnObject,
    Txn,
)
from pyteal.ast.gtxn import GtxnExpr, GtxnaExpr, TxnGroup, Gtxn
from pyteal.ast.block import Block
from pyteal.ast.gaid import GeneratedID
from pyteal.ast.gitxn import Gitxn, GitxnExpr, GitxnaExpr, InnerTxnGroup
from pyteal.ast.gload import ImportScratchValue
from pyteal.ast.global_ import Global, GlobalField
from pyteal.ast.stake import OnlineStake

from pyteal.ast.app import App, AppField, OnComplete, AppParam, AppParamObject
from pyteal.ast.asset import (
    AssetHolding,
    AssetHoldingObject,
    AssetParam,
    AssetParamObject,
)
from pyteal.ast.acct import AccountParam, AccountParamObject
from pyteal.ast.box import (
    BoxCreate,
    BoxResize,
    BoxDelete,
    BoxExtract,
    BoxReplace,
    BoxSplice,
    BoxLen,
    BoxGet,
    BoxPut,
)
from pyteal.ast.voter import VoterParam, VoterParamObject

# inner txns
from pyteal.ast.itxn import InnerTxnBuilder, InnerTxn, InnerTxnAction

# meta
from pyteal.ast.array import Array
from pyteal.ast.tmpl import Tmpl
from pyteal.ast.nonce import Nonce
from pyteal.ast.pragma import Pragma
from pyteal.ast.comment import Comment

# unary ops
from pyteal.ast.unaryexpr import (
    UnaryExpr,
    Btoi,
    Itob,
    Len,
    BitLen,
    Sha256,
    Sha512_256,
    Sha3_256,
    Keccak256,
    Not,
    BitwiseNot,
    Sqrt,
    Pop,
    Balance,
    MinBalance,
    BytesNot,
    BytesSqrt,
    BytesZero,
    Log,
)

# binary ops
from pyteal.ast.binaryexpr import (
    BinaryExpr,
    Minus,
    Div,
    Mod,
    Exp,
    BitwiseAnd,
    BitwiseOr,
    BitwiseXor,
    ShiftLeft,
    ShiftRight,
    Eq,
    Neq,
    Lt,
    Le,
    Gt,
    Ge,
    GetBit,
    GetByte,
    BytesAdd,
    BytesMinus,
    BytesDiv,
    BytesMul,
    BytesMod,
    BytesAnd,
    BytesOr,
    BytesXor,
    BytesEq,
    BytesNeq,
    BytesLt,
    BytesLe,
    BytesGt,
    BytesGe,
    ExtractUint16,
    ExtractUint32,
    ExtractUint64,
)
from pyteal.ast.base64decode import Base64Decode

# ternary ops
from pyteal.ast.ternaryexpr import (
    Divw,
    Ed25519Verify,
    Ed25519Verify_Bare,
    SetBit,
    SetByte,
)
from pyteal.ast.substring import Substring, Extract, Suffix
from pyteal.ast.replace import Replace
from pyteal.ast.jsonref import JsonRef
from pyteal.ast.mimc import MiMC

# quaternary ops
from pyteal.ast.vrfverify import VrfVerify

# more ops
from pyteal.ast.naryexpr import NaryExpr, Add, And, Mul, Or, Concat
from pyteal.ast.widemath import WideRatio

# control flow
from pyteal.ast.if_ import If
from pyteal.ast.cond import Cond
from pyteal.ast.seq import Seq
from pyteal.ast.assert_ import Assert
from pyteal.ast.err import Err
from pyteal.ast.return_ import Return, Approve, Reject
from pyteal.ast.subroutine import (
    ABIReturnSubroutine,
    Subroutine,
    SubroutineCall,
    SubroutineDeclaration,
    SubroutineDefinition,
    SubroutineFnWrapper,
)
from pyteal.ast.while_ import While
from pyteal.ast.for_ import For
from pyteal.ast.break_ import Break
from pyteal.ast.continue_ import Continue

# misc
from pyteal.ast.scratch import (
    ScratchIndex,
    ScratchLoad,
    ScratchSlot,
    ScratchStackStore,
    ScratchStore,
)
from pyteal.ast.scratchvar import DynamicScratchVar, ScratchVar
from pyteal.ast.maybe import MaybeValue
from pyteal.ast.multi import MultiValue
from pyteal.ast.opup import OpUp, OpUpMode, OpUpFeeSource
from pyteal.ast.ecdsa import EcdsaCurve, EcdsaVerify, EcdsaDecompress, EcdsaRecover
from pyteal.ast.ec import (
    EllipticCurve,
    EcAdd,
    EcScalarMul,
    EcPairingCheck,
    EcMultiScalarMul,
    EcSubgroupCheck,
    EcMapTo,
)
from pyteal.ast.router import (
    BareCallActions,
    CallConfig,
    MethodConfig,
    OnCompleteAction,
    Router,
    RouterResults,
)

# abi
import pyteal.ast.abi as abi  # noqa: I250

__all__ = [
    "abi",
    "ABIReturnSubroutine",
    "AccountParam",
    "AccountParamObject",
    "Add",
    "Addr",
    "And",
    "App",
    "AppField",
    "AppParam",
    "AppParamObject",
    "Approve",
    "Arg",
    "Array",
    "Assert",
    "AssetHolding",
    "AssetHoldingObject",
    "AssetParam",
    "AssetParamObject",
    "Balance",
    "BareCallActions",
    "Base64Decode",
    "BinaryExpr",
    "BitLen",
    "BitwiseAnd",
    "BitwiseNot",
    "BitwiseOr",
    "BitwiseXor",
    "Block",
    "BoxCreate",
    "BoxResize",
    "BoxDelete",
    "BoxExtract",
    "BoxSplice",
    "BoxGet",
    "BoxLen",
    "BoxPut",
    "BoxReplace",
    "Break",
    "Btoi",
    "Bytes",
    "BytesAdd",
    "BytesAnd",
    "BytesDiv",
    "BytesEq",
    "BytesGe",
    "BytesGt",
    "BytesLe",
    "BytesLt",
    "BytesMinus",
    "BytesMod",
    "BytesMul",
    "BytesNeq",
    "BytesNot",
    "BytesOr",
    "BytesSqrt",
    "BytesXor",
    "BytesZero",
    "CallConfig",
    "Comment",
    "Concat",
    "Cond",
    "Continue",
    "Div",
    "Divw",
    "DynamicScratchVar",
    "EcdsaCurve",
    "EcdsaDecompress",
    "EcdsaRecover",
    "EcdsaVerify",
    "Ed25519Verify_Bare",
    "Ed25519Verify",
    "EllipticCurve",
    "EcAdd",
    "EcScalarMul",
    "EcPairingCheck",
    "EcMultiScalarMul",
    "EcSubgroupCheck",
    "EcMapTo",
    "EnumInt",
    "Eq",
    "Err",
    "Exp",
    "Expr",
    "Extract",
    "ExtractUint16",
    "ExtractUint32",
    "ExtractUint64",
    "For",
    "Ge",
    "GeneratedID",
    "GetBit",
    "GetByte",
    "Gitxn",
    "GitxnaExpr",
    "GitxnExpr",
    "Global",
    "GlobalField",
    "Gt",
    "Gtxn",
    "GtxnaExpr",
    "GtxnExpr",
    "If",
    "ImportScratchValue",
    "InnerTxn",
    "InnerTxnAction",
    "InnerTxnBuilder",
    "InnerTxnGroup",
    "Int",
    "Itob",
    "JsonRef",
    "Keccak256",
    "Le",
    "LeafExpr",
    "Len",
    "Log",
    "Lt",
    "MaybeValue",
    "MethodConfig",
    "MethodSignature",
    "MinBalance",
    "Minus",
    "MiMC",
    "Mod",
    "Mul",
    "MultiValue",
    "NaryExpr",
    "Neq",
    "Nonce",
    "Not",
    "OnComplete",
    "OnCompleteAction",
    "OnlineStake",
    "OpUp",
    "OpUpFeeSource",
    "OpUpMode",
    "Or",
    "Pop",
    "Pragma",
    "Reject",
    "Replace",
    "Return",
    "Router",
    "RouterResults",
    "ScratchIndex",
    "ScratchLoad",
    "ScratchSlot",
    "ScratchStackStore",
    "ScratchStore",
    "ScratchVar",
    "Seq",
    "SetBit",
    "SetByte",
    "Sha256",
    "Sha3_256",
    "Sha512_256",
    "ShiftLeft",
    "ShiftRight",
    "Sqrt",
    "Subroutine",
    "SubroutineCall",
    "SubroutineDeclaration",
    "SubroutineDefinition",
    "SubroutineFnWrapper",
    "Substring",
    "Suffix",
    "Tmpl",
    "Txn",
    "TxnaExpr",
    "TxnArray",
    "TxnExpr",
    "TxnField",
    "TxnGroup",
    "TxnObject",
    "TxnType",
    "UnaryExpr",
    "VoterParam",
    "VoterParamObject",
    "VrfVerify",
    "While",
    "WideRatio",
]



================================================
FILE: pyteal/ast/abstractvar.py
================================================
from abc import ABC, abstractmethod
from pyteal.types import TealType
from pyteal.ast.expr import Expr


class AbstractVar(ABC):
    """AbstractVar is an abstract class that captures properties of a variable.

    A variable, on an abstract perspective, has the following properties:

    * Storing: can be stored to a certain position.
    * Loading: can be loaded from a certain position.
    * (Strong) Typed: can indicate its own type.

    ScratchVar and FrameVar inherits from this class, representing the load and storage of value
    against scratch slots or stack based on frame pointer.

    This class is intentionally hidden because it's too basic to directly expose.
    """

    @abstractmethod
    def store(self, value: Expr) -> Expr:
        """Store value in AbstractVar.

        Args:
            value: An expression that represents the value to store.
        """
        pass

    @abstractmethod
    def load(self) -> Expr:
        """Load value from AbstractVar"""
        pass

    @abstractmethod
    def storage_type(self) -> TealType:
        pass


AbstractVar.__module__ = "pyteal"


def alloc_abstract_var(stack_type: TealType) -> AbstractVar:
    """Allocate abstract var over stack, or over scratch.

    This unexported function takes a TealType as value type representation over stack (or scratch),
    and generates an AbstractVar instance.
    It infers the proto currently being used in context of subroutine evaluation,
    and swap to FrameVar to save the use of scratch slots.

    Arg:
        stack_type: TealType that represents stack type.
    """

    from pyteal.ast.scratchvar import ScratchVar
    from pyteal.ast.subroutine import SubroutineEval
    from pyteal.ast.frame import FrameVar, MAX_FRAME_LOCAL_VARS

    if SubroutineEval._current_proto:
        local_types = SubroutineEval._current_proto.mem_layout.local_stack_types

        # NOTE: you can have at most 128 local variables.
        # len(local_types) + 1 computes the resulting length,
        # should be <= 128
        if len(local_types) + 1 <= MAX_FRAME_LOCAL_VARS:
            local_types.append(stack_type)
            return FrameVar(SubroutineEval._current_proto, len(local_types) - 1)

    return ScratchVar(stack_type)



================================================
FILE: pyteal/ast/acct.py
================================================
from enum import Enum
from typing import Final, TYPE_CHECKING
from pyteal.errors import verifyFieldVersion, verifyProgramVersion

from pyteal.types import TealType, require_type
from pyteal.ir import Op
from pyteal.ast.expr import Expr
from pyteal.ast.maybe import MaybeValue

if TYPE_CHECKING:
    from pyteal.compiler import CompileOptions


class AccountParamField(Enum):
    # fmt: off
    #                    id  |         name               |     type    |  min version
    balance               = (0,  "AcctBalance",            TealType.uint64, 6)  # noqa: E221
    min_balance           = (1,  "AcctMinBalance",         TealType.uint64, 6)  # noqa: E221
    auth_addr             = (2,  "AcctAuthAddr",           TealType.bytes,  6)  # noqa: E221
    total_num_uint        = (3,  "AcctTotalNumUint",       TealType.uint64, 8)  # noqa: E221
    total_num_byte_slice  = (4,  "AcctTotalNumByteSlice",  TealType.uint64, 8)  # noqa: E221
    total_extra_app_pages = (5,  "AcctTotalExtraAppPages", TealType.uint64, 8)  # noqa: E221
    total_apps_created    = (6,  "AcctTotalAppsCreated",   TealType.uint64, 8)  # noqa: E221
    total_apps_opted_in   = (7,  "AcctTotalAppsOptedIn",   TealType.uint64, 8)  # noqa: E221
    total_assets_created  = (8,  "AcctTotalAssetsCreated", TealType.uint64, 8)  # noqa: E221
    total_assets          = (9,  "AcctTotalAssets",        TealType.uint64, 8)  # noqa: E221
    total_boxes           = (10, "AcctTotalBoxes",         TealType.uint64, 8)  # noqa: E221
    total_box_bytes       = (11, "AcctTotalBoxBytes",      TealType.uint64, 8)  # noqa: E221
    incentive_eligible    = (12, "AcctIncentiveEligible",  TealType.uint64, 11)  # noqa: E221
    last_proposed         = (13, "AcctLastProposed",       TealType.uint64, 11)  # noqa: E221
    last_heartbeat        = (14, "AcctLastHeartbeat",      TealType.uint64, 11)  # noqa: E221
    # fmt: on

    def __init__(self, id: int, name: str, type: TealType, min_version: int) -> None:
        self.id = id
        self.arg_name = name
        self.type = type
        self.min_version = min_version

    def type_of(self) -> TealType:
        return self.type


AccountParamField.__module__ = "pyteal"


class AccountParam:
    @staticmethod
    def __makeAccountParamExpr(field: AccountParamField, acct: Expr) -> MaybeValue:
        require_type(acct, TealType.anytype)

        def field_and_program_version_check(options: "CompileOptions"):
            verifyProgramVersion(
                minVersion=Op.acct_params_get.min_version,
                version=options.version,
                msg=f"{Op.acct_params_get.value} unavailable",
            )
            verifyFieldVersion(field.arg_name, field.min_version, options.version)

        return MaybeValue(
            Op.acct_params_get,
            field.type_of(),
            immediate_args=[field.arg_name],
            args=[acct],
            compile_check=field_and_program_version_check,
        )

    @classmethod
    def balance(cls, acct: Expr) -> MaybeValue:
        """Get the current balance in microalgos an account.

        Args:
            acct: An index into Txn.accounts that corresponds to the application to check or an address available at runtime.
                May evaluate to uint64 or an address.
        """
        return cls.__makeAccountParamExpr(AccountParamField.balance, acct)

    @classmethod
    def minBalance(cls, acct: Expr) -> MaybeValue:
        """Get the minimum balance in microalgos for an account.

        Args:
            acct: An index into Txn.accounts that corresponds to the application to check or an address available at runtime.
                May evaluate to uint64 or an address.
        """
        return cls.__makeAccountParamExpr(AccountParamField.min_balance, acct)

    @classmethod
    def authAddr(cls, acct: Expr) -> MaybeValue:
        """Get the authorizing address for an account. If the account is not rekeyed, the empty addresss is returned.

        Args:
            acct: An index into Txn.accounts that corresponds to the application to check or an address available at runtime.
                May evaluate to uint64 or an address.
        """
        return cls.__makeAccountParamExpr(AccountParamField.auth_addr, acct)

    @classmethod
    def totalNumUint(cls, acct: Expr) -> MaybeValue:
        """Get the total number of uint64 values allocated by the account in Global and Local States.

        Requires program version 8 or higher.

        Args:
            acct: An index into Txn.accounts that corresponds to the application to check or an address available at runtime.
                May evaluate to uint64 or an address.
        """
        return cls.__makeAccountParamExpr(AccountParamField.total_num_uint, acct)

    @classmethod
    def totalNumByteSlice(cls, acct: Expr) -> MaybeValue:
        """Get the total number of byte array values allocated by the account in Global and Local States.

        Requires program version 8 or higher.

        Args:
            acct: An index into Txn.accounts that corresponds to the application to check or an address available at runtime.
                May evaluate to uint64 or an address.
        """
        return cls.__makeAccountParamExpr(AccountParamField.total_num_byte_slice, acct)

    @classmethod
    def totalExtraAppPages(cls, acct: Expr) -> MaybeValue:
        """Get the number of extra app code pages used by the account.

        Requires program version 8 or higher.

        Args:
            acct: An index into Txn.accounts that corresponds to the application to check or an address available at runtime.
                May evaluate to uint64 or an address.
        """
        return cls.__makeAccountParamExpr(AccountParamField.total_extra_app_pages, acct)

    @classmethod
    def totalAppsCreated(cls, acct: Expr) -> MaybeValue:
        """Get the number of existing apps created by the account.

        Requires program version 8 or higher.

        Args:
            acct: An index into Txn.accounts that corresponds to the application to check or an address available at runtime.
                May evaluate to uint64 or an address.
        """
        return cls.__makeAccountParamExpr(AccountParamField.total_apps_created, acct)

    @classmethod
    def totalAppsOptedIn(cls, acct: Expr) -> MaybeValue:
        """Get the number of apps the account is opted into.

        Requires program version 8 or higher.

        Args:
            acct: An index into Txn.accounts that corresponds to the application to check or an address available at runtime.
                May evaluate to uint64 or an address.
        """
        return cls.__makeAccountParamExpr(AccountParamField.total_apps_opted_in, acct)

    @classmethod
    def totalAssetsCreated(cls, acct: Expr) -> MaybeValue:
        """Get the number of existing ASAs created by the account.

        Requires program version 8 or higher.

        Args:
            acct: An index into Txn.accounts that corresponds to the application to check or an address available at runtime.
                May evaluate to uint64 or an address.
        """
        return cls.__makeAccountParamExpr(AccountParamField.total_assets_created, acct)

    @classmethod
    def totalAssets(cls, acct: Expr) -> MaybeValue:
        """Get the number of ASAs held by the account (including ASAs the account created).

        Requires program version 8 or higher.

        Args:
            acct: An index into Txn.accounts that corresponds to the application to check or an address available at runtime.
                May evaluate to uint64 or an address.
        """
        return cls.__makeAccountParamExpr(AccountParamField.total_assets, acct)

    @classmethod
    def totalBoxes(cls, acct: Expr) -> MaybeValue:
        """Get the number of existing boxes created by the account's app.

        Requires program version 8 or higher.

        Args:
            acct: An index into Txn.accounts that corresponds to the application to check or an address available at runtime.
                May evaluate to uint64 or an address.
        """
        return cls.__makeAccountParamExpr(AccountParamField.total_boxes, acct)

    @classmethod
    def totalBoxBytes(cls, acct: Expr) -> MaybeValue:
        """Get the total number of bytes used by the account's app's box keys and values.

        Requires program version 8 or higher.

        Args:
            acct: An index into Txn.accounts that corresponds to the application to check or an address available at runtime.
                May evaluate to uint64 or an address.
        """
        return cls.__makeAccountParamExpr(AccountParamField.total_box_bytes, acct)

    @classmethod
    def incentiveEligible(cls, acct: Expr) -> MaybeValue:
        """Get account's eligibility status for block incentives.

        Requires program version 11 or higher.

        Args:
            acct: An index into Txn.accounts that corresponds to the application to check or an address available at runtime.
                May evaluate to uint64 or an address.
        """
        return cls.__makeAccountParamExpr(AccountParamField.incentive_eligible, acct)

    @classmethod
    def lastProposed(cls, acct: Expr) -> MaybeValue:
        """Get the last round for which this account proposed the accepted block.

        Requires program version 11 or higher.

        Args:
            acct: An index into Txn.accounts that corresponds to the application to check or an address available at runtime.
                May evaluate to uint64 or an address.
        """
        return cls.__makeAccountParamExpr(AccountParamField.last_proposed, acct)

    @classmethod
    def lastHeartbeat(cls, acct: Expr) -> MaybeValue:
        """Get the highest round for which this account should be considered non-absent for reasons other than proposing.

        Requires program version 11 or higher.

        Args:
            acct: An index into Txn.accounts that corresponds to the application to check or an address available at runtime.
                May evaluate to uint64 or an address.
        """
        return cls.__makeAccountParamExpr(AccountParamField.last_heartbeat, acct)


AccountParam.__module__ = "pyteal"


class AccountParamObject:
    """Represents information about an account"""

    def __init__(self, account: Expr) -> None:
        """Create a new AccountParamObject for the given account.

        Args:
            account: An index into Txn.accounts that corresponds to the application to check or an
                address available at runtime. May evaluate to uint64 or bytes, respectively.
        """
        self._account: Final = account

    def balance(self) -> MaybeValue:
        """Get the current balance in microAlgos for the account"""
        return AccountParam.balance(self._account)

    def min_balance(self) -> MaybeValue:
        """Get the minimum balance in microAlgos for the account."""
        return AccountParam.minBalance(self._account)

    def auth_address(self) -> MaybeValue:
        """Get the authorizing address for the account.

        If the account is not rekeyed, the empty address is returned."""
        return AccountParam.authAddr(self._account)

    def total_num_uint(self) -> MaybeValue:
        """Get the total number of uint64 values allocated by the account in Global and Local States."""
        return AccountParam.totalNumUint(self._account)

    def total_num_byte_slice(self) -> MaybeValue:
        """Get the total number of byte array values allocated by the account in Global and Local States."""
        return AccountParam.totalNumByteSlice(self._account)

    def total_extra_app_pages(self) -> MaybeValue:
        """Get the number of extra app code pages used by the account."""
        return AccountParam.totalExtraAppPages(self._account)

    def total_apps_created(self) -> MaybeValue:
        """Get the number of existing apps created by the account."""
        return AccountParam.totalAppsCreated(self._account)

    def total_apps_opted_in(self) -> MaybeValue:
        """Get the number of apps the account is opted into."""
        return AccountParam.totalAppsOptedIn(self._account)

    def total_assets_created(self) -> MaybeValue:
        """Get the number of existing ASAs created by the account."""
        return AccountParam.totalAssetsCreated(self._account)

    def total_assets(self) -> MaybeValue:
        """Get the number of ASAs held by the account (including ASAs the account created)."""
        return AccountParam.totalAssets(self._account)

    def total_boxes(self) -> MaybeValue:
        """Get the number of existing boxes created by the account's app."""
        return AccountParam.totalBoxes(self._account)

    def total_box_bytes(self) -> MaybeValue:
        """Get the total number of bytes used by the account's app's box keys and values."""
        return AccountParam.totalBoxBytes(self._account)

    def incentive_eligible(self) -> MaybeValue:
        """Get account's eligibility status for block incentives."""
        return AccountParam.incentiveEligible(self._account)

    def last_proposed(self) -> MaybeValue:
        """Get the last round for which this account proposed the accepted block."""
        return AccountParam.lastProposed(self._account)

    def last_heartbeat(self) -> MaybeValue:
        """Get the highest round for which this account should be considered non-absent for reasons other than proposing."""
        return AccountParam.lastHeartbeat(self._account)


AccountParamObject.__module__ = "pyteal"



================================================
FILE: pyteal/ast/acct_test.py
================================================
import pytest

import pyteal as pt
from pyteal.ast.acct import AccountParamField
from pyteal.ast.maybe_test import assert_MaybeValue_equality

avm6Options = pt.CompileOptions(version=6)
avm8Options = pt.CompileOptions(version=8)


@pytest.mark.parametrize(
    "method_name,field_name",
    [
        ("balance", "balance"),
        ("minBalance", "min_balance"),
        ("authAddr", "auth_addr"),
        ("totalNumUint", "total_num_uint"),
        ("totalNumByteSlice", "total_num_byte_slice"),
        ("totalExtraAppPages", "total_extra_app_pages"),
        ("totalAppsCreated", "total_apps_created"),
        ("totalAppsOptedIn", "total_apps_opted_in"),
        ("totalAssetsCreated", "total_assets_created"),
        ("totalAssets", "total_assets"),
        ("totalBoxes", "total_boxes"),
        ("totalBoxBytes", "total_box_bytes"),
        ("incentiveEligible", "incentive_eligible"),
        ("lastProposed", "last_proposed"),
        ("lastHeartbeat", "last_heartbeat"),
    ],
)
class TestAcctParam:
    @staticmethod
    def test_acct_param_fields_valid(method_name, field_name):
        arg = pt.Int(1)
        account_param_method = getattr(pt.AccountParam, method_name)
        expr = account_param_method(arg)
        assert expr.type_of() == pt.TealType.none

        account_param_field = AccountParamField[field_name]
        assert expr.value().type_of() == account_param_field.type_of()

        expected = pt.TealSimpleBlock(
            [
                pt.TealOp(arg, pt.Op.int, 1),
                pt.TealOp(expr, pt.Op.acct_params_get, account_param_field.arg_name),
                pt.TealOp(None, pt.Op.store, expr.slotOk),
                pt.TealOp(None, pt.Op.store, expr.slotValue),
            ]
        )

        supported_options_version = pt.CompileOptions(
            version=account_param_field.min_version
        )
        actual, _ = expr.__teal__(supported_options_version)
        actual.addIncoming()
        actual = pt.TealBlock.NormalizeBlocks(actual)

        with pt.TealComponent.Context.ignoreExprEquality():
            assert actual == expected

    @staticmethod
    def test_acct_param_version_checks(method_name, field_name):
        arg = pt.Int(1)
        account_param_method = getattr(pt.AccountParam, method_name)
        expr = account_param_method(arg)

        account_param_field = AccountParamField[field_name]

        def test_unsupported_version(version: int, match: str | None = None):
            with pytest.raises(pt.TealInputError, match=match):
                unsupported_options_version = pt.CompileOptions(version=version)
                expr.__teal__(unsupported_options_version)

        # Test program and field version checks
        program_unsupported_version = pt.ir.Op.acct_params_get.min_version - 1
        program_error_match = "unavailable"
        test_unsupported_version(program_unsupported_version, program_error_match)

        field_unsupported_version = account_param_field.min_version - 1

        # Since program version dominates, we conditionally check field error message or program error message
        # depending on whether the unsupported field version is less than or equal to the program unsupported
        # version.
        field_error_match = (
            "Program version too low to use field"
            if field_unsupported_version > program_unsupported_version
            else program_error_match
        )
        test_unsupported_version(field_unsupported_version, field_error_match)


def test_AccountParamObject():
    for account in (
        pt.Int(7),
        pt.Addr("QSA6K5MNJPEGO5SDSWXBM3K4UEI3Q2NCPS2OUXVJI5QPCHMVI27MFRSHKI"),
    ):
        obj = pt.AccountParamObject(account)

        assert obj._account is account

        assert_MaybeValue_equality(
            obj.balance(), pt.AccountParam.balance(account), avm6Options
        )
        assert_MaybeValue_equality(
            obj.min_balance(), pt.AccountParam.minBalance(account), avm6Options
        )
        assert_MaybeValue_equality(
            obj.auth_address(), pt.AccountParam.authAddr(account), avm6Options
        )

        assert_MaybeValue_equality(
            obj.total_num_uint(), pt.AccountParam.totalNumUint(account), avm8Options
        )
        assert_MaybeValue_equality(
            obj.total_num_byte_slice(),
            pt.AccountParam.totalNumByteSlice(account),
            avm8Options,
        )
        assert_MaybeValue_equality(
            obj.total_extra_app_pages(),
            pt.AccountParam.totalExtraAppPages(account),
            avm8Options,
        )
        assert_MaybeValue_equality(
            obj.total_apps_created(),
            pt.AccountParam.totalAppsCreated(account),
            avm8Options,
        )
        assert_MaybeValue_equality(
            obj.total_apps_opted_in(),
            pt.AccountParam.totalAppsOptedIn(account),
            avm8Options,
        )
        assert_MaybeValue_equality(
            obj.total_assets_created(),
            pt.AccountParam.totalAssetsCreated(account),
            avm8Options,
        )
        assert_MaybeValue_equality(
            obj.total_assets(), pt.AccountParam.totalAssets(account), avm8Options
        )
        assert_MaybeValue_equality(
            obj.total_boxes(), pt.AccountParam.totalBoxes(account), avm8Options
        )
        assert_MaybeValue_equality(
            obj.total_box_bytes(), pt.AccountParam.totalBoxBytes(account), avm8Options
        )



================================================
FILE: pyteal/ast/addr.py
================================================
from typing import TYPE_CHECKING

from pyteal.types import TealType, valid_address
from pyteal.ir import TealOp, Op, TealBlock
from pyteal.ast.leafexpr import LeafExpr

if TYPE_CHECKING:
    from pyteal.compiler import CompileOptions


class Addr(LeafExpr):
    """An expression that represents an Algorand address."""

    def __init__(self, address: str) -> None:
        """Create a new Addr expression.

        Args:
            address: A string containing a valid base32 Algorand address
        """
        super().__init__()
        valid_address(address)
        self.address = address

    def __teal__(self, options: "CompileOptions"):
        op = TealOp(self, Op.addr, self.address)
        return TealBlock.FromOp(options, op)

    def __str__(self):
        return "(address: {})".format(self.address)

    def type_of(self):
        return TealType.bytes


Addr.__module__ = "pyteal"



================================================
FILE: pyteal/ast/addr_test.py
================================================
import pytest

import pyteal as pt


def test_addr():
    expr = pt.Addr("NJUWK3DJNZTWU2LFNRUW4Z3KNFSWY2LOM5VGSZLMNFXGO2TJMVWGS3THMF")
    assert expr.type_of() == pt.TealType.bytes
    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(
                expr,
                pt.Op.addr,
                "NJUWK3DJNZTWU2LFNRUW4Z3KNFSWY2LOM5VGSZLMNFXGO2TJMVWGS3THMF",
            )
        ]
    )
    actual, _ = expr.__teal__(pt.CompileOptions())
    assert actual == expected


def test_addr_invalid():
    with pytest.raises(pt.TealInputError):
        pt.Addr("NJUWK3DJNZTWU2LFNRUW4Z3KNFSWY2LOM5VGSZLMNFXGO2TJMVWGS3TH")

    with pytest.raises(pt.TealInputError):
        pt.Addr("000000000000000000000000000000000000000000000000000000000")

    with pytest.raises(pt.TealInputError):
        pt.Addr(2)



================================================
FILE: pyteal/ast/app.py
================================================
from typing import TYPE_CHECKING, Final
from enum import Enum
from pyteal.ast.box import (
    BoxCreate,
    BoxResize,
    BoxDelete,
    BoxExtract,
    BoxReplace,
    BoxSplice,
    BoxLen,
    BoxGet,
    BoxPut,
)

from pyteal.types import TealType, require_type
from pyteal.ir import TealOp, Op, TealBlock
from pyteal.ast.leafexpr import LeafExpr
from pyteal.ast.expr import Expr
from pyteal.ast.maybe import MaybeValue
from pyteal.ast.int import EnumInt
from pyteal.ast.global_ import Global

if TYPE_CHECKING:
    from pyteal.compiler import CompileOptions


class OnComplete:
    """An enum of values that :any:`TxnObject.on_completion()` may return."""

    NoOp = EnumInt("NoOp")  # T2PT8
    OptIn = EnumInt("OptIn")  # T2PT8
    CloseOut = EnumInt("CloseOut")  # T2PT8
    ClearState = EnumInt("ClearState")  # T2PT8
    UpdateApplication = EnumInt("UpdateApplication")  # T2PT8
    DeleteApplication = EnumInt("DeleteApplication")  # T2PT8


OnComplete.__module__ = "pyteal"


class AppField(Enum):
    """Enum of app fields used to create :any:`App` objects."""

    optedIn = (Op.app_opted_in, TealType.uint64)
    localGet = (Op.app_local_get, TealType.anytype)
    localGetEx = (Op.app_local_get_ex, TealType.none)
    globalGet = (Op.app_global_get, TealType.anytype)
    globalGetEx = (Op.app_global_get_ex, TealType.none)
    localPut = (Op.app_local_put, TealType.none)
    globalPut = (Op.app_global_put, TealType.none)
    localDel = (Op.app_local_del, TealType.none)
    globalDel = (Op.app_global_del, TealType.none)

    def __init__(self, op: Op, type: TealType) -> None:
        self.op = op
        self.ret_type = type

    def get_op(self) -> Op:
        return self.op

    def type_of(self) -> TealType:
        return self.ret_type


AppField.__module__ = "pyteal"


class App(LeafExpr):
    """An expression related to applications."""

    def __init__(self, field: AppField, args) -> None:
        super().__init__()
        self.field = field
        self.args = args

    def __str__(self):
        ret_str = "({}".format(self.field.get_op())
        for a in self.args:
            ret_str += " " + a.__str__()
        ret_str += ")"
        return ret_str

    def __teal__(self, options: "CompileOptions"):
        return TealBlock.FromOp(options, TealOp(self, self.field.get_op()), *self.args)

    def type_of(self):
        return self.field.type_of()

    @classmethod
    def id(cls) -> Global:
        """Get the ID of the current running application.

        This is the same as :any:`Global.current_application_id()`.
        """
        return Global.current_application_id()

    @classmethod
    def optedIn(cls, account: Expr, app: Expr) -> "App":
        """Check if an account has opted in for an application.

        Args:
            account: An index into Txn.Accounts that corresponds to the account to check,
                must be evaluated to uint64 (or, since v4, an account address that appears in
                Txn.Accounts or is Txn.Sender, must be evaluated to bytes).
            app: An index into Txn.applications that corresponds to the application to read from,
                must be evaluated to uint64 (or, since v4, an application id that appears in
                Txn.applications or is the CurrentApplicationID, must be evaluated to int).
        """
        require_type(account, TealType.anytype)
        require_type(app, TealType.uint64)
        return cls(AppField.optedIn, [account, app])

    @classmethod
    def localGet(cls, account: Expr, key: Expr) -> "App":
        """Read from an account's local state for the current application.

        Args:
            account: An index into Txn.Accounts that corresponds to the account to check,
                must be evaluated to uint64 (or, since v4, an account address that appears in
                Txn.Accounts or is Txn.Sender, must be evaluated to bytes).
            key: The key to read from the account's local state. Must evaluate to bytes.
        """
        require_type(account, TealType.anytype)
        require_type(key, TealType.bytes)
        return cls(AppField.localGet, [account, key])

    @classmethod
    def localGetEx(cls, account: Expr, app: Expr, key: Expr) -> MaybeValue:
        """Read from an account's local state for an application.

        Args:
            account: An index into Txn.Accounts that corresponds to the account to check,
                must be evaluated to uint64 (or, since v4, an account address that appears in
                Txn.Accounts or is Txn.Sender, must be evaluated to bytes).
            app: An index into Txn.applications that corresponds to the application to read from,
                must be evaluated to uint64 (or, since v4, an application id that appears in
                Txn.applications or is the CurrentApplicationID, must be evaluated to int).
            key: The key to read from the account's local state. Must evaluate to bytes.
        """
        require_type(account, TealType.anytype)
        require_type(app, TealType.uint64)
        require_type(key, TealType.bytes)
        return MaybeValue(
            AppField.localGetEx.get_op(), TealType.anytype, args=[account, app, key]
        )

    @classmethod
    def globalGet(cls, key: Expr) -> "App":
        """Read from the global state of the current application.

        Args:
            key: The key to read from the global application state. Must evaluate to bytes.
        """
        require_type(key, TealType.bytes)
        return cls(AppField.globalGet, [key])

    @classmethod
    def globalGetEx(cls, app: Expr, key: Expr) -> MaybeValue:
        """Read from the global state of an application.

        Args:
            app: An index into Txn.applications that corresponds to the application to read from,
                must be evaluated to uint64 (or, since v4, an application id that appears in
                Txn.applications or is the CurrentApplicationID, must be evaluated to uint64).
            key: The key to read from the global application state. Must evaluate to bytes.
        """
        require_type(app, TealType.uint64)
        require_type(key, TealType.bytes)
        return MaybeValue(
            AppField.globalGetEx.get_op(), TealType.anytype, args=[app, key]
        )

    @classmethod
    def localPut(cls, account: Expr, key: Expr, value: Expr) -> "App":
        """Write to an account's local state for the current application.

        Args:
            account: An index into Txn.Accounts that corresponds to the account to check,
                must be evaluated to uint64 (or, since v4, an account address that appears in
                Txn.Accounts or is Txn.Sender, must be evaluated to bytes).
            key: The key to write in the account's local state. Must evaluate to bytes.
            value: The value to write in the account's local state. Can evaluate to any type.
        """
        require_type(account, TealType.anytype)
        require_type(key, TealType.bytes)
        require_type(value, TealType.anytype)
        return cls(AppField.localPut, [account, key, value])

    @classmethod
    def globalPut(cls, key: Expr, value: Expr) -> "App":
        """Write to the global state of the current application.

        Args:
            key: The key to write in the global application state. Must evaluate to bytes.
            value: The value to write in the global application state. Can evaluate to any type.
        """
        require_type(key, TealType.bytes)
        require_type(value, TealType.anytype)
        return cls(AppField.globalPut, [key, value])

    @classmethod
    def localDel(cls, account: Expr, key: Expr) -> "App":
        """Delete a key from an account's local state for the current application.

        Args:
            account: An index into Txn.Accounts that corresponds to the account to check,
                must be evaluated to uint64 (or, since v4, an account address that appears in
                Txn.Accounts or is Txn.Sender, must be evaluated to bytes).
            key: The key to delete from the account's local state. Must evaluate to bytes.
        """
        require_type(account, TealType.anytype)
        require_type(key, TealType.bytes)
        return cls(AppField.localDel, [account, key])

    @classmethod
    def globalDel(cls, key: Expr) -> "App":
        """Delete a key from the global state of the current application.

        Args:
            key: The key to delete from the global application state. Must evaluate to bytes.
        """
        require_type(key, TealType.bytes)
        return cls(AppField.globalDel, [key])

    @classmethod
    def box_create(cls, name: Expr, size: Expr) -> Expr:
        """Create a box with a given name and size.

        New boxes will contain a byte string of all zeros. Performing this operation on a box that
        already exists will not change its contents.

        If successful, this expression returns 0 if the box already existed, otherwise it returns 1.

        A failure will occur if you attempt to create a box that already exists with a different size.

        Args:
            name: The key used to reference this box. Must evaluate to a bytes.
            size: The number of bytes to reserve for this box. Must evaluate to a uint64.
        """
        return BoxCreate(name, size)

    @classmethod
    def box_resize(cls, name: Expr, size: Expr) -> Expr:
        """Resize an existing box.

        If the new size is larger than the old size, zero bytes will be added to the end of the box.
        If the new size is smaller than the old size, the box will be truncated from the end.

        Args:
            name: The key used to reference this box. Must evaluate to a bytes.
            size: The new number of bytes to reserve for this box. Must evaluate to a uint64.
        """
        return BoxResize(name, size)

    @classmethod
    def box_delete(cls, name: Expr) -> Expr:
        """Deletes a box given it's name.

        This expression returns 1 if the box existed, otherwise it returns 0.

        Deleting a nonexistent box is allowed, but has no effect.

        Args:
            name: The key the box was created with. Must evaluate to bytes.
        """
        return BoxDelete(name)

    @classmethod
    def box_extract(cls, name: Expr, start: Expr, length: Expr) -> Expr:
        """Extracts bytes in a box given its name, start index and stop index.

        Args:
            name: The key the box was created with. Must evaluate to bytes.
            start: The byte index into the box to start reading. Must evaluate to uint64.
            length: The byte length into the box from start to stop reading. Must evaluate to uint64.
        """
        return BoxExtract(name, start, length)

    @classmethod
    def box_replace(cls, name: Expr, start: Expr, value: Expr) -> Expr:
        """Replaces bytes in a box given its name, start index, and value.

        Args:
            name: The key the box was created with. Must evaluate to bytes.
            start: The byte index into the box to start writing. Must evaluate to uint64.
            value: The value to start writing at start index. Must evaluate to bytes.
        """
        return BoxReplace(name, start, value)

    @classmethod
    def box_splice(
        cls, name: Expr, start: Expr, length: Expr, new_content: Expr
    ) -> Expr:
        """
        Replaces the range of bytes from `start` through `start + length` with `new_content`.

        Bytes after `start + length` will be shifted to the right.

        Recall that boxes are constant length, and this operation will not change the length of the
        box. Instead content may be adjusted as so:

            * If the length of the new content is less than `length`, the bytes following `start + length` will be shifted to the left, and the end of the box will be padded with zeros.

            * If the length of the new content is greater than `length`, the bytes following `start + length` will be shifted to the right and bytes exceeding the length of the box will be truncated.

        Args:
            name: The name of the box to modify. Must evaluate to bytes.
            start: The byte index into the box to start writing. Must evaluate to uint64.
            length: The length of the bytes to be replaced. Must evaluate to uint64.
            new_content: The new content to write into the box. Must evaluate to bytes.
        """
        return BoxSplice(name, start, length, new_content)

    @classmethod
    def box_length(cls, name: Expr) -> MaybeValue:
        """Get the byte length of the box specified by its name.

        Args:
            name: The key the box was created with. Must evaluate to bytes.
        """
        return BoxLen(name)

    @classmethod
    def box_get(cls, name: Expr) -> MaybeValue:
        """Get the full contents of a box given its name.

        Args:
            name: The key the box was created with. Must evaluate to bytes.
        """
        return BoxGet(name)

    @classmethod
    def box_put(cls, name: Expr, value: Expr) -> Expr:
        """Write all contents to a box given its name.

        Args:
            name: The key the box was created with. Must evaluate to bytes.
            value: The value to write to the box. Must evaluate to bytes.
        """
        return BoxPut(name, value)


App.__module__ = "pyteal"


class AppParam:
    @classmethod
    def approvalProgram(cls, app: Expr) -> MaybeValue:
        """Get the bytecode of Approval Program for the application.

        Args:
            app: An index into Txn.applications that correspond to the application to check.
                Must evaluate to uint64.
        """
        require_type(app, TealType.uint64)
        return MaybeValue(
            Op.app_params_get,
            TealType.bytes,
            immediate_args=["AppApprovalProgram"],
            args=[app],
        )

    @classmethod
    def clearStateProgram(cls, app: Expr) -> MaybeValue:
        """Get the bytecode of Clear State Program for the application.

        Args:
            app: An index into Txn.applications that correspond to the application to check.
                Must evaluate to uint64.
        """
        require_type(app, TealType.uint64)
        return MaybeValue(
            Op.app_params_get,
            TealType.bytes,
            immediate_args=["AppClearStateProgram"],
            args=[app],
        )

    @classmethod
    def globalNumUint(cls, app: Expr) -> MaybeValue:
        """Get the number of uint64 values allowed in Global State for the application.

        Args:
            app: An index into Txn.applications that correspond to the application to check.
                Must evaluate to uint64.
        """
        require_type(app, TealType.uint64)
        return MaybeValue(
            Op.app_params_get,
            TealType.uint64,
            immediate_args=["AppGlobalNumUint"],
            args=[app],
        )

    @classmethod
    def globalNumByteSlice(cls, app: Expr) -> MaybeValue:
        """Get the number of byte array values allowed in Global State for the application.

        Args:
            app: An index into Txn.applications that correspond to the application to check.
                Must evaluate to uint64.
        """
        require_type(app, TealType.uint64)
        return MaybeValue(
            Op.app_params_get,
            TealType.uint64,
            immediate_args=["AppGlobalNumByteSlice"],
            args=[app],
        )

    @classmethod
    def localNumUint(cls, app: Expr) -> MaybeValue:
        """Get the number of uint64 values allowed in Local State for the application.

        Args:
            app: An index into Txn.applications that correspond to the application to check.
                Must evaluate to uint64.
        """
        require_type(app, TealType.uint64)
        return MaybeValue(
            Op.app_params_get,
            TealType.uint64,
            immediate_args=["AppLocalNumUint"],
            args=[app],
        )

    @classmethod
    def localNumByteSlice(cls, app: Expr) -> MaybeValue:
        """Get the number of byte array values allowed in Local State for the application.

        Args:
            app: An index into Txn.applications that correspond to the application to check.
                Must evaluate to uint64.
        """
        require_type(app, TealType.uint64)
        return MaybeValue(
            Op.app_params_get,
            TealType.uint64,
            immediate_args=["AppLocalNumByteSlice"],
            args=[app],
        )

    @classmethod
    def extraProgramPages(cls, app: Expr) -> MaybeValue:
        """Get the number of Extra Program Pages of code space for the application.

        Args:
            app: An index into Txn.applications that correspond to the application to check.
                Must evaluate to uint64.
        """
        require_type(app, TealType.uint64)
        return MaybeValue(
            Op.app_params_get,
            TealType.uint64,
            immediate_args=["AppExtraProgramPages"],
            args=[app],
        )

    @classmethod
    def creator(cls, app: Expr) -> MaybeValue:
        """Get the creator address for the application.

        Args:
            app: An index into Txn.applications that correspond to the application to check.
                Must evaluate to uint64.
        """
        require_type(app, TealType.uint64)
        return MaybeValue(
            Op.app_params_get, TealType.bytes, immediate_args=["AppCreator"], args=[app]
        )

    @classmethod
    def address(cls, app: Expr) -> MaybeValue:
        """Get the escrow address for the application.

        Args:
            app: An index into Txn.applications that correspond to the application to check.
                Must evaluate to uint64.
        """
        require_type(app, TealType.uint64)
        return MaybeValue(
            Op.app_params_get, TealType.bytes, immediate_args=["AppAddress"], args=[app]
        )


AppParam.__module__ = "pyteal"


class AppParamObject:
    """Represents information about an application's parameters"""

    def __init__(self, app: Expr) -> None:
        """Create a new AppParamObject for the given application.

        Args:
            app: An identifier for the app. It must be an index into Txn.ForeignApps that
                corresponds to the app to check, or since v4, an application ID that appears in
                Txn.ForeignApps or is the CurrentApplicationID. In either case, it must evaluate to
                uint64.
        """
        require_type(app, TealType.uint64)
        self._app: Final = app

    def approval_program(self) -> MaybeValue:
        """Get the bytecode of Approval Program for the application."""
        return AppParam.approvalProgram(self._app)

    def clear_state_program(self) -> MaybeValue:
        return AppParam.clearStateProgram(self._app)

    def global_num_uint(self) -> MaybeValue:
        """Get the number of uint64 values allowed in Global State for the application."""
        return AppParam.globalNumUint(self._app)

    def global_num_byte_slice(self) -> MaybeValue:
        """Get the number of byte array values allowed in Global State for the application."""
        return AppParam.globalNumByteSlice(self._app)

    def local_num_uint(self) -> MaybeValue:
        """Get the number of uint64 values allowed in Local State for the application."""
        return AppParam.localNumUint(self._app)

    def local_num_byte_slice(self) -> MaybeValue:
        """Get the number of byte array values allowed in Local State for the application."""
        return AppParam.localNumByteSlice(self._app)

    def extra_program_pages(self) -> MaybeValue:
        """Get the number of Extra Program Pages of code space for the application."""
        return AppParam.extraProgramPages(self._app)

    def creator_address(self) -> MaybeValue:
        """Get the creator address for the application."""
        return AppParam.creator(self._app)

    def address(self) -> MaybeValue:
        """Get the escrow address for the application."""
        return AppParam.address(self._app)


AppParamObject.__module__ = "pyteal"



================================================
FILE: pyteal/ast/app_test.py
================================================
import pytest

import pyteal as pt
from pyteal.ast.maybe_test import assert_MaybeValue_equality

options = pt.CompileOptions()
avm4Options = pt.CompileOptions(version=4)
avm5Options = pt.CompileOptions(version=5)


def test_on_complete():
    assert pt.OnComplete.NoOp.__teal__(options)[0] == pt.TealSimpleBlock(
        [pt.TealOp(pt.OnComplete.NoOp, pt.Op.int, "NoOp")]
    )

    assert pt.OnComplete.OptIn.__teal__(options)[0] == pt.TealSimpleBlock(
        [pt.TealOp(pt.OnComplete.OptIn, pt.Op.int, "OptIn")]
    )

    assert pt.OnComplete.CloseOut.__teal__(options)[0] == pt.TealSimpleBlock(
        [pt.TealOp(pt.OnComplete.CloseOut, pt.Op.int, "CloseOut")]
    )

    assert pt.OnComplete.ClearState.__teal__(options)[0] == pt.TealSimpleBlock(
        [pt.TealOp(pt.OnComplete.ClearState, pt.Op.int, "ClearState")]
    )

    assert pt.OnComplete.UpdateApplication.__teal__(options)[0] == pt.TealSimpleBlock(
        [pt.TealOp(pt.OnComplete.UpdateApplication, pt.Op.int, "UpdateApplication")]
    )

    assert pt.OnComplete.DeleteApplication.__teal__(options)[0] == pt.TealSimpleBlock(
        [pt.TealOp(pt.OnComplete.DeleteApplication, pt.Op.int, "DeleteApplication")]
    )


def test_app_id():
    expr = pt.App.id()
    assert expr.type_of() == pt.TealType.uint64
    with pt.TealComponent.Context.ignoreExprEquality():
        assert (
            expr.__teal__(options)[0]
            == pt.Global.current_application_id().__teal__(options)[0]
        )


def test_opted_in():
    args = [pt.Int(1), pt.Int(12)]
    expr = pt.App.optedIn(args[0], args[1])
    assert expr.type_of() == pt.TealType.uint64

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(args[0], pt.Op.int, 1),
            pt.TealOp(args[1], pt.Op.int, 12),
            pt.TealOp(expr, pt.Op.app_opted_in),
        ]
    )

    actual, _ = expr.__teal__(options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    assert actual == expected


def test_opted_in_direct_ref():
    args = [pt.Bytes("sender address"), pt.Int(100)]
    expr = pt.App.optedIn(args[0], args[1])
    assert expr.type_of() == pt.TealType.uint64

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(args[0], pt.Op.byte, '"sender address"'),
            pt.TealOp(args[1], pt.Op.int, 100),
            pt.TealOp(expr, pt.Op.app_opted_in),
        ]
    )

    actual, _ = expr.__teal__(options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    assert actual == expected


def test_opted_in_invalid():
    with pytest.raises(pt.TealTypeError):
        pt.App.optedIn(pt.Bytes("sender"), pt.Bytes("100"))

    with pytest.raises(pt.TealTypeError):
        pt.App.optedIn(pt.Int(123456), pt.Bytes("364"))


def test_local_get():
    args = [pt.Int(0), pt.Bytes("key")]
    expr = pt.App.localGet(args[0], args[1])
    assert expr.type_of() == pt.TealType.anytype

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(args[0], pt.Op.int, 0),
            pt.TealOp(args[1], pt.Op.byte, '"key"'),
            pt.TealOp(expr, pt.Op.app_local_get),
        ]
    )

    actual, _ = expr.__teal__(options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    assert actual == expected


def test_local_get_direct_ref():
    args = [pt.Txn.sender(), pt.Bytes("key")]
    expr = pt.App.localGet(args[0], args[1])
    assert expr.type_of() == pt.TealType.anytype

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(args[0], pt.Op.txn, "Sender"),
            pt.TealOp(args[1], pt.Op.byte, '"key"'),
            pt.TealOp(expr, pt.Op.app_local_get),
        ]
    )

    actual, _ = expr.__teal__(options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    assert actual == expected


def test_local_get_invalid():
    with pytest.raises(pt.TealTypeError):
        pt.App.localGet(pt.Txn.sender(), pt.Int(1337))

    with pytest.raises(pt.TealTypeError):
        pt.App.localGet(pt.Int(0), pt.Int(1))


def test_local_get_ex():
    args = [pt.Int(0), pt.Int(6), pt.Bytes("key")]
    expr = pt.App.localGetEx(args[0], args[1], args[2])
    assert expr.type_of() == pt.TealType.none
    assert expr.value().type_of() == pt.TealType.anytype

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(args[0], pt.Op.int, 0),
            pt.TealOp(args[1], pt.Op.int, 6),
            pt.TealOp(args[2], pt.Op.byte, '"key"'),
            pt.TealOp(expr, pt.Op.app_local_get_ex),
            pt.TealOp(None, pt.Op.store, expr.slotOk),
            pt.TealOp(None, pt.Op.store, expr.slotValue),
        ]
    )

    actual, _ = expr.__teal__(options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    with pt.TealComponent.Context.ignoreExprEquality():
        assert actual == expected


def test_local_get_ex_direct_ref():
    args = [pt.Txn.sender(), pt.Int(6), pt.Bytes("key")]
    expr = pt.App.localGetEx(args[0], args[1], args[2])
    assert expr.type_of() == pt.TealType.none
    assert expr.value().type_of() == pt.TealType.anytype

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(args[0], pt.Op.txn, "Sender"),
            pt.TealOp(args[1], pt.Op.int, 6),
            pt.TealOp(args[2], pt.Op.byte, '"key"'),
            pt.TealOp(expr, pt.Op.app_local_get_ex),
            pt.TealOp(None, pt.Op.store, expr.slotOk),
            pt.TealOp(None, pt.Op.store, expr.slotValue),
        ]
    )

    actual, _ = expr.__teal__(options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    with pt.TealComponent.Context.ignoreExprEquality():
        assert actual == expected


def test_local_get_ex_invalid():
    with pytest.raises(pt.TealTypeError):
        pt.App.localGetEx(pt.Txn.sender(), pt.Int(0), pt.Int(0x123456))

    with pytest.raises(pt.TealTypeError):
        pt.App.localGetEx(pt.Int(0), pt.Bytes("app"), pt.Bytes("key"))


def test_global_get():
    arg = pt.Bytes("key")
    expr = pt.App.globalGet(arg)
    assert expr.type_of() == pt.TealType.anytype

    expected = pt.TealSimpleBlock(
        [pt.TealOp(arg, pt.Op.byte, '"key"'), pt.TealOp(expr, pt.Op.app_global_get)]
    )

    actual, _ = expr.__teal__(options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    assert actual == expected


def test_global_get_invalid():
    with pytest.raises(pt.TealTypeError):
        pt.App.globalGet(pt.Int(7))


def test_global_get_ex():
    args = [pt.Int(6), pt.Bytes("key")]
    expr = pt.App.globalGetEx(args[0], args[1])
    assert expr.type_of() == pt.TealType.none
    assert expr.value().type_of() == pt.TealType.anytype

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(args[0], pt.Op.int, 6),
            pt.TealOp(args[1], pt.Op.byte, '"key"'),
            pt.TealOp(expr, pt.Op.app_global_get_ex),
            pt.TealOp(None, pt.Op.store, expr.slotOk),
            pt.TealOp(None, pt.Op.store, expr.slotValue),
        ]
    )

    actual, _ = expr.__teal__(options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    with pt.TealComponent.Context.ignoreExprEquality():
        assert actual == expected


def test_global_get_ex_direct_ref():
    args = [pt.Txn.applications[0], pt.Bytes("key")]
    expr = pt.App.globalGetEx(args[0], args[1])
    assert expr.type_of() == pt.TealType.none
    assert expr.value().type_of() == pt.TealType.anytype

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(args[0], pt.Op.txna, "Applications", 0),
            pt.TealOp(args[1], pt.Op.byte, '"key"'),
            pt.TealOp(expr, pt.Op.app_global_get_ex),
            pt.TealOp(None, pt.Op.store, expr.slotOk),
            pt.TealOp(None, pt.Op.store, expr.slotValue),
        ]
    )

    actual, _ = expr.__teal__(avm4Options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    with pt.TealComponent.Context.ignoreExprEquality():
        assert actual == expected


def test_global_get_ex_invalid():
    with pytest.raises(pt.TealTypeError):
        pt.App.globalGetEx(pt.Bytes("app"), pt.Int(12))

    with pytest.raises(pt.TealTypeError):
        pt.App.globalGetEx(pt.Int(0), pt.Int(1))


def test_local_put():
    args = [pt.Int(0), pt.Bytes("key"), pt.Int(5)]
    expr = pt.App.localPut(args[0], args[1], args[2])
    assert expr.type_of() == pt.TealType.none

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(args[0], pt.Op.int, 0),
            pt.TealOp(args[1], pt.Op.byte, '"key"'),
            pt.TealOp(args[2], pt.Op.int, 5),
            pt.TealOp(expr, pt.Op.app_local_put),
        ]
    )

    actual, _ = expr.__teal__(options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    assert actual == expected


def test_local_put_direct_ref():
    args = [pt.Txn.sender(), pt.Bytes("key"), pt.Int(5)]
    expr = pt.App.localPut(args[0], args[1], args[2])
    assert expr.type_of() == pt.TealType.none

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(args[0], pt.Op.txn, "Sender"),
            pt.TealOp(args[1], pt.Op.byte, '"key"'),
            pt.TealOp(args[2], pt.Op.int, 5),
            pt.TealOp(expr, pt.Op.app_local_put),
        ]
    )

    actual, _ = expr.__teal__(options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    assert actual == expected


def test_local_put_invalid():
    with pytest.raises(pt.TealTypeError):
        pt.App.localPut(pt.Txn.sender(), pt.Int(55), pt.Int(5))

    with pytest.raises(pt.TealTypeError):
        pt.App.localPut(pt.Int(1), pt.Int(0), pt.Int(5))

    with pytest.raises(pt.TealTypeError):
        pt.App.localPut(pt.Int(1), pt.Bytes("key"), pt.Pop(pt.Int(1)))


def test_global_put():
    args = [pt.Bytes("key"), pt.Int(5)]
    expr = pt.App.globalPut(args[0], args[1])
    assert expr.type_of() == pt.TealType.none

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(args[0], pt.Op.byte, '"key"'),
            pt.TealOp(args[1], pt.Op.int, 5),
            pt.TealOp(expr, pt.Op.app_global_put),
        ]
    )

    actual, _ = expr.__teal__(options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    assert actual == expected


def test_global_put_invalid():
    with pytest.raises(pt.TealTypeError):
        pt.App.globalPut(pt.Int(0), pt.Int(5))

    with pytest.raises(pt.TealTypeError):
        pt.App.globalPut(pt.Bytes("key"), pt.Pop(pt.Int(1)))


def test_local_del():
    args = [pt.Int(0), pt.Bytes("key")]
    expr = pt.App.localDel(args[0], args[1])
    assert expr.type_of() == pt.TealType.none

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(args[0], pt.Op.int, 0),
            pt.TealOp(args[1], pt.Op.byte, '"key"'),
            pt.TealOp(expr, pt.Op.app_local_del),
        ]
    )

    actual, _ = expr.__teal__(options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    assert actual == expected


def test_local_del_direct_ref():
    args = [pt.Txn.sender(), pt.Bytes("key")]
    expr = pt.App.localDel(args[0], args[1])
    assert expr.type_of() == pt.TealType.none

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(args[0], pt.Op.txn, "Sender"),
            pt.TealOp(args[1], pt.Op.byte, '"key"'),
            pt.TealOp(expr, pt.Op.app_local_del),
        ]
    )

    actual, _ = expr.__teal__(options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    assert actual == expected


def test_local_del_invalid():
    with pytest.raises(pt.TealTypeError):
        pt.App.localDel(pt.Txn.sender(), pt.Int(123))

    with pytest.raises(pt.TealTypeError):
        pt.App.localDel(pt.Int(1), pt.Int(2))


def test_global_del():
    arg = pt.Bytes("key")
    expr = pt.App.globalDel(arg)
    assert expr.type_of() == pt.TealType.none

    expected = pt.TealSimpleBlock(
        [pt.TealOp(arg, pt.Op.byte, '"key"'), pt.TealOp(expr, pt.Op.app_global_del)]
    )

    actual, _ = expr.__teal__(options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    assert actual == expected


def test_global_del_invalid():
    with pytest.raises(pt.TealTypeError):
        pt.App.globalDel(pt.Int(2))


def test_app_param_approval_program_valid():
    arg = pt.Int(1)
    expr = pt.AppParam.approvalProgram(arg)
    assert expr.type_of() == pt.TealType.none
    assert expr.value().type_of() == pt.TealType.bytes

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(arg, pt.Op.int, 1),
            pt.TealOp(expr, pt.Op.app_params_get, "AppApprovalProgram"),
            pt.TealOp(None, pt.Op.store, expr.slotOk),
            pt.TealOp(None, pt.Op.store, expr.slotValue),
        ]
    )

    actual, _ = expr.__teal__(avm5Options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    with pt.TealComponent.Context.ignoreExprEquality():
        assert actual == expected


def test_app_param_approval_program_invalid():
    with pytest.raises(pt.TealTypeError):
        pt.AppParam.approvalProgram(pt.Txn.sender())


def test_app_param_clear_state_program_valid():
    arg = pt.Int(0)
    expr = pt.AppParam.clearStateProgram(arg)
    assert expr.type_of() == pt.TealType.none
    assert expr.value().type_of() == pt.TealType.bytes

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(arg, pt.Op.int, 0),
            pt.TealOp(expr, pt.Op.app_params_get, "AppClearStateProgram"),
            pt.TealOp(None, pt.Op.store, expr.slotOk),
            pt.TealOp(None, pt.Op.store, expr.slotValue),
        ]
    )

    actual, _ = expr.__teal__(avm5Options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    with pt.TealComponent.Context.ignoreExprEquality():
        assert actual == expected


def test_app_param_clear_state_program_invalid():
    with pytest.raises(pt.TealTypeError):
        pt.AppParam.clearStateProgram(pt.Txn.sender())


def test_app_param_global_num_uint_valid():
    arg = pt.Int(1)
    expr = pt.AppParam.globalNumUint(arg)
    assert expr.type_of() == pt.TealType.none
    assert expr.value().type_of() == pt.TealType.uint64

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(arg, pt.Op.int, 1),
            pt.TealOp(expr, pt.Op.app_params_get, "AppGlobalNumUint"),
            pt.TealOp(None, pt.Op.store, expr.slotOk),
            pt.TealOp(None, pt.Op.store, expr.slotValue),
        ]
    )

    actual, _ = expr.__teal__(avm5Options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    with pt.TealComponent.Context.ignoreExprEquality():
        assert actual == expected


def test_app_param_global_num_uint_invalid():
    with pytest.raises(pt.TealTypeError):
        pt.AppParam.globalNumUint(pt.Txn.sender())


def test_app_param_global_num_byte_slice_valid():
    arg = pt.Int(1)
    expr = pt.AppParam.globalNumByteSlice(arg)
    assert expr.type_of() == pt.TealType.none
    assert expr.value().type_of() == pt.TealType.uint64

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(arg, pt.Op.int, 1),
            pt.TealOp(expr, pt.Op.app_params_get, "AppGlobalNumByteSlice"),
            pt.TealOp(None, pt.Op.store, expr.slotOk),
            pt.TealOp(None, pt.Op.store, expr.slotValue),
        ]
    )

    actual, _ = expr.__teal__(avm5Options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    with pt.TealComponent.Context.ignoreExprEquality():
        assert actual == expected


def test_app_param_global_num_byte_slice_invalid():
    with pytest.raises(pt.TealTypeError):
        pt.AppParam.globalNumByteSlice(pt.Txn.sender())


def test_app_param_local_num_uint_valid():
    arg = pt.Int(1)
    expr = pt.AppParam.localNumUint(arg)
    assert expr.type_of() == pt.TealType.none
    assert expr.value().type_of() == pt.TealType.uint64

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(arg, pt.Op.int, 1),
            pt.TealOp(expr, pt.Op.app_params_get, "AppLocalNumUint"),
            pt.TealOp(None, pt.Op.store, expr.slotOk),
            pt.TealOp(None, pt.Op.store, expr.slotValue),
        ]
    )

    actual, _ = expr.__teal__(avm5Options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    with pt.TealComponent.Context.ignoreExprEquality():
        assert actual == expected


def test_app_param_local_num_uint_invalid():
    with pytest.raises(pt.TealTypeError):
        pt.AppParam.localNumUint(pt.Txn.sender())


def test_app_param_local_num_byte_slice_valid():
    arg = pt.Int(1)
    expr = pt.AppParam.localNumByteSlice(arg)
    assert expr.type_of() == pt.TealType.none
    assert expr.value().type_of() == pt.TealType.uint64

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(arg, pt.Op.int, 1),
            pt.TealOp(expr, pt.Op.app_params_get, "AppLocalNumByteSlice"),
            pt.TealOp(None, pt.Op.store, expr.slotOk),
            pt.TealOp(None, pt.Op.store, expr.slotValue),
        ]
    )

    actual, _ = expr.__teal__(avm5Options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    with pt.TealComponent.Context.ignoreExprEquality():
        assert actual == expected


def test_app_param_local_num_byte_slice_invalid():
    with pytest.raises(pt.TealTypeError):
        pt.AppParam.localNumByteSlice(pt.Txn.sender())


def test_app_param_extra_programs_page_valid():
    arg = pt.Int(1)
    expr = pt.AppParam.extraProgramPages(arg)
    assert expr.type_of() == pt.TealType.none
    assert expr.value().type_of() == pt.TealType.uint64

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(arg, pt.Op.int, 1),
            pt.TealOp(expr, pt.Op.app_params_get, "AppExtraProgramPages"),
            pt.TealOp(None, pt.Op.store, expr.slotOk),
            pt.TealOp(None, pt.Op.store, expr.slotValue),
        ]
    )

    actual, _ = expr.__teal__(avm5Options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    with pt.TealComponent.Context.ignoreExprEquality():
        assert actual == expected


def test_app_param_extra_program_pages_invalid():
    with pytest.raises(pt.TealTypeError):
        pt.AppParam.extraProgramPages(pt.Txn.sender())


def test_app_param_creator_valid():
    arg = pt.Int(1)
    expr = pt.AppParam.creator(arg)
    assert expr.type_of() == pt.TealType.none
    assert expr.value().type_of() == pt.TealType.bytes

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(arg, pt.Op.int, 1),
            pt.TealOp(expr, pt.Op.app_params_get, "AppCreator"),
            pt.TealOp(None, pt.Op.store, expr.slotOk),
            pt.TealOp(None, pt.Op.store, expr.slotValue),
        ]
    )

    actual, _ = expr.__teal__(avm5Options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    with pt.TealComponent.Context.ignoreExprEquality():
        assert actual == expected


def test_app_param_creator_invalid():
    with pytest.raises(pt.TealTypeError):
        pt.AppParam.creator(pt.Txn.sender())


def test_app_param_address_valid():
    arg = pt.Int(1)
    expr = pt.AppParam.address(arg)
    assert expr.type_of() == pt.TealType.none
    assert expr.value().type_of() == pt.TealType.bytes

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(arg, pt.Op.int, 1),
            pt.TealOp(expr, pt.Op.app_params_get, "AppAddress"),
            pt.TealOp(None, pt.Op.store, expr.slotOk),
            pt.TealOp(None, pt.Op.store, expr.slotValue),
        ]
    )

    actual, _ = expr.__teal__(avm5Options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    with pt.TealComponent.Context.ignoreExprEquality():
        assert actual == expected


def test_app_param_address_invalid():
    with pytest.raises(pt.TealTypeError):
        pt.AppParam.address(pt.Txn.sender())


def test_AppParamObject():
    for app in (pt.Int(1), pt.Int(100)):
        obj = pt.AppParamObject(app)

        assert obj._app is app

        assert_MaybeValue_equality(
            obj.approval_program(), pt.AppParam.approvalProgram(app), avm5Options
        )
        assert_MaybeValue_equality(
            obj.clear_state_program(), pt.AppParam.clearStateProgram(app), avm5Options
        )
        assert_MaybeValue_equality(
            obj.global_num_uint(), pt.AppParam.globalNumUint(app), avm5Options
        )
        assert_MaybeValue_equality(
            obj.global_num_byte_slice(),
            pt.AppParam.globalNumByteSlice(app),
            avm5Options,
        )
        assert_MaybeValue_equality(
            obj.local_num_uint(), pt.AppParam.localNumUint(app), avm5Options
        )
        assert_MaybeValue_equality(
            obj.local_num_byte_slice(), pt.AppParam.localNumByteSlice(app), avm5Options
        )
        assert_MaybeValue_equality(
            obj.extra_program_pages(), pt.AppParam.extraProgramPages(app), avm5Options
        )
        assert_MaybeValue_equality(
            obj.creator_address(), pt.AppParam.creator(app), avm5Options
        )
        assert_MaybeValue_equality(obj.address(), pt.AppParam.address(app), avm5Options)



================================================
FILE: pyteal/ast/arg.py
================================================
from typing import Union, cast, TYPE_CHECKING

from pyteal.types import TealType, require_type
from pyteal.ir import TealOp, Op, TealBlock
from pyteal.errors import TealInputError, verifyProgramVersion
from pyteal.ast.expr import Expr
from pyteal.ast.leafexpr import LeafExpr

if TYPE_CHECKING:
    from pyteal.compiler import CompileOptions


class Arg(LeafExpr):
    """An expression to get an argument when running in signature verification mode."""

    def __init__(self, index: Union[int, Expr]) -> None:
        """Get an argument for this program.

        Should only be used in signature verification mode. For application mode arguments, see
        :any:`TxnObject.application_args`.

        Args:
            index: The index of the argument to get. The index must be between 0 and 255 inclusive.
                Starting in AVM v5, the index may be a PyTeal expression that evaluates to uint64.
        """
        super().__init__()

        if type(index) is int:
            if index < 0 or index > 255:
                raise TealInputError("invalid arg index {}".format(index))
        else:
            require_type(cast(Expr, index), TealType.uint64)

        self.index = index

    def __teal__(self, options: "CompileOptions"):
        if type(self.index) is int:
            op = TealOp(self, Op.arg, self.index)
            return TealBlock.FromOp(options, op)

        verifyProgramVersion(
            Op.args.min_version,
            options.version,
            "Program version too low to use dynamic indexes with Arg",
        )

        op = TealOp(self, Op.args)
        return TealBlock.FromOp(options, op, cast(Expr, self.index))

    def __str__(self):
        return "(arg {})".format(self.index)

    def type_of(self):
        return TealType.bytes


Arg.__module__ = "pyteal"



================================================
FILE: pyteal/ast/arg_test.py
================================================
import pytest

import pyteal as pt

avm2Options = pt.CompileOptions(version=2)
avm4Options = pt.CompileOptions(version=4)
avm5Options = pt.CompileOptions(version=5)


def test_arg_static():
    for i in range(256):
        expr = pt.Arg(i)
        assert expr.type_of() == pt.TealType.bytes
        assert not expr.has_return()

        expected = pt.TealSimpleBlock([pt.TealOp(expr, pt.Op.arg, i)])

        actual, _ = expr.__teal__(avm2Options)
        assert actual == expected


def test_arg_dynamic():
    i = pt.Int(7)
    expr = pt.Arg(i)
    assert expr.type_of() == pt.TealType.bytes
    assert not expr.has_return()

    expected = pt.TealSimpleBlock(
        [pt.TealOp(i, pt.Op.int, 7), pt.TealOp(expr, pt.Op.args)]
    )

    actual, _ = expr.__teal__(avm5Options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    assert actual == expected

    with pytest.raises(pt.TealInputError):
        expr.__teal__(avm4Options)


def test_arg_invalid():
    with pytest.raises(pt.TealTypeError):
        pt.Arg(pt.Bytes("k"))

    with pytest.raises(pt.TealInputError):
        pt.Arg(-1)

    with pytest.raises(pt.TealInputError):
        pt.Arg(256)



================================================
FILE: pyteal/ast/array.py
================================================
from abc import ABC, abstractmethod

from pyteal.ast.expr import Expr


class Array(ABC):
    """Represents a variable length array of objects."""

    @abstractmethod
    def length(self) -> Expr:
        """Get the length of the array."""
        pass

    @abstractmethod
    def __getitem__(self, index: int):
        """Get the value at a given index in this array."""
        pass


Array.__module__ = "pyteal"



================================================
FILE: pyteal/ast/assert_.py
================================================
from typing import TYPE_CHECKING

from pyteal.types import TealType, require_type
from pyteal.ir import TealOp, Op, TealBlock, TealSimpleBlock, TealConditionalBlock
from pyteal.ast.expr import Expr
from pyteal.ast.comment import Comment
from pyteal.ast.seq import Seq

if TYPE_CHECKING:
    from pyteal.compiler import CompileOptions


class Assert(Expr):
    """A control flow expression to verify that a condition is true."""

    def __init__(
        self, cond: Expr, *additional_conds: Expr, comment: str | None = None
    ) -> None:
        """Create an assert statement that raises an error if the condition is false.

        Args:
            cond: The condition to check. Must evaluate to a uint64.
            *additional_conds: Additional conditions to check. Must evaluate to uint64.
            comment: String comment to place on the line immediately prior to the assert op
        """
        super().__init__()
        require_type(cond, TealType.uint64)
        for cond_single in additional_conds:
            require_type(cond_single, TealType.uint64)

        self.comment = comment
        self.cond = [cond] + list(additional_conds)
        self._sframes_container: Expr | None = None

    def __teal__(self, options: "CompileOptions"):
        if len(self.cond) > 1:
            asserts: list[Expr] = []
            for cond in self.cond:
                asrt = Assert(cond, comment=self.comment)
                asrt.trace = cond.trace
                asrt._sframes_container = cond
                asserts.append(asrt)
            return Seq(*asserts).__teal__(options)

        if options.version >= Op.assert_.min_version:
            # use assert op if available
            conds: list[Expr] = [self.cond[0]]
            if self.comment is not None:
                conds.append(Comment(self.comment))
            return TealBlock.FromOp(options, TealOp(self, Op.assert_), *conds)

        # if assert op is not available, use branches and err
        condStart, condEnd = self.cond[0].__teal__(options)

        end = TealSimpleBlock([])
        errBlock = TealSimpleBlock([TealOp(self, Op.err)])

        branchBlock = TealConditionalBlock([])
        branchBlock.setTrueBlock(end)
        branchBlock.setFalseBlock(errBlock)

        condEnd.setNextBlock(branchBlock)

        return condStart, end

    def __str__(self):
        return "(Assert {})".format(self.cond)

    def type_of(self):
        return TealType.none

    def has_return(self):
        return False


Assert.__module__ = "pyteal"



================================================
FILE: pyteal/ast/assert_test.py
================================================
import pytest

import pyteal as pt

avm2Options = pt.CompileOptions(version=2)
avm3Options = pt.CompileOptions(version=3)


def test_teal_2_assert():
    arg = pt.Int(1)
    expr = pt.Assert(arg)
    assert expr.type_of() == pt.TealType.none

    expected, _ = arg.__teal__(avm2Options)
    expectedBranch = pt.TealConditionalBlock([])
    expectedBranch.setTrueBlock(pt.TealSimpleBlock([]))
    expectedBranch.setFalseBlock(pt.Err().__teal__(avm2Options)[0])
    expected.setNextBlock(expectedBranch)

    actual, _ = expr.__teal__(avm2Options)

    with pt.TealComponent.Context.ignoreExprEquality():
        assert actual == expected


def test_teal_2_assert_multi():
    args = [pt.Int(1), pt.Int(2)]
    expr = pt.Assert(*args)
    assert expr.type_of() == pt.TealType.none

    firstAssert = pt.Assert(args[0])
    secondAssert = pt.Assert(args[1])

    expected, _ = pt.Seq(firstAssert, secondAssert).__teal__(avm2Options)

    actual, _ = expr.__teal__(avm2Options)

    with pt.TealComponent.Context.ignoreExprEquality():
        assert actual == expected


def test_teal_3_assert():
    arg = pt.Int(1)
    expr = pt.Assert(arg)
    assert expr.type_of() == pt.TealType.none

    expected = pt.TealSimpleBlock(
        [pt.TealOp(arg, pt.Op.int, 1), pt.TealOp(expr, pt.Op.assert_)]
    )

    actual, _ = expr.__teal__(avm3Options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    assert actual == expected


def test_teal_3_assert_multi():
    args = [pt.Int(1), pt.Int(2)]
    expr = pt.Assert(*args)
    assert expr.type_of() == pt.TealType.none

    expected = pt.TealSimpleBlock(
        [pt.TealOp(args[0], pt.Op.int, 1), pt.TealOp(expr, pt.Op.assert_)]
        + [pt.TealOp(args[1], pt.Op.int, 2), pt.TealOp(expr, pt.Op.assert_)]
    )

    actual, _ = expr.__teal__(avm3Options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    with pt.TealComponent.Context.ignoreExprEquality():
        assert actual == expected


def test_assert_comment():
    comment = "Make sure 1 is true"
    expr = pt.Assert(pt.Int(1), comment=comment)
    assert expr.type_of() == pt.TealType.none

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(None, pt.Op.int, 1),
            pt.TealOp(None, pt.Op.comment, comment),
            pt.TealOp(None, pt.Op.assert_),
        ]
    )

    actual, _ = expr.__teal__(avm3Options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    with pt.TealComponent.Context.ignoreExprEquality():
        assert actual == expected


def test_assert_comment_multi():
    comment = "Make sure numbers > 0 are true"
    expr = pt.Assert(pt.Int(1), pt.Int(2), pt.Int(3), comment=comment)
    assert expr.type_of() == pt.TealType.none

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(None, pt.Op.int, 1),
            pt.TealOp(None, pt.Op.comment, comment),
            pt.TealOp(None, pt.Op.assert_),
            pt.TealOp(None, pt.Op.int, 2),
            pt.TealOp(None, pt.Op.comment, comment),
            pt.TealOp(None, pt.Op.assert_),
            pt.TealOp(None, pt.Op.int, 3),
            pt.TealOp(None, pt.Op.comment, comment),
            pt.TealOp(None, pt.Op.assert_),
        ]
    )

    actual, _ = expr.__teal__(avm3Options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    with pt.TealComponent.Context.ignoreExprEquality():
        assert actual == expected


def test_assert_invalid():
    with pytest.raises(pt.TealTypeError):
        pt.Assert(pt.Txn.receiver())

    with pytest.raises(pt.TealTypeError):
        pt.Assert(pt.Int(1), pt.Txn.receiver())



================================================
FILE: pyteal/ast/asset.py
================================================
from typing import Final

from pyteal.types import TealType, require_type
from pyteal.ir import Op
from pyteal.ast.expr import Expr
from pyteal.ast.maybe import MaybeValue


class AssetHolding:
    @classmethod
    def balance(cls, account: Expr, asset: Expr) -> MaybeValue:
        """Get the amount of an asset held by an account.

        Args:
            account: An index into Txn.Accounts that corresponds to the account to check,
                must be evaluated to uint64 (or, since v4, an account address that appears in
                Txn.Accounts or is Txn.Sender, must be evaluated to bytes).
            asset: The ID of the asset to get, must be evaluated to uint64 (or, since v4,
                a Txn.assets offset).
        """
        require_type(account, TealType.anytype)
        require_type(asset, TealType.uint64)
        return MaybeValue(
            Op.asset_holding_get,
            TealType.uint64,
            immediate_args=["AssetBalance"],
            args=[account, asset],
        )

    @classmethod
    def frozen(cls, account: Expr, asset: Expr) -> MaybeValue:
        """Check if an asset is frozen for an account.

        A value of 1 indicates frozen and 0 indicates not frozen.

        Args:
            account: An index into Txn.Accounts that corresponds to the account to check,
                must be evaluated to uint64 (or, since v4, an account address that appears in
                Txn.Accounts or is Txn.Sender, must be evaluated to bytes).
            asset: The ID of the asset to get, must be evaluated to uint64 (or, since v4,
                a Txn.assets offset).
        """
        require_type(account, TealType.anytype)
        require_type(asset, TealType.uint64)
        return MaybeValue(
            Op.asset_holding_get,
            TealType.uint64,
            immediate_args=["AssetFrozen"],
            args=[account, asset],
        )


AssetHolding.__module__ = "pyteal"


class AssetHoldingObject:
    """Represents information about an account's holding of an asset"""

    def __init__(self, asset: Expr, account: Expr) -> None:
        """Create a new AssetParamObject for the given asset.

        Args:
            asset: An identifier for the asset. It must be an index into Txn.ForeignAssets that
                corresponds to the asset to check, or since v4, an asset ID that appears in
                Txn.ForeignAssets. In either case, it must evaluate to uint64.
            account: An identifier for the account. It must be an index into Txn.Accounts that
                corresponds to the account to check (in which case it must evaluate to uint64), or
                since v4, an account address that appears in Txn.Accounts or is Txn.Sender (in which
                case it must evaluate to bytes).
        """
        require_type(asset, TealType.uint64)
        self._asset: Final = asset
        require_type(account, TealType.anytype)
        self._account: Final = account

    def balance(self) -> MaybeValue:
        """Get the amount of the asset held by the account."""
        return AssetHolding.balance(self._account, self._asset)

    def frozen(self) -> MaybeValue:
        """Check if the asset is frozen for the account.

        A value of 1 indicates frozen and 0 indicates not frozen.
        """
        return AssetHolding.frozen(self._account, self._asset)


AssetHoldingObject.__module__ = "pyteal"


class AssetParam:
    @classmethod
    def total(cls, asset: Expr) -> MaybeValue:
        """Get the total number of units of an asset.

        Args:
            asset: An index into Txn.assets that corresponds to the asset to check,
                must be evaluated to uint64 (or since v4, an asset ID that appears in
                Txn.assets).
        """
        require_type(asset, TealType.uint64)
        return MaybeValue(
            Op.asset_params_get,
            TealType.uint64,
            immediate_args=["AssetTotal"],
            args=[asset],
        )

    @classmethod
    def decimals(cls, asset: Expr) -> MaybeValue:
        """Get the number of decimals for an asset.

        Args:
            asset: An index into Txn.assets that corresponds to the asset to check,
                must be evaluated to uint64 (or since v4, an asset ID that appears in
                Txn.assets).
        """
        require_type(asset, TealType.uint64)
        return MaybeValue(
            Op.asset_params_get,
            TealType.uint64,
            immediate_args=["AssetDecimals"],
            args=[asset],
        )

    @classmethod
    def defaultFrozen(cls, asset: Expr) -> MaybeValue:
        """Check if an asset is frozen by default.

        Args:
            asset: An index into Txn.assets that corresponds to the asset to check,
                must be evaluated to uint64 (or since v4, an asset ID that appears in
                Txn.assets).
        """
        require_type(asset, TealType.uint64)
        return MaybeValue(
            Op.asset_params_get,
            TealType.uint64,
            immediate_args=["AssetDefaultFrozen"],
            args=[asset],
        )

    @classmethod
    def unitName(cls, asset: Expr) -> MaybeValue:
        """Get the unit name of an asset.

        Args:
            asset: An index into Txn.assets that corresponds to the asset to check,
                must be evaluated to uint64 (or since v4, an asset ID that appears in
                Txn.assets).
        """
        require_type(asset, TealType.uint64)
        return MaybeValue(
            Op.asset_params_get,
            TealType.bytes,
            immediate_args=["AssetUnitName"],
            args=[asset],
        )

    @classmethod
    def name(cls, asset: Expr) -> MaybeValue:
        """Get the name of an asset.

        Args:
            asset: An index into Txn.assets that corresponds to the asset to check,
                must be evaluated to uint64 (or since v4, an asset ID that appears in
                Txn.assets).
        """
        require_type(asset, TealType.uint64)
        return MaybeValue(
            Op.asset_params_get,
            TealType.bytes,
            immediate_args=["AssetName"],
            args=[asset],
        )

    @classmethod
    def url(cls, asset: Expr) -> MaybeValue:
        """Get the URL of an asset.

        Args:
            asset: An index into Txn.assets that corresponds to the asset to check,
                must be evaluated to uint64 (or since v4, an asset ID that appears in
                Txn.assets).
        """
        require_type(asset, TealType.uint64)
        return MaybeValue(
            Op.asset_params_get,
            TealType.bytes,
            immediate_args=["AssetURL"],
            args=[asset],
        )

    @classmethod
    def metadataHash(cls, asset: Expr) -> MaybeValue:
        """Get the arbitrary commitment for an asset.

        If set, this will be 32 bytes long.

        Args:
            asset: An index into Txn.assets that corresponds to the asset to check,
                must be evaluated to uint64 (or since v4, an asset ID that appears in
                Txn.assets).
        """
        require_type(asset, TealType.uint64)
        return MaybeValue(
            Op.asset_params_get,
            TealType.bytes,
            immediate_args=["AssetMetadataHash"],
            args=[asset],
        )

    @classmethod
    def manager(cls, asset: Expr) -> MaybeValue:
        """Get the manager address for an asset.

        Args:
            asset: An index into Txn.assets that corresponds to the asset to check,
                must be evaluated to uint64 (or since v4, an asset ID that appears in
                Txn.assets).
        """
        require_type(asset, TealType.uint64)
        return MaybeValue(
            Op.asset_params_get,
            TealType.bytes,
            immediate_args=["AssetManager"],
            args=[asset],
        )

    @classmethod
    def reserve(cls, asset: Expr) -> MaybeValue:
        """Get the reserve address for an asset.

        Args:
            asset: An index into Txn.assets that corresponds to the asset to check,
                must be evaluated to uint64 (or since v4, an asset ID that appears in
                Txn.assets).
        """
        require_type(asset, TealType.uint64)
        return MaybeValue(
            Op.asset_params_get,
            TealType.bytes,
            immediate_args=["AssetReserve"],
            args=[asset],
        )

    @classmethod
    def freeze(cls, asset: Expr) -> MaybeValue:
        """Get the freeze address for an asset.

        Args:
            asset: An index into Txn.assets that corresponds to the asset to check,
                must be evaluated to uint64 (or since v4, an asset ID that appears in
                Txn.assets).
        """
        require_type(asset, TealType.uint64)
        return MaybeValue(
            Op.asset_params_get,
            TealType.bytes,
            immediate_args=["AssetFreeze"],
            args=[asset],
        )

    @classmethod
    def clawback(cls, asset: Expr) -> MaybeValue:
        """Get the clawback address for an asset.

        Args:
            asset: An index into Txn.assets that corresponds to the asset to check,
                must be evaluated to uint64 (or since v4, an asset ID that appears in
                Txn.assets).
        """
        require_type(asset, TealType.uint64)
        return MaybeValue(
            Op.asset_params_get,
            TealType.bytes,
            immediate_args=["AssetClawback"],
            args=[asset],
        )

    @classmethod
    def creator(cls, asset: Expr) -> MaybeValue:
        """Get the creator address for an asset.

        Args:
            asset: An index into Txn.assets that corresponds to the asset to check. Must
                evaluate to uint64.
        """
        require_type(asset, TealType.uint64)
        return MaybeValue(
            Op.asset_params_get,
            TealType.bytes,
            immediate_args=["AssetCreator"],
            args=[asset],
        )


AssetParam.__module__ = "pyteal"


class AssetParamObject:
    """Represents information about an asset's parameters"""

    def __init__(self, asset: Expr) -> None:
        """Create a new AssetParamObject for the given asset.

        Args:
            asset: An identifier for the asset. It must be an index into Txn.ForeignAssets that
                corresponds to the asset to check, or since v4, an asset ID that appears in
                Txn.ForeignAssets. In either case, it must evaluate to uint64.
        """
        require_type(asset, TealType.uint64)
        self._asset: Final = asset

    def total(self) -> MaybeValue:
        """Get the total number of units of the asset."""
        return AssetParam.total(self._asset)

    def decimals(self) -> MaybeValue:
        """Get the number of decimals for the asset."""
        return AssetParam.decimals(self._asset)

    def default_frozen(self) -> MaybeValue:
        """Check if the asset is frozen by default."""
        return AssetParam.defaultFrozen(self._asset)

    def unit_name(self) -> MaybeValue:
        """Get the unit name of the asset."""
        return AssetParam.unitName(self._asset)

    def name(self) -> MaybeValue:
        """Get the name of the asset."""
        return AssetParam.name(self._asset)

    def url(self) -> MaybeValue:
        """Get the URL of the asset."""
        return AssetParam.url(self._asset)

    def metadata_hash(self) -> MaybeValue:
        """Get the arbitrary commitment for the asset.

        If set, this will be 32 bytes long."""
        return AssetParam.metadataHash(self._asset)

    def manager_address(self) -> MaybeValue:
        """Get the manager address for the asset."""
        return AssetParam.manager(self._asset)

    def reserve_address(self) -> MaybeValue:
        """Get the reserve address for the asset."""
        return AssetParam.reserve(self._asset)

    def freeze_address(self) -> MaybeValue:
        """Get the freeze address for the asset."""
        return AssetParam.freeze(self._asset)

    def clawback_address(self) -> MaybeValue:
        """Get the clawback address for the asset."""
        return AssetParam.clawback(self._asset)

    def creator_address(self) -> MaybeValue:
        """Get the creator address for the asset."""
        return AssetParam.creator(self._asset)


AssetParamObject.__module__ = "pyteal"



================================================
FILE: pyteal/ast/asset_test.py
================================================
import pytest

import pyteal as pt
from pyteal.ast.maybe_test import assert_MaybeValue_equality

avm2Options = pt.CompileOptions()
avm4Options = pt.CompileOptions(version=4)
avm5Options = pt.CompileOptions(version=5)


def test_asset_holding_balance():
    args = pt.Int(0), pt.Int(17)
    expr = pt.AssetHolding.balance(args[0], args[1])
    assert expr.type_of() == pt.TealType.none
    assert expr.value().type_of() == pt.TealType.uint64

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(args[0], pt.Op.int, 0),
            pt.TealOp(args[1], pt.Op.int, 17),
            pt.TealOp(expr, pt.Op.asset_holding_get, "AssetBalance"),
            pt.TealOp(None, pt.Op.store, expr.slotOk),
            pt.TealOp(None, pt.Op.store, expr.slotValue),
        ]
    )

    actual, _ = expr.__teal__(avm2Options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    with pt.TealComponent.Context.ignoreExprEquality():
        assert actual == expected


def test_asset_holding_balance_direct_ref():
    args = [pt.Txn.sender(), pt.Txn.assets[17]]
    expr = pt.AssetHolding.balance(args[0], args[1])
    assert expr.type_of() == pt.TealType.none
    assert expr.value().type_of() == pt.TealType.uint64

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(args[0], pt.Op.txn, "Sender"),
            pt.TealOp(args[1], pt.Op.txna, "Assets", 17),
            pt.TealOp(expr, pt.Op.asset_holding_get, "AssetBalance"),
            pt.TealOp(None, pt.Op.store, expr.slotOk),
            pt.TealOp(None, pt.Op.store, expr.slotValue),
        ]
    )

    actual, _ = expr.__teal__(avm4Options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    with pt.TealComponent.Context.ignoreExprEquality():
        assert actual == expected


def test_asset_holding_balance_invalid():
    with pytest.raises(pt.TealTypeError):
        pt.AssetHolding.balance(pt.Txn.sender(), pt.Bytes("100"))

    with pytest.raises(pt.TealTypeError):
        pt.AssetHolding.balance(pt.Int(0), pt.Txn.receiver())


def test_asset_holding_frozen():
    args = [pt.Int(0), pt.Int(17)]
    expr = pt.AssetHolding.frozen(args[0], args[1])
    assert expr.type_of() == pt.TealType.none
    assert expr.value().type_of() == pt.TealType.uint64

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(args[0], pt.Op.int, 0),
            pt.TealOp(args[1], pt.Op.int, 17),
            pt.TealOp(expr, pt.Op.asset_holding_get, "AssetFrozen"),
            pt.TealOp(None, pt.Op.store, expr.slotOk),
            pt.TealOp(None, pt.Op.store, expr.slotValue),
        ]
    )

    actual, _ = expr.__teal__(avm2Options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    with pt.TealComponent.Context.ignoreExprEquality():
        assert actual == expected


def test_asset_holding_frozen_direct_ref():
    args = [pt.Txn.sender(), pt.Txn.assets[17]]
    expr = pt.AssetHolding.frozen(args[0], args[1])
    assert expr.type_of() == pt.TealType.none
    assert expr.value().type_of() == pt.TealType.uint64

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(args[0], pt.Op.txn, "Sender"),
            pt.TealOp(args[1], pt.Op.txna, "Assets", 17),
            pt.TealOp(expr, pt.Op.asset_holding_get, "AssetFrozen"),
            pt.TealOp(None, pt.Op.store, expr.slotOk),
            pt.TealOp(None, pt.Op.store, expr.slotValue),
        ]
    )

    actual, _ = expr.__teal__(avm4Options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    with pt.TealComponent.Context.ignoreExprEquality():
        assert actual == expected


def test_asset_holding_frozen_invalid():
    with pytest.raises(pt.TealTypeError):
        pt.AssetHolding.frozen(pt.Txn.sender(), pt.Bytes("17"))

    with pytest.raises(pt.TealTypeError):
        pt.AssetHolding.frozen(pt.Int(0), pt.Txn.receiver())


def test_asset_param_total():
    arg = pt.Int(0)
    expr = pt.AssetParam.total(arg)
    assert expr.type_of() == pt.TealType.none
    assert expr.value().type_of() == pt.TealType.uint64

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(arg, pt.Op.int, 0),
            pt.TealOp(expr, pt.Op.asset_params_get, "AssetTotal"),
            pt.TealOp(None, pt.Op.store, expr.slotOk),
            pt.TealOp(None, pt.Op.store, expr.slotValue),
        ]
    )

    actual, _ = expr.__teal__(avm2Options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    with pt.TealComponent.Context.ignoreExprEquality():
        assert actual == expected


def test_asset_param_total_direct_ref():
    arg = pt.Txn.assets[0]
    expr = pt.AssetParam.total(arg)
    assert expr.type_of() == pt.TealType.none
    assert expr.value().type_of() == pt.TealType.uint64

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(arg, pt.Op.txna, "Assets", 0),
            pt.TealOp(expr, pt.Op.asset_params_get, "AssetTotal"),
            pt.TealOp(None, pt.Op.store, expr.slotOk),
            pt.TealOp(None, pt.Op.store, expr.slotValue),
        ]
    )

    actual, _ = expr.__teal__(avm4Options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    with pt.TealComponent.Context.ignoreExprEquality():
        assert actual == expected


def test_asset_param_total_invalid():
    with pytest.raises(pt.TealTypeError):
        pt.AssetParam.total(pt.Txn.sender())


def test_asset_param_decimals():
    arg = pt.Int(0)
    expr = pt.AssetParam.decimals(arg)
    assert expr.type_of() == pt.TealType.none
    assert expr.value().type_of() == pt.TealType.uint64

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(arg, pt.Op.int, 0),
            pt.TealOp(expr, pt.Op.asset_params_get, "AssetDecimals"),
            pt.TealOp(None, pt.Op.store, expr.slotOk),
            pt.TealOp(None, pt.Op.store, expr.slotValue),
        ]
    )

    actual, _ = expr.__teal__(avm2Options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    with pt.TealComponent.Context.ignoreExprEquality():
        assert actual == expected


def test_asset_param_decimals_direct_ref():
    arg = pt.Txn.assets[0]
    expr = pt.AssetParam.decimals(arg)
    assert expr.type_of() == pt.TealType.none
    assert expr.value().type_of() == pt.TealType.uint64

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(arg, pt.Op.txna, "Assets", 0),
            pt.TealOp(expr, pt.Op.asset_params_get, "AssetDecimals"),
            pt.TealOp(None, pt.Op.store, expr.slotOk),
            pt.TealOp(None, pt.Op.store, expr.slotValue),
        ]
    )

    actual, _ = expr.__teal__(avm4Options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    with pt.TealComponent.Context.ignoreExprEquality():
        assert actual == expected


def test_asset_param_decimals_invalid():
    with pytest.raises(pt.TealTypeError):
        pt.AssetParam.decimals(pt.Txn.sender())


def test_asset_param_default_frozen():
    arg = pt.Int(0)
    expr = pt.AssetParam.defaultFrozen(arg)
    assert expr.type_of() == pt.TealType.none
    assert expr.value().type_of() == pt.TealType.uint64

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(arg, pt.Op.int, 0),
            pt.TealOp(expr, pt.Op.asset_params_get, "AssetDefaultFrozen"),
            pt.TealOp(None, pt.Op.store, expr.slotOk),
            pt.TealOp(None, pt.Op.store, expr.slotValue),
        ]
    )

    actual, _ = expr.__teal__(avm2Options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    with pt.TealComponent.Context.ignoreExprEquality():
        assert actual == expected


def test_asset_param_default_frozen_direct_ref():
    arg = pt.Txn.assets[0]
    expr = pt.AssetParam.defaultFrozen(arg)
    assert expr.type_of() == pt.TealType.none
    assert expr.value().type_of() == pt.TealType.uint64

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(arg, pt.Op.txna, "Assets", 0),
            pt.TealOp(expr, pt.Op.asset_params_get, "AssetDefaultFrozen"),
            pt.TealOp(None, pt.Op.store, expr.slotOk),
            pt.TealOp(None, pt.Op.store, expr.slotValue),
        ]
    )

    actual, _ = expr.__teal__(avm4Options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    with pt.TealComponent.Context.ignoreExprEquality():
        assert actual == expected


def test_asset_param_default_frozen_invalid():
    with pytest.raises(pt.TealTypeError):
        pt.AssetParam.defaultFrozen(pt.Txn.sender())


def test_asset_param_unit_name():
    arg = pt.Int(0)
    expr = pt.AssetParam.unitName(arg)
    assert expr.type_of() == pt.TealType.none
    assert expr.value().type_of() == pt.TealType.bytes

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(arg, pt.Op.int, 0),
            pt.TealOp(expr, pt.Op.asset_params_get, "AssetUnitName"),
            pt.TealOp(None, pt.Op.store, expr.slotOk),
            pt.TealOp(None, pt.Op.store, expr.slotValue),
        ]
    )

    actual, _ = expr.__teal__(avm2Options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    with pt.TealComponent.Context.ignoreExprEquality():
        assert actual == expected


def test_asset_param_unit_name_direct_ref():
    arg = pt.Txn.assets[0]
    expr = pt.AssetParam.unitName(arg)
    assert expr.type_of() == pt.TealType.none
    assert expr.value().type_of() == pt.TealType.bytes

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(arg, pt.Op.txna, "Assets", 0),
            pt.TealOp(expr, pt.Op.asset_params_get, "AssetUnitName"),
            pt.TealOp(None, pt.Op.store, expr.slotOk),
            pt.TealOp(None, pt.Op.store, expr.slotValue),
        ]
    )

    actual, _ = expr.__teal__(avm4Options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    with pt.TealComponent.Context.ignoreExprEquality():
        assert actual == expected


def test_asset_param_unit_name_invalid():
    with pytest.raises(pt.TealTypeError):
        pt.AssetParam.unitName(pt.Txn.sender())


def test_asset_param_name():
    arg = pt.Int(0)
    expr = pt.AssetParam.name(arg)
    assert expr.type_of() == pt.TealType.none
    assert expr.value().type_of() == pt.TealType.bytes

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(arg, pt.Op.int, 0),
            pt.TealOp(expr, pt.Op.asset_params_get, "AssetName"),
            pt.TealOp(None, pt.Op.store, expr.slotOk),
            pt.TealOp(None, pt.Op.store, expr.slotValue),
        ]
    )

    actual, _ = expr.__teal__(avm2Options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    with pt.TealComponent.Context.ignoreExprEquality():
        assert actual == expected


def test_asset_param_name_direct_ref():
    arg = pt.Txn.assets[0]
    expr = pt.AssetParam.name(arg)
    assert expr.type_of() == pt.TealType.none
    assert expr.value().type_of() == pt.TealType.bytes

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(arg, pt.Op.txna, "Assets", 0),
            pt.TealOp(expr, pt.Op.asset_params_get, "AssetName"),
            pt.TealOp(None, pt.Op.store, expr.slotOk),
            pt.TealOp(None, pt.Op.store, expr.slotValue),
        ]
    )

    actual, _ = expr.__teal__(avm4Options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    with pt.TealComponent.Context.ignoreExprEquality():
        assert actual == expected


def test_asset_param_name_invalid():
    with pytest.raises(pt.TealTypeError):
        pt.AssetParam.name(pt.Txn.sender())


def test_asset_param_url():
    arg = pt.Int(0)
    expr = pt.AssetParam.url(arg)
    assert expr.type_of() == pt.TealType.none
    assert expr.value().type_of() == pt.TealType.bytes

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(arg, pt.Op.int, 0),
            pt.TealOp(expr, pt.Op.asset_params_get, "AssetURL"),
            pt.TealOp(None, pt.Op.store, expr.slotOk),
            pt.TealOp(None, pt.Op.store, expr.slotValue),
        ]
    )

    actual, _ = expr.__teal__(avm2Options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    with pt.TealComponent.Context.ignoreExprEquality():
        assert actual == expected


def test_asset_param_url_direct_ref():
    arg = pt.Txn.assets[0]
    expr = pt.AssetParam.url(arg)
    assert expr.type_of() == pt.TealType.none
    assert expr.value().type_of() == pt.TealType.bytes

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(arg, pt.Op.txna, "Assets", 0),
            pt.TealOp(expr, pt.Op.asset_params_get, "AssetURL"),
            pt.TealOp(None, pt.Op.store, expr.slotOk),
            pt.TealOp(None, pt.Op.store, expr.slotValue),
        ]
    )

    actual, _ = expr.__teal__(avm4Options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    with pt.TealComponent.Context.ignoreExprEquality():
        assert actual == expected


def test_asset_param_url_invalid():
    with pytest.raises(pt.TealTypeError):
        pt.AssetParam.url(pt.Txn.sender())


def test_asset_param_metadata_hash():
    arg = pt.Int(0)
    expr = pt.AssetParam.metadataHash(arg)
    assert expr.type_of() == pt.TealType.none
    assert expr.value().type_of() == pt.TealType.bytes

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(arg, pt.Op.int, 0),
            pt.TealOp(expr, pt.Op.asset_params_get, "AssetMetadataHash"),
            pt.TealOp(None, pt.Op.store, expr.slotOk),
            pt.TealOp(None, pt.Op.store, expr.slotValue),
        ]
    )

    actual, _ = expr.__teal__(avm2Options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    with pt.TealComponent.Context.ignoreExprEquality():
        assert actual == expected


def test_asset_param_metadata_hash_direct_ref():
    arg = pt.Txn.assets[0]
    expr = pt.AssetParam.metadataHash(arg)
    assert expr.type_of() == pt.TealType.none
    assert expr.value().type_of() == pt.TealType.bytes

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(arg, pt.Op.txna, "Assets", 0),
            pt.TealOp(expr, pt.Op.asset_params_get, "AssetMetadataHash"),
            pt.TealOp(None, pt.Op.store, expr.slotOk),
            pt.TealOp(None, pt.Op.store, expr.slotValue),
        ]
    )

    actual, _ = expr.__teal__(avm4Options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    with pt.TealComponent.Context.ignoreExprEquality():
        assert actual == expected


def test_asset_param_metadata_hash_invalid():
    with pytest.raises(pt.TealTypeError):
        pt.AssetParam.metadataHash(pt.Txn.sender())


def test_asset_param_manager():
    arg = pt.Int(0)
    expr = pt.AssetParam.manager(arg)
    assert expr.type_of() == pt.TealType.none
    assert expr.value().type_of() == pt.TealType.bytes

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(arg, pt.Op.int, 0),
            pt.TealOp(expr, pt.Op.asset_params_get, "AssetManager"),
            pt.TealOp(None, pt.Op.store, expr.slotOk),
            pt.TealOp(None, pt.Op.store, expr.slotValue),
        ]
    )

    actual, _ = expr.__teal__(avm2Options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    with pt.TealComponent.Context.ignoreExprEquality():
        assert actual == expected


def test_asset_param_manager_direct_ref():
    arg = pt.Txn.assets[0]
    expr = pt.AssetParam.manager(arg)
    assert expr.type_of() == pt.TealType.none
    assert expr.value().type_of() == pt.TealType.bytes

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(arg, pt.Op.txna, "Assets", 0),
            pt.TealOp(expr, pt.Op.asset_params_get, "AssetManager"),
            pt.TealOp(None, pt.Op.store, expr.slotOk),
            pt.TealOp(None, pt.Op.store, expr.slotValue),
        ]
    )

    actual, _ = expr.__teal__(avm4Options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    with pt.TealComponent.Context.ignoreExprEquality():
        assert actual == expected


def test_asset_param_manager_invalid():
    with pytest.raises(pt.TealTypeError):
        pt.AssetParam.manager(pt.Txn.sender())


def test_asset_param_reserve():
    arg = pt.Int(2)
    expr = pt.AssetParam.reserve(arg)
    assert expr.type_of() == pt.TealType.none
    assert expr.value().type_of() == pt.TealType.bytes

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(arg, pt.Op.int, 2),
            pt.TealOp(expr, pt.Op.asset_params_get, "AssetReserve"),
            pt.TealOp(None, pt.Op.store, expr.slotOk),
            pt.TealOp(None, pt.Op.store, expr.slotValue),
        ]
    )

    actual, _ = expr.__teal__(avm2Options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    with pt.TealComponent.Context.ignoreExprEquality():
        assert actual == expected


def test_asset_param_reserve_direct_ref():
    arg = pt.Txn.assets[2]
    expr = pt.AssetParam.reserve(arg)
    assert expr.type_of() == pt.TealType.none
    assert expr.value().type_of() == pt.TealType.bytes

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(arg, pt.Op.txna, "Assets", 2),
            pt.TealOp(expr, pt.Op.asset_params_get, "AssetReserve"),
            pt.TealOp(None, pt.Op.store, expr.slotOk),
            pt.TealOp(None, pt.Op.store, expr.slotValue),
        ]
    )

    actual, _ = expr.__teal__(avm4Options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    with pt.TealComponent.Context.ignoreExprEquality():
        assert actual == expected


def test_asset_param_reserve_invalid():
    with pytest.raises(pt.TealTypeError):
        pt.AssetParam.reserve(pt.Txn.sender())


def test_asset_param_freeze():
    arg = pt.Int(0)
    expr = pt.AssetParam.freeze(arg)
    assert expr.type_of() == pt.TealType.none
    assert expr.value().type_of() == pt.TealType.bytes

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(arg, pt.Op.int, 0),
            pt.TealOp(expr, pt.Op.asset_params_get, "AssetFreeze"),
            pt.TealOp(None, pt.Op.store, expr.slotOk),
            pt.TealOp(None, pt.Op.store, expr.slotValue),
        ]
    )

    actual, _ = expr.__teal__(avm2Options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    with pt.TealComponent.Context.ignoreExprEquality():
        assert actual == expected


def test_asset_param_freeze_direct_ref():
    arg = pt.Txn.assets[0]
    expr = pt.AssetParam.freeze(arg)
    assert expr.type_of() == pt.TealType.none
    assert expr.value().type_of() == pt.TealType.bytes

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(arg, pt.Op.txna, "Assets", 0),
            pt.TealOp(expr, pt.Op.asset_params_get, "AssetFreeze"),
            pt.TealOp(None, pt.Op.store, expr.slotOk),
            pt.TealOp(None, pt.Op.store, expr.slotValue),
        ]
    )

    actual, _ = expr.__teal__(avm4Options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    with pt.TealComponent.Context.ignoreExprEquality():
        assert actual == expected


def test_asset_param_freeze_invalid():
    with pytest.raises(pt.TealTypeError):
        pt.AssetParam.freeze(pt.Txn.sender())


def test_asset_param_clawback():
    arg = pt.Int(1)
    expr = pt.AssetParam.clawback(arg)
    assert expr.type_of() == pt.TealType.none
    assert expr.value().type_of() == pt.TealType.bytes

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(arg, pt.Op.int, 1),
            pt.TealOp(expr, pt.Op.asset_params_get, "AssetClawback"),
            pt.TealOp(None, pt.Op.store, expr.slotOk),
            pt.TealOp(None, pt.Op.store, expr.slotValue),
        ]
    )

    actual, _ = expr.__teal__(avm2Options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    with pt.TealComponent.Context.ignoreExprEquality():
        assert actual == expected


def test_asset_param_clawback_direct_ref():
    arg = pt.Txn.assets[1]
    expr = pt.AssetParam.clawback(arg)
    assert expr.type_of() == pt.TealType.none
    assert expr.value().type_of() == pt.TealType.bytes

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(arg, pt.Op.txna, "Assets", 1),
            pt.TealOp(expr, pt.Op.asset_params_get, "AssetClawback"),
            pt.TealOp(None, pt.Op.store, expr.slotOk),
            pt.TealOp(None, pt.Op.store, expr.slotValue),
        ]
    )

    actual, _ = expr.__teal__(avm4Options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    with pt.TealComponent.Context.ignoreExprEquality():
        assert actual == expected


def test_asset_param_clawback_invalid():
    with pytest.raises(pt.TealTypeError):
        pt.AssetParam.clawback(pt.Txn.sender())


def test_asset_param_creator_valid():
    arg = pt.Int(1)
    expr = pt.AssetParam.creator(arg)
    assert expr.type_of() == pt.TealType.none
    assert expr.value().type_of() == pt.TealType.bytes

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(arg, pt.Op.int, 1),
            pt.TealOp(expr, pt.Op.asset_params_get, "AssetCreator"),
            pt.TealOp(None, pt.Op.store, expr.slotOk),
            pt.TealOp(None, pt.Op.store, expr.slotValue),
        ]
    )

    actual, _ = expr.__teal__(avm5Options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    with pt.TealComponent.Context.ignoreExprEquality():
        assert actual == expected


def test_asset_param_creator_invalid():
    with pytest.raises(pt.TealTypeError):
        pt.AssetParam.creator(pt.Txn.sender())


def test_AssetHoldingObject():
    for asset in (pt.Int(1), pt.Int(100)):
        for account in (
            pt.Int(7),
            pt.Addr("QSA6K5MNJPEGO5SDSWXBM3K4UEI3Q2NCPS2OUXVJI5QPCHMVI27MFRSHKI"),
        ):
            obj = pt.AssetHoldingObject(asset, account)

            assert obj._asset is asset
            assert obj._account is account

            assert_MaybeValue_equality(
                obj.balance(), pt.AssetHolding.balance(account, asset), avm5Options
            )
            assert_MaybeValue_equality(
                obj.frozen(), pt.AssetHolding.frozen(account, asset), avm5Options
            )


def test_AssetParamObject():
    for asset in (pt.Int(1), pt.Int(100)):
        obj = pt.AssetParamObject(asset)

        assert obj._asset is asset

        assert_MaybeValue_equality(obj.total(), pt.AssetParam.total(asset), avm5Options)
        assert_MaybeValue_equality(
            obj.decimals(), pt.AssetParam.decimals(asset), avm5Options
        )
        assert_MaybeValue_equality(
            obj.default_frozen(), pt.AssetParam.defaultFrozen(asset), avm5Options
        )
        assert_MaybeValue_equality(
            obj.unit_name(), pt.AssetParam.unitName(asset), avm5Options
        )
        assert_MaybeValue_equality(obj.name(), pt.AssetParam.name(asset), avm5Options)
        assert_MaybeValue_equality(obj.url(), pt.AssetParam.url(asset), avm5Options)
        assert_MaybeValue_equality(
            obj.metadata_hash(), pt.AssetParam.metadataHash(asset), avm5Options
        )
        assert_MaybeValue_equality(
            obj.manager_address(), pt.AssetParam.manager(asset), avm5Options
        )
        assert_MaybeValue_equality(
            obj.reserve_address(), pt.AssetParam.reserve(asset), avm5Options
        )
        assert_MaybeValue_equality(
            obj.freeze_address(), pt.AssetParam.freeze(asset), avm5Options
        )
        assert_MaybeValue_equality(
            obj.clawback_address(), pt.AssetParam.clawback(asset), avm5Options
        )
        assert_MaybeValue_equality(
            obj.creator_address(), pt.AssetParam.creator(asset), avm5Options
        )



================================================
FILE: pyteal/ast/base64decode.py
================================================
from typing import TYPE_CHECKING
from enum import Enum

from pyteal.types import TealType, require_type
from pyteal.errors import verifyFieldVersion
from pyteal.ir import TealOp, Op, TealBlock
from pyteal.ast.expr import Expr

if TYPE_CHECKING:
    from pyteal.compiler import CompileOptions


class Base64Encoding(Enum):
    # fmt: off
    #     id  |   name   | min version
    url = (0, "URLEncoding", 7)
    std = (1, "StdEncoding", 7)
    # fmt: on

    def __init__(self, id: int, name: str, min_version: int) -> None:
        self.id = id
        self.arg_name = name
        self.min_version = min_version


Base64Encoding.__module__ = "pyteal"


class Base64Decode(Expr):
    """An expression that decodes a base64-encoded byte string according to a specific encoding.

    See [RFC 4648](https://rfc-editor.org/rfc/rfc4648.html#section-4) (sections 4 and 5) for information on specifications.

    It is assumed that the encoding ends with the exact number of = padding characters as required by the RFC.
    When padding occurs, any unused pad bits in the encoding must be set to zero or the decoding will fail.
    The special cases of \\n and \\r are allowed but completely ignored. An error will result when attempting
    to decode a string with a character that is not in the encoding alphabet or not one of =, \\r, or \\n.

    NOTE:  Base64Decode usage is not intended for introducing constants. Instead, use :any:`Bytes`.
    """

    def __init__(self, encoding: Base64Encoding, base64: Expr) -> None:
        super().__init__()
        self.encoding = encoding

        require_type(base64, TealType.bytes)
        self.base64 = base64

    def __teal__(self, options: "CompileOptions"):
        verifyFieldVersion(
            self.encoding.arg_name, self.encoding.min_version, options.version
        )

        op = TealOp(self, Op.base64_decode, self.encoding.arg_name)
        return TealBlock.FromOp(options, op, self.base64)

    def __str__(self):
        return "(Base64Decode {})".format(self.encoding.arg_name)

    def type_of(self):
        return TealType.bytes

    def has_return(self):
        return False

    @classmethod
    def url(cls, base64: Expr) -> Expr:
        """Decode a base64-encoded byte string according to the URL encoding.

        Refer to the `Base64Decode` class documentation for more information.

        Args:
            base64: A base64-encoded byte string.
        """
        return cls(Base64Encoding.url, base64)

    @classmethod
    def std(cls, base64: Expr) -> Expr:
        """Decode a base64-encoded byte string according to the Standard encoding.

        Refer to the `Base64Decode` class documentation for more information.

        Args:
            base64: A base64-encoded byte string.
        """
        return cls(Base64Encoding.std, base64)


Base64Decode.__module__ = "pyteal"



================================================
FILE: pyteal/ast/base64decode_test.py
================================================
import pytest

import pyteal as pt

avm6Options = pt.CompileOptions(version=6)
avm7Options = pt.CompileOptions(version=7)


def test_base64decode_std():
    arg = pt.Bytes("aGVsbG8gd29ybGQ=")
    expr = pt.Base64Decode.std(arg)
    assert expr.type_of() == pt.TealType.bytes

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(arg, pt.Op.byte, '"aGVsbG8gd29ybGQ="'),
            pt.TealOp(expr, pt.Op.base64_decode, "StdEncoding"),
        ]
    )

    actual, _ = expr.__teal__(avm7Options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    assert actual == expected

    with pytest.raises(pt.TealInputError):
        expr.__teal__(avm6Options)


def test_base64decode_url():
    arg = pt.Bytes("aGVsbG8gd29ybGQ")
    expr = pt.Base64Decode.url(arg)
    assert expr.type_of() == pt.TealType.bytes

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(arg, pt.Op.byte, '"aGVsbG8gd29ybGQ"'),
            pt.TealOp(expr, pt.Op.base64_decode, "URLEncoding"),
        ]
    )

    actual, _ = expr.__teal__(avm7Options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    assert actual == expected

    with pytest.raises(pt.TealInputError):
        expr.__teal__(avm6Options)


def test_base64decode_invalid():
    with pytest.raises(pt.TealTypeError):
        pt.Base64Decode.std(pt.Int(0))
    with pytest.raises(pt.TealTypeError):
        pt.Base64Decode.url(pt.Int(0))



================================================
FILE: pyteal/ast/binaryexpr.py
================================================
from typing import Union, Tuple, cast, TYPE_CHECKING

from pyteal.types import TealType, require_type
from pyteal.errors import verifyProgramVersion
from pyteal.ir import TealOp, Op, TealBlock
from pyteal.ast.expr import Expr

if TYPE_CHECKING:
    from pyteal.compiler import CompileOptions


class BinaryExpr(Expr):
    """An expression with two arguments."""

    def __init__(
        self,
        op: Op,
        inputType: Union[TealType, Tuple[TealType, TealType]],
        outputType: TealType,
        argLeft: Expr,
        argRight: Expr,
    ) -> None:
        super().__init__()
        if type(inputType) is tuple:
            leftType, rightType = inputType
        else:
            leftType = cast(TealType, inputType)
            rightType = leftType
        require_type(argLeft, leftType)
        require_type(argRight, rightType)

        self.op = op
        self.outputType = outputType
        self.argLeft = argLeft
        self.argRight = argRight

    def __teal__(self, options: "CompileOptions"):
        verifyProgramVersion(
            self.op.min_version,
            options.version,
            "Program version too low to use op {}".format(self.op),
        )

        return TealBlock.FromOp(
            options, TealOp(self, self.op), self.argLeft, self.argRight
        )

    def __str__(self):
        return "({} {} {})".format(
            str(self.op).title().replace("_", ""), self.argLeft, self.argRight
        )

    def type_of(self):
        return self.outputType

    def has_return(self):
        return False


BinaryExpr.__module__ = "pyteal"


def Minus(left: Expr, right: Expr) -> Expr:
    """Subtract two numbers.

    Produces left - right.

    Args:
        left: Must evaluate to uint64.
        right: Must evaluate to uint64.
    """
    return BinaryExpr(Op.minus, TealType.uint64, TealType.uint64, left, right)


def Div(left: Expr, right: Expr) -> Expr:
    """Divide two numbers.

    Produces left / right.

    Args:
        left: Must evaluate to uint64.
        right: Must evaluate to uint64.
    """
    return BinaryExpr(Op.div, TealType.uint64, TealType.uint64, left, right)


def Mod(left: Expr, right: Expr) -> Expr:
    """Modulo expression.

    Produces left % right.

    Args:
        left: Must evaluate to uint64.
        right: Must evaluate to uint64.
    """
    return BinaryExpr(Op.mod, TealType.uint64, TealType.uint64, left, right)


def Exp(a: Expr, b: Expr) -> Expr:
    """Exponential expression.

    Produces a ** b.

    Requires program version 4 or higher.

    Args:
        a: Must evaluate to uint64.
        b: Must evaluate to uint64.
    """
    return BinaryExpr(Op.exp, TealType.uint64, TealType.uint64, a, b)


def BitwiseAnd(left: Expr, right: Expr) -> Expr:
    """Bitwise and expression.

    Produces left & right.

    Args:
        left: Must evaluate to uint64.
        right: Must evaluate to uint64.
    """
    return BinaryExpr(Op.bitwise_and, TealType.uint64, TealType.uint64, left, right)


def BitwiseOr(left: Expr, right: Expr) -> Expr:
    """Bitwise or expression.

    Produces left | right.

    Args:
        left: Must evaluate to uint64.
        right: Must evaluate to uint64.
    """
    return BinaryExpr(Op.bitwise_or, TealType.uint64, TealType.uint64, left, right)


def BitwiseXor(left: Expr, right: Expr) -> Expr:
    """Bitwise xor expression.

    Produces left ^ right.

    Args:
        left: Must evaluate to uint64.
        right: Must evaluate to uint64.
    """
    return BinaryExpr(Op.bitwise_xor, TealType.uint64, TealType.uint64, left, right)


def ShiftLeft(a: Expr, b: Expr) -> Expr:
    """Bitwise left shift expression.

    Produces a << b. This is equivalent to a times 2^b, modulo 2^64.

    Requires program version 4 or higher.

    Args:
        a: Must evaluate to uint64.
        b: Must evaluate to uint64.
    """
    return BinaryExpr(Op.shl, TealType.uint64, TealType.uint64, a, b)


def ShiftRight(a: Expr, b: Expr) -> Expr:
    """Bitwise right shift expression.

    Produces a >> b. This is equivalent to a divided by 2^b.

    Requires program version 4 or higher.

    Args:
        a: Must evaluate to uint64.
        b: Must evaluate to uint64.
    """
    return BinaryExpr(Op.shr, TealType.uint64, TealType.uint64, a, b)


def Eq(left: Expr, right: Expr) -> Expr:
    """Equality expression.

    Checks if left == right.

    Args:
        left: A value to check.
        right: The other value to check. Must evaluate to the same type as left.
    """
    return BinaryExpr(Op.eq, right.type_of(), TealType.uint64, left, right)


def Neq(left: Expr, right: Expr) -> Expr:
    """Difference expression.

    Checks if left != right.

    Args:
        left: A value to check.
        right: The other value to check. Must evaluate to the same type as left.
    """
    return BinaryExpr(Op.neq, right.type_of(), TealType.uint64, left, right)


def Lt(left: Expr, right: Expr) -> Expr:
    """Less than expression.

    Checks if left < right.

    Args:
        left: Must evaluate to uint64.
        right: Must evaluate to uint64.
    """
    return BinaryExpr(Op.lt, TealType.uint64, TealType.uint64, left, right)


def Le(left: Expr, right: Expr) -> Expr:
    """Less than or equal to expression.

    Checks if left <= right.

    Args:
        left: Must evaluate to uint64.
        right: Must evaluate to uint64.
    """
    return BinaryExpr(Op.le, TealType.uint64, TealType.uint64, left, right)


def Gt(left: Expr, right: Expr) -> Expr:
    """Greater than expression.

    Checks if left > right.

    Args:
        left: Must evaluate to uint64.
        right: Must evaluate to uint64.
    """
    return BinaryExpr(Op.gt, TealType.uint64, TealType.uint64, left, right)


def Ge(left: Expr, right: Expr) -> Expr:
    """Greater than or equal to expression.

    Checks if left >= right.

    Args:
        left: Must evaluate to uint64.
        right: Must evaluate to uint64.
    """
    return BinaryExpr(Op.ge, TealType.uint64, TealType.uint64, left, right)


def GetBit(value: Expr, index: Expr) -> Expr:
    """Get the bit value of an expression at a specific index.

    The meaning of index differs if value is an integer or a byte string.

    * For integers, bit indexing begins with low-order bits. For example, :code:`GetBit(Int(16), Int(4))`
      yields 1. Any other valid index would yield a bit value of 0. Any integer less than 64 is a
      valid index.

    * For byte strings, bit indexing begins at the first byte. For example, :code:`GetBit(Bytes("base16", "0xf0"), Int(0))`
      yields 1. Any index less than 4 would yield 1, and any valid index 4 or greater would yield 0.
      Any integer less than 8*Len(value) is a valid index.

    Requires program version 3 or higher.

    Args:
        value: The value containing bits. Can evaluate to any type.
        index: The index of the bit to extract. Must evaluate to uint64.
    """
    return BinaryExpr(
        Op.getbit, (TealType.anytype, TealType.uint64), TealType.uint64, value, index
    )


def GetByte(value: Expr, index: Expr) -> Expr:
    """Extract a single byte as an integer from a byte string.

    Similar to GetBit, indexing begins at the first byte. For example, :code:`GetByte(Bytes("base16", "0xff0000"), Int(0))`
    yields 255. Any other valid index would yield 0.

    Requires program version 3 or higher.

    Args:
        value: The value containing the bytes. Must evaluate to bytes.
        index: The index of the byte to extract. Must evaluate to an integer less than Len(value).
    """
    return BinaryExpr(
        Op.getbyte, (TealType.bytes, TealType.uint64), TealType.uint64, value, index
    )


def BytesAdd(left: Expr, right: Expr) -> Expr:
    """Add two numbers as bytes.

    Produces left + right, where left and right are interpreted as big-endian unsigned integers.
    Arguments must not exceed 64 bytes.

    Requires program version 4 or higher.

    Args:
        left: Must evaluate to bytes.
        right: Must evaluate to bytes.
    """
    return BinaryExpr(Op.b_add, TealType.bytes, TealType.bytes, left, right)


def BytesMinus(left: Expr, right: Expr) -> Expr:
    """Subtract two numbers as bytes.

    Produces left - right, where left and right are interpreted as big-endian unsigned integers.
    Arguments must not exceed 64 bytes.

    Requires program version 4 or higher.

    Args:
        left: Must evaluate to bytes.
        right: Must evaluate to bytes.
    """
    return BinaryExpr(Op.b_minus, TealType.bytes, TealType.bytes, left, right)


def BytesDiv(left: Expr, right: Expr) -> Expr:
    """Divide two numbers as bytes.

    Produces left / right, where left and right are interpreted as big-endian unsigned integers.
    Arguments must not exceed 64 bytes.

    Panics if right is 0.

    Requires program version 4 or higher.

    Args:
        left: Must evaluate to bytes.
        right: Must evaluate to bytes.
    """
    return BinaryExpr(Op.b_div, TealType.bytes, TealType.bytes, left, right)


def BytesMul(left: Expr, right: Expr) -> Expr:
    """Multiply two numbers as bytes.

    Produces left * right, where left and right are interpreted as big-endian unsigned integers.
    Arguments must not exceed 64 bytes.

    Requires program version 4 or higher.

    Args:
        left: Must evaluate to bytes.
        right: Must evaluate to bytes.
    """
    return BinaryExpr(Op.b_mul, TealType.bytes, TealType.bytes, left, right)


def BytesMod(left: Expr, right: Expr) -> Expr:
    """Modulo expression with bytes as arguments.

    Produces left % right, where left and right are interpreted as big-endian unsigned integers.
    Arguments must not exceed 64 bytes.

    Panics if right is 0.

    Requires program version 4 or higher.

    Args:
        left: Must evaluate to bytes.
        right: Must evaluate to bytes.
    """
    return BinaryExpr(Op.b_mod, TealType.bytes, TealType.bytes, left, right)


def BytesAnd(left: Expr, right: Expr) -> Expr:
    """Bitwise and expression with bytes as arguments.

    Produces left & right.
    Left and right are zero-left extended to the greater of their lengths.
    Arguments must not exceed 64 bytes.

    Requires program version 4 or higher.

    Args:
        left: Must evaluate to bytes.
        right: Must evaluate to bytes.
    """
    return BinaryExpr(Op.b_and, TealType.bytes, TealType.bytes, left, right)


def BytesOr(left: Expr, right: Expr) -> Expr:
    """Bitwise or expression with bytes as arguments.

    Produces left | right.
    Left and right are zero-left extended to the greater of their lengths.
    Arguments must not exceed 64 bytes.

    Requires program version 4 or higher.

    Args:
        left: Must evaluate to bytes.
        right: Must evaluate to bytes.
    """
    return BinaryExpr(Op.b_or, TealType.bytes, TealType.bytes, left, right)


def BytesXor(left: Expr, right: Expr) -> Expr:
    """Bitwise xor expression with bytes as arguments.

    Produces left ^ right.
    Left and right are zero-left extended to the greater of their lengths.
    Arguments must not exceed 64 bytes.

    Requires program version 4 or higher.

    Args:
        left: Must evaluate to bytes.
        right: Must evaluate to bytes.
    """
    return BinaryExpr(Op.b_xor, TealType.bytes, TealType.bytes, left, right)


def BytesEq(left: Expr, right: Expr) -> Expr:
    """Equality expression with bytes as arguments.

    Checks if left == right, where left and right are interpreted as big-endian unsigned integers.
    Arguments must not exceed 64 bytes.

    Requires program version 4 or higher.

    Args:
        left: Must evaluate to bytes.
        right: Must evaluate to bytes.
    """
    return BinaryExpr(Op.b_eq, TealType.bytes, TealType.uint64, left, right)


def BytesNeq(left: Expr, right: Expr) -> Expr:
    """Difference expression with bytes as arguments.

    Checks if left != right, where left and right are interpreted as big-endian unsigned integers.
    Arguments must not exceed 64 bytes.

    Requires program version 4 or higher.

    Args:
        left: Must evaluate to bytes.
        right: Must evaluate to bytes.
    """
    return BinaryExpr(Op.b_neq, TealType.bytes, TealType.uint64, left, right)


def BytesLt(left: Expr, right: Expr) -> Expr:
    """Less than expression with bytes as arguments.

    Checks if left < right, where left and right are interpreted as big-endian unsigned integers.
    Arguments must not exceed 64 bytes.

    Requires program version 4 or higher.

    Args:
        left: Must evaluate to bytes.
        right: Must evaluate to bytes.
    """
    return BinaryExpr(Op.b_lt, TealType.bytes, TealType.uint64, left, right)


def BytesLe(left: Expr, right: Expr) -> Expr:
    """Less than or equal to expression with bytes as arguments.

    Checks if left <= right, where left and right are interpreted as big-endian unsigned integers.
    Arguments must not exceed 64 bytes.

    Requires program version 4 or higher.

    Args:
        left: Must evaluate to bytes.
        right: Must evaluate to bytes.
    """
    return BinaryExpr(Op.b_le, TealType.bytes, TealType.uint64, left, right)


def BytesGt(left: Expr, right: Expr) -> Expr:
    """Greater than expression with bytes as arguments.

    Checks if left > right, where left and right are interpreted as big-endian unsigned integers.
    Arguments must not exceed 64 bytes.

    Requires program version 4 or higher.

    Args:
        left: Must evaluate to bytes.
        right: Must evaluate to bytes.
    """
    return BinaryExpr(Op.b_gt, TealType.bytes, TealType.uint64, left, right)


def BytesGe(left: Expr, right: Expr) -> Expr:
    """Greater than or equal to expression with bytes as arguments.

    Checks if left >= right, where left and right are interpreted as big-endian unsigned integers.
    Arguments must not exceed 64 bytes.

    Requires program version 4 or higher.

    Args:
        left: Must evaluate to bytes.
        right: Must evaluate to bytes.
    """
    return BinaryExpr(Op.b_ge, TealType.bytes, TealType.uint64, left, right)


def ExtractUint16(string: Expr, offset: Expr) -> Expr:
    """Extract 2 bytes (16 bits) and convert them to an integer.

    The bytes starting at :code:`offset` up to but not including :code:`offset + 2` will be
    interpreted as a big-endian unsigned integer.

    If :code:`offset + 2` exceeds :code:`Len(string)`, the program fails.

    Requires program version 5 or higher.

    Args:
        string: The bytestring to extract from. Must evaluate to bytes.
        offset: The offset in the bytestring to start extracing. Must evaluate to uint64.
    """
    return BinaryExpr(
        Op.extract_uint16,
        (TealType.bytes, TealType.uint64),
        TealType.uint64,
        string,
        offset,
    )


def ExtractUint32(string: Expr, offset: Expr) -> Expr:
    """Extract 4 bytes (32 bits) and convert them to an integer.

    The bytes starting at :code:`offset` up to but not including :code:`offset + 4` will be
    interpreted as a big-endian unsigned integer.

    If :code:`offset + 4` exceeds :code:`Len(string)`, the program fails.

    Requires program version 5 or higher.

    Args:
        string: The bytestring to extract from. Must evaluate to bytes.
        offset: The offset in the bytestring to start extracing. Must evaluate to uint64.
    """
    return BinaryExpr(
        Op.extract_uint32,
        (TealType.bytes, TealType.uint64),
        TealType.uint64,
        string,
        offset,
    )


def ExtractUint64(string: Expr, offset: Expr) -> Expr:
    """Extract 8 bytes (64 bits) and convert them to an integer.

    The bytes starting at :code:`offset` up to but not including :code:`offset + 8` will be
    interpreted as a big-endian unsigned integer.

    If :code:`offset + 8` exceeds :code:`Len(string)`, the program fails.

    Requires program version 5 or higher.

    Args:
        string: The bytestring to extract from. Must evaluate to bytes.
        offset: The offset in the bytestring to start extracing. Must evaluate to uint64.
    """
    return BinaryExpr(
        Op.extract_uint64,
        (TealType.bytes, TealType.uint64),
        TealType.uint64,
        string,
        offset,
    )



================================================
FILE: pyteal/ast/binaryexpr_test.py
================================================
import pytest

import pyteal as pt

avm2Options = pt.CompileOptions(version=2)
avm3Options = pt.CompileOptions(version=3)
avm4Options = pt.CompileOptions(version=4)
avm5Options = pt.CompileOptions(version=5)


def test_add():
    args = [pt.Int(2), pt.Int(3)]
    expr = pt.Add(args[0], args[1])
    assert expr.type_of() == pt.TealType.uint64

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(args[0], pt.Op.int, 2),
            pt.TealOp(args[1], pt.Op.int, 3),
            pt.TealOp(expr, pt.Op.add),
        ]
    )

    actual, _ = expr.__teal__(avm2Options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    assert actual == expected


def test_add_overload():
    args = [pt.Int(2), pt.Int(3), pt.Int(4)]
    expr = args[0] + args[1] + args[2]
    assert expr.type_of() == pt.TealType.uint64

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(args[0], pt.Op.int, 2),
            pt.TealOp(args[1], pt.Op.int, 3),
            pt.TealOp(None, pt.Op.add),
            pt.TealOp(args[2], pt.Op.int, 4),
            pt.TealOp(None, pt.Op.add),
        ]
    )

    actual, _ = expr.__teal__(avm2Options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    with pt.TealComponent.Context.ignoreExprEquality():
        assert actual == expected


def test_add_invalid():
    with pytest.raises(pt.TealTypeError):
        pt.Add(pt.Int(2), pt.Txn.receiver())

    with pytest.raises(pt.TealTypeError):
        pt.Add(pt.Txn.sender(), pt.Int(2))


def test_minus():
    args = [pt.Int(5), pt.Int(6)]
    expr = pt.Minus(args[0], args[1])
    assert expr.type_of() == pt.TealType.uint64

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(args[0], pt.Op.int, 5),
            pt.TealOp(args[1], pt.Op.int, 6),
            pt.TealOp(expr, pt.Op.minus),
        ]
    )

    actual, _ = expr.__teal__(avm2Options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    assert actual == expected


def test_minus_overload():
    args = [pt.Int(10), pt.Int(1), pt.Int(2)]
    expr = args[0] - args[1] - args[2]
    assert expr.type_of() == pt.TealType.uint64

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(args[0], pt.Op.int, 10),
            pt.TealOp(args[1], pt.Op.int, 1),
            pt.TealOp(None, pt.Op.minus),
            pt.TealOp(args[2], pt.Op.int, 2),
            pt.TealOp(None, pt.Op.minus),
        ]
    )

    actual, _ = expr.__teal__(avm2Options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    with pt.TealComponent.Context.ignoreExprEquality():
        assert actual == expected


def test_minus_invalid():
    with pytest.raises(pt.TealTypeError):
        pt.Minus(pt.Int(2), pt.Txn.receiver())

    with pytest.raises(pt.TealTypeError):
        pt.Minus(pt.Txn.sender(), pt.Int(2))


def test_mul():
    args = [pt.Int(3), pt.Int(8)]
    expr = pt.Mul(args[0], args[1])
    assert expr.type_of() == pt.TealType.uint64

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(args[0], pt.Op.int, 3),
            pt.TealOp(args[1], pt.Op.int, 8),
            pt.TealOp(expr, pt.Op.mul),
        ]
    )

    actual, _ = expr.__teal__(avm2Options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    assert actual == expected


def test_mul_overload():
    args = [pt.Int(3), pt.Int(8), pt.Int(10)]
    expr = args[0] * args[1] * args[2]
    assert expr.type_of() == pt.TealType.uint64

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(args[0], pt.Op.int, 3),
            pt.TealOp(args[1], pt.Op.int, 8),
            pt.TealOp(None, pt.Op.mul),
            pt.TealOp(args[2], pt.Op.int, 10),
            pt.TealOp(None, pt.Op.mul),
        ]
    )

    actual, _ = expr.__teal__(avm2Options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    with pt.TealComponent.Context.ignoreExprEquality():
        assert actual == expected


def test_mul_invalid():
    with pytest.raises(pt.TealTypeError):
        pt.Mul(pt.Int(2), pt.Txn.receiver())

    with pytest.raises(pt.TealTypeError):
        pt.Mul(pt.Txn.sender(), pt.Int(2))


def test_div():
    args = [pt.Int(9), pt.Int(3)]
    expr = pt.Div(args[0], args[1])
    assert expr.type_of() == pt.TealType.uint64

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(args[0], pt.Op.int, 9),
            pt.TealOp(args[1], pt.Op.int, 3),
            pt.TealOp(expr, pt.Op.div),
        ]
    )

    actual, _ = expr.__teal__(avm2Options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    assert actual == expected


def test_div_overload():
    args = [pt.Int(9), pt.Int(3), pt.Int(3)]
    expr = args[0] / args[1] / args[2]
    assert expr.type_of() == pt.TealType.uint64

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(args[0], pt.Op.int, 9),
            pt.TealOp(args[1], pt.Op.int, 3),
            pt.TealOp(None, pt.Op.div),
            pt.TealOp(args[2], pt.Op.int, 3),
            pt.TealOp(None, pt.Op.div),
        ]
    )

    actual, _ = expr.__teal__(avm2Options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    with pt.TealComponent.Context.ignoreExprEquality():
        assert actual == expected


def test_div_invalid():
    with pytest.raises(pt.TealTypeError):
        pt.Div(pt.Int(2), pt.Txn.receiver())

    with pytest.raises(pt.TealTypeError):
        pt.Div(pt.Txn.sender(), pt.Int(2))


def test_mod():
    args = [pt.Int(10), pt.Int(9)]
    expr = pt.Mod(args[0], args[1])
    assert expr.type_of() == pt.TealType.uint64

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(args[0], pt.Op.int, 10),
            pt.TealOp(args[1], pt.Op.int, 9),
            pt.TealOp(expr, pt.Op.mod),
        ]
    )

    actual, _ = expr.__teal__(avm2Options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    assert actual == expected


def test_mod_overload():
    args = [pt.Int(10), pt.Int(9), pt.Int(100)]
    expr = args[0] % args[1] % args[2]
    assert expr.type_of() == pt.TealType.uint64

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(args[0], pt.Op.int, 10),
            pt.TealOp(args[1], pt.Op.int, 9),
            pt.TealOp(None, pt.Op.mod),
            pt.TealOp(args[2], pt.Op.int, 100),
            pt.TealOp(None, pt.Op.mod),
        ]
    )

    actual, _ = expr.__teal__(avm2Options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    with pt.TealComponent.Context.ignoreExprEquality():
        assert actual == expected


def test_mod_invalid():
    with pytest.raises(pt.TealTypeError):
        pt.Mod(pt.Txn.receiver(), pt.Int(2))

    with pytest.raises(pt.TealTypeError):
        pt.Mod(pt.Int(2), pt.Txn.sender())


def test_exp():
    args = [pt.Int(2), pt.Int(9)]
    expr = pt.Exp(args[0], args[1])
    assert expr.type_of() == pt.TealType.uint64

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(args[0], pt.Op.int, 2),
            pt.TealOp(args[1], pt.Op.int, 9),
            pt.TealOp(expr, pt.Op.exp),
        ]
    )

    actual, _ = expr.__teal__(avm4Options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    assert actual == expected

    with pytest.raises(pt.TealInputError):
        expr.__teal__(avm3Options)


def test_exp_overload():
    args = [pt.Int(2), pt.Int(3), pt.Int(1)]
    # this is equivalent to args[0] ** (args[1] ** args[2])
    expr = args[0] ** args[1] ** args[2]
    assert expr.type_of() == pt.TealType.uint64

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(args[0], pt.Op.int, 2),
            pt.TealOp(args[1], pt.Op.int, 3),
            pt.TealOp(args[2], pt.Op.int, 1),
            pt.TealOp(None, pt.Op.exp),
            pt.TealOp(None, pt.Op.exp),
        ]
    )

    actual, _ = expr.__teal__(avm4Options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    with pt.TealComponent.Context.ignoreExprEquality():
        assert actual == expected

    with pytest.raises(pt.TealInputError):
        expr.__teal__(avm3Options)


def test_exp_invalid():
    with pytest.raises(pt.TealTypeError):
        pt.Exp(pt.Txn.receiver(), pt.Int(2))

    with pytest.raises(pt.TealTypeError):
        pt.Exp(pt.Int(2), pt.Txn.sender())


def test_arithmetic():
    args = [pt.Int(2), pt.Int(3), pt.Int(5), pt.Int(6), pt.Int(8), pt.Int(9)]
    v = ((args[0] + args[1]) / ((args[2] - args[3]) * args[4])) % args[5]
    assert v.type_of() == pt.TealType.uint64

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(args[0], pt.Op.int, 2),
            pt.TealOp(args[1], pt.Op.int, 3),
            pt.TealOp(None, pt.Op.add),
            pt.TealOp(args[2], pt.Op.int, 5),
            pt.TealOp(args[3], pt.Op.int, 6),
            pt.TealOp(None, pt.Op.minus),
            pt.TealOp(args[4], pt.Op.int, 8),
            pt.TealOp(None, pt.Op.mul),
            pt.TealOp(None, pt.Op.div),
            pt.TealOp(args[5], pt.Op.int, 9),
            pt.TealOp(None, pt.Op.mod),
        ]
    )

    actual, _ = v.__teal__(avm2Options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    with pt.TealComponent.Context.ignoreExprEquality():
        assert actual == expected


def test_bitwise_and():
    args = [pt.Int(1), pt.Int(2)]
    expr = pt.BitwiseAnd(args[0], args[1])
    assert expr.type_of() == pt.TealType.uint64

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(args[0], pt.Op.int, 1),
            pt.TealOp(args[1], pt.Op.int, 2),
            pt.TealOp(expr, pt.Op.bitwise_and),
        ]
    )

    actual, _ = expr.__teal__(avm2Options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    assert actual == expected


def test_bitwise_and_overload():
    args = [pt.Int(1), pt.Int(2), pt.Int(4)]
    expr = args[0] & args[1] & args[2]
    assert expr.type_of() == pt.TealType.uint64

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(args[0], pt.Op.int, 1),
            pt.TealOp(args[1], pt.Op.int, 2),
            pt.TealOp(None, pt.Op.bitwise_and),
            pt.TealOp(args[2], pt.Op.int, 4),
            pt.TealOp(None, pt.Op.bitwise_and),
        ]
    )

    actual, _ = expr.__teal__(avm2Options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    with pt.TealComponent.Context.ignoreExprEquality():
        assert actual == expected


def test_bitwise_and_invalid():
    with pytest.raises(pt.TealTypeError):
        pt.BitwiseAnd(pt.Int(2), pt.Txn.receiver())

    with pytest.raises(pt.TealTypeError):
        pt.BitwiseAnd(pt.Txn.sender(), pt.Int(2))


def test_bitwise_or():
    args = [pt.Int(1), pt.Int(2)]
    expr = pt.BitwiseOr(args[0], args[1])
    assert expr.type_of() == pt.TealType.uint64

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(args[0], pt.Op.int, 1),
            pt.TealOp(args[1], pt.Op.int, 2),
            pt.TealOp(expr, pt.Op.bitwise_or),
        ]
    )

    actual, _ = expr.__teal__(avm2Options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    assert actual == expected


def test_bitwise_or_overload():
    args = [pt.Int(1), pt.Int(2), pt.Int(4)]
    expr = args[0] | args[1] | args[2]
    assert expr.type_of() == pt.TealType.uint64

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(args[0], pt.Op.int, 1),
            pt.TealOp(args[1], pt.Op.int, 2),
            pt.TealOp(None, pt.Op.bitwise_or),
            pt.TealOp(args[2], pt.Op.int, 4),
            pt.TealOp(None, pt.Op.bitwise_or),
        ]
    )

    actual, _ = expr.__teal__(avm2Options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    with pt.TealComponent.Context.ignoreExprEquality():
        assert actual == expected


def test_bitwise_or_invalid():
    with pytest.raises(pt.TealTypeError):
        pt.BitwiseOr(pt.Int(2), pt.Txn.receiver())

    with pytest.raises(pt.TealTypeError):
        pt.BitwiseOr(pt.Txn.sender(), pt.Int(2))


def test_bitwise_xor():
    args = [pt.Int(1), pt.Int(3)]
    expr = pt.BitwiseXor(args[0], args[1])
    assert expr.type_of() == pt.TealType.uint64

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(args[0], pt.Op.int, 1),
            pt.TealOp(args[1], pt.Op.int, 3),
            pt.TealOp(expr, pt.Op.bitwise_xor),
        ]
    )

    actual, _ = expr.__teal__(avm2Options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    assert actual == expected


def test_bitwise_xor_overload():
    args = [pt.Int(1), pt.Int(3), pt.Int(5)]
    expr = args[0] ^ args[1] ^ args[2]
    assert expr.type_of() == pt.TealType.uint64

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(args[0], pt.Op.int, 1),
            pt.TealOp(args[1], pt.Op.int, 3),
            pt.TealOp(None, pt.Op.bitwise_xor),
            pt.TealOp(args[2], pt.Op.int, 5),
            pt.TealOp(None, pt.Op.bitwise_xor),
        ]
    )

    actual, _ = expr.__teal__(avm2Options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    with pt.TealComponent.Context.ignoreExprEquality():
        assert actual == expected


def test_bitwise_xor_invalid():
    with pytest.raises(pt.TealTypeError):
        pt.BitwiseXor(pt.Int(2), pt.Txn.receiver())

    with pytest.raises(pt.TealTypeError):
        pt.BitwiseXor(pt.Txn.sender(), pt.Int(2))


def test_shift_left():
    args = [pt.Int(5), pt.Int(1)]
    expr = pt.ShiftLeft(args[0], args[1])
    assert expr.type_of() == pt.TealType.uint64

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(args[0], pt.Op.int, 5),
            pt.TealOp(args[1], pt.Op.int, 1),
            pt.TealOp(expr, pt.Op.shl),
        ]
    )

    actual, _ = expr.__teal__(avm4Options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    assert actual == expected

    with pytest.raises(pt.TealInputError):
        expr.__teal__(avm3Options)


def test_shift_left_overload():
    args = [pt.Int(5), pt.Int(1), pt.Int(2)]
    expr = args[0] << args[1] << args[2]
    assert expr.type_of() == pt.TealType.uint64

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(args[0], pt.Op.int, 5),
            pt.TealOp(args[1], pt.Op.int, 1),
            pt.TealOp(None, pt.Op.shl),
            pt.TealOp(args[2], pt.Op.int, 2),
            pt.TealOp(None, pt.Op.shl),
        ]
    )

    actual, _ = expr.__teal__(avm4Options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    with pt.TealComponent.Context.ignoreExprEquality():
        assert actual == expected

    with pytest.raises(pt.TealInputError):
        expr.__teal__(avm3Options)


def test_shift_left_invalid():
    with pytest.raises(pt.TealTypeError):
        pt.ShiftLeft(pt.Int(2), pt.Txn.receiver())

    with pytest.raises(pt.TealTypeError):
        pt.ShiftLeft(pt.Txn.sender(), pt.Int(2))


def test_shift_right():
    args = [pt.Int(5), pt.Int(1)]
    expr = pt.ShiftRight(args[0], args[1])
    assert expr.type_of() == pt.TealType.uint64

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(args[0], pt.Op.int, 5),
            pt.TealOp(args[1], pt.Op.int, 1),
            pt.TealOp(expr, pt.Op.shr),
        ]
    )

    actual, _ = expr.__teal__(avm4Options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    assert actual == expected

    with pytest.raises(pt.TealInputError):
        expr.__teal__(avm3Options)


def test_shift_right_overload():
    args = [pt.Int(5), pt.Int(1), pt.Int(2)]
    expr = args[0] >> args[1] >> args[2]
    assert expr.type_of() == pt.TealType.uint64

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(args[0], pt.Op.int, 5),
            pt.TealOp(args[1], pt.Op.int, 1),
            pt.TealOp(None, pt.Op.shr),
            pt.TealOp(args[2], pt.Op.int, 2),
            pt.TealOp(None, pt.Op.shr),
        ]
    )

    actual, _ = expr.__teal__(avm4Options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    with pt.TealComponent.Context.ignoreExprEquality():
        assert actual == expected

    with pytest.raises(pt.TealInputError):
        expr.__teal__(avm3Options)


def test_shift_right_invalid():
    with pytest.raises(pt.TealTypeError):
        pt.ShiftRight(pt.Int(2), pt.Txn.receiver())

    with pytest.raises(pt.TealTypeError):
        pt.ShiftRight(pt.Txn.sender(), pt.Int(2))


def test_eq():
    args_int = [pt.Int(2), pt.Int(3)]
    expr_int = pt.Eq(args_int[0], args_int[1])
    assert expr_int.type_of() == pt.TealType.uint64

    expected_int = pt.TealSimpleBlock(
        [
            pt.TealOp(args_int[0], pt.Op.int, 2),
            pt.TealOp(args_int[1], pt.Op.int, 3),
            pt.TealOp(expr_int, pt.Op.eq),
        ]
    )

    actual_int, _ = expr_int.__teal__(avm2Options)
    actual_int.addIncoming()
    actual_int = pt.TealBlock.NormalizeBlocks(actual_int)

    assert actual_int == expected_int

    args_bytes = [pt.Txn.receiver(), pt.Txn.sender()]
    expr_bytes = pt.Eq(args_bytes[0], args_bytes[1])
    assert expr_bytes.type_of() == pt.TealType.uint64

    expected_bytes = pt.TealSimpleBlock(
        [
            pt.TealOp(args_bytes[0], pt.Op.txn, "Receiver"),
            pt.TealOp(args_bytes[1], pt.Op.txn, "Sender"),
            pt.TealOp(expr_bytes, pt.Op.eq),
        ]
    )

    actual_bytes, _ = expr_bytes.__teal__(avm2Options)
    actual_bytes.addIncoming()
    actual_bytes = pt.TealBlock.NormalizeBlocks(actual_bytes)

    assert actual_bytes == expected_bytes


def test_eq_overload():
    args_int = [pt.Int(2), pt.Int(3)]
    expr_int = args_int[0] == args_int[1]
    assert expr_int.type_of() == pt.TealType.uint64

    expected_int = pt.TealSimpleBlock(
        [
            pt.TealOp(args_int[0], pt.Op.int, 2),
            pt.TealOp(args_int[1], pt.Op.int, 3),
            pt.TealOp(expr_int, pt.Op.eq),
        ]
    )

    actual_int, _ = expr_int.__teal__(avm2Options)
    actual_int.addIncoming()
    actual_int = pt.TealBlock.NormalizeBlocks(actual_int)

    assert actual_int == expected_int

    args_bytes = [pt.Txn.receiver(), pt.Txn.sender()]
    expr_bytes = args_bytes[0] == args_bytes[1]
    assert expr_bytes.type_of() == pt.TealType.uint64

    expected_bytes = pt.TealSimpleBlock(
        [
            pt.TealOp(args_bytes[0], pt.Op.txn, "Receiver"),
            pt.TealOp(args_bytes[1], pt.Op.txn, "Sender"),
            pt.TealOp(expr_bytes, pt.Op.eq),
        ]
    )

    actual_bytes, _ = expr_bytes.__teal__(avm2Options)
    actual_bytes.addIncoming()
    actual_bytes = pt.TealBlock.NormalizeBlocks(actual_bytes)

    assert actual_bytes == expected_bytes


def test_eq_invalid():
    with pytest.raises(pt.TealTypeError):
        pt.Eq(pt.Txn.fee(), pt.Txn.receiver())

    with pytest.raises(pt.TealTypeError):
        pt.Eq(pt.Txn.sender(), pt.Int(7))


def test_neq():
    args_int = [pt.Int(2), pt.Int(3)]
    expr_int = pt.Neq(args_int[0], args_int[1])
    assert expr_int.type_of() == pt.TealType.uint64

    expected_int = pt.TealSimpleBlock(
        [
            pt.TealOp(args_int[0], pt.Op.int, 2),
            pt.TealOp(args_int[1], pt.Op.int, 3),
            pt.TealOp(expr_int, pt.Op.neq),
        ]
    )

    actual_int, _ = expr_int.__teal__(avm2Options)
    actual_int.addIncoming()
    actual_int = pt.TealBlock.NormalizeBlocks(actual_int)

    assert actual_int == expected_int

    args_bytes = [pt.Txn.receiver(), pt.Txn.sender()]
    expr_bytes = pt.Neq(args_bytes[0], args_bytes[1])
    assert expr_bytes.type_of() == pt.TealType.uint64

    expected_bytes = pt.TealSimpleBlock(
        [
            pt.TealOp(args_bytes[0], pt.Op.txn, "Receiver"),
            pt.TealOp(args_bytes[1], pt.Op.txn, "Sender"),
            pt.TealOp(expr_bytes, pt.Op.neq),
        ]
    )

    actual_bytes, _ = expr_bytes.__teal__(avm2Options)
    actual_bytes.addIncoming()
    actual_bytes = pt.TealBlock.NormalizeBlocks(actual_bytes)

    assert actual_bytes == expected_bytes


def test_neq_overload():
    args_int = [pt.Int(2), pt.Int(3)]
    expr_int = args_int[0] != args_int[1]
    assert expr_int.type_of() == pt.TealType.uint64

    expected_int = pt.TealSimpleBlock(
        [
            pt.TealOp(args_int[0], pt.Op.int, 2),
            pt.TealOp(args_int[1], pt.Op.int, 3),
            pt.TealOp(expr_int, pt.Op.neq),
        ]
    )

    actual_int, _ = expr_int.__teal__(avm2Options)
    actual_int.addIncoming()
    actual_int = pt.TealBlock.NormalizeBlocks(actual_int)

    assert actual_int == expected_int

    args_bytes = [pt.Txn.receiver(), pt.Txn.sender()]
    expr_bytes = args_bytes[0] != args_bytes[1]
    assert expr_bytes.type_of() == pt.TealType.uint64

    expected_bytes = pt.TealSimpleBlock(
        [
            pt.TealOp(args_bytes[0], pt.Op.txn, "Receiver"),
            pt.TealOp(args_bytes[1], pt.Op.txn, "Sender"),
            pt.TealOp(expr_bytes, pt.Op.neq),
        ]
    )

    actual_bytes, _ = expr_bytes.__teal__(avm2Options)
    actual_bytes.addIncoming()
    actual_bytes = pt.TealBlock.NormalizeBlocks(actual_bytes)

    assert actual_bytes == expected_bytes


def test_neq_invalid():
    with pytest.raises(pt.TealTypeError):
        pt.Neq(pt.Txn.fee(), pt.Txn.receiver())

    with pytest.raises(pt.TealTypeError):
        pt.Neq(pt.Txn.sender(), pt.Int(7))


def test_lt():
    args = [pt.Int(2), pt.Int(3)]
    expr = pt.Lt(args[0], args[1])
    assert expr.type_of() == pt.TealType.uint64

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(args[0], pt.Op.int, 2),
            pt.TealOp(args[1], pt.Op.int, 3),
            pt.TealOp(expr, pt.Op.lt),
        ]
    )

    actual, _ = expr.__teal__(avm2Options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    assert actual == expected


def test_lt_overload():
    args = [pt.Int(2), pt.Int(3)]
    expr = args[0] < args[1]
    assert expr.type_of() == pt.TealType.uint64

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(args[0], pt.Op.int, 2),
            pt.TealOp(args[1], pt.Op.int, 3),
            pt.TealOp(expr, pt.Op.lt),
        ]
    )

    actual, _ = expr.__teal__(avm2Options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    assert actual == expected


def test_lt_invalid():
    with pytest.raises(pt.TealTypeError):
        pt.Lt(pt.Int(7), pt.Txn.receiver())

    with pytest.raises(pt.TealTypeError):
        pt.Lt(pt.Txn.sender(), pt.Int(7))


def test_le():
    args = [pt.Int(1), pt.Int(2)]
    expr = pt.Le(args[0], args[1])
    assert expr.type_of() == pt.TealType.uint64

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(args[0], pt.Op.int, 1),
            pt.TealOp(args[1], pt.Op.int, 2),
            pt.TealOp(expr, pt.Op.le),
        ]
    )

    actual, _ = expr.__teal__(avm2Options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    assert actual == expected


def test_le_overload():
    args = [pt.Int(1), pt.Int(2)]
    expr = args[0] <= args[1]
    assert expr.type_of() == pt.TealType.uint64

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(args[0], pt.Op.int, 1),
            pt.TealOp(args[1], pt.Op.int, 2),
            pt.TealOp(expr, pt.Op.le),
        ]
    )

    actual, _ = expr.__teal__(avm2Options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    assert actual == expected


def test_le_invalid():
    with pytest.raises(pt.TealTypeError):
        pt.Le(pt.Int(1), pt.Txn.receiver())

    with pytest.raises(pt.TealTypeError):
        pt.Le(pt.Txn.sender(), pt.Int(1))


def test_gt():
    args = [pt.Int(2), pt.Int(3)]
    expr = pt.Gt(args[0], args[1])
    assert expr.type_of() == pt.TealType.uint64

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(args[0], pt.Op.int, 2),
            pt.TealOp(args[1], pt.Op.int, 3),
            pt.TealOp(expr, pt.Op.gt),
        ]
    )

    actual, _ = expr.__teal__(avm2Options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    assert actual == expected


def test_gt_overload():
    args = [pt.Int(2), pt.Int(3)]
    expr = args[0] > args[1]
    assert expr.type_of() == pt.TealType.uint64

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(args[0], pt.Op.int, 2),
            pt.TealOp(args[1], pt.Op.int, 3),
            pt.TealOp(expr, pt.Op.gt),
        ]
    )

    actual, _ = expr.__teal__(avm2Options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    assert actual == expected


def test_gt_invalid():
    with pytest.raises(pt.TealTypeError):
        pt.Gt(pt.Int(1), pt.Txn.receiver())

    with pytest.raises(pt.TealTypeError):
        pt.Gt(pt.Txn.receiver(), pt.Int(1))


def test_ge():
    args = [pt.Int(1), pt.Int(10)]
    expr = pt.Ge(args[0], args[1])
    assert expr.type_of() == pt.TealType.uint64

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(args[0], pt.Op.int, 1),
            pt.TealOp(args[1], pt.Op.int, 10),
            pt.TealOp(expr, pt.Op.ge),
        ]
    )

    actual, _ = expr.__teal__(avm2Options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    assert actual == expected


def test_ge_overload():
    args = [pt.Int(1), pt.Int(10)]
    expr = args[0] >= args[1]
    assert expr.type_of() == pt.TealType.uint64

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(args[0], pt.Op.int, 1),
            pt.TealOp(args[1], pt.Op.int, 10),
            pt.TealOp(expr, pt.Op.ge),
        ]
    )

    actual, _ = expr.__teal__(avm2Options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    assert actual == expected


def test_ge_invalid():
    with pytest.raises(pt.TealTypeError):
        pt.Ge(pt.Int(1), pt.Txn.receiver())

    with pytest.raises(pt.TealTypeError):
        pt.Ge(pt.Txn.receiver(), pt.Int(1))


def test_get_bit_int():
    args = [pt.Int(3), pt.Int(1)]
    expr = pt.GetBit(args[0], args[1])
    assert expr.type_of() == pt.TealType.uint64

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(args[0], pt.Op.int, 3),
            pt.TealOp(args[1], pt.Op.int, 1),
            pt.TealOp(expr, pt.Op.getbit),
        ]
    )

    actual, _ = expr.__teal__(avm3Options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    assert actual == expected

    with pytest.raises(pt.TealInputError):
        expr.__teal__(avm2Options)


def test_get_bit_bytes():
    args = [pt.Bytes("base16", "0xFF"), pt.Int(1)]
    expr = pt.GetBit(args[0], args[1])
    assert expr.type_of() == pt.TealType.uint64

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(args[0], pt.Op.byte, "0xFF"),
            pt.TealOp(args[1], pt.Op.int, 1),
            pt.TealOp(expr, pt.Op.getbit),
        ]
    )

    actual, _ = expr.__teal__(avm3Options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    assert actual == expected

    with pytest.raises(pt.TealInputError):
        expr.__teal__(avm2Options)


def test_get_bit_invalid():
    with pytest.raises(pt.TealTypeError):
        pt.GetBit(pt.Int(3), pt.Bytes("index"))

    with pytest.raises(pt.TealTypeError):
        pt.GetBit(pt.Bytes("base16", "0xFF"), pt.Bytes("index"))


def test_get_byte():
    args = [pt.Bytes("base16", "0xFF"), pt.Int(0)]
    expr = pt.GetByte(args[0], args[1])
    assert expr.type_of() == pt.TealType.uint64

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(args[0], pt.Op.byte, "0xFF"),
            pt.TealOp(args[1], pt.Op.int, 0),
            pt.TealOp(expr, pt.Op.getbyte),
        ]
    )

    actual, _ = expr.__teal__(avm3Options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    assert actual == expected

    with pytest.raises(pt.TealInputError):
        expr.__teal__(avm2Options)


def test_get_byte_invalid():
    with pytest.raises(pt.TealTypeError):
        pt.GetByte(pt.Int(3), pt.Int(0))

    with pytest.raises(pt.TealTypeError):
        pt.GetBit(pt.Bytes("base16", "0xFF"), pt.Bytes("index"))


def test_b_add():
    args = [
        pt.Bytes("base16", "0xFFFFFFFFFFFFFFFFFF"),
        pt.Bytes("base16", "0xFFFFFFFFFFFFFFFFFE"),
    ]
    expr = pt.BytesAdd(args[0], args[1])
    assert expr.type_of() == pt.TealType.bytes

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(args[0], pt.Op.byte, "0xFFFFFFFFFFFFFFFFFF"),
            pt.TealOp(args[1], pt.Op.byte, "0xFFFFFFFFFFFFFFFFFE"),
            pt.TealOp(expr, pt.Op.b_add),
        ]
    )

    actual, _ = expr.__teal__(avm4Options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    assert actual == expected

    with pytest.raises(pt.TealInputError):
        expr.__teal__(avm3Options)


def test_b_add_invalid():
    with pytest.raises(pt.TealTypeError):
        pt.BytesAdd(pt.Int(2), pt.Txn.receiver())

    with pytest.raises(pt.TealTypeError):
        pt.BytesAdd(pt.Bytes("base16", "0xFF"), pt.Int(2))


def test_b_minus():
    args = [
        pt.Bytes("base16", "0xFFFFFFFFFFFFFFFFFF"),
        pt.Bytes("base16", "0xFFFFFFFFFFFFFFFFFE"),
    ]
    expr = pt.BytesMinus(args[0], args[1])
    assert expr.type_of() == pt.TealType.bytes

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(args[0], pt.Op.byte, "0xFFFFFFFFFFFFFFFFFF"),
            pt.TealOp(args[1], pt.Op.byte, "0xFFFFFFFFFFFFFFFFFE"),
            pt.TealOp(expr, pt.Op.b_minus),
        ]
    )

    actual, _ = expr.__teal__(avm4Options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    assert actual == expected

    with pytest.raises(pt.TealInputError):
        expr.__teal__(avm3Options)


def test_b_minus_invalid():
    with pytest.raises(pt.TealTypeError):
        pt.BytesMinus(pt.Int(2), pt.Txn.receiver())

    with pytest.raises(pt.TealTypeError):
        pt.BytesMinus(pt.Bytes("base16", "0xFF"), pt.Int(2))


def test_b_div():
    args = [pt.Bytes("base16", "0xFFFFFFFFFFFFFFFF00"), pt.Bytes("base16", "0xFF")]
    expr = pt.BytesDiv(args[0], args[1])
    assert expr.type_of() == pt.TealType.bytes

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(args[0], pt.Op.byte, "0xFFFFFFFFFFFFFFFF00"),
            pt.TealOp(args[1], pt.Op.byte, "0xFF"),
            pt.TealOp(expr, pt.Op.b_div),
        ]
    )

    actual, _ = expr.__teal__(avm4Options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    assert actual == expected

    with pytest.raises(pt.TealInputError):
        expr.__teal__(avm3Options)


def test_b_div_invalid():
    with pytest.raises(pt.TealTypeError):
        pt.BytesDiv(pt.Int(2), pt.Txn.receiver())

    with pytest.raises(pt.TealTypeError):
        pt.BytesDiv(pt.Bytes("base16", "0xFF"), pt.Int(2))


def test_b_mul():
    args = [pt.Bytes("base16", "0xFFFFFFFFFFFFFFFF"), pt.Bytes("base16", "0xFF")]
    expr = pt.BytesMul(args[0], args[1])
    assert expr.type_of() == pt.TealType.bytes

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(args[0], pt.Op.byte, "0xFFFFFFFFFFFFFFFF"),
            pt.TealOp(args[1], pt.Op.byte, "0xFF"),
            pt.TealOp(expr, pt.Op.b_mul),
        ]
    )

    actual, _ = expr.__teal__(avm4Options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    assert actual == expected

    with pytest.raises(pt.TealInputError):
        expr.__teal__(avm3Options)


def test_b_mul_invalid():
    with pytest.raises(pt.TealTypeError):
        pt.BytesMul(pt.Int(2), pt.Txn.receiver())

    with pytest.raises(pt.TealTypeError):
        pt.BytesMul(pt.Bytes("base16", "0xFF"), pt.Int(2))


def test_b_mod():
    args = [pt.Bytes("base16", "0xFFFFFFFFFFFFFFFFFF"), pt.Bytes("base16", "0xFF")]
    expr = pt.BytesMod(args[0], args[1])
    assert expr.type_of() == pt.TealType.bytes

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(args[0], pt.Op.byte, "0xFFFFFFFFFFFFFFFFFF"),
            pt.TealOp(args[1], pt.Op.byte, "0xFF"),
            pt.TealOp(expr, pt.Op.b_mod),
        ]
    )

    actual, _ = expr.__teal__(avm4Options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    assert actual == expected

    with pytest.raises(pt.TealInputError):
        expr.__teal__(avm3Options)


def test_b_mod_invalid():
    with pytest.raises(pt.TealTypeError):
        pt.BytesMod(pt.Int(2), pt.Txn.receiver())

    with pytest.raises(pt.TealTypeError):
        pt.BytesMod(pt.Bytes("base16", "0xFF"), pt.Int(2))


def test_b_and():
    args = [pt.Bytes("base16", "0xFFFFFFFFFFFFFFFFF0"), pt.Bytes("base16", "0xFF")]
    expr = pt.BytesAnd(args[0], args[1])
    assert expr.type_of() == pt.TealType.bytes

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(args[0], pt.Op.byte, "0xFFFFFFFFFFFFFFFFF0"),
            pt.TealOp(args[1], pt.Op.byte, "0xFF"),
            pt.TealOp(expr, pt.Op.b_and),
        ]
    )

    actual, _ = expr.__teal__(avm4Options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    assert actual == expected

    with pytest.raises(pt.TealInputError):
        expr.__teal__(avm3Options)


def test_b_and_invalid():
    with pytest.raises(pt.TealTypeError):
        pt.BytesAnd(pt.Int(2), pt.Txn.receiver())

    with pytest.raises(pt.TealTypeError):
        pt.BytesAnd(pt.Bytes("base16", "0xFF"), pt.Int(2))


def test_b_or():
    args = [pt.Bytes("base16", "0xFFFFFFFFFFFFFFFFF0"), pt.Bytes("base16", "0xFF")]
    expr = pt.BytesOr(args[0], args[1])
    assert expr.type_of() == pt.TealType.bytes

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(args[0], pt.Op.byte, "0xFFFFFFFFFFFFFFFFF0"),
            pt.TealOp(args[1], pt.Op.byte, "0xFF"),
            pt.TealOp(expr, pt.Op.b_or),
        ]
    )

    actual, _ = expr.__teal__(avm4Options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    assert actual == expected

    with pytest.raises(pt.TealInputError):
        expr.__teal__(avm3Options)


def test_b_or_invalid():
    with pytest.raises(pt.TealTypeError):
        pt.BytesOr(pt.Int(2), pt.Txn.receiver())

    with pytest.raises(pt.TealTypeError):
        pt.BytesOr(pt.Bytes("base16", "0xFF"), pt.Int(2))


def test_b_xor():
    args = [pt.Bytes("base16", "0xFFFFFFFFFFFFFFFFF0"), pt.Bytes("base16", "0xFF")]
    expr = pt.BytesXor(args[0], args[1])
    assert expr.type_of() == pt.TealType.bytes

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(args[0], pt.Op.byte, "0xFFFFFFFFFFFFFFFFF0"),
            pt.TealOp(args[1], pt.Op.byte, "0xFF"),
            pt.TealOp(expr, pt.Op.b_xor),
        ]
    )

    actual, _ = expr.__teal__(avm4Options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    assert actual == expected

    with pytest.raises(pt.TealInputError):
        expr.__teal__(avm3Options)


def test_b_xor_invalid():
    with pytest.raises(pt.TealTypeError):
        pt.BytesXor(pt.Int(2), pt.Txn.receiver())

    with pytest.raises(pt.TealTypeError):
        pt.BytesXor(pt.Bytes("base16", "0xFF"), pt.Int(2))


def test_b_eq():
    args = [
        pt.Bytes("base16", "0xFFFFFFFFFFFFFFFFFF"),
        pt.Bytes("base16", "0xFFFFFFFFFFFFFFFFFF"),
    ]
    expr = pt.BytesEq(args[0], args[1])
    assert expr.type_of() == pt.TealType.uint64

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(args[0], pt.Op.byte, "0xFFFFFFFFFFFFFFFFFF"),
            pt.TealOp(args[1], pt.Op.byte, "0xFFFFFFFFFFFFFFFFFF"),
            pt.TealOp(expr, pt.Op.b_eq),
        ]
    )

    actual, _ = expr.__teal__(avm4Options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    assert actual == expected

    with pytest.raises(pt.TealInputError):
        expr.__teal__(avm3Options)


def test_b_eq_invalid():
    with pytest.raises(pt.TealTypeError):
        pt.BytesEq(pt.Int(2), pt.Txn.receiver())

    with pytest.raises(pt.TealTypeError):
        pt.BytesEq(pt.Bytes("base16", "0xFF"), pt.Int(2))


def test_b_neq():
    args = [
        pt.Bytes("base16", "0xFFFFFFFFFFFFFFFFFF"),
        pt.Bytes("base16", "0xFFFFFFFFFFFFFFFFFF"),
    ]
    expr = pt.BytesNeq(args[0], args[1])
    assert expr.type_of() == pt.TealType.uint64

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(args[0], pt.Op.byte, "0xFFFFFFFFFFFFFFFFFF"),
            pt.TealOp(args[1], pt.Op.byte, "0xFFFFFFFFFFFFFFFFFF"),
            pt.TealOp(expr, pt.Op.b_neq),
        ]
    )

    actual, _ = expr.__teal__(avm4Options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    assert actual == expected

    with pytest.raises(pt.TealInputError):
        expr.__teal__(avm3Options)


def test_b_neq_invalid():
    with pytest.raises(pt.TealTypeError):
        pt.BytesNeq(pt.Int(2), pt.Txn.receiver())

    with pytest.raises(pt.TealTypeError):
        pt.BytesNeq(pt.Bytes("base16", "0xFF"), pt.Int(2))


def test_b_lt():
    args = [
        pt.Bytes("base16", "0xFFFFFFFFFFFFFFFFF0"),
        pt.Bytes("base16", "0xFFFFFFFFFFFFFFFFFF"),
    ]
    expr = pt.BytesLt(args[0], args[1])
    assert expr.type_of() == pt.TealType.uint64

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(args[0], pt.Op.byte, "0xFFFFFFFFFFFFFFFFF0"),
            pt.TealOp(args[1], pt.Op.byte, "0xFFFFFFFFFFFFFFFFFF"),
            pt.TealOp(expr, pt.Op.b_lt),
        ]
    )

    actual, _ = expr.__teal__(avm4Options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    assert actual == expected

    with pytest.raises(pt.TealInputError):
        expr.__teal__(avm3Options)


def test_b_lt_invalid():
    with pytest.raises(pt.TealTypeError):
        pt.BytesLt(pt.Int(2), pt.Txn.receiver())

    with pytest.raises(pt.TealTypeError):
        pt.BytesLt(pt.Bytes("base16", "0xFF"), pt.Int(2))


def test_b_le():
    args = [
        pt.Bytes("base16", "0xFFFFFFFFFFFFFFFFF0"),
        pt.Bytes("base16", "0xFFFFFFFFFFFFFFFFFF"),
    ]
    expr = pt.BytesLe(args[0], args[1])
    assert expr.type_of() == pt.TealType.uint64

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(args[0], pt.Op.byte, "0xFFFFFFFFFFFFFFFFF0"),
            pt.TealOp(args[1], pt.Op.byte, "0xFFFFFFFFFFFFFFFFFF"),
            pt.TealOp(expr, pt.Op.b_le),
        ]
    )

    actual, _ = expr.__teal__(avm4Options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    assert actual == expected

    with pytest.raises(pt.TealInputError):
        expr.__teal__(avm3Options)


def test_b_le_invalid():
    with pytest.raises(pt.TealTypeError):
        pt.BytesLe(pt.Int(2), pt.Txn.receiver())

    with pytest.raises(pt.TealTypeError):
        pt.BytesLe(pt.Bytes("base16", "0xFF"), pt.Int(2))


def test_b_gt():
    args = [
        pt.Bytes("base16", "0xFFFFFFFFFFFFFFFFFF"),
        pt.Bytes("base16", "0xFFFFFFFFFFFFFFFFF0"),
    ]
    expr = pt.BytesGt(args[0], args[1])
    assert expr.type_of() == pt.TealType.uint64

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(args[0], pt.Op.byte, "0xFFFFFFFFFFFFFFFFFF"),
            pt.TealOp(args[1], pt.Op.byte, "0xFFFFFFFFFFFFFFFFF0"),
            pt.TealOp(expr, pt.Op.b_gt),
        ]
    )

    actual, _ = expr.__teal__(avm4Options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    assert actual == expected

    with pytest.raises(pt.TealInputError):
        expr.__teal__(avm3Options)


def test_b_gt_invalid():
    with pytest.raises(pt.TealTypeError):
        pt.BytesGt(pt.Int(2), pt.Txn.receiver())

    with pytest.raises(pt.TealTypeError):
        pt.BytesGt(pt.Bytes("base16", "0xFF"), pt.Int(2))


def test_b_ge():
    args = [
        pt.Bytes("base16", "0xFFFFFFFFFFFFFFFFFF"),
        pt.Bytes("base16", "0xFFFFFFFFFFFFFFFFF0"),
    ]
    expr = pt.BytesGe(args[0], args[1])
    assert expr.type_of() == pt.TealType.uint64

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(args[0], pt.Op.byte, "0xFFFFFFFFFFFFFFFFFF"),
            pt.TealOp(args[1], pt.Op.byte, "0xFFFFFFFFFFFFFFFFF0"),
            pt.TealOp(expr, pt.Op.b_ge),
        ]
    )

    actual, _ = expr.__teal__(avm4Options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    assert actual == expected

    with pytest.raises(pt.TealInputError):
        expr.__teal__(avm3Options)


def test_b_ge_invalid():
    with pytest.raises(pt.TealTypeError):
        pt.BytesGe(pt.Int(2), pt.Txn.receiver())

    with pytest.raises(pt.TealTypeError):
        pt.BytesGe(pt.Bytes("base16", "0xFF"), pt.Int(2))


def test_extract_uint():
    for expression, op in (
        (pt.ExtractUint16, pt.Op.extract_uint16),
        (pt.ExtractUint32, pt.Op.extract_uint32),
        (pt.ExtractUint64, pt.Op.extract_uint64),
    ):
        args = [
            pt.Bytes("base16", "0xFFFFFFFFFFFFFFFFFF"),
            pt.Int(2),
        ]
        expr = expression(args[0], args[1])
        assert expr.type_of() == pt.TealType.uint64

        expected = pt.TealSimpleBlock(
            [
                pt.TealOp(args[0], pt.Op.byte, "0xFFFFFFFFFFFFFFFFFF"),
                pt.TealOp(args[1], pt.Op.int, 2),
                pt.TealOp(expr, op),
            ]
        )

        actual, _ = expr.__teal__(avm5Options)
        actual.addIncoming()
        actual = pt.TealBlock.NormalizeBlocks(actual)

        assert actual == expected

        with pytest.raises(pt.TealInputError):
            expr.__teal__(avm4Options)


def test_extract_uint_invalid():
    for expression in (pt.ExtractUint16, pt.ExtractUint32, pt.ExtractUint64):
        with pytest.raises(pt.TealTypeError):
            expression(pt.Int(2), pt.Txn.receiver())

        with pytest.raises(pt.TealTypeError):
            expression(pt.Bytes("base16", "0xFF"), pt.Txn.receiver())



================================================
FILE: pyteal/ast/block.py
================================================
from typing import TYPE_CHECKING
from enum import Enum

from pyteal.types import TealType, require_type
from pyteal.errors import verifyFieldVersion
from pyteal.ir import TealOp, Op, TealBlock
from pyteal.ast.expr import Expr
from pyteal.ast.leafexpr import LeafExpr

if TYPE_CHECKING:
    from pyteal.compiler import CompileOptions


class BlockField(Enum):
    # fmt: off
    #                 id  |    name     |      type     | min version
    block_seed = (0, "BlkSeed",      TealType.bytes,  7)  # noqa: E222
    block_timestamp = (1, "BlkTimestamp", TealType.uint64, 7)  # noqa: E222
    block_proposer = (2, "BlkProposer", TealType.bytes, 11)  # noqa: E222
    block_fees_collected = (3, "BlkFeesCollected", TealType.uint64, 11)  # noqa: E222
    block_bonus = (4, "BlkBonus", TealType.uint64, 11)  # noqa: E222
    block_branch = (5, "BlkBranch", TealType.bytes, 11)  # noqa: E222
    block_fee_sink = (6, "BlkFeeSink", TealType.bytes, 11)  # noqa: E222
    block_protocol = (7, "BlkProtocol", TealType.bytes, 11)  # noqa: E222
    block_txn_counter = (8, "BlkTxnCounter", TealType.uint64, 11)  # noqa: E222
    block_proposer_payout = (9, "BlkProposerPayout", TealType.uint64, 11)  # noqa: E222

    # fmt: on

    def __init__(self, id: int, name: str, type: TealType, min_version: int) -> None:
        self.id = id
        self.arg_name = name
        self.ret_type = type
        self.min_version = min_version

    def type_of(self) -> TealType:
        return self.ret_type


BlockField.__module__ = "pyteal"


class Block(LeafExpr):
    """An expression that accesses a block property."""

    def __init__(self, field: BlockField, block: Expr) -> None:
        super().__init__()
        self.field = field

        require_type(block, TealType.uint64)
        self.block = block

    def __teal__(self, options: "CompileOptions"):
        verifyFieldVersion(self.field.arg_name, self.field.min_version, options.version)

        op = TealOp(self, Op.block, self.field.arg_name)
        return TealBlock.FromOp(options, op, self.block)

    def __str__(self):
        return "(Block {})".format(self.field.arg_name)

    def type_of(self):
        return self.field.type_of()

    @classmethod
    def seed(cls, block: Expr) -> Expr:
        """Get the seed of a block.

        Args:
            block: A block index that corresponds to the block to check,
                must be evaluated to uint64. Fails if the block index is not less than
                :code:`Txn.first_valid()` or more than 1001 rounds before :code:`Txn.last_valid()`.
        """
        return cls(BlockField.block_seed, block)

    @classmethod
    def timestamp(cls, block: Expr) -> Expr:
        """Get the timestamp of a block.

        Args:
            block: A block index that corresponds to the block to check,
                must be evaluated to uint64. Fails if the block index is not less than
                :code:`Txn.first_valid()` or more than 1001 rounds before :code:`Txn.last_valid()`.
        """
        return cls(BlockField.block_timestamp, block)

    @classmethod
    def proposer(cls, block: Expr) -> Expr:
        """Get the proposer of a block.

        Requires program version 11 or higher.

        Args:
            block: A block index that corresponds to the block to check,
                must be evaluated to uint64. Fails if the block index is not less than
                :code:`Txn.first_valid()` or more than 1001 rounds before :code:`Txn.last_valid()`.
        """
        return cls(BlockField.block_proposer, block)

    @classmethod
    def fees_collected(cls, block: Expr) -> Expr:
        """Get the fees collected from all the transactions in a block.

        Requires program version 11 or higher.

        Args:
            block: A block index that corresponds to the block to check,
                must be evaluated to uint64. Fails if the block index is not less than
                :code:`Txn.first_valid()` or more than 1001 rounds before :code:`Txn.last_valid()`.
        """
        return cls(BlockField.block_fees_collected, block)

    @classmethod
    def bonus(cls, block: Expr) -> Expr:
        """Get the bonus payout available for proposing the block.

        Requires program version 11 or higher.

        Args:
            block: A block index that corresponds to the block to check,
                must be evaluated to uint64. Fails if the block index is not less than
                :code:`Txn.first_valid()` or more than 1001 rounds before :code:`Txn.last_valid()`.
        """
        return cls(BlockField.block_bonus, block)

    @classmethod
    def branch(cls, block: Expr) -> Expr:
        """Get the branch of a block.

        Requires program version 11 or higher.

        Args:
            block: A block index that corresponds to the block to check,
                must be evaluated to uint64. Fails if the block index is not less than
                :code:`Txn.first_valid()` or more than 1001 rounds before :code:`Txn.last_valid()`.
        """
        return cls(BlockField.block_branch, block)

    @classmethod
    def fee_sink(cls, block: Expr) -> Expr:
        """Get the FeeSink address of a block.

        Requires program version 11 or higher.

        Args:
            block: A block index that corresponds to the block to check,
                must be evaluated to uint64. Fails if the block index is not less than
                :code:`Txn.first_valid()` or more than 1001 rounds before :code:`Txn.last_valid()`.
        """
        return cls(BlockField.block_fee_sink, block)

    @classmethod
    def protocol(cls, block: Expr) -> Expr:
        """Get the protocol version of a block.

        Requires program version 11 or higher.

        Args:
            block: A block index that corresponds to the block to check,
                must be evaluated to uint64. Fails if the block index is not less than
                :code:`Txn.first_valid()` or more than 1001 rounds before :code:`Txn.last_valid()`.
        """
        return cls(BlockField.block_protocol, block)

    @classmethod
    def txn_counter(cls, block: Expr) -> Expr:
        """Get the transaction counter of a block.

        Requires program version 11 or higher.

        Args:
            block: A block index that corresponds to the block to check,
                must be evaluated to uint64. Fails if the block index is not less than
                :code:`Txn.first_valid()` or more than 1001 rounds before :code:`Txn.last_valid()`.
        """
        return cls(BlockField.block_txn_counter, block)

    @classmethod
    def proposer_payout(cls, block: Expr) -> Expr:
        """Get the amount earned by the proposer for proposing the block.

        Requires program version 11 or higher.

        Args:
            block: A block index that corresponds to the block to check,
                must be evaluated to uint64. Fails if the block index is not less than
                :code:`Txn.first_valid()` or more than 1001 rounds before :code:`Txn.last_valid()`.
        """
        return cls(BlockField.block_proposer_payout, block)


Block.__module__ = "pyteal"



================================================
FILE: pyteal/ast/block_test.py
================================================
import pytest

import pyteal as pt

avm6Options = pt.CompileOptions(version=6)
avm7Options = pt.CompileOptions(version=7)
avm10Options = pt.CompileOptions(version=10)
avm11Options = pt.CompileOptions(version=11)


def test_block_seed():
    arg = pt.Int(0)
    expr = pt.Block.seed(arg)
    assert expr.type_of() == pt.TealType.bytes

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(arg, pt.Op.int, 0),
            pt.TealOp(expr, pt.Op.block, "BlkSeed"),
        ]
    )

    actual, _ = expr.__teal__(avm7Options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    assert actual == expected

    with pytest.raises(pt.TealInputError):
        expr.__teal__(avm6Options)


def test_block_seed_invalid():
    with pytest.raises(pt.TealTypeError):
        pt.Block.seed(pt.Bytes(""))


def test_block_timestamp():
    arg = pt.Int(0)
    expr = pt.Block.timestamp(arg)
    assert expr.type_of() == pt.TealType.uint64

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(arg, pt.Op.int, 0),
            pt.TealOp(expr, pt.Op.block, "BlkTimestamp"),
        ]
    )

    actual, _ = expr.__teal__(avm7Options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    assert actual == expected

    with pytest.raises(pt.TealInputError):
        expr.__teal__(avm6Options)


def test_block_timestamp_invalid():
    with pytest.raises(pt.TealTypeError):
        pt.Block.timestamp(pt.Txn.sender())


def test_block_v11_fields():
    arg = pt.Int(0)
    cases = [
        ("proposer", "BlkProposer", pt.TealType.bytes),
        ("fees_collected", "BlkFeesCollected", pt.TealType.uint64),
        ("bonus", "BlkBonus", pt.TealType.uint64),
        ("branch", "BlkBranch", pt.TealType.bytes),
        ("fee_sink", "BlkFeeSink", pt.TealType.bytes),
        ("protocol", "BlkProtocol", pt.TealType.bytes),
        ("txn_counter", "BlkTxnCounter", pt.TealType.uint64),
        ("proposer_payout", "BlkProposerPayout", pt.TealType.uint64),
    ]
    for tc in cases:
        block_method = getattr(pt.Block, tc[0])
        expr = block_method(arg)
        assert expr.type_of() == tc[2]

        expected = pt.TealSimpleBlock(
            [
                pt.TealOp(arg, pt.Op.int, 0),
                pt.TealOp(expr, pt.Op.block, tc[1]),
            ]
        )

    actual, _ = expr.__teal__(avm11Options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    assert actual == expected

    with pytest.raises(pt.TealInputError):
        expr.__teal__(avm10Options)



================================================
FILE: pyteal/ast/box.py
================================================
from typing import TYPE_CHECKING
from pyteal.ast.maybe import MaybeValue
from pyteal.errors import verifyProgramVersion

from pyteal.types import TealType, require_type
from pyteal.ir import TealOp, Op, TealBlock
from pyteal.ast.expr import Expr

if TYPE_CHECKING:
    from pyteal.compiler import CompileOptions


class BoxCreate(Expr):
    """Create a box with a given name and size."""

    def __init__(self, name: Expr, size: Expr) -> None:
        """
        Args:
            name: The key used to reference this box. Must evaluate to a bytes.
            size: The number of bytes to reserve for this box. Must evaluate to a uint64.
        """

        super().__init__()
        require_type(name, TealType.bytes)
        require_type(size, TealType.uint64)
        self.name = name
        self.size = size

    def __teal__(self, options: "CompileOptions"):
        verifyProgramVersion(
            minVersion=Op.box_create.min_version,
            version=options.version,
            msg=f"{Op.box_create} unavailable",
        )
        return TealBlock.FromOp(
            options, TealOp(self, Op.box_create), self.name, self.size
        )

    def __str__(self):
        return f"(box_create {self.name} {self.size})"

    def type_of(self):
        return TealType.uint64

    def has_return(self):
        return False


BoxCreate.__module__ = "pyteal"


class BoxResize(Expr):
    """Resize an existing box.

    If the new size is larger than the old size, zero bytes will be added to the end of the box.
    If the new size is smaller than the old size, the box will be truncated from the end.
    """

    def __init__(self, name: Expr, size: Expr) -> None:
        """
        Args:
            name: The key used to reference this box. Must evaluate to a bytes.
            size: The new number of bytes to reserve for this box. Must evaluate to a uint64.
        """

        super().__init__()
        require_type(name, TealType.bytes)
        require_type(size, TealType.uint64)
        self.name = name
        self.size = size

    def __teal__(self, options: "CompileOptions"):
        verifyProgramVersion(
            minVersion=Op.box_resize.min_version,
            version=options.version,
            msg=f"{Op.box_resize} unavailable",
        )
        return TealBlock.FromOp(
            options, TealOp(self, Op.box_resize), self.name, self.size
        )

    def __str__(self):
        return f"(box_resize {self.name} {self.size})"

    def type_of(self):
        return TealType.none

    def has_return(self):
        return False


BoxResize.__module__ = "pyteal"


class BoxDelete(Expr):
    """Deletes a box given its name."""

    def __init__(self, name: Expr) -> None:
        """
        Args:
            name: The key the box was created with. Must evaluate to bytes.
        """
        super().__init__()
        require_type(name, TealType.bytes)
        self.name = name

    def __teal__(self, options: "CompileOptions"):
        verifyProgramVersion(
            minVersion=Op.box_del.min_version,
            version=options.version,
            msg=f"{Op.box_del} unavailable",
        )
        return TealBlock.FromOp(options, TealOp(self, Op.box_del), self.name)

    def __str__(self):
        return f"(box_del {self.name})"

    def type_of(self):
        return TealType.uint64

    def has_return(self):
        return False


BoxDelete.__module__ = "pyteal"


class BoxReplace(Expr):
    """Replaces bytes in a box given its name, start index, and value.

    Also see BoxSplice.
    """

    def __init__(self, name: Expr, start: Expr, value: Expr) -> None:
        """
        Args:
            name: The key the box was created with. Must evaluate to bytes.
            start: The byte index into the box to start writing. Must evaluate to uint64.
            value: The value to start writing at start index. Must evaluate to bytes.
        """
        super().__init__()
        require_type(name, TealType.bytes)
        require_type(start, TealType.uint64)
        require_type(value, TealType.bytes)
        self.name = name
        self.start = start
        self.value = value

    def __teal__(self, options: "CompileOptions"):
        verifyProgramVersion(
            minVersion=Op.box_replace.min_version,
            version=options.version,
            msg=f"{Op.box_replace} unavailable",
        )
        return TealBlock.FromOp(
            options, TealOp(self, Op.box_replace), self.name, self.start, self.value
        )

    def __str__(self):
        return f"(box_replace {self.name} {self.start} {self.value})"

    def type_of(self):
        return TealType.none

    def has_return(self):
        return False


BoxReplace.__module__ = "pyteal"


class BoxExtract(Expr):
    """Extracts bytes in a box given its name, start index and stop index."""

    def __init__(self, name: Expr, start: Expr, length: Expr) -> None:
        """
        Args:
            name: The key the box was created with. Must evaluate to bytes.
            start: The byte index into the box to start reading. Must evaluate to uint64.
            length: The byte length into the box from start to stop reading. Must evaluate to uint64.
        """

        super().__init__()
        require_type(name, TealType.bytes)
        require_type(start, TealType.uint64)
        require_type(length, TealType.uint64)
        self.name = name
        self.start = start
        self.length = length

    def __teal__(self, options: "CompileOptions"):
        verifyProgramVersion(
            minVersion=Op.box_extract.min_version,
            version=options.version,
            msg=f"{Op.box_extract} unavailable",
        )
        return TealBlock.FromOp(
            options, TealOp(self, Op.box_extract), self.name, self.start, self.length
        )

    def __str__(self):
        return f"(box_extract {self.name} {self.start} {self.length})"

    def type_of(self):
        return TealType.bytes

    def has_return(self):
        return False


BoxExtract.__module__ = "pyteal"


class BoxSplice(Expr):
    """Splice content into a box."""

    def __init__(
        self, name: Expr, start: Expr, length: Expr, new_content: Expr
    ) -> None:
        """
        Replaces the range of bytes from `start` through `start + length` with `new_content`.

        Bytes after `start + length` will be shifted to the right.

        Recall that boxes are constant length, and this operation will not change the length of the
        box. Instead content may be adjusted as so:

            * If the length of the new content is less than `length`, the bytes following `start + length` will be shifted to the left, and the end of the box will be padded with zeros.

            * If the length of the new content is greater than `length`, the bytes following `start + length` will be shifted to the right and bytes exceeding the length of the box will be truncated.

        Args:
            name: The name of the box to modify. Must evaluate to bytes.
            start: The byte index into the box to start writing. Must evaluate to uint64.
            length: The length of the bytes to be replaced. Must evaluate to uint64.
            new_content: The new content to write into the box. Must evaluate to bytes.
        """
        super().__init__()
        require_type(name, TealType.bytes)
        require_type(start, TealType.uint64)
        require_type(length, TealType.uint64)
        require_type(new_content, TealType.bytes)
        self.name = name
        self.start = start
        self.length = length
        self.new_content = new_content

    def __teal__(self, options: "CompileOptions"):
        verifyProgramVersion(
            minVersion=Op.box_splice.min_version,
            version=options.version,
            msg=f"{Op.box_splice} unavailable",
        )
        return TealBlock.FromOp(
            options,
            TealOp(self, Op.box_splice),
            self.name,
            self.start,
            self.length,
            self.new_content,
        )

    def __str__(self):
        return f"(box_splice {self.name} {self.start} {self.length} {self.new_content})"

    def type_of(self):
        return TealType.none

    def has_return(self):
        return False


BoxSplice.__module__ = "pyteal"


def BoxLen(name: Expr) -> MaybeValue:
    """
    Get the byte length of the box specified by its name.

    Args:
        name: The key the box was created with. Must evaluate to bytes.
    """
    require_type(name, TealType.bytes)
    return MaybeValue(Op.box_len, TealType.uint64, args=[name])


def BoxGet(name: Expr) -> MaybeValue:
    """
    Get the full contents of a box given its name.

    Args:
        name: The key the box was created with. Must evaluate to bytes.
    """
    require_type(name, TealType.bytes)
    return MaybeValue(Op.box_get, TealType.bytes, args=[name])


class BoxPut(Expr):
    """Write all contents to a box given its name."""

    def __init__(self, name: Expr, value: Expr) -> None:
        """
        Args:
            name: The key the box was created with. Must evaluate to bytes.
            value: The value to write to the box. Must evaluate to bytes.
        """

        super().__init__()
        require_type(name, TealType.bytes)
        require_type(value, TealType.bytes)
        self.name = name
        self.value = value

    def __teal__(self, options: "CompileOptions"):
        verifyProgramVersion(
            minVersion=Op.box_put.min_version,
            version=options.version,
            msg=f"{Op.box_put} unavailable",
        )
        return TealBlock.FromOp(
            options, TealOp(self, Op.box_put), self.name, self.value
        )

    def __str__(self):
        return f"(box_put {self.name})"

    def type_of(self):
        return TealType.none

    def has_return(self):
        return False


BoxPut.__module__ = "pyteal"



================================================
FILE: pyteal/ast/box_test.py
================================================
from typing import Callable, Tuple

import pytest
import pyteal as pt

avm7Options = pt.CompileOptions(version=7)
avm8Options = pt.CompileOptions(version=8)
avm10Options = pt.CompileOptions(version=10)

POSITIVE_TEST_CASES: list[Tuple[int, pt.Expr, pt.TealType]] = [
    (8, pt.BoxCreate(pt.Bytes("box"), pt.Int(10)), pt.TealType.uint64),
    (8, pt.BoxDelete(pt.Bytes("box")), pt.TealType.uint64),
    (8, pt.BoxExtract(pt.Bytes("box"), pt.Int(2), pt.Int(4)), pt.TealType.bytes),
    (
        8,
        pt.BoxReplace(pt.Bytes("box"), pt.Int(3), pt.Bytes("replace")),
        pt.TealType.none,
    ),
    (8, pt.BoxLen(pt.Bytes("box")), pt.TealType.none),
    (8, pt.BoxGet(pt.Bytes("box")), pt.TealType.none),
    (8, pt.BoxPut(pt.Bytes("box"), pt.Bytes("goonery")), pt.TealType.none),
    (10, pt.BoxResize(pt.Bytes("box"), pt.Int(16)), pt.TealType.none),
    (
        10,
        pt.BoxSplice(pt.Bytes("box"), pt.Int(5), pt.Int(2), pt.Bytes("replacement")),
        pt.TealType.none,
    ),
]


@pytest.mark.parametrize("version, test_case, test_case_type", POSITIVE_TEST_CASES)
def test_compile_version_and_type(version, test_case, test_case_type):
    with pytest.raises(pt.TealInputError):
        test_case.__teal__(pt.CompileOptions(version=version - 1))

    test_case.__teal__(pt.CompileOptions(version=version))
    assert test_case.type_of() == test_case_type
    assert not test_case.has_return()


INVALID_TEST_CASES: list[Tuple[list[pt.Expr], type | Callable[..., pt.MaybeValue]]] = [
    ([pt.Bytes("box"), pt.Bytes("ten")], pt.BoxCreate),
    ([pt.Int(0xB0B), pt.Int(10)], pt.BoxCreate),
    ([pt.Int(0xA11CE)], pt.BoxDelete),
    ([pt.Bytes("box"), pt.Int(2), pt.Bytes("three")], pt.BoxExtract),
    ([pt.Bytes("box"), pt.Int(2), pt.Int(0x570FF)], pt.BoxReplace),
    ([pt.Int(12)], pt.BoxLen),
    ([pt.Int(45)], pt.BoxGet),
    ([pt.Bytes("box"), pt.Int(123)], pt.BoxPut),
    ([pt.Int(1), pt.Int(2)], pt.BoxResize),
    ([pt.Bytes("box"), pt.Bytes("b")], pt.BoxResize),
    ([pt.Bytes("box"), pt.Int(123), pt.Int(456), pt.Int(7)], pt.BoxSplice),
    ([pt.Bytes("box"), pt.Int(123), pt.Bytes("456"), pt.Bytes("x")], pt.BoxSplice),
    ([pt.Bytes("box"), pt.Bytes("123"), pt.Int(456), pt.Bytes("x")], pt.BoxSplice),
    ([pt.Int(8), pt.Int(123), pt.Int(456), pt.Bytes("x")], pt.BoxSplice),
]


@pytest.mark.parametrize("test_args, test_expr", INVALID_TEST_CASES)
def test_box_invalid_args(test_args, test_expr):
    with pytest.raises(pt.TealTypeError):
        test_expr(*test_args)


def test_box_create_compile():
    name_arg: pt.Expr = pt.Bytes("eineName")
    size_arg: pt.Expr = pt.Int(10)
    expr: pt.Expr = pt.BoxCreate(name_arg, size_arg)

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(name_arg, pt.Op.byte, '"eineName"'),
            pt.TealOp(size_arg, pt.Op.int, 10),
            pt.TealOp(expr, pt.Op.box_create),
        ]
    )
    actual, _ = expr.__teal__(avm8Options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    assert expected == actual


def test_box_resize_compile():
    name_arg: pt.Expr = pt.Bytes("eineName")
    size_arg: pt.Expr = pt.Int(10)
    expr: pt.Expr = pt.BoxResize(name_arg, size_arg)

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(name_arg, pt.Op.byte, '"eineName"'),
            pt.TealOp(size_arg, pt.Op.int, 10),
            pt.TealOp(expr, pt.Op.box_resize),
        ]
    )
    actual, _ = expr.__teal__(avm10Options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    assert expected == actual


def test_box_delete_compile():
    name_arg: pt.Expr = pt.Bytes("eineName")
    expr: pt.Expr = pt.BoxDelete(name_arg)

    expected = pt.TealSimpleBlock(
        [pt.TealOp(name_arg, pt.Op.byte, '"eineName"'), pt.TealOp(expr, pt.Op.box_del)]
    )
    actual, _ = expr.__teal__(avm8Options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    assert expected == actual


def test_box_extract():
    name_arg: pt.Expr = pt.Bytes("eineName")
    srt_arg: pt.Expr = pt.Int(10)
    end_arg: pt.Expr = pt.Int(15)
    expr: pt.Expr = pt.BoxExtract(name_arg, srt_arg, end_arg)

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(name_arg, pt.Op.byte, '"eineName"'),
            pt.TealOp(srt_arg, pt.Op.int, 10),
            pt.TealOp(end_arg, pt.Op.int, 15),
            pt.TealOp(expr, pt.Op.box_extract),
        ]
    )
    actual, _ = expr.__teal__(avm8Options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    assert expected == actual


def test_box_replace():
    name_arg: pt.Expr = pt.Bytes("eineName")
    srt_arg: pt.Expr = pt.Int(10)
    replace_arg: pt.Expr = pt.Bytes("replace-str")
    expr: pt.Expr = pt.BoxReplace(name_arg, srt_arg, replace_arg)

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(name_arg, pt.Op.byte, '"eineName"'),
            pt.TealOp(srt_arg, pt.Op.int, 10),
            pt.TealOp(replace_arg, pt.Op.byte, '"replace-str"'),
            pt.TealOp(expr, pt.Op.box_replace),
        ]
    )
    actual, _ = expr.__teal__(avm8Options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    assert expected == actual


def test_box_splice():
    name_arg: pt.Expr = pt.Bytes("eineName")
    srt_arg: pt.Expr = pt.Int(10)
    len_arg: pt.Expr = pt.Int(17)
    replace_arg: pt.Expr = pt.Bytes("replace-str")
    expr: pt.Expr = pt.BoxSplice(name_arg, srt_arg, len_arg, replace_arg)

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(name_arg, pt.Op.byte, '"eineName"'),
            pt.TealOp(srt_arg, pt.Op.int, 10),
            pt.TealOp(len_arg, pt.Op.int, 17),
            pt.TealOp(replace_arg, pt.Op.byte, '"replace-str"'),
            pt.TealOp(expr, pt.Op.box_splice),
        ]
    )
    actual, _ = expr.__teal__(avm10Options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    assert expected == actual


def test_box_length():
    name_arg: pt.Expr = pt.Bytes("eineName")
    expr: pt.MaybeValue = pt.BoxLen(name_arg)

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(None, pt.Op.byte, '"eineName"'),
            pt.TealOp(None, pt.Op.box_len),
            pt.TealOp(None, pt.Op.store, expr.output_slots[1]),
            pt.TealOp(None, pt.Op.store, expr.output_slots[0]),
        ]
    )
    actual, _ = expr.__teal__(avm8Options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    with pt.TealComponent.Context.ignoreExprEquality():
        assert expected == actual


def test_box_get():
    name_arg: pt.Expr = pt.Bytes("eineName")
    expr: pt.MaybeValue = pt.BoxGet(name_arg)

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(None, pt.Op.byte, '"eineName"'),
            pt.TealOp(None, pt.Op.box_get),
            pt.TealOp(None, pt.Op.store, expr.output_slots[1]),
            pt.TealOp(None, pt.Op.store, expr.output_slots[0]),
        ]
    )
    actual, _ = expr.__teal__(avm8Options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    with pt.TealComponent.Context.ignoreExprEquality():
        assert expected == actual


def test_box_put():
    name_arg: pt.Expr = pt.Bytes("eineName")
    put_arg: pt.Expr = pt.Bytes("put-str")
    expr: pt.Expr = pt.BoxPut(name_arg, put_arg)

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(name_arg, pt.Op.byte, '"eineName"'),
            pt.TealOp(put_arg, pt.Op.byte, '"put-str"'),
            pt.TealOp(expr, pt.Op.box_put),
        ]
    )
    actual, _ = expr.__teal__(avm8Options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    assert expected == actual



================================================
FILE: pyteal/ast/break_.py
================================================
from typing import TYPE_CHECKING

from pyteal.types import TealType
from pyteal.errors import TealCompileError
from pyteal.ast.expr import Expr
from pyteal.ir import TealSimpleBlock


if TYPE_CHECKING:
    from pyteal.compiler import CompileOptions


class Break(Expr):
    """A break expression"""

    def __init__(self) -> None:
        """Create a new break expression.

        This operation is only permitted in a loop.

        """
        super().__init__()

    def __str__(self) -> str:
        return "break"

    def __teal__(self, options: "CompileOptions"):
        if not options.isInLoop():
            raise TealCompileError("break is only allowed in a loop", self)

        start = TealSimpleBlock([])
        options.addLoopBreakBlock(start)

        return start, start

    def type_of(self):
        return TealType.none

    def has_return(self):
        return False


Break.__module__ = "pyteal"



================================================
FILE: pyteal/ast/break_test.py
================================================
import pytest

import pyteal as pt

options = pt.CompileOptions()


def test_break_fail():
    with pytest.raises(pt.TealCompileError):
        pt.Break().__teal__(options)

    with pytest.raises(pt.TealCompileError):
        pt.If(pt.Int(1), pt.Break()).__teal__(options)

    with pytest.raises(pt.TealCompileError):
        pt.Seq([pt.Break()]).__teal__(options)

    with pytest.raises(TypeError):
        pt.Break(pt.Int(1))


def test_break():
    expr = pt.Break()

    assert expr.type_of() == pt.TealType.none
    assert not expr.has_return()

    expected = pt.TealSimpleBlock([])

    options.enterLoop()
    actual, _ = expr.__teal__(options)
    breakBlocks, continueBlocks = options.exitLoop()

    assert actual == expected
    assert breakBlocks == [actual]
    assert continueBlocks == []



================================================
FILE: pyteal/ast/bytes.py
================================================
from typing import TYPE_CHECKING, cast, overload

from pyteal.ast.leafexpr import LeafExpr
from pyteal.errors import TealInputError
from pyteal.ir import Op, TealBlock, TealOp
from pyteal.types import TealType, valid_base16, valid_base32, valid_base64
from pyteal.util import escapeStr

if TYPE_CHECKING:
    from pyteal.compiler import CompileOptions


class Bytes(LeafExpr):
    """An expression that represents a byte string."""

    @overload
    def __init__(self, arg1: str | bytes | bytearray) -> None:
        pass

    @overload
    def __init__(self, arg1: str, arg2: str) -> None:
        pass

    def __init__(self, arg1: str | bytes | bytearray, arg2: str | None = None) -> None:
        """
        __init__(arg1: Union[str, bytes, bytearray]) -> None
        __init__(self, arg1: str, arg2: str) -> None

        Create a new byte string.

        Depending on the encoding, there are different arguments to pass:

        For UTF-8 strings:
            Pass the string as the only argument. For example, ``Bytes("content")``.
        For raw bytes or bytearray objects:
            Pass the bytes or bytearray as the only argument. For example, ``Bytes(b"content")``.
        For base16, base32, or base64 strings:
            Pass the base as the first argument and the string as the second argument. For example,
            ``Bytes("base16", "636F6E74656E74")``, ``Bytes("base32", "ORFDPQ6ARJK")``,
            ``Bytes("base64", "Y29udGVudA==")``.
        Special case for base16:
            The prefix "0x" may be present in a base16 byte string. For example,
            ``Bytes("base16", "0x636F6E74656E74")``.
        """
        super().__init__()
        if arg2 is None:
            if type(arg1) is str:
                self.base = "utf8"
                self.byte_str = escapeStr(arg1)
            elif type(arg1) in (bytes, bytearray):
                self.base = "base16"
                self.byte_str = cast(bytes | bytearray, arg1).hex()
            else:
                raise TealInputError(f"Unknown argument type: {type(arg1)}")
        else:
            if type(arg1) is not str:
                raise TealInputError(f"Unknown type for base: {type(arg1)}")

            if type(arg2) is not str:
                raise TealInputError(f"Unknown type for value: {type(arg2)}")

            self.base = arg1

            if self.base == "base32":
                valid_base32(arg2)
                self.byte_str = arg2
            elif self.base == "base64":
                self.byte_str = arg2
                valid_base64(self.byte_str)
            elif self.base == "base16":
                if arg2.startswith("0x"):
                    self.byte_str = arg2[2:]
                else:
                    self.byte_str = arg2
                valid_base16(self.byte_str)
            else:
                raise TealInputError(
                    f"invalid base {self.base}, need to be base32, base64, or base16."
                )

    def __teal__(self, options: "CompileOptions"):
        if self.base == "utf8":
            payload = self.byte_str
        elif self.base == "base16":
            payload = "0x" + self.byte_str
        else:
            payload = f"{self.base}({self.byte_str})"
        op = TealOp(self, Op.byte, payload)
        return TealBlock.FromOp(options, op)

    def __str__(self):
        return f"({self.base} bytes: {self.byte_str})"

    def type_of(self):
        return TealType.bytes


Bytes.__module__ = "pyteal"



================================================
FILE: pyteal/ast/bytes_test.py
================================================
import pytest

import pyteal as pt
from pyteal.errors import TealInputError

options = pt.CompileOptions()


def test_bytes_base32_no_padding():
    for s in (
        "ME",
        "MFRA",
        "MFRGG",
        "MFRGGZA",
        "MFRGGZDF",
        "7Z5PWO2C6LFNQFGHWKSK5H47IQP5OJW2M3HA2QPXTY3WTNP5NU2MHBW27M",
    ):
        expr = pt.Bytes("base32", s)
        assert expr.type_of() == pt.TealType.bytes
        expected = pt.TealSimpleBlock(
            [pt.TealOp(expr, pt.Op.byte, "base32(" + s + ")")]
        )
        actual, _ = expr.__teal__(options)
        assert actual == expected


def test_bytes_base32_padding():
    for s in (
        "ME======",
        "MFRA====",
        "MFRGG===",
        "MFRGGZA=",
        "7Z5PWO2C6LFNQFGHWKSK5H47IQP5OJW2M3HA2QPXTY3WTNP5NU2MHBW27M======",
    ):
        expr = pt.Bytes("base32", s)
        assert expr.type_of() == pt.TealType.bytes
        expected = pt.TealSimpleBlock(
            [pt.TealOp(expr, pt.Op.byte, "base32(" + s + ")")]
        )
        actual, _ = expr.__teal__(options)
        assert actual == expected


def test_bytes_base32_empty():
    expr = pt.Bytes("base32", "")
    assert expr.type_of() == pt.TealType.bytes
    expected = pt.TealSimpleBlock([pt.TealOp(expr, pt.Op.byte, "base32()")])
    actual, _ = expr.__teal__(options)
    assert actual == expected


def test_bytes_base64():
    expr = pt.Bytes("base64", "Zm9vYmE=")
    assert expr.type_of() == pt.TealType.bytes
    expected = pt.TealSimpleBlock([pt.TealOp(expr, pt.Op.byte, "base64(Zm9vYmE=)")])
    actual, _ = expr.__teal__(options)
    assert actual == expected


def test_bytes_base64_empty():
    expr = pt.Bytes("base64", "")
    assert expr.type_of() == pt.TealType.bytes
    expected = pt.TealSimpleBlock([pt.TealOp(expr, pt.Op.byte, "base64()")])
    actual, _ = expr.__teal__(options)
    assert actual == expected


def test_bytes_base16():
    expr = pt.Bytes("base16", "A21212EF")
    assert expr.type_of() == pt.TealType.bytes
    expected = pt.TealSimpleBlock([pt.TealOp(expr, pt.Op.byte, "0xA21212EF")])
    actual, _ = expr.__teal__(options)
    assert actual == expected


def test_bytes_base16_prefix():
    expr = pt.Bytes("base16", "0xA21212EF")
    assert expr.type_of() == pt.TealType.bytes
    expected = pt.TealSimpleBlock([pt.TealOp(expr, pt.Op.byte, "0xA21212EF")])
    actual, _ = expr.__teal__(options)
    assert actual == expected


def test_bytes_base16_empty():
    expr = pt.Bytes("base16", "")
    assert expr.type_of() == pt.TealType.bytes
    expected = pt.TealSimpleBlock([pt.TealOp(expr, pt.Op.byte, "0x")])
    actual, _ = expr.__teal__(options)
    assert actual == expected


B16_ODD_LEN_TESTCASES = ["F", "0c1"]


@pytest.mark.parametrize("testcase", B16_ODD_LEN_TESTCASES)
def test_bytes_base16_odd_len(testcase):
    with pytest.raises(TealInputError):
        pt.Bytes("base16", testcase)


def test_bytes_utf8():
    expr = pt.Bytes("hello world")
    assert expr.type_of() == pt.TealType.bytes
    expected = pt.TealSimpleBlock([pt.TealOp(expr, pt.Op.byte, '"hello world"')])
    actual, _ = expr.__teal__(options)
    assert actual == expected


def test_bytes_utf8_special_chars():
    expr = pt.Bytes("\t \n \r\n \\ \" ' 😀")
    assert expr.type_of() == pt.TealType.bytes
    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(
                expr, pt.Op.byte, '"\\t \\n \\r\\n \\\\ \\" \' \\xf0\\x9f\\x98\\x80"'
            )
        ]
    )
    actual, _ = expr.__teal__(options)
    assert actual == expected


def test_bytes_utf8_empty():
    expr = pt.Bytes("")
    assert expr.type_of() == pt.TealType.bytes
    expected = pt.TealSimpleBlock([pt.TealOp(expr, pt.Op.byte, '""')])
    actual, _ = expr.__teal__(options)
    assert actual == expected


def test_bytes_raw():
    for value in (b"hello world", bytearray(b"hello world")):
        expr = pt.Bytes(value)
        assert expr.type_of() == pt.TealType.bytes
        expected = pt.TealSimpleBlock([pt.TealOp(expr, pt.Op.byte, "0x" + value.hex())])
        actual, _ = expr.__teal__(options)
        assert actual == expected


def test_bytes_raw_empty():
    for value in (b"", bytearray(b"")):
        expr = pt.Bytes(value)
        assert expr.type_of() == pt.TealType.bytes
        expected = pt.TealSimpleBlock([pt.TealOp(expr, pt.Op.byte, "0x")])
        actual, _ = expr.__teal__(options)
        assert actual == expected


def test_bytes_invalid():
    with pytest.raises(pt.TealInputError):
        pt.Bytes("base16", b"FF")

    with pytest.raises(pt.TealInputError):
        pt.Bytes(b"base16", "FF")

    with pytest.raises(pt.TealInputError):
        pt.Bytes("base23", "")

    with pytest.raises(pt.TealInputError):
        pt.Bytes("base32", "Zm9vYmE=")

    with pytest.raises(pt.TealInputError):
        pt.Bytes("base32", "MFRGG====")

    with pytest.raises(pt.TealInputError):
        pt.Bytes("base32", "MFRGG==")

    with pytest.raises(pt.TealInputError):
        pt.Bytes("base32", "CCCCCC==")

    with pytest.raises(pt.TealInputError):
        pt.Bytes("base32", "CCCCCC")

    with pytest.raises(pt.TealInputError):
        pt.Bytes("base32", "C=======")

    with pytest.raises(pt.TealInputError):
        pt.Bytes("base32", "C")

    with pytest.raises(pt.TealInputError):
        pt.Bytes("base32", "=")

    with pytest.raises(pt.TealInputError):
        pt.Bytes("base64", "?????")

    with pytest.raises(pt.TealInputError):
        pt.Bytes("base16", "7Z5PWO2C6LFNQFGHWKSK5H47IQP5OJW2M3HA2QPXTY3WTNP5NU2MHBW27M")



================================================
FILE: pyteal/ast/comment.py
================================================
from typing import TYPE_CHECKING

from pyteal.errors import TealInputError
from pyteal.types import TealType
from pyteal.ir import TealBlock, TealSimpleBlock, TealOp, Op
from pyteal.ast.expr import Expr
from pyteal.ast.seq import Seq

if TYPE_CHECKING:
    from pyteal.compiler import CompileOptions


class CommentExpr(Expr):
    """Represents a single line comment in TEAL source code.

    This class is intentionally hidden because it's too basic to directly expose. Anything exposed
    to users should be able to handle multi-line comments by breaking them apart and using this
    class.
    """

    def __init__(self, single_line_comment: str) -> None:
        super().__init__()
        if "\n" in single_line_comment or "\r" in single_line_comment:
            raise TealInputError(
                "Newlines should not be present in the CommentExpr constructor"
            )
        self.comment = single_line_comment

    def __teal__(self, options: "CompileOptions") -> tuple[TealBlock, TealSimpleBlock]:
        op = TealOp(self, Op.comment, self.comment)
        return TealBlock.FromOp(options, op)

    def __str__(self):
        return f'(Comment "{self.comment}")'

    def type_of(self):
        return TealType.none

    def has_return(self):
        return False


CommentExpr.__module__ = "pyteal"


def Comment(comment: str, expr: Expr | None = None) -> Expr:
    """Wrap an existing expression with a comment.

    This comment will be present in the compiled TEAL source immediately before the first op of the
    expression.

    Note that when TEAL source is assembled into bytes, all comments are omitted.

    Args:
        comment: The comment that will be associated with the expression.
        expr: The expression to be commented.

    Returns:
        A new expression which is functionally equivalent to the input expression, but which will
        compile with the given comment string.
    """
    lines = comment.splitlines()
    comment_lines: list[Expr] = [CommentExpr(line) for line in lines]
    if expr is not None:
        comment_lines.append(expr)
    return Seq(*comment_lines)



================================================
FILE: pyteal/ast/comment_test.py
================================================
import pytest

import pyteal as pt
from pyteal.ast.comment import CommentExpr

options = pt.CompileOptions()


def test_CommentExpr():
    for comment in ("", "hello world", " // a b c //    \t . "):
        expr = CommentExpr(comment)
        assert expr.comment == comment
        assert expr.type_of() == pt.TealType.none
        assert expr.has_return() is False

        expected = pt.TealSimpleBlock(
            [
                pt.TealOp(expr, pt.Op.comment, comment),
            ]
        )

        actual, _ = expr.__teal__(options)
        actual.addIncoming()
        actual = pt.TealBlock.NormalizeBlocks(actual)

        assert actual == expected

    for newline in ("\n", "\r\n", "\r"):
        with pytest.raises(
            pt.TealInputError,
            match=r"Newlines should not be present in the CommentExpr constructor$",
        ):
            CommentExpr(f"one line{newline}two lines")


def test_Comment_Expr_empty():
    comment = "dope"
    expr = pt.Comment(comment)
    assert type(expr) is pt.Seq
    assert len(expr.args) == 1

    assert getattr(expr.args[0], "comment") == comment


def test_Comment_empty():
    to_wrap = pt.Int(1)
    comment = ""
    expr = pt.Comment(comment, to_wrap)
    assert type(expr) is pt.Seq
    assert len(expr.args) == 1

    assert expr.args[0] is to_wrap


def test_Comment_single_line():
    to_wrap = pt.Int(1)
    comment = "just an int"
    expr = pt.Comment(comment, to_wrap)
    assert type(expr) is pt.Seq
    assert len(expr.args) == 2

    assert type(expr.args[0]) is CommentExpr
    assert expr.args[0].comment == comment

    assert expr.args[1] is to_wrap

    version = 6
    expected_teal = f"""#pragma version {version}
// {comment}
int 1
return"""
    actual_teal = pt.compileTeal(
        pt.Return(expr), version=version, mode=pt.Mode.Application
    )
    assert actual_teal == expected_teal


def test_Comment_multi_line():
    to_wrap = pt.Int(1)
    comment = """just an int
but its really more than that isnt it? an integer here is a uint64 stack type but looking further what does that mean? 
You might say its a 64 bit representation of an element of the set Z and comes from the latin `integer` meaning `whole`
since it has no fractional part. You might also say this run on comment has gone too far. See https://en.wikipedia.org/wiki/Integer for more details 
"""

    comment_parts = [
        "just an int",
        "but its really more than that isnt it? an integer here is a uint64 stack type but looking further what does that mean? ",
        "You might say its a 64 bit representation of an element of the set Z and comes from the latin `integer` meaning `whole`",
        "since it has no fractional part. You might also say this run on comment has gone too far. See https://en.wikipedia.org/wiki/Integer for more details ",
    ]

    expr = pt.Comment(comment, to_wrap)
    assert type(expr) is pt.Seq
    assert len(expr.args) == 5

    for i, part in enumerate(comment_parts):
        arg = expr.args[i]
        assert type(arg) is CommentExpr
        assert arg.comment == part

    assert expr.args[4] is to_wrap

    version = 6
    expected_teal = f"""#pragma version {version}
// just an int
// but its really more than that isnt it? an integer here is a uint64 stack type but looking further what does that mean? 
// You might say its a 64 bit representation of an element of the set Z and comes from the latin `integer` meaning `whole`
// since it has no fractional part. You might also say this run on comment has gone too far. See https://en.wikipedia.org/wiki/Integer for more details 
int 1
return"""
    actual_teal = pt.compileTeal(
        pt.Return(expr), version=version, mode=pt.Mode.Application
    )

    assert actual_teal == expected_teal



================================================
FILE: pyteal/ast/cond.py
================================================
from typing import List, cast, TYPE_CHECKING
from pyteal.ast.seq import _use_seq_if_multiple

from pyteal.types import TealType, require_type
from pyteal.ir import TealOp, Op, TealSimpleBlock, TealConditionalBlock
from pyteal.errors import TealInputError
from pyteal.ast.expr import Expr

if TYPE_CHECKING:
    from pyteal.compiler import CompileOptions


def _reformat_multi_argv(argv: tuple[list[Expr], ...]) -> list[list[Expr]]:
    """Reformat a list of lists of expressions with potentially multiple value expressions into a list of lists of expressions with only one value expression
        by using Seq blocks where appropriate.

    Example:
        [ [a, b, c], [d, e, f] ] -> [ [a, Seq(b, c)], [d, Seq(e, f)] ]
    """
    reformatted = []
    for arg in argv:
        # Note: this is not a valid Cond arg, but will be caught later in Cond.__init__()
        if len(arg) <= 1:
            reformatted.append(arg)
        else:
            reformatted.append([arg[0], _use_seq_if_multiple(arg[1:])])

    return reformatted


class Cond(Expr):
    """A chainable branching expression that supports an arbitrary number of conditions."""

    def __init__(self, *argv: List[Expr]):
        """Create a new Cond expression.

        At least one argument must be provided, and each argument must be a list with two or more elements.
        The first element is a condition which evalutes to uint64, and the remaining elements are the body
        of the condition, which will execute if that condition is true. The last elements of the condition bodies
        must have the same return type. During execution, each condition is tested in order, and the first
        condition to evaluate to a true value will cause its associated body to execute and become
        the value for this Cond expression. If no condition evalutes to a true value, the Cond
        expression produces an error and the TEAL program terminates.

        Example:
            .. code-block:: python

                Cond([Global.group_size() == Int(5), bid],
                    [Global.group_size() == Int(4), redeem, log],
                    [Global.group_size() == Int(1), wrapup])
        """
        super().__init__()

        if len(argv) < 1:
            raise TealInputError("Cond requires at least one [condition, value]")

        value_type = None
        sequenced_argv = _reformat_multi_argv(argv)

        for arg in sequenced_argv:
            msg = "Cond should be in the form of Cond([cond1, value1], [cond2, value2], ...), error in {}"
            if not isinstance(arg, list):
                raise TealInputError(msg.format(arg))
            if len(arg) != 2:
                raise TealInputError(msg.format(arg))

            require_type(arg[0], TealType.uint64)  # cond_n should be int

            if value_type is None:  # the types of all branches should be the same
                value_type = arg[1].type_of()
            else:
                require_type(arg[1], value_type)

        self.value_type = value_type
        self.args = sequenced_argv

    def __teal__(self, options: "CompileOptions"):
        start = None
        end = TealSimpleBlock([])
        prevBranch: TealConditionalBlock | None = None
        for i, (cond, pred) in enumerate(self.args):
            condStart, condEnd = cond.__teal__(options)
            predStart, predEnd = pred.__teal__(options)

            branchBlock = TealConditionalBlock([], root_expr=cond)
            branchBlock.setTrueBlock(predStart)

            condEnd.setNextBlock(branchBlock)
            predEnd.setNextBlock(end)
            if i == 0:
                start = condStart
            else:
                cast(TealConditionalBlock, prevBranch).setFalseBlock(condStart)

            prevBranch = branchBlock

        errBlock = TealSimpleBlock([TealOp(self, Op.err)])
        cast(TealConditionalBlock, prevBranch).setFalseBlock(errBlock)

        return start, end

    def __str__(self):
        ret_str = "(Cond"
        for a in self.args:
            ret_str += " [" + a[0].__str__() + ", " + a[1].__str__() + "]"
        ret_str += ")"
        return ret_str

    def type_of(self):
        return self.value_type

    def has_return(self):
        # this expression has a return op only if all possible conditions result in a return op
        return all(pred.has_return() for (_, pred) in self.args)


Cond.__module__ = "pyteal"



================================================
FILE: pyteal/ast/cond_test.py
================================================
import pytest

import pyteal as pt

options = pt.CompileOptions()


def test_cond_one_pred():
    expr = pt.Cond([pt.Int(1), pt.Int(2)])
    assert expr.type_of() == pt.TealType.uint64

    cond1, _ = pt.Int(1).__teal__(options)
    pred1, _ = pt.Int(2).__teal__(options)
    cond1Branch = pt.TealConditionalBlock([])
    cond1.setNextBlock(cond1Branch)
    cond1Branch.setTrueBlock(pred1)
    cond1Branch.setFalseBlock(pt.Err().__teal__(options)[0])
    pred1.setNextBlock(pt.TealSimpleBlock([]))
    expected = cond1

    actual, _ = expr.__teal__(options)

    with pt.TealComponent.Context.ignoreExprEquality():
        assert actual == expected


def test_cond_two_pred():
    expr = pt.Cond([pt.Int(1), pt.Bytes("one")], [pt.Int(0), pt.Bytes("zero")])
    assert expr.type_of() == pt.TealType.bytes

    cond1, _ = pt.Int(1).__teal__(options)
    pred1, _ = pt.Bytes("one").__teal__(options)
    cond1Branch = pt.TealConditionalBlock([])
    cond2, _ = pt.Int(0).__teal__(options)
    pred2, _ = pt.Bytes("zero").__teal__(options)
    cond2Branch = pt.TealConditionalBlock([])
    end = pt.TealSimpleBlock([])

    cond1.setNextBlock(cond1Branch)
    cond1Branch.setTrueBlock(pred1)
    cond1Branch.setFalseBlock(cond2)
    pred1.setNextBlock(end)

    cond2.setNextBlock(cond2Branch)
    cond2Branch.setTrueBlock(pred2)
    cond2Branch.setFalseBlock(pt.Err().__teal__(options)[0])
    pred2.setNextBlock(end)

    expected = cond1

    actual, _ = expr.__teal__(options)

    with pt.TealComponent.Context.ignoreExprEquality():
        assert actual == expected


def test_cond_three_pred():
    expr = pt.Cond(
        [pt.Int(1), pt.Int(2)], [pt.Int(3), pt.Int(4)], [pt.Int(5), pt.Int(6)]
    )
    assert expr.type_of() == pt.TealType.uint64

    cond1, _ = pt.Int(1).__teal__(options)
    pred1, _ = pt.Int(2).__teal__(options)
    cond1Branch = pt.TealConditionalBlock([])
    cond2, _ = pt.Int(3).__teal__(options)
    pred2, _ = pt.Int(4).__teal__(options)
    cond2Branch = pt.TealConditionalBlock([])
    cond3, _ = pt.Int(5).__teal__(options)
    pred3, _ = pt.Int(6).__teal__(options)
    cond3Branch = pt.TealConditionalBlock([])
    end = pt.TealSimpleBlock([])

    cond1.setNextBlock(cond1Branch)
    cond1Branch.setTrueBlock(pred1)
    cond1Branch.setFalseBlock(cond2)
    pred1.setNextBlock(end)

    cond2.setNextBlock(cond2Branch)
    cond2Branch.setTrueBlock(pred2)
    cond2Branch.setFalseBlock(cond3)
    pred2.setNextBlock(end)

    cond3.setNextBlock(cond3Branch)
    cond3Branch.setTrueBlock(pred3)
    cond3Branch.setFalseBlock(pt.Err().__teal__(options)[0])
    pred3.setNextBlock(end)

    expected = cond1

    actual, _ = expr.__teal__(options)

    with pt.TealComponent.Context.ignoreExprEquality():
        assert actual == expected


def test_cond_has_return():
    exprWithReturn = pt.Cond(
        [pt.Int(1), pt.Return(pt.Int(1))], [pt.Int(0), pt.Return(pt.Int(0))]
    )
    assert exprWithReturn.has_return()

    exprWithoutReturn = pt.Cond(
        [pt.Int(1), pt.Bytes("one")], [pt.Int(0), pt.Bytes("zero")]
    )
    assert not exprWithoutReturn.has_return()

    exprSemiReturn = pt.Cond(
        [pt.Int(1), pt.Return(pt.Int(1))],
        [pt.Int(0), pt.App.globalPut(pt.Bytes("key"), pt.Bytes("value"))],
    )
    assert not exprSemiReturn.has_return()


def test_cond_invalid():
    with pytest.raises(pt.TealInputError):
        pt.Cond()

    with pytest.raises(pt.TealInputError):
        pt.Cond([])

    with pytest.raises(pt.TealInputError):
        pt.Cond([pt.Int(1)], [pt.Int(2), pt.Pop(pt.Txn.receiver())])

    with pytest.raises(pt.TealTypeError):
        pt.Cond([pt.Int(1), pt.Int(2)], [pt.Int(2), pt.Txn.receiver()])

    with pytest.raises(pt.TealTypeError):
        pt.Cond([pt.Arg(0), pt.Int(2)])

    with pytest.raises(pt.TealTypeError):
        pt.Cond([pt.Int(1), pt.Int(2)], [pt.Int(2), pt.Pop(pt.Int(2))])

    with pytest.raises(pt.TealTypeError):
        pt.Cond([pt.Int(1), pt.Pop(pt.Int(1))], [pt.Int(2), pt.Int(2)])


def test_cond_two_pred_multi():
    args = [
        pt.Int(1),
        [pt.Pop(pt.Int(1)), pt.Bytes("one")],
        pt.Int(0),
        [pt.Pop(pt.Int(2)), pt.Bytes("zero")],
    ]
    expr = pt.Cond(
        [args[0]] + args[1],
        [args[2]] + args[3],
    )
    assert expr.type_of() == pt.TealType.bytes

    cond1, _ = args[0].__teal__(options)
    pred1, pred1End = pt.Seq(args[1]).__teal__(options)
    cond1Branch = pt.TealConditionalBlock([])
    cond2, _ = args[2].__teal__(options)
    pred2, pred2End = pt.Seq(args[3]).__teal__(options)
    cond2Branch = pt.TealConditionalBlock([])
    end = pt.TealSimpleBlock([])

    cond1.setNextBlock(cond1Branch)
    cond1Branch.setTrueBlock(pred1)
    cond1Branch.setFalseBlock(cond2)
    pred1End.setNextBlock(end)

    cond2.setNextBlock(cond2Branch)
    cond2Branch.setTrueBlock(pred2)
    cond2Branch.setFalseBlock(pt.Err().__teal__(options)[0])
    pred2End.setNextBlock(end)

    expected = cond1

    actual, _ = expr.__teal__(options)

    with pt.TealComponent.Context.ignoreExprEquality():
        assert actual == expected



================================================
FILE: pyteal/ast/continue_.py
================================================
from typing import TYPE_CHECKING

from pyteal.types import TealType
from pyteal.errors import TealCompileError
from pyteal.ast.expr import Expr
from pyteal.ir import TealSimpleBlock


if TYPE_CHECKING:
    from pyteal.compiler import CompileOptions


class Continue(Expr):
    """A continue expression"""

    def __init__(self) -> None:
        """Create a new continue expression.

        This operation is only permitted in a loop.

        """
        super().__init__()

    def __str__(self) -> str:
        return "continue"

    def __teal__(self, options: "CompileOptions"):
        if not options.isInLoop():
            raise TealCompileError("continue is only allowed in a loop", self)

        start = TealSimpleBlock([])
        options.addLoopContinueBlock(start)

        return start, start

    def type_of(self):
        return TealType.none

    def has_return(self):
        return False


Continue.__module__ = "pyteal"



================================================
FILE: pyteal/ast/continue_test.py
================================================
import pytest

import pyteal as pt

options = pt.CompileOptions()


def test_continue_fail():
    with pytest.raises(pt.TealCompileError):
        pt.Continue().__teal__(options)

    with pytest.raises(pt.TealCompileError):
        pt.If(pt.Int(1), pt.Continue()).__teal__(options)

    with pytest.raises(pt.TealCompileError):
        pt.Seq([pt.Continue()]).__teal__(options)

    with pytest.raises(TypeError):
        pt.Continue(pt.Int(1))


def test_continue():
    expr = pt.Continue()

    assert expr.type_of() == pt.TealType.none
    assert not expr.has_return()

    expected = pt.TealSimpleBlock([])

    options.enterLoop()
    actual, _ = expr.__teal__(options)
    breakBlocks, continueBlocks = options.exitLoop()

    assert actual == expected
    assert breakBlocks == []
    assert continueBlocks == [actual]



================================================
FILE: pyteal/ast/ec.py
================================================
from typing import TYPE_CHECKING
from enum import Enum

from pyteal.ast.expr import Expr

from pyteal.ir import Op, TealBlock, TealOp
from pyteal.types import TealType, require_type
from pyteal.errors import verifyFieldVersion, verifyProgramVersion

if TYPE_CHECKING:
    from pyteal.compiler import CompileOptions


class EllipticCurve(Enum):
    # fmt: off
    #            id | name         | min version
    BN254g1 =     (0, "BN254g1",     10)
    BN254g2 =     (1, "BN254g2",     10)
    BLS12_381g1 = (2, "BLS12_381g1", 10)
    BLS12_381g2 = (3, "BLS12_381g2", 10)
    # fmt: on

    def __init__(self, id: int, name: str, min_version: int) -> None:
        self.id = id
        self.arg_name = name
        self.min_version = min_version


class EcOperation(Expr):
    def __init__(
        self, op: Op, curve: EllipticCurve, args: list[Expr], return_type: TealType
    ) -> None:
        super().__init__()
        self.op = op
        assert curve in EllipticCurve
        self.curve = curve
        for arg in args:
            require_type(arg, TealType.bytes)
        self.args = args
        self.return_type = return_type

    def __teal__(self, options: "CompileOptions"):
        verifyProgramVersion(
            self.op.min_version,
            options.version,
            f"Program version too low to use op {self.op}",
        )

        verifyFieldVersion(self.curve.arg_name, self.curve.min_version, options.version)

        op = TealOp(self, self.op, self.curve.arg_name)
        return TealBlock.FromOp(options, op, *self.args)

    def __str__(self):
        return f"(EcOperation {self.op} {self.curve} {self.args})"

    def type_of(self):
        return self.return_type

    def has_return(self):
        return False


def EcAdd(curve: EllipticCurve, a: Expr, b: Expr) -> Expr:
    """Add two points on the given elliptic curve.

    Args:
        curve: The elliptic curve to use.
        a: The first point to add. Must evaluate to bytes.
        b: The second point to add. Must evaluate to bytes.

    Returns:
        An expression which evaluates to the sum of the two points on the given
        curve.
    """
    return EcOperation(Op.ec_add, curve, [a, b], TealType.bytes)


def EcScalarMul(curve: EllipticCurve, point: Expr, scalar: Expr) -> Expr:
    """Multiply a point on the given elliptic curve by a scalar.

    Args:
        curve: The elliptic curve to use.
        point: The point to multiply. Must evaluate to bytes.
        scalar: The scalar to multiply by, encoded as a big-endian unsigned
            integer. Must evaluate to bytes. Fails if this value exceeds 32 bytes.

    Returns:
        An expression which evaluates to the product of the point and scalar on
        the given curve.
    """
    return EcOperation(Op.ec_scalar_mul, curve, [point, scalar], TealType.bytes)


def EcPairingCheck(curve: EllipticCurve, a: Expr, b: Expr) -> Expr:
    """Check the pairing of two points on the given elliptic curve.

    Args:
        curve: The elliptic curve to use.
        a: The first point to check. Must evaluate to bytes.
        b: The second point to check. Must evaluate to bytes.

    Returns:
        An expression which evaluates to 1 if the product of the pairing of each
        point in `a` with its respective point in `b` is equal to the identity
        element of the target group. Otherwise, evaluates to 0.
    """
    return EcOperation(Op.ec_pairing_check, curve, [a, b], TealType.uint64)


def EcMultiScalarMul(curve: EllipticCurve, a: Expr, b: Expr) -> Expr:
    """Multiply a point on the given elliptic curve by a series of scalars.

    Args:
        curve: The elliptic curve to use.
        a: The point to multiply. Must evaluate to bytes.
        b: A list of concatenated, big-endian, 32-byte scalar integers to
            multiply by.

    Returns:
        An expression that evaluates to curve point :code:`b_0a_0 + b_1a_1 + b_2a_2 + ... + b_Na_N`.
    """
    return EcOperation(Op.ec_multi_scalar_mul, curve, [a, b], TealType.bytes)


def EcSubgroupCheck(curve: EllipticCurve, a: Expr) -> Expr:
    """Check if a point is in the main prime-order subgroup of the given elliptic curve.

    Args:
        curve: The elliptic curve to use.
        a: The point to check. Must evaluate to bytes.

    Returns:
        An expression that evaluates to 1 if the point is in the main prime-order
        subgroup of the curve (including the point at infinity) else 0. Program
        fails if the point is not in the curve at all.
    """
    return EcOperation(Op.ec_subgroup_check, curve, [a], TealType.uint64)


def EcMapTo(curve: EllipticCurve, a: Expr) -> Expr:
    """Map field element `a` to group `curve`.

    Args:
        curve: The elliptic curve to use.
        a: The field element to map. Must evaluate to bytes.

    Returns:
        An expression that evaluates to the mapped point.
    """
    return EcOperation(Op.ec_map_to, curve, [a], TealType.bytes)



================================================
FILE: pyteal/ast/ec_test.py
================================================
from typing import Callable

import pytest

import pyteal as pt

OPERATIONS: list[
    tuple[
        Callable[[pt.EllipticCurve, pt.Expr], pt.Expr]
        | Callable[[pt.EllipticCurve, pt.Expr, pt.Expr], pt.Expr],
        pt.Op,
        int,
        pt.TealType,
    ]
] = [
    (pt.EcAdd, pt.Op.ec_add, 2, pt.TealType.bytes),
    (pt.EcScalarMul, pt.Op.ec_scalar_mul, 2, pt.TealType.bytes),
    (pt.EcPairingCheck, pt.Op.ec_pairing_check, 2, pt.TealType.uint64),
    (pt.EcMultiScalarMul, pt.Op.ec_multi_scalar_mul, 2, pt.TealType.bytes),
    (pt.EcSubgroupCheck, pt.Op.ec_subgroup_check, 1, pt.TealType.uint64),
    (pt.EcMapTo, pt.Op.ec_map_to, 1, pt.TealType.bytes),
]


def test_EcOperation():
    for operation, expected_op, num_args, expected_return_type in OPERATIONS:
        for curve in pt.EllipticCurve:
            args = [pt.Bytes(f"arg{i}") for i in range(num_args)]
            expr = operation(curve, *args)
            assert expr.type_of() == expected_return_type

            expected = pt.TealSimpleBlock(
                [pt.TealOp(arg, pt.Op.byte, f'"arg{i}"') for i, arg in enumerate(args)]
                + [pt.TealOp(expr, expected_op, curve.arg_name)]
            )

            actual, _ = expr.__teal__(pt.CompileOptions(version=10))
            actual.addIncoming()
            actual = pt.TealBlock.NormalizeBlocks(actual)

            assert actual == expected

            # Test wrong arg types
            for i in range(num_args):
                bad_args = args.copy()
                bad_args[i] = pt.Int(1)
                with pytest.raises(pt.TealTypeError):
                    operation(curve, *bad_args)



================================================
FILE: pyteal/ast/ecdsa.py
================================================
from enum import Enum
from typing import Tuple, TYPE_CHECKING

from pyteal.ast.expr import Expr
from pyteal.ast.multi import MultiValue
from pyteal.errors import (
    TealTypeError,
    verifyFieldVersion,
    verifyProgramVersion,
    TealInputError,
)
from pyteal.ir import Op, TealBlock, TealOp
from pyteal.types import TealType, require_type

if TYPE_CHECKING:
    from pyteal.compiler import CompileOptions


EcdsaPubkey = [TealType.bytes, TealType.bytes]


class EcdsaCurve(Enum):
    """Enum representing an elliptic curve specification used in ECDSA."""

    Secp256k1 = (0, "Secp256k1", 5)
    Secp256r1 = (1, "Secp256r1", 7)

    def __init__(self, id: int, name: str, min_version: int) -> None:
        self.id = id
        self.arg_name = name
        self.min_version = min_version


class EcdsaVerifyExpr(Expr):
    """Implements basic ECDSA verification functionality

    This class shouldn't be directly used in a PyTeal program. The EcdsaVerify function
    should be used instead."""

    def __init__(
        self,
        curve: EcdsaCurve,
        data: Expr,
        sigA: Expr,
        sigB: Expr,
        pkX: Expr,
        pkY: Expr,
    ):
        super().__init__()
        require_type(data, TealType.bytes)
        require_type(sigA, TealType.bytes)
        require_type(sigB, TealType.bytes)
        require_type(pkX, TealType.bytes)
        require_type(pkY, TealType.bytes)

        self.op = Op.ecdsa_verify
        self.curve = curve
        self.args = [data, sigA, sigB, pkX, pkY]

    def __teal__(self, options: "CompileOptions"):
        verifyProgramVersion(
            self.op.min_version,
            options.version,
            "Program version too low to use op {}".format(self.op),
        )

        verifyFieldVersion(self.curve.arg_name, self.curve.min_version, options.version)

        return TealBlock.FromOp(
            options, TealOp(self, self.op, self.curve.arg_name), *self.args
        )

    def __str__(self):
        return "({} {} {} {} {} {} {})".format(self.op, self.curve, *self.args)

    def type_of(self):
        return TealType.uint64

    def has_return(self):
        return False


def EcdsaVerify(
    curve: EcdsaCurve,
    data: Expr,
    sigA: Expr,
    sigB: Expr,
    pubkey: Tuple[Expr, Expr] | MultiValue,
) -> Expr:
    """Verify an ECDSA signature.

    The public key argument can be represented as either a tuple of Byte expressions
    representing the (X,Y) point on the elliptic curve or a MultiValue expression returning
    two Byte expressions, ex. the value returned by EcdsaDecompress or EcdsaRecover. All byte
    arguments must be big endian encoded.

    Args:
        curve: Enum representing the ECDSA curve used for the signature and public key
        data: Hash value of the signed data. Must be 32 bytes long.
        sigA: First component of the signature. Must evaluate to bytes.
        sigB: Second component of the signature. Must evaluate to bytes.
        pubkey: Public key used to verify signature. Represented as either a tuple of expressions
            that must evaluate to bytes or as a MultiValue expression that returns two byte values.

    Returns:
        An expression evaluating to either 0 or 1 representing the success of verification
    """

    if not isinstance(curve, EcdsaCurve):
        raise TealTypeError(curve, EcdsaCurve)

    if isinstance(pubkey, MultiValue):
        if pubkey.types != EcdsaPubkey:
            raise TealTypeError(pubkey.types, EcdsaPubkey)

        return pubkey.outputReducer(
            lambda X, Y: EcdsaVerifyExpr(curve, data, sigA, sigB, X, Y)
        )

    return EcdsaVerifyExpr(curve, data, sigA, sigB, pubkey[0], pubkey[1])


def EcdsaDecompress(curve: EcdsaCurve, compressed_pk: Expr) -> MultiValue:
    """Decompress an ECDSA public key.
    Args:
        curve: Enum representing the ECDSA curve used for the public key
        compressed_pk: The compressed public key. Must be 33 bytes long and big endian encoded.
    Returns:
        A MultiValue expression representing the two components of the public key, big endian
        encoded.
    """

    if not isinstance(curve, EcdsaCurve):
        raise TealTypeError(curve, EcdsaCurve)

    require_type(compressed_pk, TealType.bytes)
    return MultiValue(
        Op.ecdsa_pk_decompress,
        EcdsaPubkey,
        immediate_args=[curve.arg_name],
        args=[compressed_pk],
        compile_check=lambda options: verifyFieldVersion(
            curve.arg_name, curve.min_version, options.version
        ),
    )


def EcdsaRecover(
    curve: EcdsaCurve, data: Expr, recovery_id: Expr, sigA: Expr, sigB: Expr
) -> MultiValue:
    """Recover an ECDSA public key from a signature.
    All byte arguments must be big endian encoded.
    Args:
        curve: Enum representing the ECDSA curve used for the public key
        data: Hash value of the signed data. Must be 32 bytes long.
        recovery_id: value used to extract public key from signature. Must evaluate to uint.
        sigA: First component of the signature. Must evaluate to bytes.
        sigB: Second component of the signature. Must evaluate to bytes.
    Returns:
        A MultiValue expression representing the two components of the public key, big endian
        encoded.
    """

    if not isinstance(curve, EcdsaCurve):
        raise TealTypeError(curve, EcdsaCurve)

    if curve != EcdsaCurve.Secp256k1:
        raise TealInputError("Recover only supports Secp256k1")

    require_type(data, TealType.bytes)
    require_type(recovery_id, TealType.uint64)
    require_type(sigA, TealType.bytes)
    require_type(sigB, TealType.bytes)
    return MultiValue(
        Op.ecdsa_pk_recover,
        EcdsaPubkey,
        immediate_args=[curve.arg_name],
        args=[data, recovery_id, sigA, sigB],
        compile_check=lambda options: verifyFieldVersion(
            curve.arg_name, curve.min_version, options.version
        ),
    )



================================================
FILE: pyteal/ast/ecdsa_test.py
================================================
import pytest
from typing import Union, List, cast

import pyteal as pt

avm4Options = pt.CompileOptions(version=4)
avm5Options = pt.CompileOptions(version=5)
avm7Options = pt.CompileOptions(version=7)

curve_options_map = {
    pt.EcdsaCurve.Secp256k1: avm5Options,
    pt.EcdsaCurve.Secp256r1: avm7Options,
}


@pytest.mark.parametrize("curve", [pt.EcdsaCurve.Secp256k1, pt.EcdsaCurve.Secp256r1])
def test_ecdsa_decompress(curve: pt.EcdsaCurve):
    compressed_pubkey = pt.Bytes("XY")
    pubkey = pt.EcdsaDecompress(curve, compressed_pubkey)
    assert pubkey.type_of() == pt.TealType.none

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(compressed_pubkey, pt.Op.byte, '"XY"'),
            pt.TealOp(pubkey, pt.Op.ecdsa_pk_decompress, curve.arg_name),
            pt.TealOp(
                pubkey.output_slots[1].store(), pt.Op.store, pubkey.output_slots[1]
            ),
            pt.TealOp(
                pubkey.output_slots[0].store(), pt.Op.store, pubkey.output_slots[0]
            ),
        ]
    )

    actual, _ = pubkey.__teal__(curve_options_map[curve])
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    with pt.TealComponent.Context.ignoreExprEquality():
        assert actual == expected

    # compile without errors this is necessary so assembly is also tested
    pt.compileTeal(
        pt.Seq(pubkey, pt.Approve()), pt.Mode.Application, version=curve.min_version
    )

    with pytest.raises(pt.TealInputError):
        pt.compileTeal(
            pt.Seq(pubkey, pt.Approve()),
            pt.Mode.Application,
            version=curve.min_version - 1,
        )


@pytest.mark.parametrize("curve", [pt.EcdsaCurve.Secp256k1, pt.EcdsaCurve.Secp256r1])
def test_ecdsa_recover(curve: pt.EcdsaCurve):
    if curve != pt.EcdsaCurve.Secp256k1:
        with pytest.raises(pt.TealInputError):
            pt.EcdsaRecover(
                curve, pt.Bytes("data"), pt.Int(1), pt.Bytes("sigA"), pt.Bytes("sigB")
            )
    else:
        args = [pt.Bytes("data"), pt.Int(1), pt.Bytes("sigA"), pt.Bytes("sigB")]
        pubkey = pt.EcdsaRecover(curve, args[0], args[1], args[2], args[3])
        assert pubkey.type_of() == pt.TealType.none

        expected = pt.TealSimpleBlock(
            [
                pt.TealOp(args[0], pt.Op.byte, '"data"'),
                pt.TealOp(args[1], pt.Op.int, 1),
                pt.TealOp(args[2], pt.Op.byte, '"sigA"'),
                pt.TealOp(args[3], pt.Op.byte, '"sigB"'),
                pt.TealOp(pubkey, pt.Op.ecdsa_pk_recover, curve.arg_name),
                pt.TealOp(
                    pubkey.output_slots[1].store(), pt.Op.store, pubkey.output_slots[1]
                ),
                pt.TealOp(
                    pubkey.output_slots[0].store(), pt.Op.store, pubkey.output_slots[0]
                ),
            ]
        )

        actual, _ = pubkey.__teal__(curve_options_map[curve])
        actual.addIncoming()
        actual = pt.TealBlock.NormalizeBlocks(actual)

        with pt.TealComponent.Context.ignoreExprEquality():
            assert actual == expected

        # compile without errors this is necessary so assembly is also tested
        pt.compileTeal(
            pt.Seq(pubkey, pt.Approve()), pt.Mode.Application, version=curve.min_version
        )

        with pytest.raises(pt.TealInputError):
            pt.compileTeal(
                pt.Seq(pubkey, pt.Approve()),
                pt.Mode.Application,
                version=curve.min_version - 1,
            )


@pytest.mark.parametrize("curve", [pt.EcdsaCurve.Secp256k1, pt.EcdsaCurve.Secp256r1])
def test_ecdsa_verify_basic(curve: pt.EcdsaCurve):
    args = [pt.Bytes("data"), pt.Bytes("sigA"), pt.Bytes("sigB")]
    pubkey = (pt.Bytes("X"), pt.Bytes("Y"))
    expr = pt.EcdsaVerify(curve, args[0], args[1], args[2], pubkey)
    assert expr.type_of() == pt.TealType.uint64

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(args[0], pt.Op.byte, '"data"'),
            pt.TealOp(args[1], pt.Op.byte, '"sigA"'),
            pt.TealOp(args[2], pt.Op.byte, '"sigB"'),
            pt.TealOp(pubkey[0], pt.Op.byte, '"X"'),
            pt.TealOp(pubkey[1], pt.Op.byte, '"Y"'),
            pt.TealOp(expr, pt.Op.ecdsa_verify, curve.arg_name),
        ]
    )

    actual, _ = expr.__teal__(curve_options_map[curve])
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    assert actual == expected

    # compile without errors this is necessary so assembly is also tested
    pt.compileTeal(
        pt.Seq(pt.Pop(expr), pt.Approve()),
        pt.Mode.Application,
        version=curve.min_version,
    )

    with pytest.raises(pt.TealInputError):
        pt.compileTeal(
            pt.Seq(pt.Pop(expr), pt.Approve()),
            pt.Mode.Application,
            version=curve.min_version - 1,
        )


@pytest.mark.parametrize("curve", [pt.EcdsaCurve.Secp256k1, pt.EcdsaCurve.Secp256r1])
def test_ecdsa_verify_compressed_pk(curve: pt.EcdsaCurve):
    args = [pt.Bytes("data"), pt.Bytes("sigA"), pt.Bytes("sigB")]
    compressed_pubkey = pt.Bytes("XY")
    pubkey = pt.EcdsaDecompress(curve, compressed_pubkey)
    expr = pt.EcdsaVerify(curve, args[0], args[1], args[2], pubkey)
    assert expr.type_of() == pt.TealType.uint64

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(compressed_pubkey, pt.Op.byte, '"XY"'),
            pt.TealOp(pubkey, pt.Op.ecdsa_pk_decompress, curve.arg_name),
            pt.TealOp(
                pubkey.output_slots[1].store(), pt.Op.store, pubkey.output_slots[1]
            ),
            pt.TealOp(
                pubkey.output_slots[0].store(), pt.Op.store, pubkey.output_slots[0]
            ),
            pt.TealOp(args[0], pt.Op.byte, '"data"'),
            pt.TealOp(args[1], pt.Op.byte, '"sigA"'),
            pt.TealOp(args[2], pt.Op.byte, '"sigB"'),
            pt.TealOp(
                pubkey.output_slots[0].load(), pt.Op.load, pubkey.output_slots[0]
            ),
            pt.TealOp(
                pubkey.output_slots[1].load(), pt.Op.load, pubkey.output_slots[1]
            ),
            pt.TealOp(expr, pt.Op.ecdsa_verify, curve.arg_name),
        ]
    )

    actual, _ = expr.__teal__(curve_options_map[curve])
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    with pt.TealComponent.Context.ignoreExprEquality():
        assert actual == expected

    # compile without errors this is necessary so assembly is also tested
    pt.compileTeal(
        pt.Seq(pt.Pop(expr), pt.Approve()),
        pt.Mode.Application,
        version=curve.min_version,
    )

    with pytest.raises(pt.TealInputError):
        pt.compileTeal(
            pt.Seq(pt.Pop(expr), pt.Approve()),
            pt.Mode.Application,
            version=curve.min_version - 1,
        )


def test_ecdsa_verify_recovered_pk():
    curve = pt.EcdsaCurve.Secp256k1
    args = [pt.Bytes("data"), pt.Int(1), pt.Bytes("sigA"), pt.Bytes("sigB")]
    pubkey = pt.EcdsaRecover(curve, args[0], args[1], args[2], args[3])
    expr = pt.EcdsaVerify(curve, args[0], args[2], args[3], pubkey)
    assert expr.type_of() == pt.TealType.uint64

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(args[0], pt.Op.byte, '"data"'),
            pt.TealOp(args[1], pt.Op.int, 1),
            pt.TealOp(args[2], pt.Op.byte, '"sigA"'),
            pt.TealOp(args[3], pt.Op.byte, '"sigB"'),
            pt.TealOp(pubkey, pt.Op.ecdsa_pk_recover, curve.arg_name),
            pt.TealOp(
                pubkey.output_slots[1].store(), pt.Op.store, pubkey.output_slots[1]
            ),
            pt.TealOp(
                pubkey.output_slots[0].store(), pt.Op.store, pubkey.output_slots[0]
            ),
            pt.TealOp(args[0], pt.Op.byte, '"data"'),
            pt.TealOp(args[1], pt.Op.byte, '"sigA"'),
            pt.TealOp(args[2], pt.Op.byte, '"sigB"'),
            pt.TealOp(
                pubkey.output_slots[0].load(), pt.Op.load, pubkey.output_slots[0]
            ),
            pt.TealOp(
                pubkey.output_slots[1].load(), pt.Op.load, pubkey.output_slots[1]
            ),
            pt.TealOp(expr, pt.Op.ecdsa_verify, curve.arg_name),
        ]
    )

    actual, _ = expr.__teal__(curve_options_map[curve])
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    with pt.TealComponent.Context.ignoreExprEquality():
        assert actual == expected

    # compile without errors this is necessary so assembly is also tested
    pt.compileTeal(
        pt.Seq(pt.Pop(expr), pt.Approve()),
        pt.Mode.Application,
        version=curve.min_version,
    )

    with pytest.raises(pt.TealInputError):
        pt.compileTeal(
            pt.Seq(pt.Pop(expr), pt.Approve()),
            pt.Mode.Application,
            version=curve.min_version - 1,
        )


@pytest.mark.parametrize("curve", [pt.EcdsaCurve.Secp256k1, pt.EcdsaCurve.Secp256r1])
def test_ecdsa_invalid(curve: pt.EcdsaCurve):
    if curve == pt.EcdsaCurve.Secp256k1:
        with pytest.raises(pt.TealTypeError):
            args: List[Union[pt.Bytes, pt.Int]] = [
                pt.Bytes("data"),
                pt.Bytes("1"),
                pt.Bytes("sigA"),
                pt.Bytes("sigB"),
            ]
            pt.EcdsaRecover(curve, args[0], args[1], args[2], args[3])

    with pytest.raises(pt.TealTypeError):
        pt.EcdsaDecompress(curve, pt.Int(1))

    with pytest.raises(pt.TealTypeError):
        args = [pt.Bytes("data"), pt.Bytes("sigA"), pt.Bytes("sigB")]
        pubkey: Union[tuple[pt.Bytes, Union[pt.Int, pt.Bytes]], pt.MultiValue] = (
            pt.Bytes("X"),
            pt.Int(1),
        )
        pt.EcdsaVerify(curve, args[0], args[1], args[2], pubkey)

    with pytest.raises(pt.TealTypeError):
        args = [pt.Bytes("data"), pt.Int(1), pt.Bytes("sigB")]
        pubkey = (pt.Bytes("X"), pt.Bytes("Y"))
        pt.EcdsaVerify(curve, args[0], args[1], args[2], pubkey)

    with pytest.raises(pt.TealTypeError):
        args = [pt.Bytes("data"), pt.Bytes("sigA"), pt.Bytes("sigB")]
        compressed_pk = pt.Bytes("XY")
        pubkey = pt.MultiValue(
            pt.Op.ecdsa_pk_decompress,
            [pt.TealType.uint64, pt.TealType.bytes],
            immediate_args=[curve.__str__()],
            args=[compressed_pk],
        )
        pt.EcdsaVerify(curve, args[0], args[1], args[2], pubkey)

    with pytest.raises(pt.TealInputError):
        args = [pt.Bytes("data"), pt.Bytes("sigA"), pt.Bytes("sigB")]
        pubkey = (pt.Bytes("X"), pt.Bytes("Y"))
        expr = pt.EcdsaVerify(curve, args[0], args[1], args[2], pubkey)

        expr.__teal__(avm4Options)

    with pytest.raises(pt.TealTypeError):
        args = [pt.Bytes("data"), pt.Bytes("sigA"), pt.Bytes("sigB")]
        pubkey = (pt.Bytes("X"), pt.Bytes("Y"))
        expr = pt.EcdsaVerify(cast(pt.EcdsaCurve, 5), args[0], args[1], args[2], pubkey)



================================================
FILE: pyteal/ast/err.py
================================================
from typing import TYPE_CHECKING

from pyteal.types import TealType
from pyteal.ir import TealOp, Op, TealBlock
from pyteal.ast.expr import Expr

if TYPE_CHECKING:
    from pyteal.compiler import CompileOptions


class Err(Expr):
    """Expression that causes the program to immediately fail when executed."""

    def __teal__(self, options: "CompileOptions"):
        op = TealOp(self, Op.err)
        return TealBlock.FromOp(options, op)

    def __str__(self):
        return "(err)"

    def type_of(self):
        return TealType.none

    def has_return(self):
        return True


Err.__module__ = "pyteal"



================================================
FILE: pyteal/ast/err_test.py
================================================
import pyteal as pt


def test_err():
    expr = pt.Err()
    assert expr.type_of() == pt.TealType.none
    assert expr.has_return()
    expected = pt.TealSimpleBlock([pt.TealOp(expr, pt.Op.err)])
    actual, _ = expr.__teal__(pt.CompileOptions())
    assert actual == expected



================================================
FILE: pyteal/ast/expr.py
================================================
from abc import ABC, abstractmethod
from typing import TYPE_CHECKING

from pyteal.ir import TealBlock, TealSimpleBlock
from pyteal.stack_frame import NatalStackFrame
from pyteal.types import TealType

if TYPE_CHECKING:
    from pyteal.compiler import CompileOptions


class Expr(ABC):
    """Abstract base class for PyTeal expressions."""

    def __init__(self):
        import traceback

        self.trace = traceback.format_stack()[0:-1]
        self.stack_frames: NatalStackFrame = NatalStackFrame()

    def getDefinitionTrace(self) -> list[str]:
        return self.trace

    @abstractmethod
    def type_of(self) -> TealType:
        """Get the return type of this expression."""
        pass

    @abstractmethod
    def has_return(self) -> bool:
        """Check if this expression always returns from the current subroutine or program."""
        pass

    @abstractmethod
    def __str__(self) -> str:
        """Get a string representation of this expression."""
        pass

    @abstractmethod
    def __teal__(self, options: "CompileOptions") -> tuple[TealBlock, TealSimpleBlock]:
        """Assemble TEAL IR for this component and its arguments."""
        pass

    def __lt__(self, other):
        from pyteal.ast.binaryexpr import Lt

        return Lt(self, other)

    def __gt__(self, other):
        from pyteal.ast.binaryexpr import Gt

        return Gt(self, other)

    def __le__(self, other):
        from pyteal.ast.binaryexpr import Le

        return Le(self, other)

    def __ge__(self, other):
        from pyteal.ast.binaryexpr import Ge

        return Ge(self, other)

    def __eq__(self, other):
        from pyteal.ast.binaryexpr import Eq

        return Eq(self, other)

    def __ne__(self, other):
        from pyteal.ast.binaryexpr import Neq

        return Neq(self, other)

    def __add__(self, other):
        from pyteal.ast.naryexpr import Add

        return Add(self, other)

    def __sub__(self, other):
        from pyteal.ast.binaryexpr import Minus

        return Minus(self, other)

    def __mul__(self, other):
        from pyteal.ast.naryexpr import Mul

        return Mul(self, other)

    def __truediv__(self, other):
        from pyteal.ast.binaryexpr import Div

        return Div(self, other)

    def __mod__(self, other):
        from pyteal.ast.binaryexpr import Mod

        return Mod(self, other)

    def __pow__(self, other):
        from pyteal.ast.binaryexpr import Exp

        return Exp(self, other)

    def __invert__(self):
        from pyteal.ast.unaryexpr import BitwiseNot

        return BitwiseNot(self)

    def __and__(self, other):
        from pyteal.ast.binaryexpr import BitwiseAnd

        return BitwiseAnd(self, other)

    def __or__(self, other):
        from pyteal.ast.binaryexpr import BitwiseOr

        return BitwiseOr(self, other)

    def __xor__(self, other):
        from pyteal.ast.binaryexpr import BitwiseXor

        return BitwiseXor(self, other)

    def __lshift__(self, other):
        from pyteal.ast.binaryexpr import ShiftLeft

        return ShiftLeft(self, other)

    def __rshift__(self, other):
        from pyteal.ast.binaryexpr import ShiftRight

        return ShiftRight(self, other)

    def And(self, other: "Expr") -> "Expr":
        """Take the logical And of this expression and another one.

        This expression must evaluate to uint64.

        This is the same as using :func:`And()` with two arguments.
        """
        from pyteal.ast.naryexpr import And

        return And(self, other)

    def Or(self, other: "Expr") -> "Expr":
        """Take the logical Or of this expression and another one.

        This expression must evaluate to uint64.

        This is the same as using :func:`Or()` with two arguments.
        """
        from pyteal.ast.naryexpr import Or

        return Or(self, other)


Expr.__module__ = "pyteal"



================================================
FILE: pyteal/ast/for_.py
================================================
from typing import TYPE_CHECKING, Optional
from pyteal.ast.seq import _use_seq_if_multiple

from pyteal.types import TealType, require_type
from pyteal.ir import TealSimpleBlock, TealConditionalBlock
from pyteal.errors import TealCompileError
from pyteal.ast.expr import Expr

if TYPE_CHECKING:
    from pyteal.compiler import CompileOptions


class For(Expr):
    """For expression."""

    def __init__(self, start: Expr, cond: Expr, step: Expr) -> None:
        """Create a new For expression.

        When this For expression is executed, the condition will be evaluated, and if it produces a
        true value, doBlock will be executed and return to the start of the expression execution.
        Otherwise, no branch will be executed.

        Args:
            start: Expression setting the variable's initial value
            cond: The condition to check. Must evaluate to uint64.
            step: Expression to update the variable's value.

        Example:
            .. code-block:: python

                i = ScratchVar()
                For(i.store(Int(0)), i.load() < Int(10), i.store(i.load() + Int(1))
                    .Do(expr1, expr2, ...)
        """
        super().__init__()
        require_type(cond, TealType.uint64)
        require_type(start, TealType.none)
        require_type(step, TealType.none)

        self.start = start
        self.cond = cond
        self.step = step
        self.doBlock: Optional[Expr] = None

    def __teal__(self, options: "CompileOptions"):
        if self.doBlock is None:
            raise TealCompileError("For expression must have a doBlock", self)

        options.enterLoop()

        end = TealSimpleBlock([])
        start, startEnd = self.start.__teal__(options)
        condStart, condEnd = self.cond.__teal__(options)
        doStart, doEnd = self.doBlock.__teal__(options)

        stepStart, stepEnd = self.step.__teal__(options)
        stepEnd.setNextBlock(condStart)
        stepEnd._sframes_container = self
        doEnd.setNextBlock(stepStart)

        branchBlock = TealConditionalBlock([], root_expr=self)
        branchBlock.setTrueBlock(doStart)
        branchBlock.setFalseBlock(end)

        condEnd.setNextBlock(branchBlock)

        startEnd.setNextBlock(condStart)

        breakBlocks, continueBlocks = options.exitLoop()

        for block in breakBlocks:
            block.setNextBlock(end)

        for block in continueBlocks:
            block.setNextBlock(stepStart)

        return start, end

    def __str__(self):
        if self.start is None:
            raise TealCompileError("For expression must have a start", self)
        if self.cond is None:
            raise TealCompileError("For expression must have a condition", self)
        if self.step is None:
            raise TealCompileError("For expression must have a end", self)
        if self.doBlock is None:
            raise TealCompileError("For expression must have a doBlock", self)

        return "(For {} {} {} {})".format(
            self.start, self.cond, self.step, self.doBlock
        )

    def type_of(self):
        if self.doBlock is None:
            raise TealCompileError("For expression must have a doBlock", self)
        return TealType.none

    def has_return(self):
        return False

    def Do(self, doBlock: Expr, *do_block_multi: Expr):
        if self.doBlock is not None:
            raise TealCompileError("For expression already has a doBlock", self)

        doBlock = _use_seq_if_multiple(doBlock, *do_block_multi)

        require_type(doBlock, TealType.none)
        self.doBlock = doBlock
        return self


For.__module__ = "pyteal"



================================================
FILE: pyteal/ast/for_test.py
================================================
import pytest

import pyteal as pt

options = pt.CompileOptions()


def test_for_compiles():
    i = pt.ScratchVar()

    expr = pt.For(i.store(pt.Int(0)), pt.Int(1), i.store(i.load() + pt.Int(1))).Do(
        pt.App.globalPut(pt.Itob(pt.Int(0)), pt.Itob(pt.Int(2)))
    )
    assert expr.type_of() == pt.TealType.none
    assert not expr.has_return()
    expr.__teal__(options)


def test_nested_for_compiles():
    i = pt.ScratchVar()
    expr = pt.For(i.store(pt.Int(0)), pt.Int(1), i.store(i.load() + pt.Int(1))).Do(
        pt.Seq(
            [
                pt.For(i.store(pt.Int(0)), pt.Int(1), i.store(i.load() + pt.Int(1))).Do(
                    pt.Seq([i.store(pt.Int(0))])
                )
            ]
        )
    )
    assert expr.type_of() == pt.TealType.none
    assert not expr.has_return()


def test_continue_break():
    i = pt.ScratchVar()
    expr = pt.For(i.store(pt.Int(0)), pt.Int(1), i.store(i.load() + pt.Int(1))).Do(
        pt.Seq([pt.If(pt.Int(1), pt.Break(), pt.Continue())])
    )
    assert expr.type_of() == pt.TealType.none
    assert not expr.has_return()
    expr.__teal__(options)


def test_for():
    i = pt.ScratchVar()
    items = [
        (i.store(pt.Int(0))),
        i.load() < pt.Int(10),
        i.store(i.load() + pt.Int(1)),
        pt.App.globalPut(pt.Itob(i.load()), i.load() * pt.Int(2)),
    ]
    expr = pt.For(items[0], items[1], items[2]).Do(pt.Seq([items[3]]))

    assert expr.type_of() == pt.TealType.none
    assert not expr.has_return()

    expected, varEnd = items[0].__teal__(options)
    condStart, condEnd = items[1].__teal__(options)
    stepStart, stepEnd = items[2].__teal__(options)
    do, doEnd = pt.Seq([items[3]]).__teal__(options)
    expectedBranch = pt.TealConditionalBlock([])
    end = pt.TealSimpleBlock([])

    varEnd.setNextBlock(condStart)
    doEnd.setNextBlock(stepStart)

    expectedBranch.setTrueBlock(do)
    expectedBranch.setFalseBlock(end)
    condEnd.setNextBlock(expectedBranch)
    stepEnd.setNextBlock(condStart)

    actual, _ = expr.__teal__(options)

    assert actual == expected


def test_for_continue():
    i = pt.ScratchVar()
    items = [
        (i.store(pt.Int(0))),
        i.load() < pt.Int(10),
        i.store(i.load() + pt.Int(1)),
        pt.If(i.load() < pt.Int(4), pt.Continue()),
        pt.App.globalPut(pt.Itob(i.load()), i.load() * pt.Int(2)),
    ]
    expr = pt.For(items[0], items[1], items[2]).Do(pt.Seq([items[3], items[4]]))

    assert expr.type_of() == pt.TealType.none
    assert not expr.has_return()

    options.enterLoop()

    expected, varEnd = items[0].__teal__(options)
    condStart, condEnd = items[1].__teal__(options)
    stepStart, stepEnd = items[2].__teal__(options)
    do, doEnd = pt.Seq([items[3], items[4]]).__teal__(options)
    expectedBranch = pt.TealConditionalBlock([])
    end = pt.TealSimpleBlock([])

    doEnd.setNextBlock(stepStart)
    stepEnd.setNextBlock(condStart)

    expectedBranch.setTrueBlock(do)
    expectedBranch.setFalseBlock(end)
    condEnd.setNextBlock(expectedBranch)
    varEnd.setNextBlock(condStart)

    _, continueBlocks = options.exitLoop()

    for block in continueBlocks:
        block.setNextBlock(stepStart)

    actual, _ = expr.__teal__(options)

    assert actual == expected


def test_for_break():
    i = pt.ScratchVar()
    items = [
        (i.store(pt.Int(0))),
        i.load() < pt.Int(10),
        i.store(i.load() + pt.Int(1)),
        pt.If(i.load() == pt.Int(6), pt.Break()),
        pt.App.globalPut(pt.Itob(i.load()), i.load() * pt.Int(2)),
    ]
    expr = pt.For(items[0], items[1], items[2]).Do(pt.Seq([items[3], items[4]]))

    assert expr.type_of() == pt.TealType.none
    assert not expr.has_return()

    options.enterLoop()

    expected, varEnd = items[0].__teal__(options)
    condStart, condEnd = items[1].__teal__(options)
    stepStart, stepEnd = items[2].__teal__(options)
    do, doEnd = pt.Seq([items[3], items[4]]).__teal__(options)
    expectedBranch = pt.TealConditionalBlock([])
    end = pt.TealSimpleBlock([])

    doEnd.setNextBlock(stepStart)
    stepEnd.setNextBlock(condStart)

    expectedBranch.setTrueBlock(do)
    expectedBranch.setFalseBlock(end)
    condEnd.setNextBlock(expectedBranch)
    varEnd.setNextBlock(condStart)

    breakBlocks, _ = options.exitLoop()

    for block in breakBlocks:
        block.setNextBlock(end)

    actual, _ = expr.__teal__(options)

    assert actual == expected


def test_invalid_for():
    with pytest.raises(TypeError):
        expr = pt.For()

    with pytest.raises(TypeError):
        expr = pt.For(pt.Int(2))

    with pytest.raises(TypeError):
        expr = pt.For(pt.Int(1), pt.Int(2))

    with pytest.raises(pt.TealTypeError):
        i = pt.ScratchVar()
        expr = pt.For(i.store(pt.Int(0)), pt.Int(1), pt.Int(2))
        expr.__teal__(options)

    with pytest.raises(pt.TealCompileError):
        i = pt.ScratchVar()
        expr = pt.For(i.store(pt.Int(0)), pt.Int(1), i.store(i.load() + pt.Int(1)))
        expr.type_of()

    with pytest.raises(pt.TealCompileError):
        i = pt.ScratchVar()
        expr = pt.For(i.store(pt.Int(0)), pt.Int(1), i.store(i.load() + pt.Int(1)))
        expr.__str__()

    with pytest.raises(pt.TealTypeError):
        i = pt.ScratchVar()
        expr = pt.For(i.store(pt.Int(0)), pt.Int(1), i.store(i.load() + pt.Int(1))).Do(
            pt.Int(0)
        )

    with pytest.raises(pt.TealTypeError):
        i = pt.ScratchVar()
        expr = pt.For(i.store(pt.Int(0)), pt.Int(1), i.store(i.load() + pt.Int(1))).Do(
            pt.Pop(pt.Int(1)), pt.Int(2)
        )

    with pytest.raises(pt.TealCompileError):
        expr = (
            pt.For(i.store(pt.Int(0)), pt.Int(1), i.store(i.load() + pt.Int(1)))
            .Do(pt.Continue())
            .Do(pt.Continue())
        )
        expr.__str__()


def test_for_multi():
    i = pt.ScratchVar()
    items = [
        (i.store(pt.Int(0))),
        i.load() < pt.Int(10),
        i.store(i.load() + pt.Int(1)),
        [pt.Pop(pt.Int(1)), pt.App.globalPut(pt.Itob(i.load()), i.load() * pt.Int(2))],
    ]
    expr = pt.For(items[0], items[1], items[2]).Do(*items[3])

    assert expr.type_of() == pt.TealType.none
    assert not expr.has_return()

    expected, varEnd = items[0].__teal__(options)
    condStart, condEnd = items[1].__teal__(options)
    stepStart, stepEnd = items[2].__teal__(options)
    do, doEnd = pt.Seq(items[3]).__teal__(options)
    expectedBranch = pt.TealConditionalBlock([])
    end = pt.TealSimpleBlock([])

    varEnd.setNextBlock(condStart)
    doEnd.setNextBlock(stepStart)

    expectedBranch.setTrueBlock(do)
    expectedBranch.setFalseBlock(end)
    condEnd.setNextBlock(expectedBranch)
    stepEnd.setNextBlock(condStart)

    actual, _ = expr.__teal__(options)

    assert actual == expected



================================================
FILE: pyteal/ast/frame.py
================================================
from itertools import groupby
from typing import TYPE_CHECKING, Optional, Final

from pyteal.ast.expr import Expr
from pyteal.ast.int import Int
from pyteal.ast.bytes import Bytes
from pyteal.ast.abstractvar import AbstractVar
from pyteal.types import TealType, require_type
from pyteal.errors import TealInputError, TealInternalError, verifyProgramVersion
from pyteal.ir import TealBlock, TealSimpleBlock, TealOp, Op
from pyteal.stack_frame import NatalStackFrame

if TYPE_CHECKING:
    from pyteal.compiler import CompileOptions


MAX_FRAME_LOCAL_VARS: Final[int] = 128


class LocalTypeSegment(Expr):
    """An expression that allocates stack spaces for local variable.

    This class is intentionally hidden because it's too basic to directly expose.
    This is only used in ProtoStackLayout internally.
    """

    def __init__(self, local_type: TealType, count: int):
        super().__init__()
        self.local_type = local_type
        self.count = count
        self.auto_instance: Expr

        if self.count <= 0:
            raise TealInternalError(
                "LocalTypeSegment initialization error: segment length must be strictly greater than 0."
            )
        match self.local_type:
            case TealType.uint64 | TealType.anytype:
                self.auto_instance = Int(0)
            case TealType.bytes:
                self.auto_instance = Bytes("")
            case TealType.none:
                raise TealInternalError(
                    "Local variable in subroutine initialization must be typed."
                )

    def __teal__(self, options: "CompileOptions") -> tuple[TealBlock, TealSimpleBlock]:
        return DupN(self.auto_instance, self.count - 1).__teal__(options)

    def __str__(self) -> str:
        return f"(LocalTypeSegment: (type: {self.local_type}) (count: {self.count}))"

    def has_return(self) -> bool:
        return False

    def type_of(self) -> TealType:
        return TealType.none


LocalTypeSegment.__module__ = "pyteal"


class ProtoStackLayout(Expr):
    """An expression that carries arg types and local types for a subroutine.

    Proto return value is placed on frame index 0 against frame pointer,
    and return type is included in local_stack_types, which is the first element.

    This class is intentionally hidden because it's too basic to directly expose.
    This is only used in Proto internally.
    """

    def __init__(
        self,
        arg_stack_types: list[TealType],
        local_stack_types: list[TealType],
        num_return_allocs: int,
    ):
        super().__init__()
        if num_return_allocs < 0:
            raise TealInternalError("Return allocation number should be non-negative.")
        elif num_return_allocs > len(local_stack_types):
            raise TealInternalError(
                "ProtoStackLayout initialization error: "
                f"return allocation number {num_return_allocs} should not "
                f"be greater than local allocations {len(local_stack_types)}."
            )

        if any(t == TealType.none for t in arg_stack_types + local_stack_types):
            raise TealInternalError("Variables in frame memory layout must be typed.")

        self.num_return_allocs: int = num_return_allocs
        self.arg_stack_types: list[TealType] = arg_stack_types
        self.local_stack_types: list[TealType] = local_stack_types

    def __getitem__(self, index: int) -> TealType:
        if index < 0:
            return self.arg_stack_types[len(self.arg_stack_types) + index]
        return self.local_stack_types[index]

    def __str__(self) -> str:
        return f"(ProtoStackLayout: (args: {self.arg_stack_types}) (locals: {self.local_stack_types}))"

    @classmethod
    def from_proto(cls, proto: "Proto") -> "ProtoStackLayout":
        return cls(
            [TealType.anytype] * proto.num_args,
            [TealType.anytype] * proto.num_returns,
            proto.num_returns,
        )

    def has_return(self) -> bool:
        return False

    def type_of(self) -> TealType:
        return TealType.none

    def _succinct_repr(self) -> list[LocalTypeSegment]:
        return [
            LocalTypeSegment(t_type, len(list(dup_seg)))
            for t_type, dup_seg in groupby(self.local_stack_types)
        ]

    def __teal__(self, options: "CompileOptions") -> tuple[TealBlock, TealSimpleBlock]:
        srt = TealSimpleBlock([])
        end = srt

        # Type check of local variables are performed over LocalTypeSegments
        succinct_repr: list[LocalTypeSegment] = self._succinct_repr()
        for iter_seg in succinct_repr:
            seg_srt, seg_end = iter_seg.__teal__(options)
            end.setNextBlock(seg_srt)
            end = seg_end
        return srt, end


ProtoStackLayout.__module__ = "pyteal"


class Proto(Expr):
    """An expression that prepare top call frame for a retsub that will assume A args and R return values.

    Proto return value is placed from frame index 0 against frame pointer.

    This class is intentionally hidden because it's too basic to directly expose.
    It is only used in subroutine, for subroutine declaration computation.
    """

    def __init__(
        self,
        num_args: int,
        num_returns: int,
        *,
        mem_layout: Optional[ProtoStackLayout] = None,
    ):
        super().__init__()
        if num_args < 0:
            raise TealInputError(
                f"The number of arguments provided to Proto must be >= 0 but {num_args=}."
            )
        if num_returns < 0:
            raise TealInputError(
                f"The number of returns provided to Proto must be >= 0 but {num_returns=}."
            )
        self.num_args = num_args
        self.num_returns = num_returns

        if mem_layout:
            if mem_layout.num_return_allocs > num_returns:
                raise TealInternalError(
                    f"The number of returns {num_returns} should be greater equal to "
                    f"memory layout's number of allocations for returns {mem_layout.num_return_allocs}"
                )
            if len(mem_layout.arg_stack_types) != num_args:
                raise TealInternalError(
                    f"The number of arguments {num_args} should match with "
                    f"memory layout's number of arguments {len(mem_layout.arg_stack_types)}"
                )
        else:
            mem_layout = ProtoStackLayout.from_proto(self)

        self.mem_layout: ProtoStackLayout = mem_layout

    def __teal__(self, options: "CompileOptions") -> tuple[TealBlock, TealSimpleBlock]:
        verifyProgramVersion(
            Op.proto.min_version,
            options.version,
            "Program version too low to use op proto",
        )
        op = TealOp(self, Op.proto, self.num_args, self.num_returns)
        proto_srt, proto_end = TealBlock.FromOp(options, op)
        local_srt, local_end = self.mem_layout.__teal__(options)
        proto_end.setNextBlock(local_srt)
        NatalStackFrame.reframe_ops_in_blocks(self, proto_srt)
        return proto_srt, local_end

    def __str__(self) -> str:
        return f"(proto: num_args = {self.num_args}, num_rets = {self.num_returns})"

    def type_of(self) -> TealType:
        return TealType.none

    def has_return(self) -> bool:
        return False


Proto.__module__ = "pyteal"


class FrameDig(Expr):
    """An expression that digs a value from a position around frame pointer.

    This class is intentionally hidden because it's too basic to directly expose.
    This is used only internally by FrameVar.
    """

    def __init__(self, frame_index: int, *, inferred_type: Optional[TealType] = None):
        super().__init__()
        self.frame_index = frame_index
        self.dig_type = inferred_type if inferred_type else TealType.anytype

    def __teal__(self, options: "CompileOptions") -> tuple[TealBlock, TealSimpleBlock]:
        verifyProgramVersion(
            Op.frame_dig.min_version,
            options.version,
            "Program version too low to use op frame_dig",
        )
        op = TealOp(self, Op.frame_dig, self.frame_index)
        return TealBlock.FromOp(options, op)

    def __str__(self) -> str:
        return f"(frame_dig: dig_from = {self.frame_index})"

    def type_of(self) -> TealType:
        return self.dig_type

    def has_return(self) -> bool:
        return False


FrameDig.__module__ = "pyteal"


class FrameBury(Expr):
    """An expression that buries a value to a position around frame pointer.

    This class is intentionally hidden because it's too basic to directly expose.
    This is used only internally by FrameVar.
    """

    def __init__(
        self,
        value: Expr,
        frame_index: int,
        *,
        inferred_type: Optional[TealType] = None,
    ):
        super().__init__()

        target_type: TealType = inferred_type or TealType.anytype
        require_type(value, target_type)

        self.value = value
        self.frame_index = frame_index

    def __teal__(self, options: "CompileOptions") -> tuple[TealBlock, TealSimpleBlock]:
        verifyProgramVersion(
            Op.frame_bury.min_version,
            options.version,
            "Program version too low to use op frame_bury",
        )
        op = TealOp(self, Op.frame_bury, self.frame_index)
        return TealBlock.FromOp(options, op, self.value)

    def __str__(self) -> str:
        return f"(frame_bury (bury_to = {self.frame_index}) ({self.value}))"

    def type_of(self) -> TealType:
        return TealType.none

    def has_return(self) -> bool:
        return False


FrameBury.__module__ = "pyteal"


class FrameVar(AbstractVar):
    """An instantiation for AbstractVar based on frame pointer.

    FrameVar captures loading, storing and type of variable over stack by frame pointer.

    This class is intentionally hidden because it's too basic to directly expose.
    This is used only internally by SubroutineEval in subroutine declaration computation.
    """

    def __init__(self, under_proto: Proto, frame_index: int) -> None:
        super().__init__()
        self.proto = under_proto
        self.frame_index = frame_index
        self.stack_type = self.proto.mem_layout[frame_index]

    def storage_type(self) -> TealType:
        return self.stack_type

    def store(self, value: Expr) -> Expr:
        return FrameBury(
            value,
            self.frame_index,
            inferred_type=self.stack_type,
        )

    def load(self) -> Expr:
        return FrameDig(self.frame_index, inferred_type=self.stack_type)


FrameVar.__module__ = "pyteal"


class DupN(Expr):
    """Duplicate an expression N times.

    This class is intentionally hidden because it's too basic to directly expose.
    This is used only by Proto and LocalTypeSegment.
    """

    def __init__(self, value: Expr, repetition: int):
        """Create a DupN expression.

        Args:
            value: The value to be duplicated.
            repetition: How many additional times the value should be added to the stack. At the end
                of this operation, `repetition+1` elements will be added to the stack. Zero can be
                specified here to indicate no duplication.
        """
        super().__init__()
        require_type(value, TealType.anytype)
        if repetition < 0:
            raise TealInputError("dupn repetition should be non negative")
        self.value = value
        self.repetition = repetition

    def __teal__(self, options: "CompileOptions") -> tuple[TealBlock, TealSimpleBlock]:
        if self.repetition == 0:
            # no duplication required
            return self.value.__teal__(options)

        if self.repetition == 1:
            # use normal dup op for just 1 duplication
            op = TealOp(self, Op.dup)
            return TealBlock.FromOp(options, op, self.value)

        verifyProgramVersion(
            Op.dupn.min_version,
            options.version,
            "Program version too low to use op dupn",
        )
        op = TealOp(self, Op.dupn, self.repetition)
        return TealBlock.FromOp(options, op, self.value)

    def __str__(self) -> str:
        return f"(dupn (repetition = {self.repetition}) ({self.value}))"

    def type_of(self) -> TealType:
        return self.value.type_of()

    def has_return(self) -> bool:
        return False


DupN.__module__ = "pyteal"



================================================
FILE: pyteal/ast/frame_test.py
================================================
import pytest
import pyteal as pt
from dataclasses import dataclass
from pyteal.ast.frame import (
    FrameBury,
    FrameDig,
    Proto,
    DupN,
    LocalTypeSegment,
    ProtoStackLayout,
)

avm7Options = pt.CompileOptions(version=7)
avm8Options = pt.CompileOptions(version=8)


@pytest.mark.parametrize("input_num, output_num", [(1, 1), (1, 0), (5, 5)])
def test_proto(input_num: int, output_num: int):
    expr = Proto(input_num, output_num)
    assert not expr.has_return()
    assert expr.type_of() == pt.TealType.none

    block = [pt.TealOp(expr, pt.Op.proto, input_num, output_num)]
    if output_num > 0:
        block.append(pt.TealOp(None, pt.Op.int, 0))
    if output_num > 1:
        block.append(pt.TealOp(None, pt.Op.dupn, output_num - 1))

    expected = pt.TealSimpleBlock(block)
    actual, _ = expr.__teal__(avm8Options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    with pt.TealComponent.Context.ignoreExprEquality():
        assert actual == expected


def test_proto_invalid():
    with pytest.raises(pt.TealInputError):
        Proto(-1, 1)

    with pytest.raises(pt.TealInputError):
        Proto(1, -1)

    with pytest.raises(pt.TealInputError):
        Proto(1, 1).__teal__(avm7Options)


@pytest.mark.parametrize("depth", [-1, 0, 1, 2])
def test_frame_dig(depth: int):
    expr = FrameDig(depth)
    assert not expr.has_return()
    assert expr.type_of() == pt.TealType.anytype

    expected = pt.TealSimpleBlock([pt.TealOp(expr, pt.Op.frame_dig, depth)])
    actual, _ = expr.__teal__(avm8Options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    assert actual == expected


def test_frame_dig_invalid():
    with pytest.raises(pt.TealInputError):
        FrameDig(1).__teal__(avm7Options)


def test_frame_bury():
    byte_expr = pt.Bytes("Astartes")
    expr = FrameBury(byte_expr, 4)
    assert not expr.has_return()
    assert expr.type_of() == pt.TealType.none

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(byte_expr, pt.Op.byte, '"Astartes"'),
            pt.TealOp(expr, pt.Op.frame_bury, 4),
        ]
    )
    actual, _ = expr.__teal__(avm8Options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    assert actual == expected


def test_frame_bury_invalid():
    with pytest.raises(pt.TealTypeError):
        FrameBury(pt.Seq(), 1)

    with pytest.raises(pt.TealInputError):
        FrameBury(pt.Int(1), 1).__teal__(avm7Options)


def test_dupn_zero():
    byte_expr = pt.Bytes("Astartes")
    expr = DupN(byte_expr, 0)
    assert not expr.has_return()
    assert expr.type_of() == byte_expr.type_of()

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(byte_expr, pt.Op.byte, '"Astartes"'),
        ]
    )
    actual, _ = expr.__teal__(avm8Options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    assert actual == expected


def test_dupn_single():
    byte_expr = pt.Bytes("Astartes")
    expr = DupN(byte_expr, 1)
    assert not expr.has_return()
    assert expr.type_of() == byte_expr.type_of()

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(byte_expr, pt.Op.byte, '"Astartes"'),
            pt.TealOp(expr, pt.Op.dup),
        ]
    )
    actual, _ = expr.__teal__(avm8Options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    assert actual == expected


def test_dupn_multiple():
    byte_expr = pt.Bytes("Astartes")
    expr = DupN(byte_expr, 4)
    assert not expr.has_return()
    assert expr.type_of() == byte_expr.type_of()

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(byte_expr, pt.Op.byte, '"Astartes"'),
            pt.TealOp(expr, pt.Op.dupn, 4),
        ]
    )
    actual, _ = expr.__teal__(avm8Options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    assert actual == expected


def test_dupn_invalid():
    with pytest.raises(pt.TealTypeError):
        DupN(pt.Seq(), 10)

    with pytest.raises(pt.TealInputError):
        DupN(pt.Int(1), -10)

    with pytest.raises(pt.TealInputError):
        DupN(pt.Int(1), 10).__teal__(avm7Options)


def test_local_type_segment_invalid():
    with pytest.raises(pt.TealInternalError) as tie:
        LocalTypeSegment(pt.TealType.anytype, 0)

    assert "segment length must be strictly greater than 0" in str(tie)

    with pytest.raises(pt.TealInternalError) as tie:
        LocalTypeSegment(pt.TealType.anytype, -1)

    assert "segment length must be strictly greater than 0" in str(tie)

    with pytest.raises(pt.TealInternalError) as tie:
        LocalTypeSegment(pt.TealType.none, 2)

    assert "Local variable in subroutine initialization must be typed." in str(tie)


@dataclass
class LocalTypeSegmentTestCase:
    local_type_segment: LocalTypeSegment
    expected: pt.TealSimpleBlock


@pytest.mark.parametrize(
    "testcase",
    [
        LocalTypeSegmentTestCase(
            LocalTypeSegment(pt.TealType.anytype, 1),
            pt.TealSimpleBlock([pt.TealOp(None, pt.Op.int, 0)]),
        ),
        LocalTypeSegmentTestCase(
            LocalTypeSegment(pt.TealType.anytype, 5),
            pt.TealSimpleBlock(
                [
                    pt.TealOp(None, pt.Op.int, 0),
                    pt.TealOp(None, pt.Op.dupn, 4),
                ]
            ),
        ),
        LocalTypeSegmentTestCase(
            LocalTypeSegment(pt.TealType.uint64, 1),
            pt.TealSimpleBlock([pt.TealOp(None, pt.Op.int, 0)]),
        ),
        LocalTypeSegmentTestCase(
            LocalTypeSegment(pt.TealType.uint64, 5),
            pt.TealSimpleBlock(
                [
                    pt.TealOp(None, pt.Op.int, 0),
                    pt.TealOp(None, pt.Op.dupn, 4),
                ]
            ),
        ),
        LocalTypeSegmentTestCase(
            LocalTypeSegment(pt.TealType.bytes, 1),
            pt.TealSimpleBlock([pt.TealOp(None, pt.Op.byte, '""')]),
        ),
        LocalTypeSegmentTestCase(
            LocalTypeSegment(pt.TealType.bytes, 5),
            pt.TealSimpleBlock(
                [
                    pt.TealOp(None, pt.Op.byte, '""'),
                    pt.TealOp(None, pt.Op.dupn, 4),
                ]
            ),
        ),
    ],
)
def test_local_type_segment_compilation(testcase: LocalTypeSegmentTestCase):
    actual, _ = testcase.local_type_segment.__teal__(avm8Options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    with pt.TealComponent.Context.ignoreExprEquality():
        assert actual == testcase.expected


def test_proto_stack_layout_invalid():
    with pytest.raises(pt.TealInternalError) as tie:
        ProtoStackLayout([pt.TealType.uint64, pt.TealType.bytes], [], -1)

    assert "Return allocation number should be non-negative." == str(tie.value)

    with pytest.raises(pt.TealInternalError) as tie:
        ProtoStackLayout([pt.TealType.uint64, pt.TealType.bytes], [], 1)

    assert "should not be greater than local allocations" in str(tie.value)

    with pytest.raises(pt.TealInternalError) as tie:
        ProtoStackLayout([pt.TealType.bytes, pt.TealType.none], [], 0)

    assert "must be typed" in str(tie.value)

    with pytest.raises(pt.TealInternalError) as tie:
        ProtoStackLayout(
            [pt.TealType.bytes, pt.TealType.uint64],
            [pt.TealType.uint64, pt.TealType.none],
            0,
        )

    assert "must be typed" in str(tie.value)


@dataclass
class SuccinctReprTestCase:
    local_types: list[pt.TealType]
    expected: list[LocalTypeSegment]


@pytest.mark.parametrize(
    "testcase",
    [
        SuccinctReprTestCase([], []),
        SuccinctReprTestCase(
            [pt.TealType.anytype], [LocalTypeSegment(pt.TealType.anytype, 1)]
        ),
        SuccinctReprTestCase(
            [pt.TealType.anytype, pt.TealType.uint64],
            [
                LocalTypeSegment(pt.TealType.anytype, 1),
                LocalTypeSegment(pt.TealType.uint64, 1),
            ],
        ),
        SuccinctReprTestCase(
            [pt.TealType.bytes, pt.TealType.anytype, pt.TealType.uint64],
            [
                LocalTypeSegment(pt.TealType.bytes, 1),
                LocalTypeSegment(pt.TealType.anytype, 1),
                LocalTypeSegment(pt.TealType.uint64, 1),
            ],
        ),
        SuccinctReprTestCase(
            [
                pt.TealType.anytype,
                pt.TealType.bytes,
                pt.TealType.anytype,
                pt.TealType.uint64,
            ],
            [
                LocalTypeSegment(pt.TealType.anytype, 1),
                LocalTypeSegment(pt.TealType.bytes, 1),
                LocalTypeSegment(pt.TealType.anytype, 1),
                LocalTypeSegment(pt.TealType.uint64, 1),
            ],
        ),
        SuccinctReprTestCase(
            [
                pt.TealType.anytype,
                pt.TealType.bytes,
                pt.TealType.anytype,
                pt.TealType.uint64,
                pt.TealType.anytype,
            ],
            [
                LocalTypeSegment(pt.TealType.anytype, 1),
                LocalTypeSegment(pt.TealType.bytes, 1),
                LocalTypeSegment(pt.TealType.anytype, 1),
                LocalTypeSegment(pt.TealType.uint64, 1),
                LocalTypeSegment(pt.TealType.anytype, 1),
            ],
        ),
        SuccinctReprTestCase(
            [
                pt.TealType.anytype,
                pt.TealType.bytes,
                pt.TealType.bytes,
                pt.TealType.uint64,
                pt.TealType.uint64,
                pt.TealType.uint64,
                pt.TealType.anytype,
                pt.TealType.anytype,
                pt.TealType.anytype,
                pt.TealType.anytype,
                pt.TealType.bytes,
                pt.TealType.bytes,
                pt.TealType.uint64,
                pt.TealType.uint64,
                pt.TealType.uint64,
            ],
            [
                LocalTypeSegment(pt.TealType.anytype, 1),
                LocalTypeSegment(pt.TealType.bytes, 2),
                LocalTypeSegment(pt.TealType.uint64, 3),
                LocalTypeSegment(pt.TealType.anytype, 4),
                LocalTypeSegment(pt.TealType.bytes, 2),
                LocalTypeSegment(pt.TealType.uint64, 3),
            ],
        ),
    ],
)
def test_proto_stack_layout_succinct_repr(testcase: SuccinctReprTestCase):
    actual = ProtoStackLayout([], testcase.local_types, False)._succinct_repr()
    assert actual == testcase.expected



================================================
FILE: pyteal/ast/gaid.py
================================================
from typing import cast, Union, TYPE_CHECKING

from pyteal.types import TealType, require_type
from pyteal.ir import TealOp, Op, TealBlock
from pyteal.errors import TealInputError, verifyProgramVersion
from pyteal.config import MAX_GROUP_SIZE
from pyteal.ast.expr import Expr
from pyteal.ast.leafexpr import LeafExpr

if TYPE_CHECKING:
    from pyteal.compiler import CompileOptions


class GeneratedID(LeafExpr):
    """An expression to obtain the ID of an asset or application created by another transaction in the current group."""

    def __init__(self, txnIndex: Union[int, Expr]) -> None:
        """Create an expression to extract the created ID from a transaction in the current group.

        Requires program version 4 or higher. This operation is only permitted in application mode.

        Args:
            txnIndex: The index of the transaction from which the created ID should be obtained.
                This index may be a Python int, or it may be a PyTeal expression that evaluates at runtime.
                If it's an expression, it must evaluate to a uint64.
                In all cases, the index must be less than the index of the current transaction.
        """
        super().__init__()
        if type(txnIndex) is int:
            if txnIndex < 0 or txnIndex >= MAX_GROUP_SIZE:
                raise TealInputError(
                    "Invalid transaction index {}, shoud be in [0, {})".format(
                        txnIndex, MAX_GROUP_SIZE
                    )
                )
        else:
            require_type(cast(Expr, txnIndex), TealType.uint64)
        self.txnIndex = txnIndex

    def __str__(self):
        return "(Gaid {})".format(self.txnIndex)

    def __teal__(self, options: "CompileOptions"):
        verifyProgramVersion(
            Op.gaid.min_version,
            options.version,
            "Program version too low to use Gaid expression",
        )

        if type(self.txnIndex) is int:
            op = TealOp(self, Op.gaid, self.txnIndex)
            return TealBlock.FromOp(options, op)

        op = TealOp(self, Op.gaids)
        return TealBlock.FromOp(options, op, cast(Expr, self.txnIndex))

    def type_of(self):
        return TealType.uint64


GeneratedID.__module__ = "pyteal"



================================================
FILE: pyteal/ast/gaid_test.py
================================================
import pytest

import pyteal as pt

avm3Options = pt.CompileOptions(version=3)
avm4Options = pt.CompileOptions(version=4)


def test_gaid_teal_3():
    with pytest.raises(pt.TealInputError):
        pt.GeneratedID(0).__teal__(avm3Options)


def test_gaid():
    expr = pt.GeneratedID(0)
    assert expr.type_of() == pt.TealType.uint64

    expected = pt.TealSimpleBlock([pt.TealOp(expr, pt.Op.gaid, 0)])

    actual, _ = expr.__teal__(avm4Options)

    assert actual == expected


def test_gaid_invalid():
    with pytest.raises(pt.TealInputError):
        pt.GeneratedID(-1)

    with pytest.raises(pt.TealInputError):
        pt.GeneratedID(pt.MAX_GROUP_SIZE)


def test_gaid_dynamic_teal_3():
    with pytest.raises(pt.TealInputError):
        pt.GeneratedID(pt.Int(0)).__teal__(avm3Options)


def test_gaid_dynamic():
    arg = pt.Int(0)
    expr = pt.GeneratedID(arg)
    assert expr.type_of() == pt.TealType.uint64

    expected = pt.TealSimpleBlock(
        [pt.TealOp(arg, pt.Op.int, 0), pt.TealOp(expr, pt.Op.gaids)]
    )

    actual, _ = expr.__teal__(avm4Options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    assert actual == expected


def test_gaid_dynamic_invalid():
    with pytest.raises(pt.TealTypeError):
        pt.GeneratedID(pt.Bytes("index"))



================================================
FILE: pyteal/ast/gitxn.py
================================================
from typing import TYPE_CHECKING, cast, Union

from pyteal.config import MAX_GROUP_SIZE

from pyteal.errors import TealInputError, verifyFieldVersion, verifyProgramVersion
from pyteal.ir import TealOp, Op, TealBlock
from pyteal.ast.expr import Expr
from pyteal.ast.txn import TxnExpr, TxnField, TxnObject, TxnaExpr

if TYPE_CHECKING:
    from pyteal.compiler import CompileOptions


class GitxnExpr(TxnExpr):
    """An expression that accesses an inner transaction field from an inner transaction in the last inner group."""

    def __init__(self, txnIndex: int, field: TxnField) -> None:
        super().__init__(Op.gitxn, "Gitxn", field)

        # Currently we do not have gitxns. Only gitxn with immediate transaction index supported.
        if type(txnIndex) is not int:
            raise TealInputError(
                "Invalid gitxn syntax with immediate transaction field {} and transaction index {}".format(
                    field, txnIndex
                )
            )

        self.txnIndex = txnIndex

    def __str__(self):
        return "({} {} {})".format(self.name, self.txnIndex, self.field.arg_name)

    def __teal__(self, options: "CompileOptions"):
        verifyFieldVersion(self.field.arg_name, self.field.min_version, options.version)

        verifyProgramVersion(
            Op.gitxn.min_version,
            options.version,
            "Program version too low to use gitxn",
        )
        op = TealOp(self, Op.gitxn, self.txnIndex, self.field.arg_name)
        return TealBlock.FromOp(options, op)


GitxnExpr.__module__ = "pyteal"


class GitxnaExpr(TxnaExpr):
    """An expression that accesses an inner transaction array field from an inner transaction in the last inner group."""

    def __init__(self, txnIndex: int, field: TxnField, index: Union[int, Expr]) -> None:
        super().__init__(Op.gitxna, Op.gitxnas, "Gitxna", field, index)

        if type(txnIndex) is not int:
            raise TealInputError(
                f"Invalid txnIndex type:  Expected int, but received {txnIndex}."
            )

        self.txnIndex = txnIndex

    def __str__(self):
        return "({} {} {} {})".format(
            self.name, self.txnIndex, self.field.arg_name, self.index
        )

    def __teal__(self, options: "CompileOptions"):
        verifyFieldVersion(self.field.arg_name, self.field.min_version, options.version)

        if type(self.index) is int:
            opToUse = Op.gitxna
        else:
            opToUse = Op.gitxnas

        verifyProgramVersion(
            opToUse.min_version,
            options.version,
            "Program version too low to use op {}".format(opToUse),
        )

        if type(self.index) is int:
            op = TealOp(self, opToUse, self.txnIndex, self.field.arg_name, self.index)
            return TealBlock.FromOp(options, op)
        op = TealOp(self, opToUse, self.txnIndex, self.field.arg_name)
        return TealBlock.FromOp(options, op, cast(Expr, self.index))


GitxnaExpr.__module__ = "pyteal"


class InnerTxnGroup:
    """Represents a group of inner transactions."""

    def __getitem__(self, txnIndex: int) -> TxnObject:
        if type(txnIndex) is not int:
            raise TealInputError(
                "Invalid gitxn syntax, immediate txn index must be int."
            )

        if txnIndex < 0 or txnIndex >= MAX_GROUP_SIZE:
            raise TealInputError(
                "Invalid Gtxn index {}, should be in [0, {})".format(
                    txnIndex, MAX_GROUP_SIZE
                )
            )

        return TxnObject(
            lambda field: GitxnExpr(txnIndex, field),
            lambda field, index: GitxnaExpr(txnIndex, field, index),
        )


InnerTxnGroup.__module__ = "pyteal"

Gitxn: InnerTxnGroup = InnerTxnGroup()

Gitxn.__module__ = "pyteal"



================================================
FILE: pyteal/ast/gitxn_test.py
================================================
import pytest

import pyteal as pt

avm5Options = pt.CompileOptions(version=5)
avm6Options = pt.CompileOptions(version=6)


def test_gitxn_invalid():
    for ctor, e in [
        (
            lambda: pt.Gitxn[pt.MAX_GROUP_SIZE],
            pt.TealInputError,
        ),
        (
            lambda: pt.Gitxn[-1],
            pt.TealInputError,
        ),
    ]:
        with pytest.raises(e):
            ctor()


def test_gitxn_valid():
    for i in range(pt.MAX_GROUP_SIZE):
        pt.Gitxn[i].sender()


def test_gitxn_expr_invalid():
    for f, e in [
        (
            lambda: pt.GitxnExpr(pt.Int(1), pt.TxnField.sender),
            pt.TealInputError,
        ),
        (
            lambda: pt.GitxnExpr(1, pt.TxnField.sender).__teal__(avm5Options),
            pt.TealInputError,
        ),
    ]:
        with pytest.raises(e):
            f()


def test_gitxn_expr_valid():
    pt.GitxnExpr(1, pt.TxnField.sender).__teal__(avm6Options)


def test_gitxna_expr_invalid():
    for f, e in [
        (
            lambda: pt.GitxnaExpr("Invalid_type", pt.TxnField.application_args, 1),
            pt.TealInputError,
        ),
        (
            lambda: pt.GitxnaExpr(1, pt.TxnField.application_args, "Invalid_type"),
            pt.TealInputError,
        ),
        (
            lambda: pt.GitxnaExpr(
                0, pt.TxnField.application_args, pt.Assert(pt.Int(1))
            ),
            pt.TealTypeError,
        ),
        (
            lambda: pt.GitxnaExpr(0, pt.TxnField.application_args, 0).__teal__(
                avm5Options
            ),
            pt.TealInputError,
        ),
    ]:
        with pytest.raises(e):
            f()


def test_gitxna_valid():
    [
        e.__teal__(avm6Options)
        for e in [
            pt.GitxnaExpr(0, pt.TxnField.application_args, 1),
            pt.GitxnaExpr(0, pt.TxnField.application_args, pt.Int(1)),
        ]
    ]


# txn_test.py performs additional testing



================================================
FILE: pyteal/ast/gload.py
================================================
from typing import cast, Union, TYPE_CHECKING

from pyteal.types import TealType, require_type
from pyteal.ir import TealOp, Op, TealBlock
from pyteal.errors import TealInputError, verifyProgramVersion
from pyteal.config import MAX_GROUP_SIZE, NUM_SLOTS
from pyteal.ast.expr import Expr
from pyteal.ast.leafexpr import LeafExpr

if TYPE_CHECKING:
    from pyteal.compiler import CompileOptions


class ImportScratchValue(LeafExpr):
    """An expression to load a scratch value created by another transaction in the current group"""

    def __init__(self, txnIndex: Union[int, Expr], slotId: Union[int, Expr]) -> None:
        """Create an expression to load a scratch space slot from a transaction in the current group.

        Requires program version 4 or higher. This operation is only permitted in application mode.

        Args:
            txnIndex: The index of the transaction from which the created ID should be obtained.
                This index may be a Python int, or it may be a PyTeal expression that evaluates at
                runtime. If it's an expression, it must evaluate to a uint64. In all cases, the index
                must be less than the index of the current transaction.
            slotId: The index of the scratch slot that should be loaded.
                This index may be a Python int, or it may be a PyTeal expression that evaluates at
                runtime. If it's an expression, it must evaluate to a uint64. In all cases, the index
                must be in the range [0, 256).
        """
        super().__init__()
        if type(txnIndex) is int:
            if txnIndex < 0 or txnIndex >= MAX_GROUP_SIZE:
                raise TealInputError(
                    "Invalid transaction index {}, shoud be in [0, {})".format(
                        txnIndex, MAX_GROUP_SIZE
                    )
                )
            if type(slotId) is not int:
                raise TealInputError(
                    "Invalid gload syntax with immediate transaction index {} and stack slot ID {}".format(
                        txnIndex, slotId
                    )
                )
        else:
            require_type(cast(Expr, txnIndex), TealType.uint64)

        if type(slotId) is int:
            if slotId < 0 or slotId >= NUM_SLOTS:
                raise TealInputError(
                    "Invalid slot ID {}, shoud be in [0, {})".format(slotId, NUM_SLOTS)
                )
        else:
            require_type(cast(Expr, slotId), TealType.uint64)

        self.txnIndex = txnIndex
        self.slotId = slotId

    def __str__(self) -> str:
        return "(Gload {} {})".format(self.txnIndex, self.slotId)

    def __teal__(self, options: "CompileOptions"):
        def local_version_check(opcode: TealOp):
            verifyProgramVersion(
                opcode.op.min_version,
                options.version,
                "Program version too low to use {} experssion".format(opcode.op.name),
            )

        # For txnIndex and slotId, there are only three scenario as following
        #     immediate    immediate
        #     stack        immediate
        #     stack        stack
        # the last one is not allowed
        # --> immediate    stack
        # which is eliminated in __init__
        if type(self.txnIndex) is int and type(self.slotId) is int:
            op = TealOp(self, Op.gload, self.txnIndex, self.slotId)
            local_version_check(op)
            return TealBlock.FromOp(options, op)
        elif type(self.slotId) is int:
            op = TealOp(self, Op.gloads, self.slotId)
            local_version_check(op)
            return TealBlock.FromOp(options, op, cast(Expr, self.txnIndex))
        else:
            op = TealOp(self, Op.gloadss)
            local_version_check(op)
            return TealBlock.FromOp(
                options, op, cast(Expr, self.txnIndex), cast(Expr, self.slotId)
            )

    def type_of(self):
        return TealType.anytype


ImportScratchValue.__module__ = "pyteal"



================================================
FILE: pyteal/ast/gload_test.py
================================================
import pytest

import pyteal as pt

avm3Options = pt.CompileOptions(version=3)
avm4Options = pt.CompileOptions(version=4)
avm6Options = pt.CompileOptions(version=6)


def test_gload_teal_3():
    with pytest.raises(pt.TealInputError):
        pt.ImportScratchValue(0, 1).__teal__(avm3Options)

    with pytest.raises(pt.TealInputError):
        pt.ImportScratchValue(pt.Int(0), 1).__teal__(avm3Options)

    with pytest.raises(pt.TealInputError):
        pt.ImportScratchValue(pt.Int(0), pt.Int(1)).__teal__(avm3Options)


def test_gload_teal_4():
    with pytest.raises(pt.TealInputError):
        pt.ImportScratchValue(pt.Int(0), pt.Int(2)).__teal__(avm4Options)


def test_gload():
    expr = pt.ImportScratchValue(0, 1)
    assert expr.type_of() == pt.TealType.anytype

    expected = pt.TealSimpleBlock([pt.TealOp(expr, pt.Op.gload, 0, 1)])

    actual, _ = expr.__teal__(avm4Options)

    assert actual == expected


def test_gloads():
    arg = pt.Int(1)
    expr = pt.ImportScratchValue(arg, 0)
    assert expr.type_of() == pt.TealType.anytype

    expected = pt.TealSimpleBlock(
        [pt.TealOp(arg, pt.Op.int, 1), pt.TealOp(expr, pt.Op.gloads, 0)]
    )

    actual, _ = expr.__teal__(avm4Options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    assert actual == expected


def test_gloadss():
    txID = pt.Int(1)
    slotID = pt.Int(0)
    expr = pt.ImportScratchValue(txID, slotID)
    assert expr.type_of() == pt.TealType.anytype

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(txID, pt.Op.int, 1),
            pt.TealOp(slotID, pt.Op.int, 0),
            pt.TealOp(expr, pt.Op.gloadss),
        ]
    )

    actual, _ = expr.__teal__(avm6Options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    assert actual == expected


def test_gload_invalid():
    with pytest.raises(pt.TealInputError):
        pt.ImportScratchValue(-1, 0)

    with pytest.raises(pt.TealInputError):
        pt.ImportScratchValue(pt.MAX_GROUP_SIZE, 0)

    with pytest.raises(pt.TealInputError):
        pt.ImportScratchValue(0, -1)

    with pytest.raises(pt.TealInputError):
        pt.ImportScratchValue(0, pt.NUM_SLOTS)

    with pytest.raises(pt.TealInputError):
        pt.ImportScratchValue(0, pt.Int(0))

    with pytest.raises(pt.TealTypeError):
        pt.ImportScratchValue(pt.Bytes("AQID"), 0)  # byte encoding of [1, 2, 3]



================================================
FILE: pyteal/ast/global_.py
================================================
from typing import TYPE_CHECKING
from enum import Enum

from pyteal.types import TealType
from pyteal.errors import verifyFieldVersion
from pyteal.ir import TealOp, Op, TealBlock
from pyteal.ast.leafexpr import LeafExpr

if TYPE_CHECKING:
    from pyteal.compiler import CompileOptions


class GlobalField(Enum):
    min_txn_fee = (0, "MinTxnFee", TealType.uint64, 2)
    min_balance = (1, "MinBalance", TealType.uint64, 2)
    max_txn_life = (2, "MaxTxnLife", TealType.uint64, 2)
    zero_address = (3, "ZeroAddress", TealType.bytes, 2)
    group_size = (4, "GroupSize", TealType.uint64, 2)
    logic_sig_version = (5, "LogicSigVersion", TealType.uint64, 2)
    round = (6, "Round", TealType.uint64, 2)
    latest_timestamp = (7, "LatestTimestamp", TealType.uint64, 2)
    current_app_id = (8, "CurrentApplicationID", TealType.uint64, 2)
    creator_address = (9, "CreatorAddress", TealType.bytes, 3)
    current_app_address = (10, "CurrentApplicationAddress", TealType.bytes, 5)
    group_id = (11, "GroupID", TealType.bytes, 5)
    opcode_budget = (12, "OpcodeBudget", TealType.uint64, 6)
    caller_app_id = (13, "CallerApplicationID", TealType.uint64, 6)
    caller_app_address = (14, "CallerApplicationAddress", TealType.bytes, 6)
    asset_create_min_balance = (15, "AssetCreateMinBalance", TealType.uint64, 10)
    asset_opt_in_min_balance = (16, "AssetOptInMinBalance", TealType.uint64, 10)
    genesis_hash = (17, "GenesisHash", TealType.bytes, 10)
    payouts_enabled = (18, "PayoutsEnabled", TealType.uint64, 11)
    payouts_go_online_fee = (19, "PayoutsGoOnlineFee", TealType.uint64, 11)
    payouts_percent = (20, "PayoutsPercent", TealType.uint64, 11)
    payouts_min_balance = (21, "PayoutsMinBalance", TealType.uint64, 11)
    payouts_max_balance = (22, "PayoutsMaxBalance", TealType.uint64, 11)

    def __init__(self, id: int, name: str, type: TealType, min_version: int) -> None:
        self.id = id
        self.arg_name = name
        self.ret_type = type
        self.min_version = min_version

    def type_of(self) -> TealType:
        return self.ret_type


GlobalField.__module__ = "pyteal"


class Global(LeafExpr):
    """An expression that accesses a global property."""

    def __init__(self, field: GlobalField) -> None:
        super().__init__()
        self.field = field

    def __teal__(self, options: "CompileOptions"):
        verifyFieldVersion(self.field.arg_name, self.field.min_version, options.version)

        op = TealOp(self, Op.global_, self.field.arg_name)
        return TealBlock.FromOp(options, op)

    def __str__(self):
        return "(Global {})".format(self.field.arg_name)

    def type_of(self):
        return self.field.type_of()

    @classmethod
    def min_txn_fee(cls) -> "Global":
        """Get the minimum transaction fee in micro Algos."""
        return cls(GlobalField.min_txn_fee)

    @classmethod
    def min_balance(cls) -> "Global":
        """Get the minimum balance in micro Algos."""
        return cls(GlobalField.min_balance)

    @classmethod
    def max_txn_life(cls) -> "Global":
        """Get the maximum number of rounds a transaction can have."""
        return cls(GlobalField.max_txn_life)

    @classmethod
    def zero_address(cls) -> "Global":
        """Get the 32 byte zero address."""
        return cls(GlobalField.zero_address)

    @classmethod
    def group_size(cls) -> "Global":
        """Get the number of transactions in this atomic transaction group.

        This will be at least 1.
        """
        return cls(GlobalField.group_size)

    @classmethod
    def logic_sig_version(cls) -> "Global":
        """Get the maximum supported program version."""
        return cls(GlobalField.logic_sig_version)

    @classmethod
    def round(cls) -> "Global":
        """Get the current round number."""
        return cls(GlobalField.round)

    @classmethod
    def latest_timestamp(cls) -> "Global":
        """Get the latest confirmed block UNIX timestamp.

        Fails if negative."""
        return cls(GlobalField.latest_timestamp)

    @classmethod
    def current_application_id(cls) -> "Global":
        """Get the ID of the current application executing.

        Fails during Signature mode."""
        return cls(GlobalField.current_app_id)

    @classmethod
    def creator_address(cls) -> "Global":
        """Address of the creator of the current application.

        Fails during Signature mode. Requires program version 3 or higher."""
        return cls(GlobalField.creator_address)

    @classmethod
    def current_application_address(cls) -> "Global":
        """Get the address that the current application controls.

        Fails during Signature mode. Requires program version 5 or higher."""
        return cls(GlobalField.current_app_address)

    @classmethod
    def group_id(cls) -> "Global":
        """Get the ID of the current transaction group.

        If the current transaction is not part of a group, this will return 32 zero bytes.

        Requires program version 5 or higher."""
        return cls(GlobalField.group_id)

    @classmethod
    def opcode_budget(cls) -> "Global":
        """Get the remaining opcode execution budget

        Requires program version 6 or higher."""
        return cls(GlobalField.opcode_budget)

    @classmethod
    def caller_app_id(cls) -> "Global":
        """Get the id of the app that submitted the InnerTransaction that triggered this app to execute.

        If not called from another app, this will return 0

        Requires program version 6 or higher."""
        return cls(GlobalField.caller_app_id)

    @classmethod
    def caller_app_address(cls) -> "Global":
        """Get the address of the app that submitted the InnerTransaction that triggered this app to execute.

        If not called from another app, this will return the ZeroAddress

        Requires program version 6 or higher."""
        return cls(GlobalField.caller_app_address)

    @classmethod
    def asset_create_min_balance(cls) -> "Global":
        """Get the additional minimum balance required to create (and opt-into) an asset.

        Requires program version 10 or higher."""
        return cls(GlobalField.asset_create_min_balance)

    @classmethod
    def asset_opt_in_min_balance(cls) -> "Global":
        """Get the additional minimum balance required to opt-into an asset.

        Requires program version 10 or higher."""
        return cls(GlobalField.asset_opt_in_min_balance)

    @classmethod
    def genesis_hash(cls) -> "Global":
        """Get the genesis hash for the network.

        Requires program version 10 or higher."""
        return cls(GlobalField.genesis_hash)

    @classmethod
    def payouts_enabled(cls) -> "Global":
        """Get the enabled status for block incentives.

        Requires program version 11 or higher."""
        return cls(GlobalField.payouts_enabled)

    @classmethod
    def payouts_go_online_fee(cls) -> "Global":
        """Get the fee that must be paid for an account to become eligible for block incentives.

        Requires program version 11 or higher."""
        return cls(GlobalField.payouts_go_online_fee)

    @classmethod
    def payouts_percent(cls) -> "Global":
        """Get the percentage of fees in a block that will be paid to the proposer.

        Requires program version 11 or higher."""
        return cls(GlobalField.payouts_percent)

    @classmethod
    def payouts_min_balance(cls) -> "Global":
        """Get the lowest balance a proposer must have to earn a block incentive.

        Requires program version 11 or higher."""
        return cls(GlobalField.payouts_min_balance)

    @classmethod
    def payouts_max_balance(cls) -> "Global":
        """Get the highest balance a proposer must have to earn a block incentive.

        Requires program version 11 or higher."""
        return cls(GlobalField.payouts_max_balance)


Global.__module__ = "pyteal"



================================================
FILE: pyteal/ast/global_test.py
================================================
import pytest

import pyteal as pt

avm2Options = pt.CompileOptions(version=2)
avm3Options = pt.CompileOptions(version=3)
avm5Options = pt.CompileOptions(version=5)
avm6Options = pt.CompileOptions(version=6)
avm9Options = pt.CompileOptions(version=9)
avm10Options = pt.CompileOptions(version=10)
avm11Options = pt.CompileOptions(version=11)


def test_global_min_txn_fee():
    expr = pt.Global.min_txn_fee()
    assert expr.type_of() == pt.TealType.uint64

    expected = pt.TealSimpleBlock([pt.TealOp(expr, pt.Op.global_, "MinTxnFee")])

    actual, _ = expr.__teal__(avm2Options)

    assert actual == expected


def test_global_min_balance():
    expr = pt.Global.min_balance()
    assert expr.type_of() == pt.TealType.uint64

    expected = pt.TealSimpleBlock([pt.TealOp(expr, pt.Op.global_, "MinBalance")])

    actual, _ = expr.__teal__(avm2Options)

    assert actual == expected


def test_global_max_txn_life():
    expr = pt.Global.max_txn_life()
    assert expr.type_of() == pt.TealType.uint64

    expected = pt.TealSimpleBlock([pt.TealOp(expr, pt.Op.global_, "MaxTxnLife")])

    actual, _ = expr.__teal__(avm2Options)

    assert actual == expected


def test_global_zero_address():
    expr = pt.Global.zero_address()
    assert expr.type_of() == pt.TealType.bytes

    expected = pt.TealSimpleBlock([pt.TealOp(expr, pt.Op.global_, "ZeroAddress")])

    actual, _ = expr.__teal__(avm2Options)

    assert actual == expected


def test_global_group_size():
    expr = pt.Global.group_size()
    assert expr.type_of() == pt.TealType.uint64

    expected = pt.TealSimpleBlock([pt.TealOp(expr, pt.Op.global_, "GroupSize")])

    actual, _ = expr.__teal__(avm2Options)

    assert actual == expected


def test_global_logic_sig_version():
    expr = pt.Global.logic_sig_version()
    assert expr.type_of() == pt.TealType.uint64

    expected = pt.TealSimpleBlock([pt.TealOp(expr, pt.Op.global_, "LogicSigVersion")])

    actual, _ = expr.__teal__(avm2Options)

    assert actual == expected


def test_global_round():
    expr = pt.Global.round()
    assert expr.type_of() == pt.TealType.uint64

    expected = pt.TealSimpleBlock([pt.TealOp(expr, pt.Op.global_, "Round")])

    actual, _ = expr.__teal__(avm2Options)

    assert actual == expected


def test_global_latest_timestamp():
    expr = pt.Global.latest_timestamp()
    assert expr.type_of() == pt.TealType.uint64

    expected = pt.TealSimpleBlock([pt.TealOp(expr, pt.Op.global_, "LatestTimestamp")])

    actual, _ = expr.__teal__(avm2Options)

    assert actual == expected


def test_global_current_application_id():
    expr = pt.Global.current_application_id()
    assert expr.type_of() == pt.TealType.uint64

    expected = pt.TealSimpleBlock(
        [pt.TealOp(expr, pt.Op.global_, "CurrentApplicationID")]
    )

    actual, _ = expr.__teal__(avm2Options)

    assert actual == expected


def test_global_creator_address():
    expr = pt.Global.creator_address()
    assert expr.type_of() == pt.TealType.bytes

    expected = pt.TealSimpleBlock([pt.TealOp(expr, pt.Op.global_, "CreatorAddress")])

    actual, _ = expr.__teal__(avm3Options)

    assert actual == expected

    with pytest.raises(pt.TealInputError):
        expr.__teal__(avm2Options)


def test_global_current_application_address():
    expr = pt.Global.current_application_address()
    assert expr.type_of() == pt.TealType.bytes

    expected = pt.TealSimpleBlock(
        [pt.TealOp(expr, pt.Op.global_, "CurrentApplicationAddress")]
    )

    actual, _ = expr.__teal__(avm5Options)

    assert actual == expected

    with pytest.raises(pt.TealInputError):
        expr.__teal__(avm3Options)


def test_global_group_id():
    expr = pt.Global.group_id()
    assert expr.type_of() == pt.TealType.bytes

    expected = pt.TealSimpleBlock([pt.TealOp(expr, pt.Op.global_, "GroupID")])

    actual, _ = expr.__teal__(avm5Options)

    assert actual == expected

    with pytest.raises(pt.TealInputError):
        expr.__teal__(avm3Options)


def test_global_opcode_budget():
    expr = pt.Global.opcode_budget()
    assert expr.type_of() == pt.TealType.uint64

    expected = pt.TealSimpleBlock([pt.TealOp(expr, pt.Op.global_, "OpcodeBudget")])

    actual, _ = expr.__teal__(avm6Options)

    assert actual == expected

    with pytest.raises(pt.TealInputError):
        expr.__teal__(avm5Options)


def test_global_caller_application_id():
    expr = pt.Global.caller_app_id()
    assert expr.type_of() == pt.TealType.uint64

    expected = pt.TealSimpleBlock(
        [pt.TealOp(expr, pt.Op.global_, "CallerApplicationID")]
    )

    actual, _ = expr.__teal__(avm6Options)

    assert actual == expected

    with pytest.raises(pt.TealInputError):
        expr.__teal__(avm5Options)


def test_global_caller_app_address():
    expr = pt.Global.caller_app_address()
    assert expr.type_of() == pt.TealType.bytes

    expected = pt.TealSimpleBlock(
        [pt.TealOp(expr, pt.Op.global_, "CallerApplicationAddress")]
    )

    actual, _ = expr.__teal__(avm6Options)

    assert actual == expected

    with pytest.raises(pt.TealInputError):
        expr.__teal__(avm5Options)


def test_global_asset_create_min_balance():
    expr = pt.Global.asset_create_min_balance()
    assert expr.type_of() == pt.TealType.uint64

    expected = pt.TealSimpleBlock(
        [pt.TealOp(expr, pt.Op.global_, "AssetCreateMinBalance")]
    )

    actual, _ = expr.__teal__(avm10Options)

    assert actual == expected

    with pytest.raises(pt.TealInputError):
        expr.__teal__(avm9Options)


def test_global_asset_opt_in_min_balance():
    expr = pt.Global.asset_opt_in_min_balance()
    assert expr.type_of() == pt.TealType.uint64

    expected = pt.TealSimpleBlock(
        [pt.TealOp(expr, pt.Op.global_, "AssetOptInMinBalance")]
    )

    actual, _ = expr.__teal__(avm10Options)

    assert actual == expected

    with pytest.raises(pt.TealInputError):
        expr.__teal__(avm9Options)


def test_global_genesis_hash():
    expr = pt.Global.genesis_hash()
    assert expr.type_of() == pt.TealType.bytes

    expected = pt.TealSimpleBlock([pt.TealOp(expr, pt.Op.global_, "GenesisHash")])

    actual, _ = expr.__teal__(avm10Options)

    assert actual == expected

    with pytest.raises(pt.TealInputError):
        expr.__teal__(avm9Options)


def test_global_payouts_enabled():
    expr = pt.Global.payouts_enabled()
    assert expr.type_of() == pt.TealType.uint64

    expected = pt.TealSimpleBlock([pt.TealOp(expr, pt.Op.global_, "PayoutsEnabled")])

    actual, _ = expr.__teal__(avm11Options)

    assert actual == expected

    with pytest.raises(pt.TealInputError):
        expr.__teal__(avm10Options)


def test_global_payouts_go_online_fee():
    expr = pt.Global.payouts_go_online_fee()
    assert expr.type_of() == pt.TealType.uint64

    expected = pt.TealSimpleBlock(
        [pt.TealOp(expr, pt.Op.global_, "PayoutsGoOnlineFee")]
    )

    actual, _ = expr.__teal__(avm11Options)

    assert actual == expected

    with pytest.raises(pt.TealInputError):
        expr.__teal__(avm10Options)


def test_global_payouts_percent():
    expr = pt.Global.payouts_percent()
    assert expr.type_of() == pt.TealType.uint64

    expected = pt.TealSimpleBlock([pt.TealOp(expr, pt.Op.global_, "PayoutsPercent")])

    actual, _ = expr.__teal__(avm11Options)

    assert actual == expected

    with pytest.raises(pt.TealInputError):
        expr.__teal__(avm10Options)


def test_global_payouts_min_balance():
    expr = pt.Global.payouts_min_balance()
    assert expr.type_of() == pt.TealType.uint64

    expected = pt.TealSimpleBlock([pt.TealOp(expr, pt.Op.global_, "PayoutsMinBalance")])

    actual, _ = expr.__teal__(avm11Options)

    assert actual == expected

    with pytest.raises(pt.TealInputError):
        expr.__teal__(avm10Options)


def test_global_payouts_max_balance():
    expr = pt.Global.payouts_max_balance()
    assert expr.type_of() == pt.TealType.uint64

    expected = pt.TealSimpleBlock([pt.TealOp(expr, pt.Op.global_, "PayoutsMaxBalance")])

    actual, _ = expr.__teal__(avm11Options)

    assert actual == expected

    with pytest.raises(pt.TealInputError):
        expr.__teal__(avm10Options)



================================================
FILE: pyteal/ast/gtxn.py
================================================
from typing import Union, cast, TYPE_CHECKING

from pyteal.types import TealType, require_type
from pyteal.ir import TealOp, Op, TealBlock
from pyteal.errors import TealInputError, verifyFieldVersion, verifyProgramVersion
from pyteal.config import MAX_GROUP_SIZE
from pyteal.ast.expr import Expr
from pyteal.ast.txn import TxnField, TxnExpr, TxnaExpr, TxnObject

if TYPE_CHECKING:
    from pyteal.compiler import CompileOptions


def validate_txn_index_or_throw(txnIndex: Union[int, Expr]):
    if not isinstance(txnIndex, (int, Expr)):
        raise TealInputError(
            f"Invalid txnIndex type:  Expected int or Expr, but received {txnIndex}"
        )
    if isinstance(txnIndex, Expr):
        require_type(txnIndex, TealType.uint64)


class GtxnExpr(TxnExpr):
    """An expression that accesses a transaction field from a transaction in the current group."""

    def __init__(self, txnIndex: Union[int, Expr], field: TxnField) -> None:
        super().__init__(Op.gtxn, "Gtxn", field)
        validate_txn_index_or_throw(txnIndex)
        self.txnIndex = txnIndex

    def __str__(self):
        return "({} {} {})".format(self.name, self.txnIndex, self.field.arg_name)

    def __teal__(self, options: "CompileOptions"):
        verifyFieldVersion(self.field.arg_name, self.field.min_version, options.version)

        if type(self.txnIndex) is int:
            verifyProgramVersion(
                Op.gtxn.min_version,
                options.version,
                "Program version too low to use gtxn",
            )
            op = TealOp(self, Op.gtxn, self.txnIndex, self.field.arg_name)
            return TealBlock.FromOp(options, op)

        verifyProgramVersion(
            Op.gtxns.min_version,
            options.version,
            "Program version too low to index Gtxn with dynamic values",
        )

        op = TealOp(self, Op.gtxns, self.field.arg_name)
        return TealBlock.FromOp(options, op, cast(Expr, self.txnIndex))


GtxnExpr.__module__ = "pyteal"


class GtxnaExpr(TxnaExpr):
    """An expression that accesses a transaction array field from a transaction in the current group."""

    def __init__(
        self, txnIndex: Union[int, Expr], field: TxnField, index: Union[int, Expr]
    ) -> None:
        super().__init__(Op.gtxna, Op.gtxnas, "Gtxna", field, index)
        validate_txn_index_or_throw(txnIndex)
        self.txnIndex = txnIndex

    def __str__(self):
        return "({} {} {} {})".format(
            self.name, self.txnIndex, self.field.arg_name, self.index
        )

    def __teal__(self, options: "CompileOptions"):
        verifyFieldVersion(self.field.arg_name, self.field.min_version, options.version)

        if type(self.txnIndex) is int:
            if type(self.index) is int:
                opToUse = Op.gtxna
            else:
                opToUse = Op.gtxnas
        else:
            if type(self.index) is int:
                opToUse = Op.gtxnsa
            else:
                opToUse = Op.gtxnsas

        verifyProgramVersion(
            opToUse.min_version,
            options.version,
            "Program version too low to use op {}".format(opToUse),
        )

        if type(self.txnIndex) is int:
            if type(self.index) is int:
                op = TealOp(
                    self, opToUse, self.txnIndex, self.field.arg_name, self.index
                )
                return TealBlock.FromOp(options, op)
            op = TealOp(self, opToUse, self.txnIndex, self.field.arg_name)
            return TealBlock.FromOp(options, op, cast(Expr, self.index))

        if type(self.index) is int:
            op = TealOp(self, opToUse, self.field.arg_name, self.index)
            return TealBlock.FromOp(options, op, cast(Expr, self.txnIndex))

        op = TealOp(self, opToUse, self.field.arg_name)
        return TealBlock.FromOp(
            options, op, cast(Expr, self.txnIndex), cast(Expr, self.index)
        )


GtxnaExpr.__module__ = "pyteal"


class TxnGroup:
    """Represents a group of transactions."""

    def __getitem__(self, txnIndex: Union[int, Expr]) -> TxnObject:
        if type(txnIndex) is int:
            if txnIndex < 0 or txnIndex >= MAX_GROUP_SIZE:
                raise TealInputError(
                    "Invalid Gtxn index {}, shoud be in [0, {})".format(
                        txnIndex, MAX_GROUP_SIZE
                    )
                )
        else:
            require_type(cast(Expr, txnIndex), TealType.uint64)
        return TxnObject(
            lambda field: GtxnExpr(txnIndex, field),
            lambda field, index: GtxnaExpr(txnIndex, field, index),
        )


TxnGroup.__module__ = "pyteal"

Gtxn: TxnGroup = TxnGroup()

Gtxn.__module__ = "pyteal"



================================================
FILE: pyteal/ast/gtxn_test.py
================================================
import pytest

import pyteal as pt

avm6Options = pt.CompileOptions(version=6)


def test_gtxn_invalid():
    for f, e in [
        (lambda: pt.Gtxn[-1], pt.TealInputError),
        (lambda: pt.Gtxn[pt.MAX_GROUP_SIZE + 1], pt.TealInputError),
        (lambda: pt.Gtxn[pt.Pop(pt.Int(0))], pt.TealTypeError),
        (lambda: pt.Gtxn[pt.Bytes("index")], pt.TealTypeError),
    ]:
        with pytest.raises(e):
            f()


def test_gtxn_expr_invalid():
    for f, e in [
        (
            lambda: pt.GtxnExpr(pt.Assert(pt.Int(1)), pt.TxnField.sender),
            pt.TealTypeError,
        ),
    ]:
        with pytest.raises(e):
            f()


def test_gtxn_expr_valid():
    [
        e.__teal__(avm6Options)
        for e in [
            pt.GtxnExpr(1, pt.TxnField.sender),
            pt.GtxnExpr(pt.Int(1), pt.TxnField.sender),
        ]
    ]


def test_gtxna_expr_invalid():
    for f, e in [
        (
            lambda: pt.GtxnaExpr("Invalid_type", pt.TxnField.assets, 1),
            pt.TealInputError,
        ),
        (
            lambda: pt.GtxnaExpr(1, pt.TxnField.assets, "Invalid_type"),
            pt.TealInputError,
        ),
        (
            lambda: pt.GtxnaExpr(pt.Assert(pt.Int(1)), pt.TxnField.assets, 1),
            pt.TealTypeError,
        ),
        (
            lambda: pt.GtxnaExpr(1, pt.TxnField.assets, pt.Assert(pt.Int(1))),
            pt.TealTypeError,
        ),
    ]:
        with pytest.raises(e):
            f()


def test_gtxna_expr_valid():
    [
        e.__teal__(avm6Options)
        for e in [
            pt.GtxnaExpr(1, pt.TxnField.assets, 1),
            pt.GtxnaExpr(pt.Int(1), pt.TxnField.assets, pt.Int(1)),
        ]
    ]


# txn_test.py performs additional testing



================================================
FILE: pyteal/ast/if_.py
================================================
from typing import TYPE_CHECKING

from pyteal.ast.expr import Expr
from pyteal.ast.seq import _use_seq_if_multiple
from pyteal.errors import (
    TealCompileError,
    TealInputError,
)
from pyteal.types import TealType, require_type
from pyteal.ir import TealSimpleBlock, TealConditionalBlock

if TYPE_CHECKING:
    from pyteal.compiler import CompileOptions


class If(Expr):
    """Simple two-way conditional expression."""

    def __init__(
        self, cond: Expr, thenBranch: Expr | None = None, elseBranch: Expr | None = None
    ) -> None:
        """Create a new If expression.

        When this If expression is executed, the condition will be evaluated, and if it produces a
        true value, thenBranch will be executed and used as the return value for this expression.
        Otherwise, elseBranch will be executed and used as the return value, if it is provided.

        Args:
            cond: The condition to check. Must evaluate to uint64.
            thenBranch: Expression to evaluate if the condition is true.
            elseBranch (optional): Expression to evaluate if the condition is false. Must evaluate
                to the same type as thenBranch, if provided. Defaults to None.
        """
        super().__init__()
        require_type(cond, TealType.uint64)
        # Flag to denote and check whether the new If().Then() syntax is being used
        self.alternateSyntaxFlag = False

        if thenBranch:
            if elseBranch:
                require_type(thenBranch, elseBranch.type_of())
            else:
                # If there is only a thenBranch, then it should evaluate to none type
                require_type(thenBranch, TealType.none)
        else:
            self.alternateSyntaxFlag = True

        self.cond = cond
        self.thenBranch = thenBranch
        self.elseBranch = elseBranch

        self._label_cond: Expr | None = None

    def __teal__(self, options: "CompileOptions"):
        if self.thenBranch is None:
            raise TealCompileError("If expression must have a thenBranch", self)

        condStart, condEnd = self.cond.__teal__(options)
        thenStart, thenEnd = self.thenBranch.__teal__(options)
        end = TealSimpleBlock([])

        branchBlock = TealConditionalBlock([], root_expr=(self._label_cond or self))
        branchBlock.setTrueBlock(thenStart)

        condEnd.setNextBlock(branchBlock)
        thenEnd.setNextBlock(end)

        if self.elseBranch is None:
            branchBlock.setFalseBlock(end)
            branchBlock._sframes_container = self
        else:
            elseStart, elseEnd = self.elseBranch.__teal__(options)
            branchBlock.setFalseBlock(elseStart)
            elseEnd.setNextBlock(end)
            elseEnd._sframes_container = self

        return condStart, end

    def __str__(self):
        if self.thenBranch is None:
            raise TealCompileError("If expression must have a thenBranch", self)
        if self.elseBranch is None:
            return "(If {} {})".format(self.cond, self.thenBranch)
        return "(If {} {} {})".format(self.cond, self.thenBranch, self.elseBranch)

    def type_of(self):
        if self.thenBranch is None:
            raise TealCompileError("If expression must have a thenBranch", self)

        if self.elseBranch is None:
            # if there is only a thenBranch, it must evaluate to TealType.none
            require_type(self.thenBranch, TealType.none)

        return self.thenBranch.type_of()

    def has_return(self):
        if self.thenBranch is None:
            raise TealCompileError("If expression must have a thenBranch", self)

        if self.elseBranch is None:
            # return false in this case because elseBranch does not exist, so it can't have a return
            # op
            return False
        # otherwise, this expression has a return op only if both branches result in a return op
        return self.thenBranch.has_return() and self.elseBranch.has_return()

    def Then(self, thenBranch: Expr, *then_branch_multi: Expr):
        if not self.alternateSyntaxFlag:
            raise TealInputError("Cannot mix two different If syntax styles")

        thenBranch = _use_seq_if_multiple(thenBranch, *then_branch_multi)

        if not self.elseBranch:
            self.thenBranch = thenBranch
        else:
            if not isinstance(self.elseBranch, If):
                raise TealInputError("Else-Then block is malformed")
            self.elseBranch.Then(thenBranch)
        return self

    def ElseIf(self, cond):
        if not self.alternateSyntaxFlag:
            raise TealInputError("Cannot mix two different If syntax styles")

        if not self.elseBranch:
            self.elseBranch = If(cond)
            self.elseBranch._label_cond = cond
        else:
            if not isinstance(self.elseBranch, If):
                raise TealInputError("Else-ElseIf block is malformed")
            self.elseBranch.ElseIf(cond)
        return self

    def Else(self, elseBranch: Expr, *else_branch_multi: Expr):
        if not self.alternateSyntaxFlag:
            raise TealInputError("Cannot mix two different If syntax styles")

        if not self.thenBranch:
            raise TealInputError("Must set Then branch before Else branch")

        elseBranch = _use_seq_if_multiple(elseBranch, *else_branch_multi)

        if not self.elseBranch:
            require_type(elseBranch, self.thenBranch.type_of())
            self.elseBranch = elseBranch
        else:
            if not isinstance(self.elseBranch, If):
                raise TealInputError("Else-Else block is malformed")
            self.elseBranch.Else(elseBranch)
        return self


If.__module__ = "pyteal"



================================================
FILE: pyteal/ast/if_test.py
================================================
import pytest

import pyteal as pt

options = pt.CompileOptions()


def test_if_has_return():
    exprWithReturn = pt.If(pt.Int(1), pt.Return(pt.Int(1)), pt.Return(pt.Int(0)))
    assert exprWithReturn.has_return()

    exprWithoutReturn = pt.If(pt.Int(1), pt.Int(1), pt.Int(0))
    assert not exprWithoutReturn.has_return()

    exprSemiReturn = pt.If(
        pt.Int(1),
        pt.Return(pt.Int(1)),
        pt.App.globalPut(pt.Bytes("key"), pt.Bytes("value")),
    )
    assert not exprSemiReturn.has_return()


def test_if_int():
    args = [pt.Int(0), pt.Int(1), pt.Int(2)]
    expr = pt.If(args[0], args[1], args[2])
    assert expr.type_of() == pt.TealType.uint64

    expected, _ = args[0].__teal__(options)
    thenBlock, _ = args[1].__teal__(options)
    elseBlock, _ = args[2].__teal__(options)
    expectedBranch = pt.TealConditionalBlock([])
    expectedBranch.setTrueBlock(thenBlock)
    expectedBranch.setFalseBlock(elseBlock)
    expected.setNextBlock(expectedBranch)
    end = pt.TealSimpleBlock([])
    thenBlock.setNextBlock(end)
    elseBlock.setNextBlock(end)

    actual, _ = expr.__teal__(options)

    assert actual == expected


def test_if_bytes():
    args = [pt.Int(1), pt.Txn.sender(), pt.Txn.receiver()]
    expr = pt.If(args[0], args[1], args[2])
    assert expr.type_of() == pt.TealType.bytes

    expected, _ = args[0].__teal__(options)
    thenBlock, _ = args[1].__teal__(options)
    elseBlock, _ = args[2].__teal__(options)
    expectedBranch = pt.TealConditionalBlock([])
    expectedBranch.setTrueBlock(thenBlock)
    expectedBranch.setFalseBlock(elseBlock)
    expected.setNextBlock(expectedBranch)
    end = pt.TealSimpleBlock([])
    thenBlock.setNextBlock(end)
    elseBlock.setNextBlock(end)

    actual, _ = expr.__teal__(options)

    assert actual == expected


def test_if_none():
    args = [pt.Int(0), pt.Pop(pt.Txn.sender()), pt.Pop(pt.Txn.receiver())]
    expr = pt.If(args[0], args[1], args[2])
    assert expr.type_of() == pt.TealType.none

    expected, _ = args[0].__teal__(options)
    thenBlockStart, thenBlockEnd = args[1].__teal__(options)
    elseBlockStart, elseBlockEnd = args[2].__teal__(options)
    expectedBranch = pt.TealConditionalBlock([])
    expectedBranch.setTrueBlock(thenBlockStart)
    expectedBranch.setFalseBlock(elseBlockStart)
    expected.setNextBlock(expectedBranch)
    end = pt.TealSimpleBlock([])
    thenBlockEnd.setNextBlock(end)
    elseBlockEnd.setNextBlock(end)

    actual, _ = expr.__teal__(options)

    assert actual == expected


def test_if_single():
    args = [pt.Int(1), pt.Pop(pt.Int(1))]
    expr = pt.If(args[0], args[1])
    assert expr.type_of() == pt.TealType.none

    expected, _ = args[0].__teal__(options)
    thenBlockStart, thenBlockEnd = args[1].__teal__(options)
    end = pt.TealSimpleBlock([])
    expectedBranch = pt.TealConditionalBlock([])
    expectedBranch.setTrueBlock(thenBlockStart)
    expectedBranch.setFalseBlock(end)
    expected.setNextBlock(expectedBranch)
    thenBlockEnd.setNextBlock(end)

    actual, _ = expr.__teal__(options)

    assert actual == expected


def test_if_invalid():
    with pytest.raises(pt.TealTypeError):
        pt.If(pt.Int(0), pt.Txn.amount(), pt.Txn.sender())

    with pytest.raises(pt.TealTypeError):
        pt.If(pt.Txn.sender(), pt.Int(1), pt.Int(0))

    with pytest.raises(pt.TealTypeError):
        pt.If(pt.Int(0), pt.Txn.sender())

    with pytest.raises(pt.TealTypeError):
        pt.If(pt.Int(0), pt.Int(2))

    with pytest.raises(pt.TealCompileError):
        expr = pt.If(pt.Int(0))
        expr.__teal__(options)


def test_if_alt_int():
    args = [pt.Int(0), pt.Int(1), pt.Int(2)]
    expr = pt.If(args[0]).Then(args[1]).Else(args[2])
    assert expr.type_of() == pt.TealType.uint64

    expected, _ = args[0].__teal__(options)
    thenBlock, _ = args[1].__teal__(options)
    elseBlock, _ = args[2].__teal__(options)
    expectedBranch = pt.TealConditionalBlock([])
    expectedBranch.setTrueBlock(thenBlock)
    expectedBranch.setFalseBlock(elseBlock)
    expected.setNextBlock(expectedBranch)
    end = pt.TealSimpleBlock([])
    thenBlock.setNextBlock(end)
    elseBlock.setNextBlock(end)

    actual, _ = expr.__teal__(options)

    assert actual == expected


def test_if_alt_bytes():
    args = [pt.Int(1), pt.Txn.sender(), pt.Txn.receiver()]
    expr = pt.If(args[0]).Then(args[1]).Else(args[2])
    assert expr.type_of() == pt.TealType.bytes

    expected, _ = args[0].__teal__(options)
    thenBlock, _ = args[1].__teal__(options)
    elseBlock, _ = args[2].__teal__(options)
    expectedBranch = pt.TealConditionalBlock([])
    expectedBranch.setTrueBlock(thenBlock)
    expectedBranch.setFalseBlock(elseBlock)
    expected.setNextBlock(expectedBranch)
    end = pt.TealSimpleBlock([])
    thenBlock.setNextBlock(end)
    elseBlock.setNextBlock(end)

    actual, _ = expr.__teal__(options)

    assert actual == expected


def test_if_alt_none():
    args = [pt.Int(0), pt.Pop(pt.Txn.sender()), pt.Pop(pt.Txn.receiver())]
    expr = pt.If(args[0]).Then(args[1]).Else(args[2])
    assert expr.type_of() == pt.TealType.none

    expected, _ = args[0].__teal__(options)
    thenBlockStart, thenBlockEnd = args[1].__teal__(options)
    elseBlockStart, elseBlockEnd = args[2].__teal__(options)
    expectedBranch = pt.TealConditionalBlock([])
    expectedBranch.setTrueBlock(thenBlockStart)
    expectedBranch.setFalseBlock(elseBlockStart)
    expected.setNextBlock(expectedBranch)
    end = pt.TealSimpleBlock([])
    thenBlockEnd.setNextBlock(end)
    elseBlockEnd.setNextBlock(end)

    actual, _ = expr.__teal__(options)

    assert actual == expected


def test_elseif_syntax():
    args = [pt.Int(0), pt.Int(1), pt.Int(2), pt.Int(3), pt.Int(4)]
    expr = pt.If(args[0]).Then(args[1]).ElseIf(args[2]).Then(args[3]).Else(args[4])
    assert expr.type_of() == pt.TealType.uint64

    elseExpr = pt.If(args[2]).Then(args[3]).Else(args[4])
    expected, _ = args[0].__teal__(options)
    thenBlock, _ = args[1].__teal__(options)
    elseStart, elseEnd = elseExpr.__teal__(options)
    expectedBranch = pt.TealConditionalBlock([])
    expectedBranch.setTrueBlock(thenBlock)
    expectedBranch.setFalseBlock(elseStart)
    expected.setNextBlock(expectedBranch)
    end = pt.TealSimpleBlock([])
    thenBlock.setNextBlock(end)
    elseEnd.setNextBlock(end)

    actual, _ = expr.__teal__(options)

    assert actual == expected


def test_elseif_multiple():
    args = [pt.Int(0), pt.Int(1), pt.Int(2), pt.Int(3), pt.Int(4), pt.Int(5), pt.Int(6)]
    expr = (
        pt.If(args[0])
        .Then(args[1])
        .ElseIf(args[2])
        .Then(args[3])
        .ElseIf(args[4])
        .Then(args[5])
        .Else(args[6])
    )
    assert expr.type_of() == pt.TealType.uint64

    elseIfExpr = pt.If(args[2], args[3], pt.If(args[4], args[5], args[6]))
    expected, _ = args[0].__teal__(options)
    thenBlock, _ = args[1].__teal__(options)
    elseStart, elseEnd = elseIfExpr.__teal__(options)
    expectedBranch = pt.TealConditionalBlock([])
    expectedBranch.setTrueBlock(thenBlock)
    expectedBranch.setFalseBlock(elseStart)
    expected.setNextBlock(expectedBranch)
    end = pt.TealSimpleBlock([])
    thenBlock.setNextBlock(end)
    elseEnd.setNextBlock(end)

    actual, _ = expr.__teal__(options)

    assert actual == expected


def test_if_invalid_alt_syntax():
    with pytest.raises(pt.TealCompileError):
        expr = pt.If(pt.Int(0)).ElseIf(pt.Int(1))
        expr.__teal__(options)

    with pytest.raises(pt.TealCompileError):
        expr = pt.If(pt.Int(0)).ElseIf(pt.Int(1)).Then(pt.Int(2))
        expr.__teal__(options)

    with pytest.raises(pt.TealCompileError):
        expr = pt.If(pt.Int(0)).Then(pt.Int(1)).ElseIf(pt.Int(2))
        expr.__teal__(options)

    with pytest.raises(pt.TealCompileError):
        expr = pt.If(pt.Int(0)).Then(pt.Int(1)).ElseIf(pt.Int(2))
        expr.__teal__(options)

    with pytest.raises(pt.TealTypeError):
        expr = pt.If(pt.Int(0)).Then(pt.Int(2))
        expr.type_of()

    with pytest.raises(pt.TealTypeError):
        expr = pt.If(pt.Int(0)).Then(pt.Pop(pt.Int(1)), pt.Int(2))
        expr.type_of()

    with pytest.raises(pt.TealInputError):
        pt.If(pt.Int(0)).Else(pt.Int(1)).Then(pt.Int(2))

    with pytest.raises(pt.TealInputError):
        expr = pt.If(pt.Int(0)).Else(pt.Int(1))
        expr.__teal__(options)

    with pytest.raises(pt.TealInputError):
        expr = pt.If(pt.Int(0)).Else(pt.Int(1)).Then(pt.Int(2))

    with pytest.raises(pt.TealInputError):
        expr = pt.If(pt.Int(0)).Else(pt.Int(1)).Else(pt.Int(2))

    with pytest.raises(pt.TealInputError):
        expr = pt.If(pt.Int(0), pt.Pop(pt.Int(1))).Else(pt.Int(2))


def test_if_alt_multi():
    args = [pt.Int(0), [pt.Pop(pt.Int(1)), pt.Int(2)], pt.Int(3)]
    expr = pt.If(args[0]).Then(*args[1]).Else(args[2])

    expected, _ = args[0].__teal__(options)
    thenBlockStart, thenBlockEnd = pt.Seq(*args[1]).__teal__(options)
    elseBlockStart, elseBlockEnd = args[2].__teal__(options)
    expectedBranch = pt.TealConditionalBlock([])
    expectedBranch.setTrueBlock(thenBlockStart)
    expectedBranch.setFalseBlock(elseBlockStart)
    expected.setNextBlock(expectedBranch)
    end = pt.TealSimpleBlock([])
    thenBlockEnd.setNextBlock(end)
    elseBlockEnd.setNextBlock(end)

    actual, _ = expr.__teal__(options)

    assert actual == expected


def test_else_alt_multi():
    args = [pt.Int(0), pt.Int(1), [pt.Pop(pt.Int(2)), pt.Int(3)]]
    expr = pt.If(args[0]).Then(args[1]).Else(*args[2])

    expected, _ = args[0].__teal__(options)
    thenBlockStart, thenBlockEnd = args[1].__teal__(options)
    elseBlockStart, elseBlockEnd = pt.Seq(*args[2]).__teal__(options)
    expectedBranch = pt.TealConditionalBlock([])
    expectedBranch.setTrueBlock(thenBlockStart)
    expectedBranch.setFalseBlock(elseBlockStart)
    expected.setNextBlock(expectedBranch)
    end = pt.TealSimpleBlock([])
    thenBlockEnd.setNextBlock(end)
    elseBlockEnd.setNextBlock(end)

    actual, _ = expr.__teal__(options)

    assert actual == expected


def test_elseif_multiple_with_multi():
    args = [
        pt.Int(0),
        [pt.Pop(pt.Int(1)), pt.Int(2)],
        pt.Int(3),
        [pt.Pop(pt.Int(4)), pt.Int(5)],
        pt.Int(6),
        [pt.Pop(pt.Int(7)), pt.Int(8)],
        [pt.Pop(pt.Int(9)), pt.Int(10)],
    ]
    expr = (
        pt.If(args[0])
        .Then(*args[1])
        .ElseIf(args[2])
        .Then(*args[3])
        .ElseIf(args[4])
        .Then(*args[5])
        .Else(*args[6])
    )

    elseIfExpr = pt.If(
        args[2], pt.Seq(args[3]), pt.If(args[4], pt.Seq(args[5]), pt.Seq(args[6]))
    )
    expected, _ = args[0].__teal__(options)
    thenBlock, thenBlockEnd = pt.Seq(args[1]).__teal__(options)
    elseStart, elseBlockEnd = elseIfExpr.__teal__(options)
    expectedBranch = pt.TealConditionalBlock([])
    expectedBranch.setTrueBlock(thenBlock)
    expectedBranch.setFalseBlock(elseStart)
    expected.setNextBlock(expectedBranch)
    end = pt.TealSimpleBlock([])
    thenBlockEnd.setNextBlock(end)
    elseBlockEnd.setNextBlock(end)

    actual, _ = expr.__teal__(options)

    assert actual == expected



================================================
FILE: pyteal/ast/int.py
================================================
from typing import TYPE_CHECKING

from pyteal.types import TealType
from pyteal.ir import TealOp, Op, TealBlock
from pyteal.errors import TealInputError
from pyteal.ast.leafexpr import LeafExpr

if TYPE_CHECKING:
    from pyteal.compiler import CompileOptions


class Int(LeafExpr):
    """An expression that represents a uint64."""

    def __init__(self, value: int) -> None:
        """Create a new uint64.

        Args:
            value: The integer value this uint64 will represent. Must be a positive value less than
                2**64.
        """
        super().__init__()

        if type(value) is not int:
            raise TealInputError("invalid input type {} to Int".format(type(value)))
        elif value >= 0 and value < 2**64:
            self.value = value
        else:
            raise TealInputError("Int {} is out of range".format(value))

    def __teal__(self, options: "CompileOptions"):
        op = TealOp(self, Op.int, self.value)
        return TealBlock.FromOp(options, op)

    def __str__(self):
        return "(Int {})".format(self.value)

    def type_of(self):
        return TealType.uint64


Int.__module__ = "pyteal"


class EnumInt(LeafExpr):
    """An expression that represents uint64 enum values."""

    def __init__(self, name: str) -> None:
        """Create an expression to reference a uint64 enum value.

        Args:
            name: The name of the enum value.
        """
        super().__init__()
        self.name = name

    def __teal__(self, options: "CompileOptions"):
        op = TealOp(self, Op.int, self.name)
        return TealBlock.FromOp(options, op)

    def __str__(self):
        return "(IntEnum {})".format(self.name)

    def type_of(self):
        return TealType.uint64


EnumInt.__module__ = "pyteal"



================================================
FILE: pyteal/ast/int_test.py
================================================
import pytest

import pyteal as pt

options = pt.CompileOptions()


def test_int():
    values = [0, 1, 8, 232323, 2**64 - 1]

    for value in values:
        expr = pt.Int(value)
        assert expr.type_of() == pt.TealType.uint64

        expected = pt.TealSimpleBlock([pt.TealOp(expr, pt.Op.int, value)])

        actual, _ = expr.__teal__(options)

        assert actual == expected


def test_int_invalid():
    with pytest.raises(pt.TealInputError):
        pt.Int(6.7)

    with pytest.raises(pt.TealInputError):
        pt.Int(-1)

    with pytest.raises(pt.TealInputError):
        pt.Int(2**64)

    with pytest.raises(pt.TealInputError):
        pt.Int("0")


def test_enum_int():
    expr = pt.EnumInt("OptIn")
    assert expr.type_of() == pt.TealType.uint64

    expected = pt.TealSimpleBlock([pt.TealOp(expr, pt.Op.int, "OptIn")])

    actual, _ = expr.__teal__(options)

    assert actual == expected



================================================
FILE: pyteal/ast/itxn.py
================================================
from enum import Enum
import algosdk

from typing import TYPE_CHECKING, cast
from pyteal.ast.int import EnumInt
from pyteal.ast.for_ import For
from pyteal.ast.int import Int
from pyteal.ast.scratchvar import ScratchVar

from pyteal.ast.methodsig import MethodSignature
from pyteal.types import TealType, require_type
from pyteal.errors import TealInputError, TealTypeError, verifyProgramVersion
from pyteal.ir import TealOp, Op, TealBlock
from pyteal.ast.expr import Expr
from pyteal.ast.txn import (
    TxnType,
    TxnArray,
    TxnField,
    TxnExprBuilder,
    TxnaExprBuilder,
    TxnObject,
)
from pyteal.ast.seq import Seq
from pyteal.ast.bytes import Bytes
from pyteal.ast import abi

if TYPE_CHECKING:
    from pyteal.compiler import CompileOptions


class InnerTxnAction(Enum):
    Begin = Op.itxn_begin
    Submit = Op.itxn_submit
    Next = Op.itxn_next


InnerTxnAction.__module__ = "pyteal"


class InnerTxnActionExpr(Expr):
    def __init__(self, action: InnerTxnAction) -> None:
        super().__init__()
        self.action = action

    def __str__(self):
        return "(InnerTxn{})".format(self.action.name)

    def __teal__(self, options: "CompileOptions"):
        op = self.action.value

        verifyProgramVersion(
            op.min_version,
            options.version,
            "Program version too low to create inner transactions",
        )

        return TealBlock.FromOp(options, TealOp(self, op))

    def type_of(self):
        return TealType.none

    def has_return(self):
        return False


class InnerTxnFieldExpr(Expr):
    def __init__(self, field: TxnField, value: Expr) -> None:
        super().__init__()
        require_type(value, field.type_of())
        self.field = field
        self.value = value

    def __str__(self):
        return "(InnerTxnSetField {} {})".format(self.field.arg_name, self.value)

    def __teal__(self, options: "CompileOptions"):
        verifyProgramVersion(
            Op.itxn_field.min_version,
            options.version,
            "Program version too low to create inner transactions",
        )

        return TealBlock.FromOp(
            options, TealOp(self, Op.itxn_field, self.field.arg_name), self.value
        )

    def type_of(self):
        return TealType.none

    def has_return(self):
        return False


class InnerTxnBuilder:
    """This class represents expressions used to create, modify, and submit inner transactions.

    Inner transactions are transactions which applications can dynamically create. Each inner
    transaction will appear as a transaction inside of the current transaction being executed.

    As of program version 5, only the transaction types :any:`TxnType.Payment`, :any:`TxnType.AssetTransfer`,
    :any:`TxnType.AssetConfig`, and :any:`TxnType.AssetFreeze` are allowed. Additionally, not all
    fields are allowed to be set. For example, it is not currently allowed to set the rekeyTo field
    of an inner transaction.
    """

    @classmethod
    def Begin(cls) -> Expr:
        """Begin preparation of a new inner transaction.

        This new inner transaction is initialized with its sender to the application address (:any:`Global.current_application_address`);
        fee to the minimum allowable, taking into account :code:`MinTxnFee` and credit from
        overpaying in earlier transactions; :code:`FirstValid`/:code:`LastValid` to the values in
        the top-level transaction, and all other fields to zero values.

        Requires program version 5 or higher. This operation is only permitted in application mode.
        """
        return InnerTxnActionExpr(InnerTxnAction.Begin)

    @classmethod
    def Next(cls) -> Expr:
        """Begin preparation of a new inner transaction (in the same transaction group).

        This new inner transaction is initialized with its sender to the application address (:any:`Global.current_application_address`);
        fee to the minimum allowable, taking into account :code:`MinTxnFee` and credit from
        overpaying in earlier transactions; :code:`FirstValid`/:code:`LastValid` to the values in
        the top-level transaction, and all other fields to zero values.

        Requires program version 6 or higher. This operation is only permitted in application mode.
        """
        return InnerTxnActionExpr(InnerTxnAction.Next)

    @classmethod
    def Submit(cls) -> Expr:
        """Execute the current inner transaction.

        :any:`InnerTxnBuilder.Begin` and :any:`InnerTxnBuilder.SetField` must be called before
        submitting an inner transaction.

        This will fail if 256 inner transactions have already been executed, or if the
        inner transaction itself fails. Upon failure, the current program will immediately exit and
        fail as well.

        If the inner transaction is successful, then its effects can be immediately observed by this
        program with stateful expressions such as :any:`Balance`. Additionally, the fields of the
        most recently submitted inner transaction can be examined using the :any:`InnerTxn` object.
        If the inner transaction creates an asset, the new asset ID can be found by looking at
        :any:`InnerTxn.created_asset_id() <TxnObject.created_asset_id>`.

        Requires program version 5 or higher. This operation is only permitted in application mode.
        """
        return InnerTxnActionExpr(InnerTxnAction.Submit)

    @classmethod
    def SetField(cls, field: TxnField, value: Expr | list[Expr]) -> Expr:
        """Set a field of the current inner transaction.

        :any:`InnerTxnBuilder.Begin` must be called before setting any fields on an inner
        transaction.

        Note: For non-array field (e.g., note), setting it twice will overwrite the original value.
              While for array field (e.g., accounts), setting it multiple times will append the values.
              It is also possible to pass the entire array field if desired (e.g., Txn.accounts) to pass all the references.

        Requires program version 5 or higher. This operation is only permitted in application mode.

        Args:
            field: The field to set on the inner transaction.
            value: The value to that the field should take. This must evaluate to a type that is
                compatible with the field being set.
        """
        if not field.is_array:
            if type(value) is list or isinstance(value, TxnArray):
                raise TealInputError(
                    "inner transaction set field {} does not support array value".format(
                        field
                    )
                )
            return InnerTxnFieldExpr(field, cast(Expr, value))
        else:
            if type(value) is not list and not isinstance(value, TxnArray):
                raise TealInputError(
                    "inner transaction set array field {} with non-array value".format(
                        field
                    )
                )

            if type(value) is list:
                for valueIter in value:
                    if not isinstance(valueIter, Expr):
                        raise TealInputError(
                            "inner transaction set array field {} with non PyTeal expression array element {}".format(
                                field, valueIter
                            )
                        )

                return Seq(
                    *[
                        InnerTxnFieldExpr(field, cast(Expr, valueIter))
                        for valueIter in value
                    ]
                )
            else:
                arr = cast(TxnArray, value)
                return For(
                    (i := ScratchVar()).store(Int(0)),
                    i.load() < arr.length(),
                    i.store(i.load() + Int(1)),
                ).Do(InnerTxnFieldExpr(field, arr[i.load()]))

    @classmethod
    def Execute(cls, fields: dict[TxnField, Expr | list[Expr]]) -> Expr:
        """Performs a single transaction given fields passed in.

        A convenience method that accepts fields to submit a single inner transaction, which is equivalent to:

        .. code-block:: python

            InnerTxnBuilder.Begin()
            InnerTxnBuilder.SetFields(fields)
            InnerTxnBuilder.Submit()

        Requires program version 5 or higher. This operation is only permitted in application mode.

        Args:
            fields: A dictionary whose keys are fields to set and whose values are the value each
                field should take. Each value must evaluate to a type that is compatible with the
                field being set.
        """
        return Seq(cls.Begin(), cls.SetFields(fields), cls.Submit())

    @classmethod
    def SetFields(cls, fields: dict[TxnField, Expr | list[Expr]]) -> Expr:
        """Set multiple fields of the current inner transaction.

        :any:`InnerTxnBuilder.Begin` must be called before setting any fields on an inner
        transaction.

        Note: For non-array field (e.g., note), setting it twice will overwrite the original value.
              While for array field (e.g., accounts), setting it multiple times will append the values.
              It is also possible to pass the entire array field if desired (e.g., Txn.accounts) to pass all the references.

        Requires program version 5 or higher. This operation is only permitted in application mode.

        Args:
            fields: A dictionary whose keys are fields to set and whose values are the value each
                field should take. Each value must evaluate to a type that is compatible with the
                field being set.
        """
        fieldsToSet = [cls.SetField(field, value) for field, value in fields.items()]
        return Seq(fieldsToSet)

    @classmethod
    def ExecuteMethodCall(
        cls,
        *,
        app_id: Expr | None,
        method_signature: str,
        args: list[abi.BaseType | Expr | dict[TxnField, Expr | list[Expr]]],
        extra_fields: dict[TxnField, Expr | list[Expr]] | None = None,
    ) -> Expr:
        """Performs a single app call transaction formatted as an ABI method call.

        A convenience method that accepts fields to submit a single inner transaction, which is equivalent to:

        .. code-block:: python

            InnerTxnBuilder.Begin()
            InnerTxnBuilder.MethodCall(
                app_id=app_id,
                method_signature=method_signature,
                args=args,
                extra_fields=extra_fields,
            ),
            InnerTxnBuilder.Submit()

        Requires program version 5 or higher. This operation is only permitted in application mode.

        Args:
            app_id: An expression that evaluates to a `TealType.uint64` corresponding to the application being called.
                If the call is meant to create an application, the value `None` should be passed
            method_signature: A string representing the method signature of the method we're calling. This is used to do
                type checking on the arguments passed and to create the method selector passed as the first argument.
            args: A list of arguments to pass to the application. The values in this list depend on the kind of argument you wish to pass:

                - For basic ABI arguments (not Reference or Transaction types):
                    If an ABI type is passed it **MUST** match the type specified in the `method_signature`. If an Expr is passed it must evaluate to `TealType.bytes` but beyond that no type checking is performed.

                - For Reference arguments:
                    Either the Reference type or an Expr that returns the type corresponding to the reference type are allowed.
                    (i.e. Asset is TealType.uint64, Application is TealType.uint64, Account is TealType.bytes)

                - For Transaction arguments:
                    A dictionary containing TxnField to Expr that describe Transactions to be pre-pended to the transaction group being constructed.  The `TxnField.type_enum` key MUST be set and MUST match the expected transaction type specified in the `method_signature`.

            extra_fields (optional): A dictionary whose keys are fields to set and whose values are the value each
                field should take. Each value must evaluate to a type that is compatible with the
                field being set. These fields are set on the ApplicationCallTransaction being constructed
        """
        return Seq(
            cls.Begin(),
            cls.MethodCall(
                app_id=app_id,
                method_signature=method_signature,
                args=args,
                extra_fields=extra_fields,
            ),
            cls.Submit(),
        )

    @classmethod
    def MethodCall(
        cls,
        *,
        app_id: Expr | None,
        method_signature: str,
        args: list[abi.BaseType | Expr | dict[TxnField, Expr | list[Expr]]],
        extra_fields: dict[TxnField, Expr | list[Expr]] | None = None,
    ) -> Expr:
        """Adds an ABI method call transaction to the current inner transaction group.

        :any:`InnerTxnBuilder.Begin` must be called before a MethodCall can be added.

        Requires Teal version 6 or higher. This operation is only permitted in application mode.

        Args:
            app_id: An expression that evaluates to a `TealType.uint64` corresponding to the application being called.
                If the call is meant to create an application, the value `None` should be passed
            method_signature: A string representing the method signature of the method we're calling. This is used to do
                type checking on the arguments passed and to create the method selector passed as the first argument.
            args: A list of arguments to pass to the application. The values in this list depend on the kind of argument you wish to pass:

                - For basic ABI arguments (not Reference or Transaction types):
                    If an ABI type is passed it **MUST** match the type specified in the `method_signature`. If an Expr is passed it must evaluate to `TealType.bytes` but beyond that no type checking is performed.

                - For Reference arguments:
                    Either the Reference type or an Expr that returns the type corresponding to the reference type are allowed.
                    (i.e. Asset is TealType.uint64, Application is TealType.uint64, Account is TealType.bytes)

                - For Transaction arguments:
                    A dictionary containing TxnField to Expr that describe Transactions to be pre-pended to the transaction group being constructed.  The `TxnField.type_enum` key MUST be set and MUST match the expected transaction type specified in the `method_signature`.

            extra_fields (optional): A dictionary whose keys are fields to set and whose values are the value each
                field should take. Each value must evaluate to a type that is compatible with the
                field being set. These fields are set on the ApplicationCallTransaction being constructed
        """

        from pyteal.ast.abi.util import type_spec_is_assignable_to

        # Start collecting the fields we'd like to set
        fields_to_set = [
            cls.SetField(TxnField.type_enum, TxnType.ApplicationCall),
        ]

        # In the case of an app create, the `app_id` arg may be `None`
        if app_id is not None:
            require_type(app_id, TealType.uint64)
            fields_to_set.append(cls.SetField(TxnField.application_id, app_id))

        # We only care about the args
        arg_type_specs: list[abi.TypeSpec]
        arg_type_specs, _ = abi.type_specs_from_signature(method_signature)

        if len(args) != len(arg_type_specs):
            raise TealInputError(
                f"Expected {len(arg_type_specs)} arguments, got {len(args)}"
            )

        # Start app args with the method selector
        app_args: list[Expr] = [MethodSignature(method_signature)]

        # Transactions are not included in the App Call
        txns_to_pass: list[Expr] = []

        # Reference Types are treated specially
        accts: list[Expr] = []
        apps: list[Expr] = []
        assets: list[Expr] = []

        for idx, method_arg_ts in enumerate(arg_type_specs):
            arg = args[idx]

            if method_arg_ts in abi.TransactionTypeSpecs:
                if not isinstance(arg, dict):
                    raise TealTypeError(arg, dict[TxnField, Expr | list[Expr]])

                if TxnField.type_enum not in arg:
                    raise TealInputError(
                        f"Expected Transaction at arg {idx} to contain field type_enum"
                    )

                if type(arg[TxnField.type_enum]) is not EnumInt:
                    raise TealTypeError(arg[TxnField.type_enum], EnumInt)

                txntype = cast(EnumInt, arg[TxnField.type_enum]).name
                # If the arg is an unspecified transaction, no need to check the type_enum

                if not type_spec_is_assignable_to(
                    abi.type_spec_from_algosdk(txntype), method_arg_ts
                ):
                    raise TealInputError(
                        f"Expected Transaction at arg {idx} to be {method_arg_ts}, got {txntype}"
                    )

                txns_to_pass.append(InnerTxnBuilder.SetFields(arg))

            elif method_arg_ts in abi.ReferenceTypeSpecs:
                match method_arg_ts:
                    # For both acct and application, add index to
                    # app args _after_ appending since 0 is implicitly set
                    case abi.AccountTypeSpec():
                        if isinstance(arg, Expr):
                            # require the address is passed
                            require_type(arg, TealType.bytes)
                            accts.append(arg)
                        elif isinstance(arg, abi.Account):
                            accts.append(arg.address())
                        else:
                            raise TealTypeError(arg, abi.Account | Expr)

                        app_args.append(
                            Bytes(
                                algosdk.abi.ABIType.from_string("uint8").encode(
                                    len(accts)
                                )
                            )
                        )

                    case abi.ApplicationTypeSpec():
                        if isinstance(arg, Expr):
                            # require the app id be passed
                            require_type(arg, TealType.uint64)
                            apps.append(arg)
                        elif isinstance(arg, abi.Application):
                            apps.append(arg.application_id())
                        else:
                            raise TealTypeError(arg, abi.Application | Expr)

                        app_args.append(
                            Bytes(
                                algosdk.abi.ABIType.from_string("uint8").encode(
                                    len(apps)
                                )
                            )
                        )

                    # For assets, add to app_args prior to appending to assets array
                    case abi.AssetTypeSpec():
                        app_args.append(
                            Bytes(
                                algosdk.abi.ABIType.from_string("uint8").encode(
                                    len(assets)
                                )
                            )
                        )

                        if isinstance(arg, Expr):
                            require_type(arg, TealType.uint64)
                            assets.append(arg)
                        elif isinstance(arg, abi.Asset):
                            assets.append(arg.asset_id())
                        else:
                            raise TealTypeError(arg, abi.Asset | Expr)
            else:
                if isinstance(arg, Expr):
                    # This should _always_ be bytes, since we assume its already abi encoded
                    require_type(arg, TealType.bytes)
                    app_args.append(arg)
                elif isinstance(arg, abi.BaseType):
                    if not type_spec_is_assignable_to(arg.type_spec(), method_arg_ts):
                        raise TealTypeError(arg.type_spec(), method_arg_ts)
                    app_args.append(arg.encode())
                else:
                    raise TealTypeError(arg, abi.BaseType | Expr)

        if len(accts) > 0:
            fields_to_set.append(cls.SetField(TxnField.accounts, accts))

        if len(apps) > 0:
            fields_to_set.append(cls.SetField(TxnField.applications, apps))

        if len(assets) > 0:
            fields_to_set.append(cls.SetField(TxnField.assets, assets))

        fields_to_set.append(cls.SetField(TxnField.application_args, app_args))

        return Seq(
            # Add the transactions first
            *[Seq(ttp, InnerTxnBuilder.Next()) for ttp in txns_to_pass],
            # Set the fields for the app call in app args and foreign arrays
            *fields_to_set,
            # Add any remaining fields specified by the user
            InnerTxnBuilder.SetFields({} if extra_fields is None else extra_fields),
        )


InnerTxnBuilder.__module__ = "pyteal"

InnerTxn: TxnObject = TxnObject(
    TxnExprBuilder(Op.itxn, "InnerTxn"),
    TxnaExprBuilder(Op.itxna, Op.itxnas, "InnerTxna"),
)

InnerTxn.__module__ = "pyteal"



================================================
FILE: pyteal/ast/itxn_test.py
================================================
import pytest

import pyteal as pt
from pyteal.ast.txn import Txn, TxnField, TxnType
from pyteal.types import types_match

avm4Options = pt.CompileOptions(version=4)
avm5Options = pt.CompileOptions(version=5)
avm6Options = pt.CompileOptions(version=6)


def test_InnerTxnBuilder_Begin():
    expr = pt.InnerTxnBuilder.Begin()
    assert expr.type_of() == pt.TealType.none
    assert not expr.has_return()

    expected = pt.TealSimpleBlock([pt.TealOp(expr, pt.Op.itxn_begin)])

    actual, _ = expr.__teal__(avm5Options)

    assert actual == expected

    with pytest.raises(pt.TealInputError):
        expr.__teal__(avm4Options)


def test_InnerTxnBuilder_Submit():
    expr = pt.InnerTxnBuilder.Submit()
    assert expr.type_of() == pt.TealType.none
    assert not expr.has_return()

    expected = pt.TealSimpleBlock([pt.TealOp(expr, pt.Op.itxn_submit)])

    actual, _ = expr.__teal__(avm5Options)

    assert actual == expected

    with pytest.raises(pt.TealInputError):
        expr.__teal__(avm4Options)


def test_InnerTxnBuilder_Next():
    expr = pt.InnerTxnBuilder.Next()
    assert expr.type_of() == pt.TealType.none
    assert not expr.has_return()

    expected = pt.TealSimpleBlock([pt.TealOp(expr, pt.Op.itxn_next)])

    actual, _ = expr.__teal__(avm6Options)

    assert actual == expected

    with pytest.raises(pt.TealInputError):
        expr.__teal__(avm5Options)


def test_InnerTxnBuilder_SetField():
    for field in pt.TxnField:
        if field.is_array:
            with pytest.raises(pt.TealInputError):
                pt.InnerTxnBuilder.SetField(field, pt.Int(0))
            continue

        for value, opArgs in (
            (pt.Int(0), (pt.Op.int, 0)),
            (pt.Bytes("value"), (pt.Op.byte, '"value"')),
        ):
            assert field.type_of() in (pt.TealType.uint64, pt.TealType.bytes)

            if not types_match(field.type_of(), value.type_of()):
                with pytest.raises(pt.TealTypeError):
                    pt.InnerTxnBuilder.SetField(field, value)
                continue

            expr = pt.InnerTxnBuilder.SetField(field, value)
            assert expr.type_of() == pt.TealType.none
            assert not expr.has_return()

            expected = pt.TealSimpleBlock(
                [
                    pt.TealOp(value, *opArgs),
                    pt.TealOp(expr, pt.Op.itxn_field, field.arg_name),
                ]
            )

            actual, _ = expr.__teal__(avm5Options)
            actual.addIncoming()
            actual = pt.TealBlock.NormalizeBlocks(actual)

            assert actual == expected

            with pytest.raises(pt.TealInputError):
                expr.__teal__(avm4Options)


ITXN_FIELDS_CASES = [
    ({}, pt.Seq()),
    (
        {pt.TxnField.amount: pt.Int(5)},
        pt.InnerTxnBuilder.SetField(pt.TxnField.amount, pt.Int(5)),
    ),
    (
        {
            pt.TxnField.type_enum: pt.TxnType.Payment,
            pt.TxnField.close_remainder_to: pt.Txn.sender(),
        },
        pt.Seq(
            pt.InnerTxnBuilder.SetField(pt.TxnField.type_enum, pt.TxnType.Payment),
            pt.InnerTxnBuilder.SetField(
                pt.TxnField.close_remainder_to, pt.Txn.sender()
            ),
        ),
    ),
    (
        {pt.TxnField.accounts: pt.Txn.accounts},
        pt.For(
            (i := pt.ScratchVar()).store(pt.Int(0)),
            i.load() < pt.Txn.accounts.length(),
            i.store(i.load() + pt.Int(1)),
        ).Do(
            pt.InnerTxnBuilder.SetField(pt.TxnField.accounts, [Txn.accounts[i.load()]])
        ),
    ),
]


def test_InnerTxnBuilder_SetFields():
    for fields, expectedExpr in ITXN_FIELDS_CASES:
        expr = pt.InnerTxnBuilder.SetFields(fields)
        assert expr.type_of() == pt.TealType.none
        assert not expr.has_return()

        expected, _ = expectedExpr.__teal__(avm5Options)
        expected.addIncoming()
        expected = pt.TealBlock.NormalizeBlocks(expected)

        actual, _ = expr.__teal__(avm5Options)
        actual.addIncoming()
        actual = pt.TealBlock.NormalizeBlocks(actual)

        with pt.TealComponent.Context.ignoreScratchSlotEquality(), pt.TealComponent.Context.ignoreExprEquality():
            assert actual == expected

        assert pt.TealBlock.MatchScratchSlotReferences(
            pt.TealBlock.GetReferencedScratchSlots(actual),
            pt.TealBlock.GetReferencedScratchSlots(expected),
        )

        if len(fields) != 0:
            with pytest.raises(pt.TealInputError):
                expr.__teal__(avm4Options)


def test_InnerTxnBuilder_Execute():
    for fields, expectedExpr in ITXN_FIELDS_CASES:
        expr = pt.InnerTxnBuilder.Execute(fields)

        expected, _ = pt.Seq(
            pt.InnerTxnBuilder.Begin(),
            expectedExpr,
            pt.InnerTxnBuilder.Submit(),
        ).__teal__(avm5Options)
        expected.addIncoming()
        expected = pt.TealBlock.NormalizeBlocks(expected)

        actual, _ = expr.__teal__(avm5Options)
        actual.addIncoming()
        actual = pt.TealBlock.NormalizeBlocks(actual)

        with pt.TealComponent.Context.ignoreScratchSlotEquality(), pt.TealComponent.Context.ignoreExprEquality():
            assert actual == expected

        assert pt.TealBlock.MatchScratchSlotReferences(
            pt.TealBlock.GetReferencedScratchSlots(actual),
            pt.TealBlock.GetReferencedScratchSlots(expected),
        )

        with pytest.raises(pt.TealInputError):
            expr.__teal__(avm4Options)


ITXN_METHOD_CASES = (
    (
        pt.Int(1),
        "add(uint64,uint64)void",
        [t1_1 := pt.Itob(pt.Int(1)), t1_2 := pt.Itob(pt.Int(1))],
        {TxnField.fee: pt.Int(0)},
        pt.Seq(
            pt.InnerTxnBuilder.SetFields(
                {
                    pt.TxnField.type_enum: TxnType.ApplicationCall,
                    pt.TxnField.application_id: pt.Int(1),
                    pt.TxnField.application_args: [
                        pt.MethodSignature("add(uint64,uint64)void"),
                        t1_1,
                        t1_2,
                    ],
                    pt.TxnField.fee: pt.Int(0),
                }
            ),
        ),
        None,
    ),
    (
        pt.Int(1),
        "add(uint64,uint64)void",
        [t2_1 := pt.abi.Uint64(), t2_2 := pt.abi.Uint64()],
        {TxnField.fee: pt.Int(0)},
        pt.Seq(
            pt.InnerTxnBuilder.SetFields(
                {
                    pt.TxnField.type_enum: TxnType.ApplicationCall,
                    pt.TxnField.application_id: pt.Int(1),
                    pt.TxnField.application_args: [
                        pt.MethodSignature("add(uint64,uint64)void"),
                        t2_1.encode(),
                        t2_2.encode(),
                    ],
                    pt.TxnField.fee: pt.Int(0),
                }
            ),
        ),
        None,
    ),
    (
        pt.Int(1),
        "add(application,account,asset)void",
        [
            t3_1 := pt.abi.Application(),
            t3_2 := pt.abi.Account(),
            t3_3 := pt.abi.Asset(),
        ],
        {TxnField.fee: pt.Int(0)},
        pt.Seq(
            pt.InnerTxnBuilder.SetFields(
                {
                    pt.TxnField.type_enum: TxnType.ApplicationCall,
                    pt.TxnField.application_id: pt.Int(1),
                    pt.TxnField.accounts: [t3_2.address()],
                    pt.TxnField.applications: [t3_1.application_id()],
                    pt.TxnField.assets: [t3_3.asset_id()],
                    pt.TxnField.application_args: [
                        pt.MethodSignature("add(application,account,asset)void"),
                        pt.Bytes(b"\x01"),
                        pt.Bytes(b"\x01"),
                        pt.Bytes(b"\x00"),
                    ],
                    pt.TxnField.fee: pt.Int(0),
                }
            ),
        ),
        None,
    ),
    (
        pt.Int(1),
        "add(application,account,asset)void",
        [
            t4_1 := pt.Int(1),
            t4_2 := pt.Global.zero_address(),
            t4_3 := pt.Int(2),
        ],
        {TxnField.fee: pt.Int(0)},
        pt.Seq(
            pt.InnerTxnBuilder.SetFields(
                {
                    pt.TxnField.type_enum: TxnType.ApplicationCall,
                    pt.TxnField.application_id: pt.Int(1),
                    pt.TxnField.accounts: [t4_2],
                    pt.TxnField.applications: [t4_1],
                    pt.TxnField.assets: [t4_3],
                    pt.TxnField.application_args: [
                        pt.MethodSignature("add(application,account,asset)void"),
                        pt.Bytes(b"\x01"),
                        pt.Bytes(b"\x01"),
                        pt.Bytes(b"\x00"),
                    ],
                    pt.TxnField.fee: pt.Int(0),
                }
            ),
        ),
        None,
    ),
    (
        pt.Int(1),
        "add(pay,txn,appl)void",
        [
            t5_1 := {TxnField.type_enum: TxnType.Payment},
            t5_2 := {TxnField.type_enum: TxnType.AssetTransfer},
            t5_3 := {TxnField.type_enum: TxnType.ApplicationCall},
        ],
        {TxnField.fee: pt.Int(0)},
        pt.Seq(
            pt.InnerTxnBuilder.SetFields(t5_1),  # type: ignore
            pt.InnerTxnBuilder.Next(),
            pt.InnerTxnBuilder.SetFields(t5_2),  # type: ignore
            pt.InnerTxnBuilder.Next(),
            pt.InnerTxnBuilder.SetFields(t5_3),  # type: ignore
            pt.InnerTxnBuilder.Next(),
            pt.InnerTxnBuilder.SetFields(
                {
                    pt.TxnField.type_enum: TxnType.ApplicationCall,
                    pt.TxnField.application_id: pt.Int(1),
                    pt.TxnField.application_args: [
                        pt.MethodSignature("add(pay,txn,appl)void"),
                    ],
                    pt.TxnField.fee: pt.Int(0),
                }
            ),
        ),
        None,
    ),
    (
        pt.Int(1),
        "query(byte[],uint64)void",
        [t6_1 := pt.abi.DynamicBytes(), t6_2 := pt.abi.Uint64()],
        {TxnField.fee: pt.Int(0)},
        pt.Seq(
            pt.InnerTxnBuilder.SetFields(
                {
                    pt.TxnField.type_enum: TxnType.ApplicationCall,
                    pt.TxnField.application_id: pt.Int(1),
                    pt.TxnField.application_args: [
                        pt.MethodSignature("query(byte[],uint64)void"),
                        t6_1.encode(),
                        t6_2.encode(),
                    ],
                    pt.TxnField.fee: pt.Int(0),
                }
            ),
        ),
        None,
    ),
    # App create case
    (
        None,
        "create(byte[],uint64)void",
        [t6_1 := pt.abi.DynamicBytes(), t6_2 := pt.abi.Uint64()],
        {TxnField.fee: pt.Int(0)},
        pt.Seq(
            pt.InnerTxnBuilder.SetFields(
                {
                    pt.TxnField.type_enum: TxnType.ApplicationCall,
                    pt.TxnField.application_args: [
                        pt.MethodSignature("create(byte[],uint64)void"),
                        t6_1.encode(),
                        t6_2.encode(),
                    ],
                    pt.TxnField.fee: pt.Int(0),
                }
            ),
        ),
        None,
    ),
    # Error cases
    (
        pt.Int(1),
        "add(pay,txn,appl)void",
        [
            {},
            {TxnField.type_enum: TxnType.AssetTransfer},
            {TxnField.type_enum: TxnType.ApplicationCall},
        ],
        None,
        None,
        pt.TealInputError,
    ),
    (
        pt.Int(1),
        "add(pay,txn,appl)void",
        [
            {TxnField.type_enum: pt.Int(10)},
            {TxnField.type_enum: TxnType.AssetTransfer},
            {TxnField.type_enum: TxnType.ApplicationCall},
        ],
        None,
        None,
        pt.TealTypeError,
    ),
    (
        pt.Int(1),
        "add(pay,txn,appl)void",
        [
            {TxnField.type_enum: TxnType.ApplicationCall},
            {TxnField.type_enum: TxnType.AssetTransfer},
            {TxnField.type_enum: TxnType.ApplicationCall},
        ],
        None,
        None,
        pt.TealInputError,
    ),
    (
        pt.Int(1),
        "add(application,account,asset)void",
        [
            pt.abi.Asset(),
            pt.abi.Account(),
            pt.abi.Asset(),
        ],
        None,
        None,
        pt.TealTypeError,
    ),
    (
        pt.Int(1),
        "add(application)void",
        [
            pt.Bytes(""),
        ],
        None,
        None,
        pt.TealTypeError,
    ),
    (
        pt.Int(1),
        "add(asset)void",
        [
            pt.Bytes(""),
        ],
        None,
        None,
        pt.TealTypeError,
    ),
    (
        pt.Int(1),
        "add(account)void",
        [
            pt.Int(1),
        ],
        None,
        None,
        pt.TealTypeError,
    ),
    (
        pt.Int(1),
        "add(uint64,uint64)void",
        [pt.abi.String(), pt.abi.Uint64()],
        None,
        None,
        pt.TealTypeError,
    ),
    (
        pt.Int(1),
        "add(uint64,uint64)void",
        [pt.abi.Uint64()],
        None,
        None,
        pt.TealInputError,
    ),
    (
        pt.Int(1),
        "add(uint64,uint64)void",
        [pt.abi.Uint64(), pt.abi.Uint64(), pt.abi.Uint64()],
        None,
        None,
        pt.TealInputError,
    ),
)


@pytest.mark.parametrize(
    "app_id, sig, args, extra_fields, expected_expr, expected_error", ITXN_METHOD_CASES
)
def test_InnerTxnBuilder_method_call(
    app_id: pt.Expr,
    sig: str,
    args: list[pt.abi.BaseType | pt.Expr | dict[pt.TxnField, pt.Expr | list[pt.Expr]]],
    extra_fields: dict[pt.TxnField, pt.Expr | list[pt.Expr]],
    expected_expr: pt.Expr,
    expected_error: type[Exception],
):
    if expected_error is not None:
        with pytest.raises(expected_error):
            pt.InnerTxnBuilder.MethodCall(
                app_id=app_id,
                method_signature=sig,
                args=args,
                extra_fields=extra_fields,
            )
        with pytest.raises(expected_error):
            pt.InnerTxnBuilder.ExecuteMethodCall(
                app_id=app_id,
                method_signature=sig,
                args=args,
                extra_fields=extra_fields,
            )
        return

    # First run the test with MethodCall
    expr: pt.Expr = pt.InnerTxnBuilder.MethodCall(
        app_id=app_id, method_signature=sig, args=args, extra_fields=extra_fields
    )
    assert expr.type_of() == pt.TealType.none
    assert not expr.has_return()

    expected, _ = expected_expr.__teal__(avm6Options)
    expected.addIncoming()
    expected = pt.TealBlock.NormalizeBlocks(expected)

    actual, _ = expr.__teal__(avm6Options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    with pt.TealComponent.Context.ignoreScratchSlotEquality(), pt.TealComponent.Context.ignoreExprEquality():
        assert actual == expected
        assert pt.TealBlock.MatchScratchSlotReferences(
            pt.TealBlock.GetReferencedScratchSlots(actual),
            pt.TealBlock.GetReferencedScratchSlots(expected),
        )

    # Now run the same test with ExecuteMethodCall
    expr = pt.InnerTxnBuilder.ExecuteMethodCall(
        app_id=app_id, method_signature=sig, args=args, extra_fields=extra_fields
    )
    assert expr.type_of() == pt.TealType.none
    assert not expr.has_return()

    expected, _ = pt.Seq(
        pt.InnerTxnBuilder.Begin(), expected_expr, pt.InnerTxnBuilder.Submit()
    ).__teal__(avm6Options)
    expected.addIncoming()
    expected = pt.TealBlock.NormalizeBlocks(expected)

    actual, _ = expr.__teal__(avm6Options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    with pt.TealComponent.Context.ignoreScratchSlotEquality(), pt.TealComponent.Context.ignoreExprEquality():
        assert actual == expected
        assert pt.TealBlock.MatchScratchSlotReferences(
            pt.TealBlock.GetReferencedScratchSlots(actual),
            pt.TealBlock.GetReferencedScratchSlots(expected),
        )


# txn_test.py performs additional testing



================================================
FILE: pyteal/ast/jsonref.py
================================================
from typing import TYPE_CHECKING
from enum import Enum

from pyteal.types import TealType, require_type
from pyteal.errors import verifyFieldVersion, verifyProgramVersion
from pyteal.ir import TealOp, Op, TealBlock
from pyteal.ast.expr import Expr

if TYPE_CHECKING:
    from pyteal.compiler import CompileOptions


class JsonRefType(Enum):
    # fmt: off
    #              id |    name   |      type      | min version
    string = (0, "JSONString", TealType.bytes,  7)
    uint64 = (1, "JSONUint64", TealType.uint64, 7)
    object = (2, "JSONObject", TealType.bytes,  7)
    # fmt: on

    def __init__(self, id: int, name: str, type: TealType, min_version: int) -> None:
        self.id = id
        self.arg_name = name
        self.ret_type = type
        self.min_version = min_version

    def type_of(self) -> TealType:
        return self.ret_type


JsonRefType.__module__ = "pyteal"


class JsonRef(Expr):
    """An expression that accesses the value associated with a given key from a supported utf-8 encoded json object.

    The json object must satisfy a `particular specification <https://github.com/algorand/go-algorand/blob/master/data/transactions/logic/jsonspec.md>`_.
    """

    def __init__(self, type: JsonRefType, json_obj: Expr, key: Expr) -> None:
        super().__init__()

        self.type = type

        require_type(json_obj, TealType.bytes)
        self.json_obj = json_obj

        require_type(key, TealType.bytes)
        self.key = key

    def __teal__(self, options: "CompileOptions"):
        verifyProgramVersion(
            Op.json_ref.min_version,
            options.version,
            "Program version too low to use op json_ref",
        )

        verifyFieldVersion(self.type.arg_name, self.type.min_version, options.version)

        op = TealOp(self, Op.json_ref, self.type.arg_name)
        return TealBlock.FromOp(options, op, self.json_obj, self.key)

    def __str__(self):
        return "(JsonRef {} {} {})".format(self.type.arg_name, self.json_obj, self.key)

    def type_of(self):
        return self.type.type_of()

    def has_return(self):
        return False

    @classmethod
    def as_string(cls, json_obj: Expr, key: Expr) -> Expr:
        """Access the value of a given key as a string.

        Refer to the `JsonRef` class documentation for valid json specification.

        Args:
            json_obj: The utf-8 encoded json object.
            key: The key to access in the json object.
        """
        return cls(JsonRefType.string, json_obj, key)

    @classmethod
    def as_uint64(cls, json_obj: Expr, key: Expr) -> Expr:
        """Access the value of a given key as a uint64.

        Refer to the `JsonRef` class documentation for valid json specification.

        Args:
            json_obj: The utf-8 encoded json object.
            key: The key to access in the json object.
        """
        return cls(JsonRefType.uint64, json_obj, key)

    @classmethod
    def as_object(cls, json_obj: Expr, key: Expr) -> "JsonRef":
        """Access the value of a given key as a json object.

        Refer to the `JsonRef` class documentation for valid json specification.

        Args:
            json_obj: The utf-8 encoded json object.
            key: The key to access in the json object.
        """
        return cls(JsonRefType.object, json_obj, key)


JsonRef.__module__ = "pyteal"



================================================
FILE: pyteal/ast/jsonref_test.py
================================================
import pytest

import pyteal as pt

avm6Options = pt.CompileOptions(version=6)
avm7Options = pt.CompileOptions(version=7)


def test_json_string():
    args = [pt.Bytes('{"foo":"bar"}'), pt.Bytes("foo")]
    expr = pt.JsonRef.as_string(*args)
    assert expr.type_of() == pt.TealType.bytes

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(args[0], pt.Op.byte, '"{\\"foo\\":\\"bar\\"}"'),
            pt.TealOp(args[1], pt.Op.byte, '"foo"'),
            pt.TealOp(expr, pt.Op.json_ref, "JSONString"),
        ]
    )

    actual, _ = expr.__teal__(avm7Options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    assert actual == expected

    with pytest.raises(pt.TealInputError):
        expr.__teal__(avm6Options)


def test_json_uint64():
    args = [pt.Bytes('{"foo":123456789}'), pt.Bytes("foo")]
    expr = pt.JsonRef.as_uint64(*args)
    assert expr.type_of() == pt.TealType.uint64

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(args[0], pt.Op.byte, '"{\\"foo\\":123456789}"'),
            pt.TealOp(args[1], pt.Op.byte, '"foo"'),
            pt.TealOp(expr, pt.Op.json_ref, "JSONUint64"),
        ]
    )

    actual, _ = expr.__teal__(avm7Options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    assert actual == expected

    with pytest.raises(pt.TealInputError):
        expr.__teal__(avm6Options)


def test_json_object():
    args = [pt.Bytes('{"foo":{"key": "value"}}'), pt.Bytes("foo")]
    expr = pt.JsonRef.as_object(*args)
    assert expr.type_of() == pt.TealType.bytes

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(args[0], pt.Op.byte, '"{\\"foo\\":{\\"key\\": \\"value\\"}}"'),
            pt.TealOp(args[1], pt.Op.byte, '"foo"'),
            pt.TealOp(expr, pt.Op.json_ref, "JSONObject"),
        ]
    )

    actual, _ = expr.__teal__(avm7Options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    assert actual == expected

    with pytest.raises(pt.TealInputError):
        expr.__teal__(avm6Options)


def test_json_ref_invalid():
    with pytest.raises(pt.TealTypeError):
        pt.JsonRef.as_object(pt.Int(0), pt.Bytes("a"))

    with pytest.raises(pt.TealTypeError):
        pt.JsonRef.as_string(pt.Bytes("a"), pt.Int(0))



================================================
FILE: pyteal/ast/leafexpr.py
================================================
from pyteal.ast.expr import Expr


class LeafExpr(Expr):
    """Leaf expression base class."""

    def has_return(self):
        return False


LeafExpr.__module__ = "pyteal"



================================================
FILE: pyteal/ast/maybe.py
================================================
from typing import Callable, List, Union, TYPE_CHECKING

from pyteal.errors import verifyProgramVersion
from pyteal.types import TealType
from pyteal.ir import Op

from pyteal.ast.expr import Expr
from pyteal.ast.scratch import ScratchLoad, ScratchSlot
from pyteal.ast.multi import MultiValue

if TYPE_CHECKING:
    from pyteal.compiler import CompileOptions


class MaybeValue(MultiValue):
    """Represents a get operation returning a value that may not exist."""

    def __init__(
        self,
        op: Op,
        type: TealType,
        *,
        immediate_args: List[Union[int, str]] | None = None,
        args: List[Expr] | None = None,
        compile_check: Callable[["CompileOptions"], None] | None = None,
    ):
        """Create a new MaybeValue.

        Args:
            op: The operation that returns values.
            type: The type of the returned value.
            immediate_args (optional): Immediate arguments for the op. Defaults to None.
            args (optional): Stack arguments for the op. Defaults to None.
            compile_check (optional): Callable compile check. Defaults to program version check.
                This parameter overwrites the default program version check.
        """

        # Default compile check if one is not given
        def local_version_check(options: "CompileOptions"):
            verifyProgramVersion(
                minVersion=op.min_version,
                version=options.version,
                msg=f"{op.value} unavailable",
            )

        types = [type, TealType.uint64]
        super().__init__(
            op,
            types,
            immediate_args=immediate_args,
            args=args,
            compile_check=(
                local_version_check if compile_check is None else compile_check
            ),
            root_expr=self,
        )

    def hasValue(self) -> ScratchLoad:
        """Check if the value exists.

        This will return 1 if the value exists, otherwise 0.
        """
        return self.output_slots[1].load(self.types[1])

    def value(self) -> ScratchLoad:
        """Get the value.

        If the value exists, it will be returned. Otherwise, the zero value for this type will be
        returned (i.e. either 0 or an empty byte string, depending on the type).
        """
        return self.output_slots[0].load(self.types[0])

    @property
    def slotOk(self) -> ScratchSlot:
        """Get the scratch slot that stores hasValue.

        Note: This is mainly added for backwards compatibility and normally shouldn't be used
        directly in pyteal code.
        """
        return self.output_slots[1]

    @property
    def slotValue(self) -> ScratchSlot:
        """Get the scratch slot that stores the value or the zero value for the type if the value
        doesn't exist.

        Note: This is mainly added for backwards compatibility and normally shouldn't be used
        directly in pyteal code.
        """
        return self.output_slots[0]


MaybeValue.__module__ = "pyteal"



================================================
FILE: pyteal/ast/maybe_test.py
================================================
import pyteal as pt

options = pt.CompileOptions()


def assert_MaybeValue_equality(
    actual: pt.MaybeValue, expected: pt.MaybeValue, options: pt.CompileOptions
):
    actual_block, _ = actual.__teal__(options)
    actual_block.addIncoming()
    actual_block = pt.TealBlock.NormalizeBlocks(actual_block)

    expected_block, _ = expected.__teal__(options)
    expected_block.addIncoming()
    expected_block = pt.TealBlock.NormalizeBlocks(expected_block)

    with pt.TealComponent.Context.ignoreExprEquality(), pt.TealComponent.Context.ignoreScratchSlotEquality():
        assert actual_block == expected_block

    assert pt.TealBlock.MatchScratchSlotReferences(
        pt.TealBlock.GetReferencedScratchSlots(actual_block),
        pt.TealBlock.GetReferencedScratchSlots(expected_block),
    )


def test_maybe_value():
    ops = (
        pt.Op.app_global_get_ex,
        pt.Op.app_local_get_ex,
        pt.Op.asset_holding_get,
        pt.Op.asset_params_get,
    )
    types = (pt.TealType.uint64, pt.TealType.bytes, pt.TealType.anytype)
    immedate_argv = ([], ["AssetFrozen"])
    argv = ([], [pt.Int(0)], [pt.Int(1), pt.Int(2)])

    for op in ops:
        for type in types:
            for iargs in immedate_argv:
                for args in argv:
                    expr = pt.MaybeValue(op, type, immediate_args=iargs, args=args)

                    assert expr.slotOk != expr.slotValue
                    assert expr.output_slots == [expr.slotValue, expr.slotOk]

                    assert expr.hasValue().type_of() == pt.TealType.uint64
                    with pt.TealComponent.Context.ignoreExprEquality():
                        assert expr.hasValue().__teal__(options) == pt.ScratchLoad(
                            expr.slotOk
                        ).__teal__(options)

                    assert expr.value().type_of() == type
                    with pt.TealComponent.Context.ignoreExprEquality():
                        assert expr.value().__teal__(options) == pt.ScratchLoad(
                            expr.slotValue
                        ).__teal__(options)

                    assert expr.type_of() == pt.TealType.none

                    expected_call = pt.TealSimpleBlock(
                        [
                            pt.TealOp(expr, op, *iargs),
                            pt.TealOp(None, pt.Op.store, expr.slotOk),
                            pt.TealOp(None, pt.Op.store, expr.slotValue),
                        ]
                    )

                    if len(args) == 0:
                        expected = expected_call
                    elif len(args) == 1:
                        expected, after_arg = args[0].__teal__(options)
                        after_arg.setNextBlock(expected_call)
                    elif len(args) == 2:
                        expected, after_arg_1 = args[0].__teal__(options)
                        arg_2, after_arg_2 = args[1].__teal__(options)
                        after_arg_1.setNextBlock(arg_2)
                        after_arg_2.setNextBlock(expected_call)

                    expected.addIncoming()
                    expected = pt.TealBlock.NormalizeBlocks(expected)

                    actual, _ = expr.__teal__(options)
                    actual.addIncoming()
                    actual = pt.TealBlock.NormalizeBlocks(actual)

                    with pt.TealComponent.Context.ignoreExprEquality():
                        assert actual == expected



================================================
FILE: pyteal/ast/methodsig.py
================================================
from typing import TYPE_CHECKING

from pyteal.errors import TealInputError
from pyteal.types import TealType
from pyteal.ir import TealOp, Op, TealBlock

from pyteal.ast.leafexpr import LeafExpr

if TYPE_CHECKING:
    from pyteal.compiler import CompileOptions


class MethodSignature(LeafExpr):
    """An expression that represents an ABI method selector"""

    def __init__(self, methodName: str) -> None:
        """Create a new method selector for ABI method call.

        Args:
            methodName: A string containing a valid ABI method signature
        """
        super().__init__()
        if type(methodName) is not str:
            raise TealInputError(
                "invalid input type {} to Method".format(type(methodName))
            )
        elif len(methodName) == 0:
            raise TealInputError("invalid input empty string to Method")
        self.methodName = methodName

    def __teal__(self, options: "CompileOptions"):
        op = TealOp(self, Op.method_signature, '"{}"'.format(self.methodName))
        return TealBlock.FromOp(options, op)

    def __str__(self) -> str:
        return "(MethodSignature '{}')".format(self.methodName)

    def type_of(self) -> TealType:
        return TealType.bytes


MethodSignature.__module__ = "pyteal"



================================================
FILE: pyteal/ast/methodsig_test.py
================================================
import pytest

from pyteal.ast.methodsig import MethodSignature

import pyteal as pt


def test_method():
    expr = MethodSignature("add(uint64,uint64)uint64")
    assert expr.type_of() == pt.TealType.bytes

    expected = pt.TealSimpleBlock(
        [pt.TealOp(expr, pt.Op.method_signature, '"add(uint64,uint64)uint64"')]
    )
    actual, _ = expr.__teal__(pt.CompileOptions())
    assert expected == actual


def test_method_invalid():
    with pytest.raises(pt.TealInputError):
        MethodSignature(114514)

    with pytest.raises(pt.TealInputError):
        MethodSignature(['"m0()void"', '"m1()uint64"'])

    with pytest.raises(pt.TealInputError):
        MethodSignature("")



================================================
FILE: pyteal/ast/mimc.py
================================================
from typing import TYPE_CHECKING
from enum import Enum

from pyteal.types import TealType, require_type
from pyteal.errors import verifyFieldVersion, verifyProgramVersion
from pyteal.ir import TealOp, Op, TealBlock
from pyteal.ast.expr import Expr

if TYPE_CHECKING:
    from pyteal.compiler import CompileOptions


class MimcConfig(Enum):
    # fmt: off
    #           id  |   name   | min version
    bn254mp110 =  (0, "BN254Mp110",  11)  # noqa: E222
    bls12_381mp111 = (1, "BLS12_381Mp111", 11)  # noqa: E222
    # fmt: on

    def __init__(self, id: int, name: str, min_version: int) -> None:
        self.id = id
        self.arg_name = name
        self.min_version = min_version


MimcConfig.__module__ = "pyteal"


class MiMC(Expr):
    """An expression that computes the MiMC hash on a byte string message."""

    def __init__(self, config: MimcConfig, message: Expr) -> None:
        super().__init__()

        self.config = config

        require_type(message, TealType.bytes)
        self.message = message

    def __teal__(self, options: "CompileOptions"):
        verifyProgramVersion(
            Op.mimc.min_version,
            options.version,
            "Program version too low to use op mimc",
        )

        verifyFieldVersion(
            self.config.arg_name, self.config.min_version, options.version
        )

        op = TealOp(self, Op.mimc, self.config.arg_name)
        return TealBlock.FromOp(options, op, self.message)

    def __str__(self):
        return "(MiMC {})".format(self.config.arg_name)

    def type_of(self) -> TealType:
        return TealType.bytes

    def has_return(self):
        return False

    @classmethod
    def bn254mp110(cls, message: Expr) -> Expr:
        """Verifies the proof of a message against a public key using the Algorand VRF standard.

        Args:
            message: The message to hash.

        Returns:
            A 32-byte hash of message
        """
        return cls(MimcConfig.bn254mp110, message)

    @classmethod
    def bls12_381mp111(cls, message: Expr) -> Expr:
        """Verifies the proof of a message against a public key using the Chainlink VRF standard.

        Args:
            message: The message to hash.

        Returns:
            A 32-byte hash of message
        """
        return cls(MimcConfig.bls12_381mp111, message)


MiMC.__module__ = "pyteal"



================================================
FILE: pyteal/ast/mimc_test.py
================================================
import pytest

import pyteal as pt

avm10Options = pt.CompileOptions(version=10)
avm11Options = pt.CompileOptions(version=11)


def test_mimc_bn254():
    args = [pt.Bytes("a message in a bottle")]
    expr = pt.MiMC.bn254mp110(*args)
    assert expr.type_of() == pt.TealType.bytes

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(args[0], pt.Op.byte, '"a message in a bottle"'),
            pt.TealOp(expr, pt.Op.mimc, "BN254Mp110"),
        ]
    )

    actual, _ = expr.__teal__(avm11Options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    assert actual == expected

    with pytest.raises(pt.TealInputError):
        expr.__teal__(avm10Options)


def test_json_ref_invalid():
    with pytest.raises(pt.TealTypeError):
        pt.MiMC.bn254mp110(pt.Int(1))

    with pytest.raises(pt.TealTypeError):
        pt.MiMC.bls12_381mp111(pt.Int(2))



================================================
FILE: pyteal/ast/multi.py
================================================
from typing import Callable, List, Union, TYPE_CHECKING, cast

from pyteal.types import TealType
from pyteal.ir import TealOp, Op, TealBlock
from pyteal.ast.expr import Expr
from pyteal.ast.leafexpr import LeafExpr
from pyteal.ast.scratch import ScratchSlot
from pyteal.ast.seq import Seq
from pyteal.ast.scratch import ScratchStackStore

if TYPE_CHECKING:
    from pyteal.compiler import CompileOptions


class MultiValue(LeafExpr):
    """Represents an operation that returns more than one value"""

    def __init__(
        self,
        op: Op,
        types: List[TealType],
        *,
        immediate_args: List[Union[int, str]] | None = None,
        args: List[Expr] | None = None,
        compile_check: Callable[["CompileOptions"], None] = lambda _: None,
        root_expr: Expr | None = None,
    ):
        """Create a new MultiValue.

        Args:
            op: The operation that returns values.
            types: The types of the returned values.
            immediate_args (optional): Immediate arguments for the op. Defaults to None.
            args (optional): Stack arguments for the op. Defaults to None.
        """
        super().__init__()
        self.op = op
        self.types = types
        self.immediate_args = immediate_args if immediate_args is not None else []
        self.args = args if args is not None else []
        self.compile_check = compile_check

        self.output_slots = [ScratchSlot() for _ in self.types]
        self._sframes_container = root_expr

    def outputReducer(self, reducer: Callable[..., Expr]) -> Expr:
        input = [slot.load(self.types[i]) for i, slot in enumerate(self.output_slots)]
        return Seq(self, reducer(*input))

    def __str__(self):
        ret_str = "(({}".format(self.op)
        for a in self.immediate_args:
            ret_str += " " + a.__str__()

        for a in self.args:
            ret_str += " " + a.__str__()
        ret_str += ") "

        ret_str += " ".join([slot.store().__str__() for slot in self.output_slots])
        ret_str += ")"

        return ret_str

    def __teal__(self, options: "CompileOptions"):
        self.compile_check(options)

        tealOp = TealOp(self, self.op, *self.immediate_args)
        callStart, callEnd = TealBlock.FromOp(options, tealOp, *self.args)

        curEnd = callEnd
        # the list is reversed in order to preserve the ordering of the opcode's returned
        # values. ie the output to stack [A, B, C] should correspond to C->output_slots[2]
        # B->output_slots[1], and A->output_slots[0].
        for slot in reversed(self.output_slots):
            store = cast(ScratchStackStore, slot.store())
            store._sframes_container = self._sframes_container
            storeStart, storeEnd = store.__teal__(options)
            curEnd.setNextBlock(storeStart)
            curEnd = storeEnd

        return callStart, curEnd

    def type_of(self):
        return TealType.none


MultiValue.__module__ = "pyteal"



================================================
FILE: pyteal/ast/multi_test.py
================================================
import pytest
from typing import List

import pyteal as pt

options = pt.CompileOptions()


def __test_single(expr: pt.MultiValue):
    assert expr.output_slots[0] != expr.output_slots[1]

    with pt.TealComponent.Context.ignoreExprEquality():
        assert expr.output_slots[0].load().__teal__(options) == pt.ScratchLoad(
            expr.output_slots[0]
        ).__teal__(options)

    with pt.TealComponent.Context.ignoreExprEquality():
        assert expr.output_slots[1].load().__teal__(options) == pt.ScratchLoad(
            expr.output_slots[1]
        ).__teal__(options)

    assert expr.type_of() == pt.TealType.none


def __test_single_conditional(
    expr: pt.MultiValue, op, args: List[pt.Expr], iargs, reducer
):
    __test_single(expr)

    expected_call = pt.TealSimpleBlock(
        [
            pt.TealOp(expr, op, *iargs),
            pt.TealOp(expr.output_slots[1].store(), pt.Op.store, expr.output_slots[1]),
            pt.TealOp(expr.output_slots[0].store(), pt.Op.store, expr.output_slots[0]),
        ]
    )

    ifExpr = (
        pt.If(expr.output_slots[1].load())
        .Then(expr.output_slots[0].load())
        .Else(pt.App.globalGet(pt.Bytes("None")))
    )
    ifBlockStart, _ = ifExpr.__teal__(options)

    expected_call.setNextBlock(ifBlockStart)

    if len(args) == 0:
        expected: pt.TealBlock = expected_call
    elif len(args) == 1:
        expected, after_arg = args[0].__teal__(options)
        after_arg.setNextBlock(expected_call)
    elif len(args) == 2:
        expected, after_arg_1 = args[0].__teal__(options)
        arg_2, after_arg_2 = args[1].__teal__(options)
        after_arg_1.setNextBlock(arg_2)
        after_arg_2.setNextBlock(expected_call)

    expected.addIncoming()
    expected = pt.TealBlock.NormalizeBlocks(expected)

    actual, _ = expr.outputReducer(reducer).__teal__(options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    with pt.TealComponent.Context.ignoreExprEquality():
        assert actual == expected


def __test_single_assert(expr: pt.MultiValue, op, args: List[pt.Expr], iargs, reducer):
    __test_single(expr)

    expected_call = pt.TealSimpleBlock(
        [
            pt.TealOp(expr, op, *iargs),
            pt.TealOp(expr.output_slots[1].store(), pt.Op.store, expr.output_slots[1]),
            pt.TealOp(expr.output_slots[0].store(), pt.Op.store, expr.output_slots[0]),
        ]
    )

    assertExpr = pt.Seq(
        pt.Assert(expr.output_slots[1].load()), expr.output_slots[0].load()
    )
    assertBlockStart, _ = assertExpr.__teal__(options)

    expected_call.setNextBlock(assertBlockStart)

    if len(args) == 0:
        expected: pt.TealBlock = expected_call
    elif len(args) == 1:
        expected, after_arg = args[0].__teal__(options)
        after_arg.setNextBlock(expected_call)
    elif len(args) == 2:
        expected, after_arg_1 = args[0].__teal__(options)
        arg_2, after_arg_2 = args[1].__teal__(options)
        after_arg_1.setNextBlock(arg_2)
        after_arg_2.setNextBlock(expected_call)

    expected.addIncoming()
    expected = pt.TealBlock.NormalizeBlocks(expected)

    actual, _ = expr.outputReducer(reducer).__teal__(options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    with pt.TealComponent.Context.ignoreExprEquality():
        assert actual == expected


def __test_single_with_vars(
    expr: pt.MultiValue, op, args: List[pt.Expr], iargs, var1, var2, reducer
):
    __test_single(expr)

    expected_call = pt.TealSimpleBlock(
        [
            pt.TealOp(expr, op, *iargs),
            pt.TealOp(expr.output_slots[1].store(), pt.Op.store, expr.output_slots[1]),
            pt.TealOp(expr.output_slots[0].store(), pt.Op.store, expr.output_slots[0]),
        ]
    )

    varExpr = pt.Seq(
        var1.store(expr.output_slots[1].load()), var2.store(expr.output_slots[0].load())
    )
    varBlockStart, _ = varExpr.__teal__(options)

    expected_call.setNextBlock(varBlockStart)

    if len(args) == 0:
        expected: pt.TealBlock = expected_call
    elif len(args) == 1:
        expected, after_arg = args[0].__teal__(options)
        after_arg.setNextBlock(expected_call)
    elif len(args) == 2:
        expected, after_arg_1 = args[0].__teal__(options)
        arg_2, after_arg_2 = args[1].__teal__(options)
        after_arg_1.setNextBlock(arg_2)
        after_arg_2.setNextBlock(expected_call)

    expected.addIncoming()
    expected = pt.TealBlock.NormalizeBlocks(expected)

    actual, _ = expr.outputReducer(reducer).__teal__(options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    with pt.TealComponent.Context.ignoreExprEquality():
        assert actual == expected


@pytest.mark.parametrize(
    "op",
    [
        pt.Op.app_global_get_ex,
        pt.Op.app_local_get_ex,
        pt.Op.asset_holding_get,
        pt.Op.asset_params_get,
    ],
)
@pytest.mark.parametrize(
    "type", [pt.TealType.uint64, pt.TealType.bytes, pt.TealType.anytype]
)
@pytest.mark.parametrize("iargs", [[], ["AssetFrozen"]])
@pytest.mark.parametrize("args", [[], [pt.Int(0)], [pt.Int(1), pt.Int(2)]])
def test_multi_value(op, type, iargs, args):
    reducer = (
        lambda value, hasValue: pt.If(hasValue)
        .Then(value)
        .Else(pt.App.globalGet(pt.Bytes("None")))
    )
    expr = pt.MultiValue(
        op, [type, pt.TealType.uint64], immediate_args=iargs, args=args
    )
    __test_single_conditional(expr, op, args, iargs, reducer)

    reducer = lambda value, hasValue: pt.Seq(pt.Assert(hasValue), value)  # noqa: E731
    expr = pt.MultiValue(
        op, [type, pt.TealType.uint64], immediate_args=iargs, args=args
    )
    __test_single_assert(expr, op, args, iargs, reducer)

    hasValueVar = pt.ScratchVar(pt.TealType.uint64)
    valueVar = pt.ScratchVar(type)
    reducer = lambda value, hasValue: pt.Seq(  # noqa: E731
        hasValueVar.store(hasValue), valueVar.store(value)
    )
    expr = pt.MultiValue(
        op, [type, pt.TealType.uint64], immediate_args=iargs, args=args
    )
    __test_single_with_vars(expr, op, args, iargs, hasValueVar, valueVar, reducer)


def test_multi_compile_check():
    def never_fails(options):
        return

    program_never_fails = pt.MultiValue(
        pt.Op.app_global_get_ex,
        [pt.TealType.uint64, pt.TealType.uint64],
        compile_check=never_fails,
    )
    program_never_fails.__teal__(options)

    class TestException(Exception):
        pass

    def always_fails(options):
        raise TestException()

    program_always_fails = pt.MultiValue(
        pt.Op.app_global_get_ex,
        [pt.TealType.uint64, pt.TealType.uint64],
        compile_check=always_fails,
    )

    with pytest.raises(TestException):
        program_always_fails.__teal__(options)



================================================
FILE: pyteal/ast/naryexpr.py
================================================
from typing import Sequence, cast, TYPE_CHECKING

from pyteal.types import TealType, require_type
from pyteal.errors import TealInputError
from pyteal.ir import TealOp, Op, TealSimpleBlock
from pyteal.ast.expr import Expr

if TYPE_CHECKING:
    from pyteal.compiler import CompileOptions


class NaryExpr(Expr):
    """N-ary expression base class.

    This type of expression takes an arbitrary number of arguments.
    """

    def __init__(
        self, op: Op, inputType: TealType, outputType: TealType, args: Sequence[Expr]
    ):
        super().__init__()
        if len(args) == 0:
            raise TealInputError("NaryExpr requires at least one child")
        for arg in args:
            if not isinstance(arg, Expr):
                raise TealInputError(
                    "Argument is not a PyTeal expression: {}".format(arg)
                )
            require_type(arg, inputType)
        self.op = op
        self.outputType = outputType
        self.args = args

    def __teal__(self, options: "CompileOptions"):
        start = None
        end = None
        for i, arg in enumerate(self.args):
            argStart, argEnd = arg.__teal__(options)
            if i == 0:
                start = argStart
                end = argEnd
            else:
                cast(TealSimpleBlock, end).setNextBlock(argStart)
                opBlock = TealSimpleBlock([TealOp(self, self.op)])
                argEnd.setNextBlock(opBlock)
                end = opBlock

        return start, end

    def __str__(self):
        ret_str = "(" + str(self.op).title().replace("_", "")
        for a in self.args:
            ret_str += " " + a.__str__()
        ret_str += ")"
        return ret_str

    def type_of(self):
        return self.outputType

    def has_return(self):
        return False


NaryExpr.__module__ = "pyteal"


def Add(*args: Expr) -> Expr:
    """Numerical addition.

    Produces the sum of all the input arguments.

    All arguments must be PyTeal expressions that evaluate to uint64, and there must be at least one
    argument.

    Example:
        ``Add(Int(1), Int(2), Int(3))``
    """
    return NaryExpr(Op.add, TealType.uint64, TealType.uint64, args)


def Mul(*args: Expr) -> Expr:
    """Numerical multiplication.

    Produces the product of all the input arguments.

    All arguments must be PyTeal expressions that evaluate to uint64, and there must be at least one
    argument.

    Example:
        ``Mul(Int(2), Int(3), Int(4))``
    """
    return NaryExpr(Op.mul, TealType.uint64, TealType.uint64, args)


def And(*args: Expr) -> Expr:
    """Logical and expression.

    Produces 1 if all arguments are nonzero. Otherwise produces 0.

    All arguments must be PyTeal expressions that evaluate to uint64, and there must be at least one
    argument.

    Example:
        ``And(Txn.amount() == Int(500), Txn.fee() <= Int(10))``
    """
    return NaryExpr(Op.logic_and, TealType.uint64, TealType.uint64, args)


def Or(*args: Expr) -> Expr:
    """Logical or expression.

    Produces 1 if any argument is nonzero. Otherwise produces 0.

    All arguments must be PyTeal expressions that evaluate to uint64, and there must be at least one
    argument.
    """
    return NaryExpr(Op.logic_or, TealType.uint64, TealType.uint64, args)


def Concat(*args: Expr) -> Expr:
    """Concatenate byte strings.

    Produces a new byte string consisting of the contents of each of the passed in byte strings
    joined together.

    All arguments must be PyTeal expressions that evaluate to bytes, and there must be at least one
    argument.

    Example:
        ``Concat(Bytes("hello"), Bytes(" "), Bytes("world"))``
    """
    return NaryExpr(Op.concat, TealType.bytes, TealType.bytes, args)



================================================
FILE: pyteal/ast/naryexpr_test.py
================================================
import pytest

import pyteal as pt

options = pt.CompileOptions()


def test_and_one():
    arg = pt.Int(1)
    expr = pt.And(arg)
    assert expr.type_of() == pt.TealType.uint64

    expected = pt.TealSimpleBlock([pt.TealOp(arg, pt.Op.int, 1)])

    actual, _ = expr.__teal__(options)

    assert actual == expected


def test_and_two():
    args = [pt.Int(1), pt.Int(2)]
    expr = pt.And(args[0], args[1])
    assert expr.type_of() == pt.TealType.uint64

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(args[0], pt.Op.int, 1),
            pt.TealOp(args[1], pt.Op.int, 2),
            pt.TealOp(expr, pt.Op.logic_and),
        ]
    )

    actual, _ = expr.__teal__(options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    assert actual == expected


def test_and_three():
    args = [pt.Int(1), pt.Int(2), pt.Int(3)]
    expr = pt.And(args[0], args[1], args[2])
    assert expr.type_of() == pt.TealType.uint64

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(args[0], pt.Op.int, 1),
            pt.TealOp(args[1], pt.Op.int, 2),
            pt.TealOp(expr, pt.Op.logic_and),
            pt.TealOp(args[2], pt.Op.int, 3),
            pt.TealOp(expr, pt.Op.logic_and),
        ]
    )

    actual, _ = expr.__teal__(options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    assert actual == expected


def test_and_overload():
    args = [pt.Int(1), pt.Int(2)]
    expr = args[0].And(args[1])
    assert expr.type_of() == pt.TealType.uint64

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(args[0], pt.Op.int, 1),
            pt.TealOp(args[1], pt.Op.int, 2),
            pt.TealOp(expr, pt.Op.logic_and),
        ]
    )

    actual, _ = expr.__teal__(options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    assert actual == expected


def test_and_invalid():
    with pytest.raises(pt.TealInputError):
        pt.And()

    with pytest.raises(pt.TealTypeError):
        pt.And(pt.Int(1), pt.Txn.receiver())

    with pytest.raises(pt.TealTypeError):
        pt.And(pt.Txn.receiver(), pt.Int(1))

    with pytest.raises(pt.TealTypeError):
        pt.And(pt.Txn.receiver(), pt.Txn.receiver())


def test_or_one():
    arg = pt.Int(1)
    expr = pt.Or(arg)
    assert expr.type_of() == pt.TealType.uint64

    expected = pt.TealSimpleBlock([pt.TealOp(arg, pt.Op.int, 1)])

    actual, _ = expr.__teal__(options)

    assert actual == expected


def test_or_two():
    args = [pt.Int(1), pt.Int(0)]
    expr = pt.Or(args[0], args[1])
    assert expr.type_of() == pt.TealType.uint64

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(args[0], pt.Op.int, 1),
            pt.TealOp(args[1], pt.Op.int, 0),
            pt.TealOp(expr, pt.Op.logic_or),
        ]
    )

    actual, _ = expr.__teal__(options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    assert actual == expected


def test_or_three():
    args = [pt.Int(0), pt.Int(1), pt.Int(2)]
    expr = pt.Or(args[0], args[1], args[2])
    assert expr.type_of() == pt.TealType.uint64

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(args[0], pt.Op.int, 0),
            pt.TealOp(args[1], pt.Op.int, 1),
            pt.TealOp(expr, pt.Op.logic_or),
            pt.TealOp(args[2], pt.Op.int, 2),
            pt.TealOp(expr, pt.Op.logic_or),
        ]
    )

    actual, _ = expr.__teal__(options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    assert actual == expected


def test_or_overload():
    args = [pt.Int(1), pt.Int(0)]
    expr = args[0].Or(args[1])
    assert expr.type_of() == pt.TealType.uint64

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(args[0], pt.Op.int, 1),
            pt.TealOp(args[1], pt.Op.int, 0),
            pt.TealOp(expr, pt.Op.logic_or),
        ]
    )

    actual, _ = expr.__teal__(options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    assert actual == expected


def test_or_invalid():
    with pytest.raises(pt.TealInputError):
        pt.Or()

    with pytest.raises(pt.TealTypeError):
        pt.Or(pt.Int(1), pt.Txn.receiver())

    with pytest.raises(pt.TealTypeError):
        pt.Or(pt.Txn.receiver(), pt.Int(1))

    with pytest.raises(pt.TealTypeError):
        pt.Or(pt.Txn.receiver(), pt.Txn.receiver())


def test_concat_one():
    arg = pt.Bytes("a")
    expr = pt.Concat(arg)
    assert expr.type_of() == pt.TealType.bytes

    expected = pt.TealSimpleBlock([pt.TealOp(arg, pt.Op.byte, '"a"')])

    actual, _ = expr.__teal__(options)

    assert actual == expected


def test_concat_two():
    args = [pt.Bytes("a"), pt.Bytes("b")]
    expr = pt.Concat(args[0], args[1])
    assert expr.type_of() == pt.TealType.bytes

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(args[0], pt.Op.byte, '"a"'),
            pt.TealOp(args[1], pt.Op.byte, '"b"'),
            pt.TealOp(expr, pt.Op.concat),
        ]
    )

    actual, _ = expr.__teal__(options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    assert actual == expected


def test_concat_three():
    args = [pt.Bytes("a"), pt.Bytes("b"), pt.Bytes("c")]
    expr = pt.Concat(args[0], args[1], args[2])
    assert expr.type_of() == pt.TealType.bytes

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(args[0], pt.Op.byte, '"a"'),
            pt.TealOp(args[1], pt.Op.byte, '"b"'),
            pt.TealOp(expr, pt.Op.concat),
            pt.TealOp(args[2], pt.Op.byte, '"c"'),
            pt.TealOp(expr, pt.Op.concat),
        ]
    )

    actual, _ = expr.__teal__(options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    assert actual == expected


def test_concat_invalid():
    with pytest.raises(pt.TealInputError):
        pt.Concat()

    with pytest.raises(pt.TealTypeError):
        pt.Concat(pt.Int(1), pt.Txn.receiver())

    with pytest.raises(pt.TealTypeError):
        pt.Concat(pt.Txn.receiver(), pt.Int(1))

    with pytest.raises(pt.TealTypeError):
        pt.Concat(pt.Int(1), pt.Int(2))



================================================
FILE: pyteal/ast/nonce.py
================================================
from typing import TYPE_CHECKING

from pyteal.errors import TealInputError
from pyteal.ast.expr import Expr
from pyteal.ast.seq import Seq
from pyteal.ast.bytes import Bytes
from pyteal.ast.unaryexpr import Pop

if TYPE_CHECKING:
    from pyteal.compiler import CompileOptions


class Nonce(Expr):
    """A meta expression only used to change the hash of a TEAL program."""

    def __init__(self, base: str, nonce: str, child: Expr) -> None:
        """Create a new Nonce.

        The Nonce expression behaves exactly like the child expression passed into it, except it
        uses the provided nonce string to alter its structure in a way that does not affect
        execution.

        Args:
            base: The base of the nonce. Must be one of utf8, base16, base32, or base64.
            nonce: An arbitrary nonce string that conforms to base.
            child: The expression to wrap.
        """
        super().__init__()

        if base not in ("utf8", "base16", "base32", "base64"):
            raise TealInputError("Invalid base: {}".format(base))

        self.child = child
        if base == "utf8":
            self.nonce_bytes = Bytes(nonce)
        else:
            self.nonce_bytes = Bytes(base, nonce)

        self.seq = Seq([Pop(self.nonce_bytes), self.child])

    def __teal__(self, options: "CompileOptions"):
        return self.seq.__teal__(options)

    def __str__(self):
        return "(nonce: {}) {}".format(self.nonce_bytes, self.child)

    def type_of(self):
        return self.child.type_of()

    def has_return(self):
        return self.child.has_return()


Nonce.__module__ = "pyteal"



================================================
FILE: pyteal/ast/nonce_test.py
================================================
import pytest

import pyteal as pt

options = pt.CompileOptions()


def test_nonce_has_return():
    exprWithReturn = pt.Nonce(
        "base32",
        "7Z5PWO2C6LFNQFGHWKSK5H47IQP5OJW2M3HA2QPXTY3WTNP5NU2MHBW27M",
        pt.Return(pt.Int(1)),
    )
    assert exprWithReturn.has_return()

    exprWithoutReturn = pt.Nonce(
        "base32",
        "7Z5PWO2C6LFNQFGHWKSK5H47IQP5OJW2M3HA2QPXTY3WTNP5NU2MHBW27M",
        pt.Int(1),
    )
    assert not exprWithoutReturn.has_return()


def test_nonce_base32():
    arg = pt.Int(1)
    expr = pt.Nonce(
        "base32", "7Z5PWO2C6LFNQFGHWKSK5H47IQP5OJW2M3HA2QPXTY3WTNP5NU2MHBW27M", arg
    )
    assert expr.type_of() == pt.TealType.uint64

    actual, _ = expr.__teal__(options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    # copying expr from actual.ops[0] and actual.ops[1] because they can't be determined from outside code.
    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(
                actual.ops[0].expr,
                pt.Op.byte,
                "base32(7Z5PWO2C6LFNQFGHWKSK5H47IQP5OJW2M3HA2QPXTY3WTNP5NU2MHBW27M)",
            ),
            pt.TealOp(actual.ops[1].expr, pt.Op.pop),
            pt.TealOp(arg, pt.Op.int, 1),
        ]
    )

    assert actual == expected


def test_nonce_base32_empty():
    arg = pt.Int(1)
    expr = pt.Nonce("base32", "", arg)
    assert expr.type_of() == pt.TealType.uint64

    actual, _ = expr.__teal__(options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    # copying expr from actual.ops[0] and actual.ops[1] because they can't be determined from outside code.
    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(actual.ops[0].expr, pt.Op.byte, "base32()"),
            pt.TealOp(actual.ops[1].expr, pt.Op.pop),
            pt.TealOp(arg, pt.Op.int, 1),
        ]
    )

    assert actual == expected


def test_nonce_base64():
    arg = pt.Txn.sender()
    expr = pt.Nonce("base64", "Zm9vYmE=", arg)
    assert expr.type_of() == pt.TealType.bytes

    actual, _ = expr.__teal__(options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    # copying expr from actual.ops[0] and actual.ops[1] because they can't be determined from outside code.
    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(actual.ops[0].expr, pt.Op.byte, "base64(Zm9vYmE=)"),
            pt.TealOp(actual.ops[1].expr, pt.Op.pop),
            pt.TealOp(arg, pt.Op.txn, "Sender"),
        ]
    )

    assert actual == expected


def test_nonce_base64_empty():
    arg = pt.Int(1)
    expr = pt.Nonce("base64", "", arg)
    assert expr.type_of() == pt.TealType.uint64

    actual, _ = expr.__teal__(options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    # copying expr from actual.ops[0] and actual.ops[1] because they can't be determined from outside code.
    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(actual.ops[0].expr, pt.Op.byte, "base64()"),
            pt.TealOp(actual.ops[1].expr, pt.Op.pop),
            pt.TealOp(arg, pt.Op.int, 1),
        ]
    )

    assert actual == expected


def test_nonce_base16():
    arg = pt.Int(1)
    expr = pt.Nonce("base16", "A21212EF", arg)
    assert expr.type_of() == pt.TealType.uint64

    actual, _ = expr.__teal__(options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    # copying expr from actual.ops[0] and actual.ops[1] because they can't be determined from outside code.
    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(actual.ops[0].expr, pt.Op.byte, "0xA21212EF"),
            pt.TealOp(actual.ops[1].expr, pt.Op.pop),
            pt.TealOp(arg, pt.Op.int, 1),
        ]
    )

    assert actual == expected


def test_nonce_base16_prefix():
    arg = pt.Int(1)
    expr = pt.Nonce("base16", "0xA21212EF", arg)
    assert expr.type_of() == pt.TealType.uint64

    actual, _ = expr.__teal__(options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    # copying expr from actual.ops[0] and actual.ops[1] because they can't be determined from outside code.
    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(actual.ops[0].expr, pt.Op.byte, "0xA21212EF"),
            pt.TealOp(actual.ops[1].expr, pt.Op.pop),
            pt.TealOp(arg, pt.Op.int, 1),
        ]
    )

    assert actual == expected


def test_nonce_base16_empty():
    arg = pt.Int(6)
    expr = pt.Nonce("base16", "", arg)
    assert expr.type_of() == pt.TealType.uint64

    actual, _ = expr.__teal__(options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    # copying expr from actual.ops[0] and actual.ops[1] because they can't be determined from outside code.
    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(actual.ops[0].expr, pt.Op.byte, "0x"),
            pt.TealOp(actual.ops[1].expr, pt.Op.pop),
            pt.TealOp(arg, pt.Op.int, 6),
        ]
    )

    assert actual == expected


def test_nonce_invalid():
    with pytest.raises(pt.TealInputError):
        pt.Nonce("base23", "", pt.Int(1))

    with pytest.raises(pt.TealInputError):
        pt.Nonce("base32", "Zm9vYmE=", pt.Int(1))

    with pytest.raises(pt.TealInputError):
        pt.Nonce("base64", "?????", pt.Int(1))

    with pytest.raises(pt.TealInputError):
        pt.Nonce(
            "base16",
            "7Z5PWO2C6LFNQFGHWKSK5H47IQP5OJW2M3HA2QPXTY3WTNP5NU2MHBW27M",
            pt.Int(1),
        )



================================================
FILE: pyteal/ast/opup.py
================================================
from typing import Optional, cast
from pyteal.ast.app import OnComplete
from pyteal.errors import TealInputError, TealTypeError
from pyteal.ast.while_ import While
from pyteal.ast.expr import Expr
from pyteal.ast.global_ import Global
from pyteal.ast.seq import Seq
from pyteal.ast.int import Int
from pyteal.ast.bytes import Bytes
from pyteal.ast.itxn import InnerTxnBuilder
from pyteal.ast.scratchvar import ScratchVar
from pyteal.ast.txn import TxnField, TxnType
from pyteal.ast.for_ import For
from pyteal.types import TealType, require_type
from enum import Enum

ON_CALL_APP = Bytes("base16", "068101")  # v6 program "int 1"


class OpUpMode(Enum):
    """An Enum object that defines the mode used for the OpUp utility.

    Note: the Explicit mode requires the app id to be provided
    through the foreign apps array in order for it to be accessible
    during evaluation.
    """

    #: The app to call must be provided by the user.
    Explicit = 0

    #: The app to call is created then deleted for each request to increase budget.
    OnCall = 1


class OpUpFeeSource(Enum):
    """An Enum object that defines the source for fees for the OpUp utility."""

    #: Only the excess fee (credit) on the outer group should be used (set inner_tx.fee=0)
    GroupCredit = 0
    #: The app's account will cover all fees (set inner_tx.fee=Global.min_tx_fee())
    AppAccount = 1
    #: First the excess will be used, remaining fees will be taken from the app account
    Any = 2


def _fee_by_source(source: OpUpFeeSource) -> Optional[Expr]:
    match source:
        case OpUpFeeSource.GroupCredit:
            return Int(0)
        case OpUpFeeSource.AppAccount:
            return Global.min_txn_fee()
        case _:
            return None


class OpUp:
    """Utility for increasing opcode budget during app execution.

    Requires program version 6 or higher.

    Example:
        .. code-block:: python

            # OnCall mode: doesn't accept target_app_id as an argument
            opup = OpUp(OpUpMode.OnCall)
            program_with_opup = Seq(
                ...,
                opup.ensure_budget(Int(1000)),
                ...,
            )

            # Explicit mode: requires target_app_id as an argument
            opup = OpUp(OpUpMode.Explicit, Int(1))
            program_with_opup = Seq(
                ...,
                opup.ensure_budget(Int(1000)),
                ...,
            )
    """

    def __init__(self, mode: OpUpMode, target_app_id: Expr | None = None):
        """Create a new OpUp object.

        Args:
            mode: OpUpMode that determines the style of budget increase
                to use. See the OpUpMode Enum for more information.
            target_app_id (optional): In Explicit mode, the OpUp utility
                requires the app_id to target for inner app calls. Defaults
                to None.
        """

        # With only OnCall and Explicit modes supported, the mode argument
        # isn't strictly necessary, but it will most likely be required if
        # we do decide to add more modes in the future.
        if mode == OpUpMode.Explicit:
            if target_app_id is None:
                raise TealInputError(
                    "target_app_id must be specified in Explicit OpUp mode"
                )
            require_type(target_app_id, TealType.uint64)
        elif mode == OpUpMode.OnCall:
            if target_app_id is not None:
                raise TealInputError("target_app_id is not used in OnCall OpUp mode")
        else:
            raise TealInputError("Invalid OpUp mode provided")

        self.mode = mode
        self.target_app_id = target_app_id

    def _construct_itxn(self, inner_fee: Optional[Expr]) -> Expr:
        fields: dict[TxnField, Expr | list[Expr]] = {
            TxnField.type_enum: TxnType.ApplicationCall
        }

        # If an inner_fee is specified
        # add it to the transaction fields
        if inner_fee is not None:
            require_type(inner_fee, TealType.uint64)
            fields[TxnField.fee] = inner_fee

        if self.mode == OpUpMode.Explicit:
            fields |= {TxnField.application_id: cast(Expr, self.target_app_id)}
        else:
            fields |= {
                TxnField.on_completion: OnComplete.DeleteApplication,
                TxnField.approval_program: ON_CALL_APP,
                TxnField.clear_state_program: ON_CALL_APP,
            }

        return InnerTxnBuilder.Execute(fields)

    def ensure_budget(
        self, required_budget: Expr, fee_source: OpUpFeeSource = OpUpFeeSource.Any
    ) -> Expr:
        """Ensure that the budget will be at least the required_budget.

        Args:
            required_budget: minimum op-code budget to ensure for the
                upcoming execution.
            fee_source (optional): source that should be used for covering fees on
                the inner transactions that are generated.

        Note: the available budget just prior to calling ensure_budget() must be
        high enough to execute the budget increase code. The exact budget required
        depends on the provided required_budget expression, but a budget of ~20
        should be sufficient for most use cases. If lack of budget is an issue then
        consider moving the call to ensure_budget() earlier in the pyteal program."""
        require_type(required_budget, TealType.uint64)
        if type(fee_source) is not OpUpFeeSource:
            raise TealTypeError(type(fee_source), OpUpFeeSource)

        # A budget buffer is necessary to deal with an edge case of ensure_budget():
        #   if the current budget is equal to or only slightly higher than the
        #   required budget then it's possible for ensure_budget() to return with a
        #   current budget less than the required budget. The buffer prevents this
        #   from being the case.
        buffer = Int(10)
        buffered_budget = ScratchVar(TealType.uint64)
        return Seq(
            buffered_budget.store(required_budget + buffer),
            While(buffered_budget.load() > Global.opcode_budget()).Do(
                self._construct_itxn(inner_fee=_fee_by_source(fee_source))
            ),
        )

    def maximize_budget(
        self, fee: Expr, fee_source: OpUpFeeSource = OpUpFeeSource.Any
    ) -> Expr:
        """Maximize the available opcode budget without spending more than the given fee.

        Args:
            fee: fee expenditure cap for the op-code budget maximization.
            fee_source (optional): source that should be used for covering fees on
                the inner transactions that are generated.

        Note: the available budget just prior to calling maximize_budget() must be
        high enough to execute the budget increase code. The exact budget required
        depends on the provided fee expression, but a budget of ~25 should be
        sufficient for most use cases. If lack of budget is an issue then consider
        moving the call to maximize_budget() earlier in the pyteal program."""
        require_type(fee, TealType.uint64)
        if type(fee_source) is not OpUpFeeSource:
            raise TealTypeError(type(fee_source), OpUpFeeSource)

        i = ScratchVar(TealType.uint64)
        n = fee / Global.min_txn_fee()
        return For(i.store(Int(0)), i.load() < n, i.store(i.load() + Int(1))).Do(
            self._construct_itxn(inner_fee=_fee_by_source(fee_source))
        )


OpUp.__module__ = "pyteal"



================================================
FILE: pyteal/ast/opup_test.py
================================================
import pytest
from typing import NamedTuple

import pyteal as pt

avm6Options = pt.CompileOptions(version=6)


def test_OpUp_init():
    app_id = pt.Int(1)
    opup_explicit = pt.OpUp(pt.OpUpMode.Explicit, target_app_id=app_id)
    assert opup_explicit.mode is pt.OpUpMode.Explicit
    assert opup_explicit.target_app_id is app_id

    with pytest.raises(
        pt.TealInputError, match="target_app_id must be specified in Explicit OpUp mode"
    ):
        pt.OpUp(pt.OpUpMode.Explicit)

    with pytest.raises(pt.TealTypeError):
        pt.OpUp(pt.OpUpMode.Explicit, target_app_id=pt.Bytes("appid"))

    opup_oncall = pt.OpUp(pt.OpUpMode.OnCall)
    assert opup_oncall.mode is pt.OpUpMode.OnCall
    assert opup_oncall.target_app_id is None

    with pytest.raises(
        pt.TealInputError, match="target_app_id is not used in OnCall OpUp mode"
    ):
        pt.OpUp(pt.OpUpMode.OnCall, target_app_id=app_id)

    with pytest.raises(pt.TealInputError, match="Invalid OpUp mode provided"):
        pt.OpUp(None)


class OpUpTest(NamedTuple):
    opup: pt.OpUp
    fee_source: pt.OpUpFeeSource | None
    expected_inner_fields: dict[pt.TxnField, pt.Expr | list[pt.Expr]]


OP_UP_TEST_CASES: list[OpUpTest] = [
    OpUpTest(
        opup=pt.OpUp(pt.OpUpMode.Explicit, target_app_id=pt.Int(9)),
        fee_source=None,
        expected_inner_fields={
            pt.TxnField.type_enum: pt.TxnType.ApplicationCall,
            pt.TxnField.application_id: pt.Int(9),
        },
    ),
    OpUpTest(
        opup=pt.OpUp(pt.OpUpMode.Explicit, target_app_id=pt.Int(876)),
        fee_source=pt.OpUpFeeSource.Any,
        expected_inner_fields={
            pt.TxnField.type_enum: pt.TxnType.ApplicationCall,
            pt.TxnField.application_id: pt.Int(876),
        },
    ),
    OpUpTest(
        opup=pt.OpUp(pt.OpUpMode.Explicit, target_app_id=pt.Int(1000001)),
        fee_source=pt.OpUpFeeSource.GroupCredit,
        expected_inner_fields={
            pt.TxnField.type_enum: pt.TxnType.ApplicationCall,
            pt.TxnField.fee: pt.Int(0),
            pt.TxnField.application_id: pt.Int(1000001),
        },
    ),
    OpUpTest(
        opup=pt.OpUp(pt.OpUpMode.Explicit, target_app_id=pt.Int(3)),
        fee_source=pt.OpUpFeeSource.AppAccount,
        expected_inner_fields={
            pt.TxnField.type_enum: pt.TxnType.ApplicationCall,
            pt.TxnField.fee: pt.Global.min_txn_fee(),
            pt.TxnField.application_id: pt.Int(3),
        },
    ),
    OpUpTest(
        opup=pt.OpUp(pt.OpUpMode.OnCall),
        fee_source=None,
        expected_inner_fields={
            pt.TxnField.type_enum: pt.TxnType.ApplicationCall,
            pt.TxnField.on_completion: pt.OnComplete.DeleteApplication,
            pt.TxnField.approval_program: pt.Bytes("base16", "068101"),
            pt.TxnField.clear_state_program: pt.Bytes("base16", "068101"),
        },
    ),
    OpUpTest(
        opup=pt.OpUp(pt.OpUpMode.OnCall),
        fee_source=pt.OpUpFeeSource.Any,
        expected_inner_fields={
            pt.TxnField.type_enum: pt.TxnType.ApplicationCall,
            pt.TxnField.on_completion: pt.OnComplete.DeleteApplication,
            pt.TxnField.approval_program: pt.Bytes("base16", "068101"),
            pt.TxnField.clear_state_program: pt.Bytes("base16", "068101"),
        },
    ),
    OpUpTest(
        opup=pt.OpUp(pt.OpUpMode.OnCall),
        fee_source=pt.OpUpFeeSource.GroupCredit,
        expected_inner_fields={
            pt.TxnField.type_enum: pt.TxnType.ApplicationCall,
            pt.TxnField.fee: pt.Int(0),
            pt.TxnField.on_completion: pt.OnComplete.DeleteApplication,
            pt.TxnField.approval_program: pt.Bytes("base16", "068101"),
            pt.TxnField.clear_state_program: pt.Bytes("base16", "068101"),
        },
    ),
    OpUpTest(
        opup=pt.OpUp(pt.OpUpMode.OnCall),
        fee_source=pt.OpUpFeeSource.AppAccount,
        expected_inner_fields={
            pt.TxnField.type_enum: pt.TxnType.ApplicationCall,
            pt.TxnField.fee: pt.Global.min_txn_fee(),
            pt.TxnField.on_completion: pt.OnComplete.DeleteApplication,
            pt.TxnField.approval_program: pt.Bytes("base16", "068101"),
            pt.TxnField.clear_state_program: pt.Bytes("base16", "068101"),
        },
    ),
]


def test_OP_UP_TEST_CASES_is_exhaustive():
    fee_sources: list[pt.OpUpFeeSource | None] = [fs for fs in pt.OpUpFeeSource]
    fee_sources.append(None)

    for mode, fee_source in zip(pt.OpUpMode, fee_sources):
        found_combination = False

        for test_case in OP_UP_TEST_CASES:
            if test_case.opup.mode is mode and test_case.fee_source is fee_source:
                found_combination = True
                break

        assert (
            found_combination
        ), f"Combination not found in test cases: mode={mode}, fee_source={fee_source}"


@pytest.mark.parametrize("opup, fee_source, expected_inner_fields", OP_UP_TEST_CASES)
def test_OpUp_ensure_budget(
    opup: pt.OpUp,
    fee_source: pt.OpUpFeeSource | None,
    expected_inner_fields: dict[pt.TxnField, pt.Expr | list[pt.Expr]],
):
    required_budget = pt.Int(777)
    expr = (
        opup.ensure_budget(required_budget)
        if fee_source is None
        else opup.ensure_budget(required_budget, fee_source)
    )
    assert expr.type_of() == pt.TealType.none
    assert expr.has_return() is False

    intermediate_value = pt.ScratchVar()
    expected_expr = pt.Seq(
        intermediate_value.store(required_budget + pt.Int(10)),
        pt.While(intermediate_value.load() > pt.Global.opcode_budget()).Do(
            pt.InnerTxnBuilder.Execute(expected_inner_fields)
        ),
    )
    expected, _ = expected_expr.__teal__(avm6Options)
    expected.addIncoming()
    expected = pt.TealBlock.NormalizeBlocks(expected)

    actual, _ = expr.__teal__(avm6Options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    with pt.TealComponent.Context.ignoreScratchSlotEquality(), pt.TealComponent.Context.ignoreExprEquality():
        assert actual == expected

    assert pt.TealBlock.MatchScratchSlotReferences(
        pt.TealBlock.GetReferencedScratchSlots(actual),
        pt.TealBlock.GetReferencedScratchSlots(expected),
    )

    with pytest.raises(pt.TealTypeError):
        opup.ensure_budget(required_budget=pt.Bytes("budget"))

    with pytest.raises(pt.TealTypeError):
        opup.ensure_budget(
            required_budget=required_budget, fee_source=pt.Bytes("fee_src")  # type: ignore[arg-type]
        )


@pytest.mark.parametrize("opup, fee_source, expected_inner_fields", OP_UP_TEST_CASES)
def test_OpUp_maximize_budget(
    opup: pt.OpUp,
    fee_source: pt.OpUpFeeSource | None,
    expected_inner_fields: dict[pt.TxnField, pt.Expr | list[pt.Expr]],
):
    fee = pt.Int(12345)
    expr = (
        opup.maximize_budget(fee)
        if fee_source is None
        else opup.maximize_budget(fee, fee_source)
    )
    assert expr.type_of() == pt.TealType.none
    assert expr.has_return() is False

    intermediate_value = pt.ScratchVar()
    expected_expr = pt.For(
        intermediate_value.store(pt.Int(0)),
        intermediate_value.load() < fee / pt.Global.min_txn_fee(),
        intermediate_value.store(intermediate_value.load() + pt.Int(1)),
    ).Do(pt.InnerTxnBuilder.Execute(expected_inner_fields))
    expected, _ = expected_expr.__teal__(avm6Options)
    expected.addIncoming()
    expected = pt.TealBlock.NormalizeBlocks(expected)

    actual, _ = expr.__teal__(avm6Options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    with pt.TealComponent.Context.ignoreScratchSlotEquality(), pt.TealComponent.Context.ignoreExprEquality():
        assert actual == expected

    assert pt.TealBlock.MatchScratchSlotReferences(
        pt.TealBlock.GetReferencedScratchSlots(actual),
        pt.TealBlock.GetReferencedScratchSlots(expected),
    )

    with pytest.raises(pt.TealTypeError):
        opup.maximize_budget(fee=pt.Bytes("fee"))

    with pytest.raises(pt.TealTypeError):
        opup.maximize_budget(fee=fee, fee_source=pt.Bytes("fee_src"))  # type: ignore[arg-type]



================================================
FILE: pyteal/ast/pragma.py
================================================
from typing import TYPE_CHECKING, Any

from pyteal.ast.expr import Expr
from pyteal.pragma import is_valid_compiler_version, pragma

if TYPE_CHECKING:
    from pyteal.compiler import CompileOptions


class Pragma(Expr):
    """A meta expression which defines a pragma for a specific subsection of PyTeal code.

    This expression does not affect the underlying compiled TEAL code in any way."""

    def __init__(self, child: Expr, *, compiler_version: str, **kwargs: Any) -> None:
        """Define a pragma for a specific subsection of PyTeal code.

        The Pragma expression does not affect the underlying compiled TEAL code in any way,
        it merely sets a pragma for the underlying expression.

        Args:
            child: The expression to wrap.
            compiler_version: Acceptable versions of the compiler. Will fail if the current PyTeal version
                is not contained in the range. Follows the npm `semver range scheme <https://github.com/npm/node-semver#ranges>`_
                for specifying compatible versions.

        For example:

        .. code-block:: python

            @Subroutine(TealType.uint64)
            def example() -> Expr:
                # this will fail during compilation if the current PyTeal version does not satisfy
                # the version constraint
                return Pragma(
                    Seq(...),
                    compiler_version="^0.14.0"
                )
        """
        super().__init__()

        self.child = child

        if not is_valid_compiler_version(compiler_version):
            raise ValueError("Invalid compiler version: {}".format(compiler_version))
        self.compiler_version = compiler_version

    def __teal__(self, options: "CompileOptions"):
        pragma(compiler_version=self.compiler_version)

        return self.child.__teal__(options)

    def __str__(self):
        return "(pragma {})".format(self.child)

    def type_of(self):
        return self.child.type_of()

    def has_return(self):
        return self.child.has_return()


Pragma.__module__ = "pyteal"



================================================
FILE: pyteal/ast/pragma_test.py
================================================
import pytest
from tests.mock_version import mock_version  # noqa: F401

import pyteal as pt


@pytest.mark.usefixtures("mock_version")
@pytest.mark.parametrize(
    "version, compiler_version, should_error",
    [
        # valid
        ("0.12.0", "0.12.0", False),
        (
            "1.0.0+AVM7.1",
            "=1.0.0",
            False,
        ),
        # invalid
        ("0.13.0", "0.13.1", True),
        ("1.2.3a2", "<0.8.0 || >=0.12.0", True),
    ],
)
def test_pragma_expr(compiler_version, should_error):
    program = pt.Pragma(pt.Approve(), compiler_version=compiler_version)

    if should_error:
        with pytest.raises(pt.TealPragmaError):
            pt.compileTeal(program, mode=pt.Mode.Application, version=6)
    else:
        pt.compileTeal(program, mode=pt.Mode.Application, version=6)


def test_pragma_expr_does_not_change():
    without_pragma = pt.Seq(pt.Pop(pt.Add(pt.Int(1), pt.Int(2))), pt.Return(pt.Int(1)))
    pragma = pt.Pragma(without_pragma, compiler_version=">=0.0.0")

    compiled_with_pragma = pt.compileTeal(pragma, mode=pt.Mode.Application, version=6)
    compiled_without_pragma = pt.compileTeal(
        without_pragma, mode=pt.Mode.Application, version=6
    )

    assert compiled_with_pragma == compiled_without_pragma


def test_pragma_expr_has_return():
    exprWithReturn = pt.Pragma(pt.Return(pt.Int(1)), compiler_version=">=0.0.0")
    assert exprWithReturn.has_return()

    exprWithoutReturn = pt.Pragma(pt.Int(1), compiler_version=">=0.0.0")
    assert not exprWithoutReturn.has_return()


@pytest.mark.parametrize(
    "compiler_version",
    ["not a version", ">=0.1.1,<0.3.0", "1.2.3aq"],  # incorrect spec  # invalid PEP 440
)
def test_pragma_expr_invalid_compiler_version(compiler_version):
    with pytest.raises(ValueError):
        pt.Pragma(pt.Approve(), compiler_version=compiler_version)



================================================
FILE: pyteal/ast/replace.py
================================================
from typing import cast, TYPE_CHECKING

from pyteal.types import TealType, require_type
from pyteal.errors import verifyProgramVersion
from pyteal.ir import TealOp, Op, TealBlock
from pyteal.ast.expr import Expr
from pyteal.ast.int import Int
from pyteal.ast.ternaryexpr import TernaryExpr

if TYPE_CHECKING:
    from pyteal.compiler import CompileOptions


class ReplaceExpr(Expr):
    """An expression for replacing a section of a byte string at a given start index"""

    def __init__(self, original: Expr, start: Expr, replacement: Expr) -> None:
        super().__init__()

        require_type(original, TealType.bytes)
        require_type(start, TealType.uint64)
        require_type(replacement, TealType.bytes)

        self.original = original
        self.start = start
        self.replacement = replacement

    # helper method for correctly populating op
    def __get_op(self, options: "CompileOptions"):
        s = cast(Int, self.start).value
        if s < 2**8:
            return Op.replace2
        else:
            return Op.replace3

    def __teal__(self, options: "CompileOptions"):
        if not isinstance(self.start, Int):
            return TernaryExpr(
                Op.replace3,
                (TealType.bytes, TealType.uint64, TealType.bytes),
                TealType.bytes,
                self.original,
                self.start,
                self.replacement,
            ).__teal__(options)

        op = self.__get_op(options)

        verifyProgramVersion(
            op.min_version,
            options.version,
            "Program version too low to use op {}".format(op),
        )

        s = cast(Int, self.start).value
        if op == Op.replace2:
            return TealBlock.FromOp(
                options, TealOp(self, op, s), self.original, self.replacement
            )
        elif op == Op.replace3:
            return TealBlock.FromOp(
                options, TealOp(self, op), self.original, self.start, self.replacement
            )

    def __str__(self):
        return "(Replace {} {} {})".format(self.original, self.start, self.replacement)

    def type_of(self):
        return TealType.bytes

    def has_return(self):
        return False


def Replace(original: Expr, start: Expr, replacement: Expr) -> Expr:
    """
    Replace a portion of original bytes with new bytes at a given starting point.

    Requires program version 7 or higher.

    Args:
        original: The value containing the original bytes. Must evaluate to bytes.
        start: The index of the byte where replacement starts. Must evaluate to an integer less than Len(original).
        replacement: The value containing the replacement bytes. Must evaluate to bytes with length at most Len(original) - start.
    """
    return ReplaceExpr(original, start, replacement)



================================================
FILE: pyteal/ast/replace_test.py
================================================
import pytest

import pyteal as pt

avm6Options = pt.CompileOptions(version=6)
avm7Options = pt.CompileOptions(version=7)


def test_replace_immediate():
    args = [pt.Bytes("my string"), pt.Int(0), pt.Bytes("abcdefghi")]
    expr = pt.Replace(args[0], args[1], args[2])
    assert expr.type_of() == pt.TealType.bytes

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(args[0], pt.Op.byte, '"my string"'),
            pt.TealOp(args[2], pt.Op.byte, '"abcdefghi"'),
            pt.TealOp(expr, pt.Op.replace2, 0),
        ]
    )

    actual, _ = expr.__teal__(avm7Options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    assert actual == expected

    with pytest.raises(pt.TealInputError):
        expr.__teal__(avm6Options)


def test_replace_stack_int():
    my_string = "*" * 257
    args = [pt.Bytes(my_string), pt.Int(256), pt.Bytes("ab")]
    expr = pt.Replace(args[0], args[1], args[2])
    assert expr.type_of() == pt.TealType.bytes

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(args[0], pt.Op.byte, '"{my_string}"'.format(my_string=my_string)),
            pt.TealOp(args[1], pt.Op.int, 256),
            pt.TealOp(args[2], pt.Op.byte, '"ab"'),
            pt.TealOp(expr, pt.Op.replace3),
        ]
    )

    actual, _ = expr.__teal__(avm7Options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    assert actual == expected

    with pytest.raises(pt.TealInputError):
        expr.__teal__(avm6Options)


# Mirrors `test_replace_stack_int`, but attempts replacement with start != pt.Int.
def test_replace_stack_not_int():
    my_string = "*" * 257
    add = pt.Add(pt.Int(254), pt.Int(2))
    args = [pt.Bytes(my_string), add, pt.Bytes("ab")]
    expr = pt.Replace(args[0], args[1], args[2])
    assert expr.type_of() == pt.TealType.bytes

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(args[0], pt.Op.byte, '"{my_string}"'.format(my_string=my_string)),
            pt.TealOp(pt.Int(254), pt.Op.int, 254),
            pt.TealOp(pt.Int(2), pt.Op.int, 2),
            pt.TealOp(add, pt.Op.add),
            pt.TealOp(args[2], pt.Op.byte, '"ab"'),
            pt.TealOp(expr, pt.Op.replace3),
        ]
    )

    actual, _ = expr.__teal__(avm7Options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    with pt.TealComponent.Context.ignoreExprEquality():
        assert actual == expected

    with pytest.raises(pt.TealInputError):
        expr.__teal__(avm6Options)


def test_replace_invalid():
    with pytest.raises(pt.TealTypeError):
        pt.Replace(pt.Bytes("my string"), pt.Int(0), pt.Int(1))

    with pytest.raises(pt.TealTypeError):
        pt.Replace(
            pt.Bytes("my string"), pt.Bytes("should be int"), pt.Bytes("abcdefghi")
        )

    with pytest.raises(pt.TealTypeError):
        pt.Replace(pt.Bytes("my string"), pt.Txn.sender(), pt.Bytes("abcdefghi"))



================================================
FILE: pyteal/ast/return_.py
================================================
from typing import TYPE_CHECKING

from pyteal.types import TealType, require_type, types_match
from pyteal.errors import verifyProgramVersion, TealCompileError
from pyteal.ir import TealOp, Op, TealBlock
from pyteal.ast.expr import Expr
from pyteal.ast.int import Int

if TYPE_CHECKING:
    from pyteal.compiler import CompileOptions


class Return(Expr):
    """Return a value from the current execution context."""

    def __init__(self, value: Expr | None = None) -> None:
        """Create a new Return expression.

        If called from the main program, this will immediately exit the program
        and the value returned will be the program's success value (must be a
        uint64, 0 indicates failure, 1 or greater indicates success).

        If called from within a subroutine, this will return from the current
        subroutine with either no value if the subroutine does not produce a
        return value, or the given return value if it does produce a return value.
        """
        super().__init__()
        if value is not None:
            require_type(value, TealType.anytype)
        self.value = value

    def __teal__(self, options: "CompileOptions"):
        if options.currentSubroutine is not None:
            verifyProgramVersion(
                Op.retsub.min_version,
                options.version,
                "Program version too low to use subroutines",
            )
            returnType = options.currentSubroutine.return_type
            if returnType == TealType.none:
                if self.value is not None:
                    raise TealCompileError(
                        "Cannot return a value from a subroutine with return type TealType.none",
                        self,
                    )
            else:
                if self.value is None:
                    raise TealCompileError(
                        "A subroutine declares it returns a value, but no value is being returned",
                        self,
                    )
                actualType = self.value.type_of()
                if not types_match(actualType, returnType):
                    raise TealCompileError(
                        "Incompatible return type from subroutine, expected {} but got {}".format(
                            returnType, actualType
                        ),
                        self,
                    )
            op = Op.retsub
        else:
            if self.value is None:
                raise TealCompileError(
                    "Return from main program must have an argument", self
                )
            actualType = self.value.type_of()
            if not types_match(actualType, TealType.uint64):
                raise TealCompileError(
                    "Incompatible return type from main program, expected {} but got {}".format(
                        TealType.uint64, actualType
                    ),
                    self,
                )
            op = Op.return_

        args = [] if self.value is None else [self.value]
        return TealBlock.FromOp(options, TealOp(self, op), *args)

    def __str__(self):
        return "(Return {})".format(self.value)

    def type_of(self):
        return TealType.none

    def has_return(self):
        return True


Return.__module__ = "pyteal"


class ExitProgram(Expr):
    """Immediately exit the program with the indicated success value."""

    def __init__(self, success: Expr) -> None:
        super().__init__()
        require_type(success, TealType.uint64)
        self.success = success

    def __teal__(self, options: "CompileOptions"):
        return TealBlock.FromOp(options, TealOp(self, Op.return_), self.success)

    def __str__(self):
        return "(ExitProgram {})".format(self.success)

    def type_of(self):
        return TealType.none

    def has_return(self):
        return True


ExitProgram.__module__ = "pyteal"


def Approve() -> Expr:
    """Immediately exit the program and mark the execution as successful."""
    return ExitProgram(Int(1))


def Reject() -> Expr:
    """Immediately exit the program and mark the execution as unsuccessful."""
    return ExitProgram(Int(0))



================================================
FILE: pyteal/ast/return_test.py
================================================
import pytest

import pyteal as pt

options = pt.CompileOptions(version=4)


def test_main_return():
    arg = pt.Int(1)
    expr = pt.Return(arg)
    assert expr.type_of() == pt.TealType.none
    assert expr.has_return()

    expected = pt.TealSimpleBlock(
        [pt.TealOp(arg, pt.Op.int, 1), pt.TealOp(expr, pt.Op.return_)]
    )

    actual, _ = expr.__teal__(options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    assert actual == expected


def test_main_return_invalid():
    with pytest.raises(pt.TealCompileError):
        pt.Return(pt.Txn.receiver()).__teal__(options)

    with pytest.raises(pt.TealCompileError):
        pt.Return().__teal__(options)


def test_subroutine_return_value():
    cases = (
        (pt.TealType.uint64, pt.Int(1), pt.Op.int, 1),
        (pt.TealType.bytes, pt.Bytes("value"), pt.Op.byte, '"value"'),
        (pt.TealType.anytype, pt.Int(1), pt.Op.int, 1),
        (pt.TealType.anytype, pt.Bytes("value"), pt.Op.byte, '"value"'),
    )

    for tealType, value, op, opValue in cases:
        expr = pt.Return(value)

        def mySubroutine():
            return expr

        subroutine = pt.SubroutineDefinition(mySubroutine, tealType)

        assert expr.type_of() == pt.TealType.none
        assert expr.has_return()

        expected = pt.TealSimpleBlock(
            [pt.TealOp(value, op, opValue), pt.TealOp(expr, pt.Op.retsub)]
        )

        options.setSubroutine(subroutine)
        actual, _ = expr.__teal__(options)
        options.setSubroutine(None)

        actual.addIncoming()
        actual = pt.TealBlock.NormalizeBlocks(actual)

        assert actual == expected


def test_subroutine_return_value_invalid():
    cases = (
        (pt.TealType.bytes, pt.Int(1)),
        (pt.TealType.uint64, pt.Bytes("value")),
    )

    for tealType, value in cases:
        expr = pt.Return(value)

        def mySubroutine():
            return expr

        subroutine = pt.SubroutineDefinition(mySubroutine, tealType)

        options.setSubroutine(subroutine)
        with pytest.raises(pt.TealCompileError):
            expr.__teal__(options)
        options.setSubroutine(None)


def test_subroutine_return_none():
    expr = pt.Return()

    def mySubroutine():
        return expr

    subroutine = pt.SubroutineDefinition(mySubroutine, pt.TealType.none)

    assert expr.type_of() == pt.TealType.none
    assert expr.has_return()

    expected = pt.TealSimpleBlock([pt.TealOp(expr, pt.Op.retsub)])

    options.setSubroutine(subroutine)
    actual, _ = expr.__teal__(options)
    options.setSubroutine(None)

    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    assert actual == expected


def test_subroutine_return_none_invalid():
    for value in (pt.Int(1), pt.Bytes("value")):
        expr = pt.Return(value)

        def mySubroutine():
            return expr

        subroutine = pt.SubroutineDefinition(mySubroutine, pt.TealType.none)

        options.setSubroutine(subroutine)
        with pytest.raises(pt.TealCompileError):
            expr.__teal__(options)
        options.setSubroutine(None)



================================================
FILE: pyteal/ast/router_test.py
================================================
import pytest
import secrets
import typing

import algosdk.abi as sdk_abi

import pyteal as pt
from pyteal.ast.router import ASTBuilder


options = pt.CompileOptions(version=5)


@pt.ABIReturnSubroutine
def add(a: pt.abi.Uint64, b: pt.abi.Uint64, *, output: pt.abi.Uint64) -> pt.Expr:
    """add takes 2 integers a,b and adds them, returning the sum"""
    return output.set(a.get() + b.get())


@pt.ABIReturnSubroutine
def sub(a: pt.abi.Uint64, b: pt.abi.Uint64, *, output: pt.abi.Uint64) -> pt.Expr:
    """replace me"""
    return output.set(a.get() - b.get())


@pt.ABIReturnSubroutine
def mul(a: pt.abi.Uint64, b: pt.abi.Uint64, *, output: pt.abi.Uint64) -> pt.Expr:
    return output.set(a.get() * b.get())


@pt.ABIReturnSubroutine
def div(a: pt.abi.Uint64, b: pt.abi.Uint64, *, output: pt.abi.Uint64) -> pt.Expr:
    return output.set(a.get() / b.get())


@pt.ABIReturnSubroutine
def mod(a: pt.abi.Uint64, b: pt.abi.Uint64, *, output: pt.abi.Uint64) -> pt.Expr:
    return output.set(a.get() % b.get())


@pt.ABIReturnSubroutine
def qrem(
    a: pt.abi.Uint64,
    b: pt.abi.Uint64,
    *,
    output: pt.abi.Tuple2[pt.abi.Uint64, pt.abi.Uint64],
) -> pt.Expr:
    return pt.Seq(
        (q := pt.abi.Uint64()).set(a.get() / b.get()),
        (rem := pt.abi.Uint64()).set(a.get() % b.get()),
        output.set(q, rem),
    )


@pt.ABIReturnSubroutine
def reverse(a: pt.abi.String, *, output: pt.abi.String) -> pt.Expr:
    idx = pt.ScratchVar()
    buff = pt.ScratchVar()

    init = idx.store(pt.Int(0))
    cond = idx.load() < a.length()
    _iter = idx.store(idx.load() + pt.Int(1))
    return pt.Seq(
        buff.store(pt.Bytes("")),
        pt.For(init, cond, _iter).Do(
            a[idx.load()].use(lambda v: buff.store(pt.Concat(v.encode(), buff.load())))
        ),
        output.set(buff.load()),
    )


@pt.ABIReturnSubroutine
def concat_strings(
    b: pt.abi.DynamicArray[pt.abi.String], *, output: pt.abi.String
) -> pt.Expr:
    idx = pt.ScratchVar()
    buff = pt.ScratchVar()

    init = idx.store(pt.Int(0))
    cond = idx.load() < b.length()
    _iter = idx.store(idx.load() + pt.Int(1))
    return pt.Seq(
        buff.store(pt.Bytes("")),
        pt.For(init, cond, _iter).Do(
            b[idx.load()].use(lambda s: buff.store(pt.Concat(buff.load(), s.get())))
        ),
        output.set(buff.load()),
    )


@pt.ABIReturnSubroutine
def many_args(
    _a: pt.abi.Uint64,
    _b: pt.abi.Uint64,
    _c: pt.abi.Uint64,
    _d: pt.abi.Uint64,
    _e: pt.abi.Uint64,
    _f: pt.abi.Uint64,
    _g: pt.abi.Uint64,
    _h: pt.abi.Uint64,
    _i: pt.abi.Uint64,
    _j: pt.abi.Uint64,
    _k: pt.abi.Uint64,
    _l: pt.abi.Uint64,
    _m: pt.abi.Uint64,
    _n: pt.abi.Uint64,
    _o: pt.abi.Uint64,
    _p: pt.abi.Uint64,
    _q: pt.abi.Uint64,
    _r: pt.abi.Uint64,
    _s: pt.abi.Uint64,
    _t: pt.abi.Uint64,
    *,
    output: pt.abi.Uint64,
) -> pt.Expr:
    return output.set(_t.get())


@pt.ABIReturnSubroutine
def many_args_with_transaction(
    _txn: pt.abi.Transaction,
    _b: pt.abi.Uint64,
    _c: pt.abi.Uint64,
    _d: pt.abi.Uint64,
    _e: pt.abi.Uint64,
    _f: pt.abi.Uint64,
    _g: pt.abi.Uint64,
    _h: pt.abi.Uint64,
    _i: pt.abi.Uint64,
    _j: pt.abi.Uint64,
    _k: pt.abi.Uint64,
    _l: pt.abi.Uint64,
    _m: pt.abi.Uint64,
    _n: pt.abi.Uint64,
    _o: pt.abi.Uint64,
    _p: pt.abi.Uint64,
    _q: pt.abi.Uint64,
    _r: pt.abi.Uint64,
    _s: pt.abi.Uint64,
    _t: pt.abi.Uint64,
    *,
    output: pt.abi.Uint64,
) -> pt.Expr:
    return output.set(_t.get())


@pt.ABIReturnSubroutine
def add_and_store(
    a1: pt.abi.Uint64,
    a2: pt.abi.Uint64,
    a3: pt.abi.Uint64,
    a4: pt.abi.Uint64,
    a5: pt.abi.Uint64,
    a6: pt.abi.Uint64,
    a7: pt.abi.Uint64,
    a8: pt.abi.Uint64,
    a9: pt.abi.Uint64,
    a10: pt.abi.Uint64,
    a11: pt.abi.Uint64,
    a12: pt.abi.Uint64,
    a13: pt.abi.Uint64,
    a14: pt.abi.Uint64,
    a15: pt.abi.Uint64,
    a16: pt.abi.Uint64,
    t1: pt.abi.PaymentTransaction,
    *,
    output: pt.abi.Uint64,
) -> pt.Expr:
    return pt.Seq(
        output.set(a1.get() + a2.get()),
        # store the result in the sender's local state too
        pt.App.localPut(pt.Txn.sender(), pt.Bytes("result"), output.get()),
    )


@pt.Subroutine(pt.TealType.none)
def safe_clear_state_delete():
    return (
        pt.If(pt.Txn.sender() == pt.Global.creator_address())
        .Then(pt.Approve())
        .Else(pt.Reject())
    )


@pt.ABIReturnSubroutine
def dummy_doing_nothing():
    return pt.Seq(pt.Log(pt.Bytes("a message")))


@pt.Subroutine(pt.TealType.uint64)
def returning_u64():
    return pt.Int(1)


@pt.Subroutine(pt.TealType.none)
def mult_over_u64_and_log(a: pt.Expr, b: pt.Expr):
    return pt.Log(pt.Itob(a * b))


@pt.ABIReturnSubroutine
def eine_constant(*, output: pt.abi.Uint64):
    return output.set(1)


@pt.ABIReturnSubroutine
def take_abi_and_log(tb_logged: pt.abi.String):
    return pt.Log(tb_logged.get())


@pt.ABIReturnSubroutine
def not_registrable(lhs: pt.abi.Uint64, rhs: pt.Expr, *, output: pt.abi.Uint64):
    return output.set(lhs.get() * rhs)


@pt.ABIReturnSubroutine
def txn_amount(t: pt.abi.PaymentTransaction, *, output: pt.abi.Uint64):
    return output.set(t.get().amount())


@pt.ABIReturnSubroutine
def multiple_txn(
    appl: pt.abi.ApplicationCallTransaction,
    axfer: pt.abi.AssetTransferTransaction,
    pay: pt.abi.PaymentTransaction,
    any_txn: pt.abi.Transaction,
    *,
    output: pt.abi.Uint64,
):
    return output.set(
        appl.get().fee() + axfer.get().fee() + pay.get().fee() + any_txn.get().fee()
    )


GOOD_SUBROUTINE_CASES: list[pt.ABIReturnSubroutine | pt.SubroutineFnWrapper] = [
    add,
    sub,
    mul,
    div,
    mod,
    qrem,
    reverse,
    concat_strings,
    many_args,
    many_args_with_transaction,
    add_and_store,
    safe_clear_state_delete,
    dummy_doing_nothing,
    eine_constant,
    take_abi_and_log,
    txn_amount,
    multiple_txn,
]

ON_COMPLETE_CASES: list[pt.EnumInt] = [
    pt.OnComplete.NoOp,
    pt.OnComplete.OptIn,
    pt.OnComplete.CloseOut,
    pt.OnComplete.UpdateApplication,
    pt.OnComplete.DeleteApplication,
]


def power_set(no_dup_list: list, length_override: int | None = None):
    """
    This function serves as a generator for all possible elements in power_set
    over `non_dup_list`, which is a list of non-duplicated elements (matches property of a set).

    The cardinality of a powerset is 2^|non_dup_list|, so we can iterate from 0 to 2^|non_dup_list| - 1
    to index each element in such power_set.
    By binary representation of each index, we can see it as an allowance over each element in `no_dup_list`,
    and generate a unique subset of `non_dup_list`, which yields as an element of power_set of `no_dup_list`.

    Args:
        no_dup_list: a list of elements with no duplication
        length_override: a number indicating the largest size of super_set element,
            must be in range [1, len(no_dup_list)].
    """
    if length_override is None:
        length_override = len(no_dup_list)
    assert 1 <= length_override <= len(no_dup_list)
    masks = [1 << i for i in range(length_override)]
    for i in range(1 << len(no_dup_list)):
        yield [elem for mask, elem in zip(masks, no_dup_list) if i & mask]


class FullOrderCombinationGen:
    """
    This class serves as a generator for all possible vectors of maximal length `largest_perm_length` (non-negative),
    each of whose entries are one of the elements in `non_dup_list`, namely, a list of non-duplicated elements.
    """

    def __init__(self, non_dup_list: list, largest_perm_length: int) -> None:
        if largest_perm_length < 0:
            raise pt.TealInputError(
                "largest input permutation length must be non-negative"
            )
        elif len(set(non_dup_list)) != len(non_dup_list):
            raise pt.TealInputError(
                f"input non_dup_list {non_dup_list} has duplications"
            )
        elif not len(non_dup_list):
            raise pt.TealInputError("input non_dup_list must be non empty")

        self.__basis_symbol = non_dup_list
        self.__basis_size = len(self.__basis_symbol)
        self.__pre_gen_table: list[list[int]] = [
            [] for _ in range(self.__basis_size**largest_perm_length)
        ]

        # we can index all possible cases of vectors with an index in range
        # [0, |non_dup_list| ^ perm_length - 1]
        # by converting an index into |non_dup_list|-based number,
        # we can get the vector mapped by the index.

        # we iterate through [0, |non_dup_list|^largest_perm_length - 1] to precompute permutation table.
        lhs_scope = 0
        discrete_log = 0
        for expn in range(largest_perm_length + 1):
            for index in range(lhs_scope, self.__basis_size**expn):
                basis_repr = [0 for _ in range(discrete_log)]
                if discrete_log:
                    temp = index
                    for i in range(discrete_log):
                        basis_repr[i] = temp % self.__basis_size
                        temp //= self.__basis_size
                self.__pre_gen_table[index] = basis_repr

            lhs_scope = self.__basis_size**expn
            discrete_log = expn + 1

    def sample_gen(self, perm_length: int, sample_num: int = 10):
        if perm_length < 0:
            raise pt.TealInputError("input permutation length must be non-negative")
        elif perm_length == 0:
            yield []
            return

        # since we are sampling for a permutation with length `perm_length`,
        # this corresponds to sampling a value from [|non_dup_list|^(perm_length - 1), |non_dup_list|^perm_length - 1].
        # if sample number is greater than interval size, by pigeonhole principle there is re-testing
        # reduce back down to interval size
        sample_num = min(sample_num, self.__basis_size ** (perm_length - 1))

        for _ in range(sample_num):
            take = secrets.choice(
                range(
                    self.__basis_size ** (perm_length - 1),
                    self.__basis_size**perm_length,
                )
            )
            yield [self.__basis_symbol[j] for j in self.__pre_gen_table[take]]


def assemble_helper(what: pt.Expr) -> pt.TealBlock:
    assembled, _ = what.__teal__(options)
    assembled.addIncoming()
    assembled = pt.TealBlock.NormalizeBlocks(assembled)
    return assembled


def camel_to_snake(name: str) -> str:
    return "".join(["_" + c.lower() if c.isupper() else c for c in name]).lstrip("_")


def test_method_config_clear_state_failure():
    with pytest.raises(pt.TealInputError) as tie:
        pt.MethodConfig(clear_state=pt.CallConfig.CALL)

    assert "Attempt to construct clear state program from MethodConfig" in str(tie)


def test_bare_call_config_clear_state_failure():
    with pytest.raises(pt.TealInputError) as tie:
        pt.BareCallActions(
            clear_state=pt.OnCompleteAction(
                action=pt.Seq(), call_config=pt.CallConfig.CALL
            )
        )

    assert "Attempt to construct clear state program from bare app call" in str(
        tie.value
    )


def equal_ocas(oca1, oca2):
    assert oca1.call_config == oca2.call_config
    if oca1.action is None:
        assert oca2.action is None
    else:
        assert isinstance(oca1.action, pt.Int)
        assert isinstance(oca2.action, pt.Int)

    return True


def test_BareCallActions_asdict():
    no_action = pt.OnCompleteAction()
    del_action = pt.OnCompleteAction(action=pt.Int(1), call_config=pt.CallConfig.ALL)
    close_action = pt.OnCompleteAction(action=pt.Int(2), call_config=pt.CallConfig.CALL)

    bca = pt.BareCallActions(
        delete_application=del_action,
        close_out=close_action,
    )

    expected = {
        "clear_state": no_action,
        "close_out": close_action,
        "delete_application": del_action,
        "no_op": no_action,
        "opt_in": no_action,
        "update_application": no_action,
    }

    bcad = bca.asdict()
    assert set(bcad.keys()) == set(expected.keys())

    for k, oca1 in bcad.items():
        oca2 = expected[k]
        equal_ocas(oca1, oca2)


def test_BareCallActions_aslist():
    no_action = pt.OnCompleteAction()
    optin_action = pt.OnCompleteAction(action=pt.Int(1), call_config=pt.CallConfig.ALL)
    update_action = pt.OnCompleteAction(
        action=pt.Int(2), call_config=pt.CallConfig.CALL
    )

    bca = pt.BareCallActions(
        update_application=update_action,
        opt_in=optin_action,
    )

    expected = [
        no_action,
        no_action,
        no_action,
        no_action,
        optin_action,
        update_action,
    ]
    bcal = bca.aslist()
    assert len(expected) == len(bcal)

    assert all([equal_ocas(expected[i], actual) for i, actual in enumerate(bcal)])


def test_BareCallActions_get_method_config():
    from pyteal.ast.router import MethodConfig, CallConfig

    cc_all, cc_call, cc_create = (
        pt.CallConfig.ALL,
        pt.CallConfig.CALL,
        pt.CallConfig.CREATE,
    )
    optin_action = pt.OnCompleteAction(action=pt.Int(1), call_config=cc_all)
    noop_action = pt.OnCompleteAction(action=pt.Int(2), call_config=cc_call)
    update_action = pt.OnCompleteAction(action=pt.Int(3), call_config=cc_create)

    bca = pt.BareCallActions(
        update_application=update_action,
        opt_in=optin_action,
        no_op=noop_action,
    )

    mc = bca.get_method_config()
    assert mc == MethodConfig(
        close_out=CallConfig.NEVER,
        delete_application=CallConfig.NEVER,
        no_op=cc_call,
        opt_in=cc_all,
        update_application=cc_create,
        clear_state=CallConfig.NEVER,
    )


def test_router_register_method_clear_state_failure():
    router = pt.Router("doomedToFail")

    with pytest.raises(pt.TealInputError) as tie:

        @router.method(clear_state=pt.CallConfig.CALL)
        def incr_by_1(a: pt.abi.Uint64, *, output: pt.abi.Uint64) -> pt.Expr:
            return output.set(a.get() + pt.Int(1))

    assert "Attempt to register ABI method for clear state program" in str(tie)


def test_call_config():
    for cc in pt.CallConfig:
        approval_cond_on_cc: pt.Expr | int = cc.approval_condition_under_config()
        match approval_cond_on_cc:
            case pt.Expr():
                expected_cc = (
                    (pt.Txn.application_id() == pt.Int(0))
                    if cc == pt.CallConfig.CREATE
                    else (pt.Txn.application_id() != pt.Int(0))
                )
                with pt.TealComponent.Context.ignoreExprEquality():
                    assert assemble_helper(approval_cond_on_cc) == assemble_helper(
                        expected_cc
                    )
            case int():
                assert approval_cond_on_cc == int(cc) & 1
            case _:
                raise pt.TealInternalError(
                    f"unexpected approval_cond_on_cc {approval_cond_on_cc}"
                )


def test_method_config_call_config_never():
    never_mc = pt.MethodConfig(no_op=pt.CallConfig.NEVER)
    assert never_mc.is_never()
    assert never_mc.approval_cond() == 0


def _gen_method_configs(sample_count: int = 10):
    on_complete_pow_set = power_set(ON_COMPLETE_CASES)
    focg = FullOrderCombinationGen(list(pt.CallConfig), len(ON_COMPLETE_CASES))

    for on_complete_set in on_complete_pow_set:
        oc_names = [camel_to_snake(oc.name) for oc in on_complete_set]
        for call_configs in focg.sample_gen(len(on_complete_set), sample_count):
            yield pt.MethodConfig(**dict(zip(oc_names, call_configs)))


@pytest.mark.parametrize("mc", _gen_method_configs())
def test_method_config(mc: pt.MethodConfig):
    approval_check_names_n_ocs = [
        (camel_to_snake(oc.name), oc)
        for oc in ON_COMPLETE_CASES
        if str(oc) != str(pt.OnComplete.ClearState)
    ]

    if mc.is_never() or all(
        getattr(mc, i) == pt.CallConfig.NEVER for i, _ in approval_check_names_n_ocs
    ):
        assert mc.approval_cond() == 0
        return
    elif all(
        getattr(mc, i) == pt.CallConfig.ALL for i, _ in approval_check_names_n_ocs
    ):
        assert mc.approval_cond() == 1
        return
    list_of_cc = [
        (
            typing.cast(
                pt.CallConfig, getattr(mc, i)
            ).approval_condition_under_config(),
            oc,
        )
        for i, oc in approval_check_names_n_ocs
    ]
    list_of_expressions: list[pt.Expr] = []
    for expr_or_int, oc in list_of_cc:
        match expr_or_int:
            case pt.Expr():
                list_of_expressions.append(
                    pt.And(pt.Txn.on_completion() == oc, expr_or_int)
                )
            case 0:
                continue
            case 1:
                list_of_expressions.append(pt.Txn.on_completion() == oc)
    with pt.TealComponent.Context.ignoreExprEquality():
        ac = mc.approval_cond()
        assert isinstance(ac, pt.Expr)
        assert assemble_helper(ac) == assemble_helper(pt.Or(*list_of_expressions))


def test_on_complete_action():
    with pytest.raises(pt.TealInputError) as contradict_err:
        pt.OnCompleteAction(action=pt.Seq(), call_config=pt.CallConfig.NEVER)
    assert "contradicts" in str(contradict_err)
    assert pt.OnCompleteAction.never().is_empty()
    assert pt.OnCompleteAction.call_only(pt.Seq()).call_config == pt.CallConfig.CALL
    assert pt.OnCompleteAction.create_only(pt.Seq()).call_config == pt.CallConfig.CREATE
    assert pt.OnCompleteAction.always(pt.Seq()).call_config == pt.CallConfig.ALL


def test_wrap_handler_bare_call():
    BARE_CALL_CASES = [
        dummy_doing_nothing,
        safe_clear_state_delete,
        pt.Approve(),
        pt.Log(pt.Bytes("message")),
    ]
    for bare_call in BARE_CALL_CASES:
        wrapped: pt.Expr = ASTBuilder.wrap_handler(False, bare_call)
        expected: pt.Expr
        match bare_call:
            case pt.Expr():
                if bare_call.has_return():
                    expected = bare_call
                else:
                    expected = pt.Seq(bare_call, pt.Approve())
            case pt.SubroutineFnWrapper() | pt.ABIReturnSubroutine():
                expected = pt.Seq(bare_call(), pt.Approve())
            case _:
                raise pt.TealInputError("how you got here?")
        wrapped_assemble = assemble_helper(wrapped)
        wrapped_helper = assemble_helper(expected)
        with pt.TealComponent.Context.ignoreExprEquality():
            assert wrapped_assemble == wrapped_helper

    ERROR_CASES = [
        (
            pt.Int(1),
            f"bare appcall handler should be TealType.none not {pt.TealType.uint64}.",
        ),
        (
            returning_u64,
            f"subroutine call should be returning TealType.none not {pt.TealType.uint64}.",
        ),
        (
            mult_over_u64_and_log,
            "subroutine call should take 0 arg for bare appcall. this subroutine takes 2.",
        ),
        (
            eine_constant,
            f"abi-returning subroutine call should be returning void not {pt.abi.Uint64TypeSpec()}.",
        ),
        (
            take_abi_and_log,
            "abi-returning subroutine call should take 0 arg for bare appcall. this abi-returning subroutine takes 1.",
        ),
        (
            1,
            "bare appcall can only accept: none type Expr, or Subroutine/ABIReturnSubroutine with none return and no arg",
        ),
    ]
    for error_case, error_msg in ERROR_CASES:
        with pytest.raises(pt.TealInputError) as bug:
            ASTBuilder.wrap_handler(False, error_case)
        assert error_msg in str(bug)


def test_wrap_handler_method_call():
    with pytest.raises(pt.TealInputError) as bug:
        ASTBuilder.wrap_handler(True, not_registrable)
    assert "method call ABIReturnSubroutine is not routable" in str(bug)

    with pytest.raises(pt.TealInputError) as bug:
        ASTBuilder.wrap_handler(True, safe_clear_state_delete)
    assert "method call should be only registering ABIReturnSubroutine" in str(bug)

    ONLY_ABI_SUBROUTINE_CASES = list(
        filter(lambda x: isinstance(x, pt.ABIReturnSubroutine), GOOD_SUBROUTINE_CASES)
    )

    for abi_subroutine in ONLY_ABI_SUBROUTINE_CASES:
        wrapped: pt.Expr = ASTBuilder.wrap_handler(True, abi_subroutine)
        actual: pt.TealBlock = assemble_helper(wrapped)

        args: list[pt.abi.BaseType] = [
            spec.new_instance()
            for spec in typing.cast(
                list[pt.abi.TypeSpec], abi_subroutine.subroutine.expected_arg_types
            )
        ]

        app_args = [
            arg for arg in args if arg.type_spec() not in pt.abi.TransactionTypeSpecs
        ]

        app_arg_cnt = len(app_args)

        txn_args: list[pt.abi.Transaction] = [
            arg for arg in args if arg.type_spec() in pt.abi.TransactionTypeSpecs
        ]

        loading: list[pt.Expr] = []

        if app_arg_cnt > pt.METHOD_ARG_NUM_CUTOFF:
            sdk_last_arg = pt.abi.TupleTypeSpec(
                *[arg.type_spec() for arg in app_args[pt.METHOD_ARG_NUM_CUTOFF - 1 :]]
            ).new_instance()

            loading = [
                arg.decode(pt.Txn.application_args[index + 1])
                for index, arg in enumerate(app_args[: pt.METHOD_ARG_NUM_CUTOFF - 1])
            ]

            loading.append(
                sdk_last_arg.decode(pt.Txn.application_args[pt.METHOD_ARG_NUM_CUTOFF])
            )
        else:
            loading = [
                arg.decode(pt.Txn.application_args[index + 1])
                for index, arg in enumerate(app_args)
            ]

        if len(txn_args) > 0:
            for idx, txn_arg in enumerate(txn_args):
                loading.append(
                    txn_arg._set_index(
                        pt.Txn.group_index() - pt.Int(len(txn_args) - idx)
                    )
                )
                if str(txn_arg.type_spec()) != "txn":
                    loading.append(
                        pt.Assert(
                            txn_arg.get().type_enum()
                            == txn_arg.type_spec().txn_type_enum()
                        )
                    )

        if app_arg_cnt > pt.METHOD_ARG_NUM_CUTOFF:
            loading.extend(
                [
                    sdk_last_arg[idx].store_into(val)
                    for idx, val in enumerate(app_args[pt.METHOD_ARG_NUM_CUTOFF - 1 :])
                ]
            )

        evaluate: pt.Expr
        if abi_subroutine.type_of() != "void":
            output_temp = abi_subroutine.output_kwarg_info.abi_type.new_instance()
            evaluate = pt.Seq(
                abi_subroutine(*args).store_into(output_temp),
                pt.abi.MethodReturn(output_temp),
            )
        else:
            evaluate = abi_subroutine(*args)

        expected = assemble_helper(pt.Seq(*loading, evaluate, pt.Approve()))
        with (
            pt.TealComponent.Context.ignoreScratchSlotEquality(),
            pt.TealComponent.Context.ignoreExprEquality(),
        ):
            assert actual == expected

        assert pt.TealBlock.MatchScratchSlotReferences(
            pt.TealBlock.GetReferencedScratchSlots(actual),
            pt.TealBlock.GetReferencedScratchSlots(expected),
        )


def test_wrap_handler_method_txn_types():
    wrapped: pt.Expr = ASTBuilder.wrap_handler(True, multiple_txn)
    actual: pt.TealBlock = assemble_helper(wrapped)

    args: list[pt.abi.Transaction] = [
        pt.abi.ApplicationCallTransaction(),
        pt.abi.AssetTransferTransaction(),
        pt.abi.PaymentTransaction(),
        pt.abi.Transaction(),
    ]
    output_temp = pt.abi.Uint64()
    expected_ast = pt.Seq(
        args[0]._set_index(pt.Txn.group_index() - pt.Int(4)),
        pt.Assert(args[0].get().type_enum() == pt.TxnType.ApplicationCall),
        args[1]._set_index(pt.Txn.group_index() - pt.Int(3)),
        pt.Assert(args[1].get().type_enum() == pt.TxnType.AssetTransfer),
        args[2]._set_index(pt.Txn.group_index() - pt.Int(2)),
        pt.Assert(args[2].get().type_enum() == pt.TxnType.Payment),
        args[3]._set_index(pt.Txn.group_index() - pt.Int(1)),
        multiple_txn(*args).store_into(output_temp),
        pt.abi.MethodReturn(output_temp),
        pt.Approve(),
    )

    expected = assemble_helper(expected_ast)
    with (
        pt.TealComponent.Context.ignoreScratchSlotEquality(),
        pt.TealComponent.Context.ignoreExprEquality(),
    ):
        assert actual == expected

    assert pt.TealBlock.MatchScratchSlotReferences(
        pt.TealBlock.GetReferencedScratchSlots(actual),
        pt.TealBlock.GetReferencedScratchSlots(expected),
    )


def test_wrap_handler_method_call_many_args():
    wrapped: pt.Expr = ASTBuilder.wrap_handler(True, many_args)
    actual: pt.TealBlock = assemble_helper(wrapped)

    args = [pt.abi.Uint64() for _ in range(20)]
    last_arg = pt.abi.TupleTypeSpec(
        *[pt.abi.Uint64TypeSpec() for _ in range(6)]
    ).new_instance()

    output_temp = pt.abi.Uint64()
    expected_ast = pt.Seq(
        args[0].decode(pt.Txn.application_args[1]),
        args[1].decode(pt.Txn.application_args[2]),
        args[2].decode(pt.Txn.application_args[3]),
        args[3].decode(pt.Txn.application_args[4]),
        args[4].decode(pt.Txn.application_args[5]),
        args[5].decode(pt.Txn.application_args[6]),
        args[6].decode(pt.Txn.application_args[7]),
        args[7].decode(pt.Txn.application_args[8]),
        args[8].decode(pt.Txn.application_args[9]),
        args[9].decode(pt.Txn.application_args[10]),
        args[10].decode(pt.Txn.application_args[11]),
        args[11].decode(pt.Txn.application_args[12]),
        args[12].decode(pt.Txn.application_args[13]),
        args[13].decode(pt.Txn.application_args[14]),
        last_arg.decode(pt.Txn.application_args[15]),
        last_arg[0].store_into(args[14]),
        last_arg[1].store_into(args[15]),
        last_arg[2].store_into(args[16]),
        last_arg[3].store_into(args[17]),
        last_arg[4].store_into(args[18]),
        last_arg[5].store_into(args[19]),
        many_args(*args).store_into(output_temp),
        pt.abi.MethodReturn(output_temp),
        pt.Approve(),
    )
    expected = assemble_helper(expected_ast)
    with (
        pt.TealComponent.Context.ignoreScratchSlotEquality(),
        pt.TealComponent.Context.ignoreExprEquality(),
    ):
        assert actual == expected

    assert pt.TealBlock.MatchScratchSlotReferences(
        pt.TealBlock.GetReferencedScratchSlots(actual),
        pt.TealBlock.GetReferencedScratchSlots(expected),
    )


def test_contract_json_obj():
    abi_subroutines = list(
        filter(lambda x: isinstance(x, pt.ABIReturnSubroutine), GOOD_SUBROUTINE_CASES)
    )
    contract_name = "contract_name"
    router = pt.Router(contract_name, clear_state=safe_clear_state_delete)
    method_list: list[sdk_abi.Method] = []
    for subroutine in abi_subroutines:
        doc = subroutine.subroutine.implementation.__doc__
        desc = None
        if doc is not None and doc.strip() == "replace me":
            desc = "dope description"

        router.add_method_handler(subroutine, description=desc)

        ms = subroutine.method_spec()

        # Manually replace it since the override is applied in the method handler
        # not attached to the ABIReturnSubroutine itself
        ms.desc = desc or ms.desc

        sig_method = sdk_abi.Method.from_signature(subroutine.method_signature())

        assert ms.name == sig_method.name

        for idx, arg in enumerate(ms.args):
            assert arg.type == sig_method.args[idx].type

        method_list.append(ms)

    sdk_contract = sdk_abi.Contract(contract_name, method_list)
    contract = router.contract_construct()
    assert contract == sdk_contract


def test_build_program_all_empty():
    router = pt.Router("test")

    approval, clear_state, contract = router._build_program()

    expected_empty_program = pt.TealSimpleBlock(
        [
            pt.TealOp(None, pt.Op.int, 0),
            pt.TealOp(None, pt.Op.return_),
        ]
    )

    with pt.TealComponent.Context.ignoreExprEquality():
        assert assemble_helper(approval) == expected_empty_program
        assert assemble_helper(clear_state) == expected_empty_program

    expected_contract = sdk_abi.Contract("test", [])
    assert contract == expected_contract


def test_build_program_approval_empty():
    router = pt.Router("test", clear_state=pt.Approve())

    approval, clear_state, contract = router._build_program()

    expected_empty_program = pt.TealSimpleBlock(
        [
            pt.TealOp(None, pt.Op.int, 0),
            pt.TealOp(None, pt.Op.return_),
        ]
    )

    with pt.TealComponent.Context.ignoreExprEquality():
        assert assemble_helper(approval) == expected_empty_program
        assert assemble_helper(clear_state) != expected_empty_program

    expected_contract = sdk_abi.Contract("test", [])
    assert contract == expected_contract


def test_build_program_clear_state_empty():
    router = pt.Router(
        "test", pt.BareCallActions(no_op=pt.OnCompleteAction.always(pt.Approve()))
    )

    approval, clear_state, contract = router._build_program()

    expected_empty_program = pt.TealSimpleBlock(
        [
            pt.TealOp(None, pt.Op.int, 0),
            pt.TealOp(None, pt.Op.return_),
        ]
    )

    with pt.TealComponent.Context.ignoreExprEquality():
        assert assemble_helper(approval) != expected_empty_program
        assert assemble_helper(clear_state) == expected_empty_program

    expected_contract = sdk_abi.Contract("test", [])
    assert contract == expected_contract


def test_build_program_clear_state_invalid_config():
    for config in (pt.CallConfig.CREATE, pt.CallConfig.ALL):
        with pytest.raises(
            pt.TealInputError,
            match=r"^Attempt to construct clear state program from bare app call",
        ):
            pt.BareCallActions(
                clear_state=pt.OnCompleteAction(action=pt.Approve(), call_config=config)
            )

        router = pt.Router("test")  # once without a clear_state
        router = pt.Router("test", clear_state=pt.Approve())  # and for the rest, with

        with pytest.raises(
            pt.TealInputError,
            match=r"^Attempt to register ABI method for clear state program",
        ):

            @router.method(clear_state=pt.Int(1))
            def clear_state_method_fails():
                return pt.Approve()

        @pt.ABIReturnSubroutine
        def clear_state_method_succeeds():
            return pt.Approve()

        with pytest.raises(
            pt.TealInputError,
            match=r"^Attempt to construct clear state program from MethodConfig",
        ):
            router.add_method_handler(
                clear_state_method_succeeds,
                method_config=pt.MethodConfig(clear_state=config),
            )


def test_build_program_clear_state_valid_config():
    action = pt.If(pt.Txn.fee() == pt.Int(4)).Then(pt.Approve()).Else(pt.Reject())

    router_with_bare_call = pt.Router(
        "test",
        clear_state=action,
    )
    _, actual_clear_state_with_bare_call, _ = router_with_bare_call._build_program()

    expected_clear_state_with_bare_call = assemble_helper(action)

    with pt.TealComponent.Context.ignoreExprEquality():
        assert (
            assemble_helper(actual_clear_state_with_bare_call)
            == expected_clear_state_with_bare_call
        )


def test_override_names():
    r1 = pt.Router("test")

    @r1.method(name="handle")
    def handle_asa(deposit: pt.abi.AssetTransferTransaction):
        """handles the deposit where the input is an asset transfer"""
        return pt.Assert(deposit.get().asset_amount() > pt.Int(0))

    @r1.method(name="handle")
    def handle_algo(deposit: pt.abi.PaymentTransaction):
        """handles the deposit where the input is a payment"""
        return pt.Assert(deposit.get().amount() > pt.Int(0))

    ap1, cs1, c1 = r1.compile_program(version=pt.compiler.MAX_PROGRAM_VERSION)
    assert len(c1.methods) == 2
    for meth in c1.methods:
        dmeth = meth.dictify()
        assert dmeth["name"] == "handle"

    # Confirm an equivalent router definition _without_ `name` overrides produces the same output.
    r2 = pt.Router("test")

    @r2.method()
    def handle(deposit: pt.abi.AssetTransferTransaction):
        """handles the deposit where the input is an asset transfer"""
        return pt.Assert(deposit.get().asset_amount() > pt.Int(0))

    @r2.method()
    def handle(deposit: pt.abi.PaymentTransaction):  # noqa: F811
        """handles the deposit where the input is a payment"""
        return pt.Assert(deposit.get().amount() > pt.Int(0))

    ap2, cs2, c2 = r2.compile_program(version=pt.compiler.MAX_PROGRAM_VERSION)

    assert (ap1, cs1, c1) == (ap2, cs2, c2)


def test_router_compile_program_idempotence():
    on_completion_actions = pt.BareCallActions(
        opt_in=pt.OnCompleteAction.call_only(pt.Log(pt.Bytes("optin call"))),
    )
    router = pt.Router("questionable", on_completion_actions, clear_state=pt.Approve())

    approval1, clear1, contract1 = router.compile_program(version=6)
    approval2, clear2, contract2 = router.compile_program(version=6)

    assert contract1.dictify() == contract2.dictify()
    assert clear1 == clear2
    assert approval1 == approval2

    @pt.ABIReturnSubroutine
    def add(a: pt.abi.Uint64, b: pt.abi.Uint64, *, output: pt.abi.Uint64) -> pt.Expr:
        return output.set(a.get() + b.get())

    meth = router.add_method_handler(add)
    assert meth.method_signature() == "add(uint64,uint64)uint64"

    # formerly nextSlotId: 256 --> 262:
    approval1, clear1, contract1 = router.compile_program(version=6)
    # formerly nextSlotId: 262 --> 265:
    approval2, clear2, contract2 = router.compile_program(version=6)
    # formerly nextSlotId: 265 --> 268:
    approval3, clear3, contract3 = router.compile_program(version=6)

    assert contract2.dictify() == contract3.dictify()
    assert clear3 == clear2
    assert approval3 == approval3

    assert contract2.dictify() == contract1.dictify()
    assert clear2 == clear1
    assert (
        approval2 == approval1
    ), f"""{approval1=}
{approval2=}"""



================================================
FILE: pyteal/ast/scratch.py
================================================
from typing import cast, TYPE_CHECKING

from pyteal.types import TealType, require_type
from pyteal.config import NUM_SLOTS
from pyteal.errors import TealInputError, TealInternalError
from pyteal.ast.expr import Expr

if TYPE_CHECKING:
    from pyteal.compiler import CompileOptions


class ScratchSlot:
    """Represents the allocation of a scratch space slot."""

    # Unique identifier for the compiler to automatically assign slots
    # The id field is used by the compiler to map to an actual slot in the source code
    # Slot ids under 256 are manually reserved slots
    nextSlotId: int = NUM_SLOTS

    @classmethod
    def reset_slot_numbering(cls, start_index: int = NUM_SLOTS) -> None:
        cls.nextSlotId = start_index

    def __init__(self, requestedSlotId: int | None = None):
        """Initializes a scratch slot with a particular id

        Args:
            requestedSlotId (optional): A scratch slot id that the compiler must store the value.
                This id may be a Python int in the range [0-256).
        """
        if requestedSlotId is None:
            self.id = ScratchSlot.nextSlotId
            ScratchSlot.nextSlotId += 1
            self.isReservedSlot = False
        else:
            if requestedSlotId < 0 or requestedSlotId >= NUM_SLOTS:
                raise TealInputError(
                    "Invalid slot ID {}, should be in [0, {})".format(
                        requestedSlotId, NUM_SLOTS
                    )
                )
            self.id = requestedSlotId
            self.isReservedSlot = True

    def store(self, value: Expr | None = None) -> Expr:
        """Get an expression to store a value in this slot.

        Args:
            value (optional): The value to store in this slot.
                If not included, the last value on the stack will be stored.
                NOTE: storing the last value on the stack breaks the typical
                semantics of PyTeal, only use if you know what you're doing.
        """
        if value is not None:
            return ScratchStore(self, value)
        return ScratchStackStore(self)

    def load(self, type: TealType = TealType.anytype) -> "ScratchLoad":
        """Get an expression to load a value from this slot.

        Args:
            type (optional): The type being loaded from this slot, if known. Defaults to
                TealType.anytype.
        """
        return ScratchLoad(self, type)

    def index(self) -> "ScratchIndex":
        return ScratchIndex(self)

    def __repr__(self):
        return "ScratchSlot({})".format(self.id)

    def __str__(self):
        return "slot#{}".format(self.id)


ScratchSlot.__module__ = "pyteal"


class ScratchIndex(Expr):
    def __init__(self, slot: ScratchSlot):
        super().__init__()
        self.slot = slot

    def __str__(self):
        return "(ScratchIndex {})".format(self.slot)

    def type_of(self):
        return TealType.uint64

    def has_return(self):
        return False

    def __teal__(self, options: "CompileOptions"):
        from pyteal.ir import TealOp, Op, TealBlock

        op = TealOp(self, Op.int, self.slot)
        return TealBlock.FromOp(options, op)


ScratchIndex.__module__ = "pyteal"


class ScratchLoad(Expr):
    """Expression to load a value from scratch space."""

    def __init__(
        self,
        slot: ScratchSlot | None = None,
        type: TealType = TealType.anytype,
        index_expression: Expr | None = None,
    ):
        """Create a new ScratchLoad expression.

        Args:
            slot (optional): The slot to load the value from.
            type (optional): The type being loaded from this slot, if known. Defaults to
                TealType.anytype.
            index_expression (optional): As an alternative to slot,
                an expression can be supplied for the slot index.
        """
        super().__init__()

        if (slot is None) == (index_expression is None):
            raise TealInputError(
                "Exactly one of slot or index_expressions must be provided"
            )

        if index_expression:
            if not isinstance(index_expression, Expr):
                raise TealInputError(
                    "index_expression must be an Expr but was of type {}".format(
                        type(index_expression)
                    )
                )
            require_type(index_expression, TealType.uint64)

        if slot and not isinstance(slot, ScratchSlot):
            raise TealInputError(
                "cannot handle slot of type {}".format(type(self.slot))
            )

        self.slot = slot
        self.type = type
        self.index_expression = index_expression

    def __str__(self):
        return "(Load {})".format(self.slot if self.slot else self.index_expression)

    def __teal__(self, options: "CompileOptions"):
        from pyteal.ir import TealOp, Op, TealBlock

        if self.index_expression is not None:
            op = TealOp(self, Op.loads)
            return TealBlock.FromOp(options, op, self.index_expression)

        s = cast(ScratchSlot, self.slot)
        op = TealOp(self, Op.load, s)
        return TealBlock.FromOp(options, op)

    def type_of(self):
        return self.type

    def has_return(self):
        return False


ScratchLoad.__module__ = "pyteal"


class ScratchStore(Expr):
    """Expression to store a value in scratch space."""

    def __init__(
        self,
        slot: ScratchSlot | None,
        value: Expr,
        index_expression: Expr | None = None,
    ):
        """Create a new ScratchStore expression.

        Args:
            slot (optional): The slot to store the value in.
            value: The value to store.
            index_expression (optional): As an alternative to slot,
                an expression can be supplied for the slot index.
        """
        super().__init__()

        if (slot is None) == (index_expression is None):
            raise TealInternalError(
                "Exactly one of slot or index_expressions must be provided"
            )

        if index_expression:
            if not isinstance(index_expression, Expr):
                raise TealInputError(
                    "index_expression must be an Expr but was of type {}".format(
                        type(index_expression)
                    )
                )
            require_type(index_expression, TealType.uint64)

        self.slot = slot
        self.value = value
        self.index_expression = index_expression

    def __str__(self):
        return "(Store {} {})".format(
            self.slot if self.slot else self.index_expression, self.value
        )

    def __teal__(self, options: "CompileOptions"):
        from pyteal.ir import TealOp, Op, TealBlock

        if self.index_expression is not None:
            op = TealOp(self, Op.stores)
            return TealBlock.FromOp(options, op, self.index_expression, self.value)

        if not isinstance(self.slot, ScratchSlot):
            raise TealInternalError(
                "cannot handle slot of type {}".format(type(self.slot))
            )
        op = TealOp(self, Op.store, self.slot)
        return TealBlock.FromOp(options, op, self.value)

    def type_of(self):
        return TealType.none

    def has_return(self):
        return False


ScratchStore.__module__ = "pyteal"


class ScratchStackStore(Expr):
    """Expression to store a value from the stack in scratch space.

    NOTE: This expression breaks the typical semantics of PyTeal, only use if you know what you're
    doing.
    """

    def __init__(self, slot: ScratchSlot):
        """Create a new ScratchStackStore expression.

        Args:
            slot: The slot to store the value in.
        """
        super().__init__()
        self.slot = slot
        self._sframes_container: Expr | None = None

    def __str__(self):
        return "(StackStore {})".format(self.slot)

    def __teal__(self, options: "CompileOptions"):
        from pyteal.ir import TealOp, Op, TealBlock

        op = TealOp(self, Op.store, self.slot)
        op._sframes_container = self._sframes_container
        return TealBlock.FromOp(options, op)

    def type_of(self):
        return TealType.none

    def has_return(self):
        return False


ScratchStackStore.__module__ = "pyteal"



================================================
FILE: pyteal/ast/scratch_test.py
================================================
import pytest

import pyteal as pt

options = pt.CompileOptions()


def test_scratch_slot():
    slot = pt.ScratchSlot()
    assert slot == slot
    assert slot.__hash__() == slot.__hash__()
    assert slot != pt.ScratchSlot()

    with pt.TealComponent.Context.ignoreExprEquality():
        assert (
            slot.store().__teal__(options)[0]
            == pt.ScratchStackStore(slot).__teal__(options)[0]
        )
        assert (
            slot.store(pt.Int(1)).__teal__(options)[0]
            == pt.ScratchStore(slot, pt.Int(1)).__teal__(options)[0]
        )

        assert slot.load().type_of() == pt.TealType.anytype
        assert slot.load(pt.TealType.uint64).type_of() == pt.TealType.uint64
        assert (
            slot.load().__teal__(options)[0]
            == pt.ScratchLoad(slot).__teal__(options)[0]
        )


def test_scratch_load_default():
    slot = pt.ScratchSlot()
    expr = pt.ScratchLoad(slot)
    assert expr.type_of() == pt.TealType.anytype

    expected = pt.TealSimpleBlock([pt.TealOp(expr, pt.Op.load, slot)])

    actual, _ = expr.__teal__(options)

    assert actual == expected


def test_scratch_load_index_expression():
    expr = pt.ScratchLoad(slot=None, index_expression=pt.Int(1337))
    assert expr.type_of() == pt.TealType.anytype

    expected = pt.TealSimpleBlock([pt.TealOp(pt.Int(1337), pt.Op.int, 1337)])
    expected.setNextBlock(pt.TealSimpleBlock([pt.TealOp(None, pt.Op.loads)]))

    actual, _ = expr.__teal__(options)

    with pt.TealComponent.Context.ignoreExprEquality():
        assert actual == expected


def test_scratch_load_type():
    for type in (pt.TealType.uint64, pt.TealType.bytes, pt.TealType.anytype):
        slot = pt.ScratchSlot()
        expr = pt.ScratchLoad(slot, type)
        assert expr.type_of() == type

        expected = pt.TealSimpleBlock([pt.TealOp(expr, pt.Op.load, slot)])

        actual, _ = expr.__teal__(options)

        assert actual == expected


def test_scratch_store():
    for value in (
        pt.Int(1),
        pt.Bytes("test"),
        pt.App.globalGet(pt.Bytes("key")),
        pt.If(pt.Int(1), pt.Int(2), pt.Int(3)),
    ):
        slot = pt.ScratchSlot()
        expr = pt.ScratchStore(slot, value)
        assert expr.type_of() == pt.TealType.none

        expected, valueEnd = value.__teal__(options)
        storeBlock = pt.TealSimpleBlock([pt.TealOp(expr, pt.Op.store, slot)])
        valueEnd.setNextBlock(storeBlock)

        actual, _ = expr.__teal__(options)

        assert actual == expected


def test_scratch_store_index_expression():
    for value in (
        pt.Int(1),
        pt.Bytes("test"),
        pt.App.globalGet(pt.Bytes("key")),
        pt.If(pt.Int(1), pt.Int(2), pt.Int(3)),
    ):
        expr = pt.ScratchStore(slot=None, value=value, index_expression=pt.Int(1337))
        assert expr.type_of() == pt.TealType.none

        expected = pt.TealSimpleBlock([pt.TealOp(None, pt.Op.int, 1337)])
        valueStart, valueEnd = value.__teal__(options)
        expected.setNextBlock(valueStart)

        storeBlock = pt.TealSimpleBlock([pt.TealOp(expr, pt.Op.stores)])
        valueEnd.setNextBlock(storeBlock)

        actual, _ = expr.__teal__(options)

        with pt.TealComponent.Context.ignoreExprEquality():
            assert actual == expected


def test_scratch_stack_store():
    slot = pt.ScratchSlot()
    expr = pt.ScratchStackStore(slot)
    assert expr.type_of() == pt.TealType.none

    expected = pt.TealSimpleBlock([pt.TealOp(expr, pt.Op.store, slot)])

    actual, _ = expr.__teal__(options)

    assert actual == expected


def test_scratch_assign_id():
    slot = pt.ScratchSlot(255)
    expr = pt.ScratchStackStore(slot)
    assert expr.type_of() == pt.TealType.none

    expected = pt.TealSimpleBlock([pt.TealOp(expr, pt.Op.store, slot)])

    actual, _ = expr.__teal__(options)

    assert actual == expected


def test_scratch_assign_id_invalid():
    with pytest.raises(pt.TealInputError):
        pt.ScratchSlot(-1)

    with pytest.raises(pt.TealInputError):
        pt.ScratchSlot(pt.NUM_SLOTS)


def test_scratch_index():
    slot = pt.ScratchSlot()

    index = pt.ScratchIndex(slot)
    assert index.slot is slot

    assert str(index) == "(ScratchIndex " + str(slot) + ")"

    assert index.type_of() == pt.TealType.uint64

    assert not index.has_return()

    expected = pt.TealSimpleBlock([pt.TealOp(index, pt.Op.int, slot)])
    actual, _ = index.__teal__(options)

    assert actual == expected



================================================
FILE: pyteal/ast/scratchvar.py
================================================
from pyteal.errors import TealInputError
from pyteal.types import TealType, require_type

from pyteal.ast.abstractvar import AbstractVar
from pyteal.ast.expr import Expr
from pyteal.ast.scratch import ScratchSlot, ScratchLoad, ScratchStore


class ScratchVar(AbstractVar):
    """
    Interface around Scratch space, similar to get/put local/global state

    Example:
        .. code-block:: python

            myvar = ScratchVar(TealType.uint64)
            Seq([
                myvar.store(Int(5)),
                Assert(myvar.load() == Int(5))
            ])
    """

    def __init__(self, type: TealType = TealType.anytype, slotId: int | None = None):
        """Create a new ScratchVar with an optional type.

        Args:
            type (optional): The type that this variable can hold. An error will be thrown if an
                expression with an incompatible type is stored in this variable. Defaults to
                TealType.anytype.
            slotId (optional): A scratch slot id that the compiler must store the value.
                This id may be a Python int in the range [0-256).
        """
        self.slot = ScratchSlot(requestedSlotId=slotId)
        self.type = type

    def storage_type(self) -> TealType:
        """Get the type of expressions that can be stored in this ScratchVar."""
        return self.type

    def store(self, value: Expr) -> Expr:
        """Store value in Scratch Space

        Args:
            value: The value to store. Must conform to this ScratchVar's type.
        """
        require_type(value, self.type)
        return self.slot.store(value)

    def load(self) -> ScratchLoad:
        """Load value from Scratch Space"""
        return self.slot.load(self.type)

    def index(self) -> Expr:
        return self.slot.index()


ScratchVar.__module__ = "pyteal"


class DynamicScratchVar(ScratchVar):
    """
    Example of Dynamic Scratch space whereby the slot index is picked up from the stack:
        .. code-block:: python

            player_score = DynamicScratchVar(TealType.uint64)

            wilt = ScratchVar(TealType.uint64, 129)
            kobe = ScratchVar(TealType.uint64)
            dt = ScratchVar(TealType.uint64, 131)

            seq = Seq(
                player_score.set_index(wilt),
                player_score.store(Int(100)),
                player_score.set_index(kobe),
                player_score.store(Int(81)),
                player_score.set_index(dt),
                player_score.store(Int(73)),
                Assert(player_score.load() == Int(73)),
                Assert(player_score.index() == Int(131)),
                player_score.set_index(wilt),
                Assert(player_score.load() == Int(100)),
                Assert(player_score.index() == Int(129)),
                Int(100),
            )
    """

    def __init__(self, ttype: TealType = TealType.anytype):
        """Create a new DynamicScratchVar which references other ScratchVar's

        Args:
            ttype (optional): The type that this variable can hold. Defaults to TealType.anytype.
        """
        super().__init__(TealType.uint64)
        self.dynamic_type = ttype  # differentiates from ScratchVar.type

    def set_index(self, index_var: ScratchVar) -> Expr:
        """Set this DynamicScratchVar to reference the provided `index_var`.
        Followup `store`, `load` and `index` operations will use the provided `index_var` until
        `set_index()` is called again to reset the referenced ScratchVar.
        """
        # Explanatory comment per Issue #242: Preliminary evidence shows that letting users
        # pass in any ScratchVar subtype (i.e. DynamicScratchVar) may in fact work.
        # However, we are leaving this guard in place pending further investigation.
        # TODO: gain confidence that DynamicScratchVar can be used here and
        # modify the below strict type equality to `isinstance(index_var, ScratchVar)`
        if type(index_var) is not ScratchVar:
            raise TealInputError(
                "Only allowed to use ScratchVar objects for setting indices, but was given a {}".format(
                    type(index_var)
                )
            )

        return super().store(index_var.index())

    def storage_type(self) -> TealType:
        """Get the type of expressions that can be stored in this ScratchVar."""
        return self.dynamic_type

    def store(self, value: Expr) -> Expr:
        """Store the value in the referenced ScratchVar."""

        require_type(value, self.dynamic_type)
        return ScratchStore(slot=None, value=value, index_expression=self.index())

    def load(self) -> ScratchLoad:
        """Load the current value from the referenced ScratchVar."""
        return ScratchLoad(
            slot=None, type=self.dynamic_type, index_expression=self.index()
        )

    def index(self) -> Expr:
        """Get the index of the referenced ScratchVar."""
        return super().load()

    def internal_index(self) -> Expr:
        """Get the index of _this_ DynamicScratchVar, as opposed to that of the referenced ScratchVar."""
        return super().index()


DynamicScratchVar.__module__ = "pyteal"



================================================
FILE: pyteal/ast/scratchvar_test.py
================================================
import pytest

import pyteal as pt

options = pt.CompileOptions()


def test_scratchvar_type():
    myvar_default = pt.ScratchVar()
    assert myvar_default.storage_type() == pt.TealType.anytype
    assert myvar_default.store(pt.Bytes("value")).type_of() == pt.TealType.none
    assert myvar_default.load().type_of() == pt.TealType.anytype

    with pytest.raises(pt.TealTypeError):
        myvar_default.store(pt.Pop(pt.Int(1)))

    myvar_int = pt.ScratchVar(pt.TealType.uint64)
    assert myvar_int.storage_type() == pt.TealType.uint64
    assert myvar_int.store(pt.Int(1)).type_of() == pt.TealType.none
    assert myvar_int.load().type_of() == pt.TealType.uint64

    with pytest.raises(pt.TealTypeError):
        myvar_int.store(pt.Bytes("value"))

    with pytest.raises(pt.TealTypeError):
        myvar_int.store(pt.Pop(pt.Int(1)))

    myvar_bytes = pt.ScratchVar(pt.TealType.bytes)
    assert myvar_bytes.storage_type() == pt.TealType.bytes
    assert myvar_bytes.store(pt.Bytes("value")).type_of() == pt.TealType.none
    assert myvar_bytes.load().type_of() == pt.TealType.bytes

    with pytest.raises(pt.TealTypeError):
        myvar_bytes.store(pt.Int(0))

    with pytest.raises(pt.TealTypeError):
        myvar_bytes.store(pt.Pop(pt.Int(1)))


def test_scratchvar_store():
    myvar = pt.ScratchVar(pt.TealType.bytes)
    arg = pt.Bytes("value")
    expr = myvar.store(arg)

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(arg, pt.Op.byte, '"value"'),
            pt.TealOp(expr, pt.Op.store, myvar.slot),
        ]
    )

    actual, _ = expr.__teal__(options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    assert actual == expected


def test_scratchvar_load():
    myvar = pt.ScratchVar()
    expr = myvar.load()

    expected = pt.TealSimpleBlock([pt.TealOp(expr, pt.Op.load, myvar.slot)])

    actual, _ = expr.__teal__(options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    assert actual == expected


def test_scratchvar_index():
    myvar = pt.ScratchVar()
    expr = myvar.index()

    expected = pt.TealSimpleBlock([pt.TealOp(expr, pt.Op.int, myvar.slot)])

    actual, _ = expr.__teal__(options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    assert actual == expected


def test_scratchvar_assign_store():
    slotId = 2
    myvar = pt.ScratchVar(pt.TealType.uint64, slotId)
    arg = pt.Int(10)
    expr = myvar.store(arg)

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(arg, pt.Op.int, 10),
            pt.TealOp(expr, pt.Op.store, myvar.slot),
        ]
    )

    actual, _ = expr.__teal__(options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    assert actual == expected


def test_scratchvar_assign_load():
    slotId = 5
    myvar = pt.ScratchVar(slotId=slotId)
    expr = myvar.load()

    expected = pt.TealSimpleBlock([pt.TealOp(expr, pt.Op.load, myvar.slot)])

    actual, _ = expr.__teal__(options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    assert actual == expected


def test_dynamic_scratchvar_type():
    myvar_default = pt.DynamicScratchVar()
    assert myvar_default.storage_type() == pt.TealType.anytype
    assert myvar_default.store(pt.Bytes("value")).type_of() == pt.TealType.none
    assert myvar_default.load().type_of() == pt.TealType.anytype

    with pytest.raises(pt.TealTypeError):
        myvar_default.store(pt.Pop(pt.Int(1)))

    myvar_int = pt.DynamicScratchVar(pt.TealType.uint64)
    assert myvar_int.storage_type() == pt.TealType.uint64
    assert myvar_int.store(pt.Int(1)).type_of() == pt.TealType.none
    assert myvar_int.load().type_of() == pt.TealType.uint64

    with pytest.raises(pt.TealTypeError):
        myvar_int.store(pt.Bytes("value"))

    with pytest.raises(pt.TealTypeError):
        myvar_int.store(pt.Pop(pt.Int(1)))

    myvar_bytes = pt.DynamicScratchVar(pt.TealType.bytes)
    assert myvar_bytes.storage_type() == pt.TealType.bytes
    assert myvar_bytes.store(pt.Bytes("value")).type_of() == pt.TealType.none
    assert myvar_bytes.load().type_of() == pt.TealType.bytes

    with pytest.raises(pt.TealTypeError):
        myvar_bytes.store(pt.Int(0))

    with pytest.raises(pt.TealTypeError):
        myvar_bytes.store(pt.Pop(pt.Int(1)))


def test_dynamic_scratchvar_load():
    myvar = pt.DynamicScratchVar()
    expr = myvar.load()

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(pt.ScratchLoad(myvar.slot), pt.Op.load, myvar.slot),
            pt.TealOp(expr, pt.Op.loads),
        ]
    )

    actual, _ = expr.__teal__(options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    with pt.TealComponent.Context.ignoreExprEquality():
        assert actual == expected


def test_dynamic_scratchvar_store():
    myvar = pt.DynamicScratchVar(pt.TealType.bytes)
    arg = pt.Bytes("value")
    expr = myvar.store(arg)

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(pt.ScratchLoad(myvar.slot), pt.Op.load, myvar.slot),
            pt.TealOp(arg, pt.Op.byte, '"value"'),
            pt.TealOp(expr, pt.Op.stores),
        ]
    )

    actual, _ = expr.__teal__(options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    with pt.TealComponent.Context.ignoreExprEquality():
        assert actual == expected


def test_dynamic_scratchvar_index():
    myvar = pt.DynamicScratchVar()
    expr = myvar.index()

    expected = pt.TealSimpleBlock([pt.TealOp(expr, pt.Op.load, myvar.slot)])

    actual, _ = expr.__teal__(options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    assert actual == expected


def test_dynamic_scratchvar_cannot_set_index_to_another_dynamic():
    myvar = pt.DynamicScratchVar()
    myvar.load()

    regvar = pt.ScratchVar()
    myvar.set_index(regvar)

    dynvar = pt.DynamicScratchVar()

    with pytest.raises(pt.TealInputError):
        myvar.set_index(dynvar)



================================================
FILE: pyteal/ast/seq.py
================================================
from typing import List, TYPE_CHECKING, overload

from pyteal.types import TealType, require_type
from pyteal.errors import TealInputError, TealTypeError, TealSeqError
from pyteal.ir import TealSimpleBlock
from pyteal.ast.expr import Expr

if TYPE_CHECKING:
    from pyteal.compiler import CompileOptions


class Seq(Expr):
    """A control flow expression to represent a sequence of expressions."""

    @overload
    def __init__(self, *exprs: Expr) -> None:
        pass

    @overload
    def __init__(self, exprs: List[Expr]) -> None:
        pass

    def __init__(self, *exprs):
        """
        __init__(*exprs: Expr) -> None
        __init__(exprs: List[Expr]) -> None

        Create a new Seq expression.

        The new Seq expression will take on the return value of the final expression in the sequence.

        Args:
            exprs: The expressions to include in this sequence. All expressions that are not the
                final one in this list must not return any values.

        Example:
            .. code-block:: python

                Seq([
                    App.localPut(Bytes("key"), Bytes("value")),
                    Int(1)
                ])
        """
        super().__init__()

        # Handle case where a list of expressions is provided
        if len(exprs) == 1 and isinstance(exprs[0], list):
            exprs = exprs[0]

        for i, expr in enumerate(exprs):
            if not isinstance(expr, Expr):
                raise TealInputError("{} is not a pyteal expression.".format(expr))
            if i + 1 < len(exprs):
                try:
                    require_type(expr, TealType.none)
                except TealTypeError:
                    message = "{} must have a return type of TealType.none. ".format(
                        expr
                    )
                    message += (
                        "Only the last entry of a Seq array can have a return value."
                    )
                    seq_error = TealSeqError(message)
                    raise seq_error

        self.args = exprs

    def __teal__(self, options: "CompileOptions"):
        start = TealSimpleBlock([])
        end = start
        for arg in self.args:
            argStart, argEnd = arg.__teal__(options)
            end.setNextBlock(argStart)
            end = argEnd
        return start, end

    def __str__(self):
        ret_str = "(Seq"
        for a in self.args:
            ret_str += " " + a.__str__()
        ret_str += ")"
        return ret_str

    def type_of(self):
        if len(self.args) == 0:
            return TealType.none
        return self.args[-1].type_of()

    def has_return(self):
        # this expression declares it has a return op only if its final expression has a return op
        # TODO: technically if ANY expression, not just the final one, returns true for has_return,
        # this could return true as well. But in that case all expressions after the one that
        # returns true for has_return is dead code, so it could be optimized away
        if len(self.args) == 0:
            return False
        return self.args[-1].has_return()


Seq.__module__ = "pyteal"


@overload
def _use_seq_if_multiple(exprs: list[Expr]) -> Expr: ...


@overload
def _use_seq_if_multiple(*exprs: Expr) -> Expr: ...


def _use_seq_if_multiple(*exprs):
    """If multiple expressions are provided, wrap them in a Seq expression."""

    # Guard against no expressions
    if len(exprs) == 0:
        raise TealInputError("Expressions cannot be empty.")

    # Handle case where a list of expressions is provided
    if len(exprs) == 1 and isinstance(exprs[0], list):
        exprs = exprs[0]

    if len(exprs) > 1:
        return Seq(*exprs)
    return exprs[0]



================================================
FILE: pyteal/ast/seq_test.py
================================================
import pytest

import pyteal as pt
from pyteal.ast.seq import _use_seq_if_multiple

options = pt.CompileOptions()


def test_seq_zero():
    for expr in (pt.Seq(), pt.Seq([])):
        assert expr.type_of() == pt.TealType.none
        assert not expr.has_return()

        expected = pt.TealSimpleBlock([])

        actual, _ = expr.__teal__(options)

        assert actual == expected


def test_seq_one():
    items = [pt.Int(0)]
    expr = pt.Seq(items)
    assert expr.type_of() == pt.TealType.uint64

    expected, _ = items[0].__teal__(options)

    actual, _ = expr.__teal__(options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    assert actual == expected


def test_seq_two():
    items = [pt.App.localPut(pt.Int(0), pt.Bytes("key"), pt.Int(1)), pt.Int(7)]
    expr = pt.Seq(items)
    assert expr.type_of() == items[-1].type_of()

    expected, first_end = items[0].__teal__(options)
    first_end.setNextBlock(items[1].__teal__(options)[0])
    expected.addIncoming()
    expected = pt.TealBlock.NormalizeBlocks(expected)

    actual, _ = expr.__teal__(options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    assert actual == expected


def test_seq_three():
    items = [
        pt.App.localPut(pt.Int(0), pt.Bytes("key1"), pt.Int(1)),
        pt.App.localPut(pt.Int(1), pt.Bytes("key2"), pt.Bytes("value2")),
        pt.Pop(pt.Bytes("end")),
    ]
    expr = pt.Seq(items)
    assert expr.type_of() == items[-1].type_of()

    expected, first_end = items[0].__teal__(options)
    second_start, second_end = items[1].__teal__(options)
    first_end.setNextBlock(second_start)
    third_start, _ = items[2].__teal__(options)
    second_end.setNextBlock(third_start)

    expected.addIncoming()
    expected = pt.TealBlock.NormalizeBlocks(expected)

    actual, _ = expr.__teal__(options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    assert actual == expected


def test_seq_has_return():
    exprWithReturn = pt.Seq(
        [
            pt.App.localPut(pt.Int(0), pt.Bytes("key1"), pt.Int(1)),
            pt.Return(pt.Int(1)),
        ]
    )
    assert exprWithReturn.has_return()

    exprWithoutReturn = pt.Seq(
        [pt.App.localPut(pt.Int(0), pt.Bytes("key1"), pt.Int(1)), pt.Int(1)]
    )
    assert not exprWithoutReturn.has_return()


def test_seq_invalid():
    with pytest.raises(pt.TealSeqError):
        pt.Seq([pt.Int(1), pt.Pop(pt.Int(2))])

    with pytest.raises(pt.TealSeqError):
        pt.Seq([pt.Int(1), pt.Int(2)])

    with pytest.raises(pt.TealSeqError):
        pt.Seq([pt.Seq([pt.Pop(pt.Int(1)), pt.Int(2)]), pt.Int(3)])


def test_seq_overloads_equivalence():
    items = [
        pt.App.localPut(pt.Int(0), pt.Bytes("key1"), pt.Int(1)),
        pt.App.localPut(pt.Int(1), pt.Bytes("key2"), pt.Bytes("value2")),
        pt.Pop(pt.Bytes("end")),
    ]
    expr1 = pt.Seq(items)
    expr2 = pt.Seq(*items)

    expected = expr1.__teal__(options)
    actual = expr2.__teal__(options)

    assert actual == expected


def test_use_seq_if_multiple():
    # Test a single expression
    items = [pt.Int(1)]
    expr = _use_seq_if_multiple(*items)

    expected = items[0].__teal__(options)
    actual = expr.__teal__(options)

    assert actual == expected

    # Test multiple expressions
    items = [pt.Pop(pt.Int(1)), pt.Int(2)]
    expr = _use_seq_if_multiple(*items)

    expected = pt.Seq(items).__teal__(options)
    actual = expr.__teal__(options)

    assert actual == expected


def test_use_seq_if_multiple_overloads_equivalence():
    items = [pt.Pop(pt.Int(1)), pt.Int(2)]
    expr = _use_seq_if_multiple(items)

    expected = pt.Seq(items).__teal__(options)
    actual = expr.__teal__(options)

    assert actual == expected



================================================
FILE: pyteal/ast/stake.py
================================================
from typing import TYPE_CHECKING

from pyteal.types import TealType
from pyteal.ir import TealOp, Op, TealBlock
from pyteal.errors import verifyProgramVersion
from pyteal.ast.leafexpr import LeafExpr

if TYPE_CHECKING:
    from pyteal.compiler import CompileOptions


class OnlineStake(LeafExpr):
    """An expression to obtain the online stake for the agreement round."""

    def __str__(self):
        return "(OnlineStake)"

    def __teal__(self, options: "CompileOptions"):
        verifyProgramVersion(
            Op.online_stake.min_version,
            options.version,
            "Program version too low to use OnlineStake expression",
        )

        op = TealOp(self, Op.online_stake)
        return TealBlock.FromOp(options, op)

    def type_of(self):
        return TealType.uint64


OnlineStake.__module__ = "pyteal"



================================================
FILE: pyteal/ast/stake_test.py
================================================
import pytest

import pyteal as pt

avm1Options = pt.CompileOptions(version=10)
avm11Options = pt.CompileOptions(version=11)


def test_online_stake_teal_10():
    with pytest.raises(pt.TealInputError):
        pt.OnlineStake().__teal__(avm1Options)


def test_online_stake():
    expr = pt.OnlineStake()
    assert expr.type_of() == pt.TealType.uint64

    expected = pt.TealSimpleBlock([pt.TealOp(expr, pt.Op.online_stake)])

    actual, _ = expr.__teal__(avm11Options)

    assert actual == expected



================================================
FILE: pyteal/ast/subroutine.py
================================================
from contextlib import contextmanager
import algosdk.abi as sdk_abi
import warnings

from dataclasses import dataclass
from docstring_parser import parse as parse_docstring
from inspect import isclass, Parameter, signature, get_annotations
from types import MappingProxyType, NoneType
from typing import Any, Callable, Final, TYPE_CHECKING, cast, ClassVar

from pyteal.ast import abi
from pyteal.ast.expr import Expr
from pyteal.ast.seq import Seq
from pyteal.ast.scratchvar import DynamicScratchVar, ScratchVar, ScratchSlot
from pyteal.ast.frame import FrameBury, Proto, FrameVar, ProtoStackLayout
from pyteal.errors import TealInputError, TealInternalError, verifyProgramVersion
from pyteal.ir import TealOp, Op, TealBlock
from pyteal.stack_frame import NatalStackFrame
from pyteal.types import TealType

if TYPE_CHECKING:
    from pyteal.compiler import CompileOptions


class _SubroutineDeclByOption:
    def __init__(self, subroutine_def: "SubroutineDefinition") -> None:
        self.subroutine: SubroutineDefinition = subroutine_def
        self.option_map: dict[bool, SubroutineDeclaration | None] = {
            True: None,
            False: None,
        }
        self.option_method: dict[bool, SubroutineEval] = {
            True: SubroutineEval.fp_evaluator(),
            False: SubroutineEval.normal_evaluator(),
        }
        self.has_return: bool | None = None
        self.type_of: TealType | None = None

    def get_declaration(self) -> "SubroutineDeclaration":
        warnings.warn(
            "`get_declaration` is being deprecated: Please use `get_declaration_by_option` instead.",
            DeprecationWarning,
        )
        return self.get_declaration_by_option(False)

    def get_declaration_by_option(
        self,
        fp_option: bool = True,
    ) -> "SubroutineDeclaration":
        decl = self.option_map[fp_option]
        if decl is not None:
            return decl
        self.option_map[fp_option] = self.option_method[fp_option].evaluate(
            self.subroutine
        )
        return cast(SubroutineDeclaration, self.option_map[fp_option])

    def __probe_info(self, fp_option: bool) -> tuple[bool, TealType]:
        starting_slot_id = ScratchSlot.nextSlotId
        is_pre_existing = self.option_map[fp_option] is not None
        decl = self.get_declaration_by_option(fp_option)
        has_return, type_of = decl.has_return(), decl.type_of()
        if not is_pre_existing:
            self.option_map[fp_option] = None
        ScratchSlot.reset_slot_numbering(starting_slot_id)
        return has_return, type_of

    def __info_prepare(self) -> None:
        if self.has_return is not None and self.type_of is not None:
            return
        ss_ret, ss_type = self.__probe_info(False)
        fp_ret, fp_type = self.__probe_info(True)
        assert ss_ret == fp_ret
        assert ss_type == fp_type
        self.has_return = ss_ret
        self.type_of = ss_type

    def versions_type_of(self) -> TealType:
        self.__info_prepare()
        return cast(TealType, self.type_of)

    def versions_has_return(self) -> bool:
        self.__info_prepare()
        return cast(bool, self.has_return)

    def get_declarations(self) -> None:
        self.option_map[False] = self.get_declaration_by_option(False)
        self.option_map[True] = self.get_declaration_by_option(True)


_SubroutineDeclByOption.__module__ = "pyteal"


class SubroutineDefinition:
    """
    Class that leverages TEAL's `callsub` and `retsub` opcode-pair for subroutines
    """

    nextSubroutineId = 0

    def __init__(
        self,
        implementation: Callable[..., Expr],
        return_type: TealType,
        name_str: str | None = None,
        has_abi_output: bool = False,
    ) -> None:
        """
        Args:
            implementation: The python function defining the subroutine
            return_type: the TealType to be returned by the subroutine
            name_str (optional): the name that is used to identify the subroutine.
                If omitted, the name defaults to the implementation's __name__ attribute
            has_abi_output (optional): the boolean that tells if ABI output kwarg for subroutine is used.
        """
        super().__init__()
        self.id = SubroutineDefinition.nextSubroutineId
        SubroutineDefinition.nextSubroutineId += 1

        self.return_type = return_type
        self.declaration: "SubroutineDeclaration | None" = None
        self.declarations: _SubroutineDeclByOption = _SubroutineDeclByOption(self)

        self.implementation: Callable = implementation
        self.has_abi_output: bool = has_abi_output

        self.implementation_params: MappingProxyType[str, Parameter]
        self.annotations: dict[str, type]
        self.expected_arg_types: list[type[Expr] | type[ScratchVar] | abi.TypeSpec]
        self.by_ref_args: set[str]
        self.abi_args: dict[str, abi.TypeSpec]
        self.output_kwarg: dict[str, abi.TypeSpec]

        (
            self.implementation_params,
            self.annotations,
            self.expected_arg_types,
            self.by_ref_args,
            self.abi_args,
            self.output_kwarg,
        ) = self._validate()

        self.__name: str = name_str if name_str else self.implementation.__name__

        self.stack_frames: NatalStackFrame = NatalStackFrame()

    def _validate(self, input_types: list[TealType | None] | None = None) -> tuple[
        MappingProxyType[str, Parameter],
        dict[str, type],
        list[type[Expr] | type[ScratchVar] | abi.TypeSpec],
        set[str],
        dict[str, abi.TypeSpec],
        dict[str, abi.TypeSpec],
    ]:
        """Validate the full function signature and annotations for subroutine definition.

        NOTE: `self.implementation` should be set before calling `_validate()`

        This function iterates through `sig.parameters.items()`, and checks each of subroutine arguments.
        On each of the subroutine arguments, the following checks are performed:
        - If argument is not POSITION_ONLY or not POSITIONAL_OR_KEYWORD, error
        - If argument has default value, error

        After the previous checks, the function signature is correct in structure,
        but we still need to check the argument types are matching requirements
        (i.e., in {Expr, ScratchVar, inheritances of abi.BaseType}).

        Finally, this function outputs:
        - `implementation_params` - ordered map from parameter name to inspect.Parameter
        - `annotations` - map from parameter name to annotation (if available)
        - `expected_arg_types` - an array of elements of Type[Expr], Type[ScratchVar] or abi.TypeSpec instances
          It helps type-checking on SubroutineCall from `invoke` method.
        - `by_ref_args` - a set of argument names, which are type annotated by ScratchVar.
        We put the scratch slot id on the stack, rather than the value itself.
        - `abi_args` - a set of argument names, which are type annotated by ABI types.
        We load the ABI scratch space stored value to stack, and store them later in subroutine's local ABI values.
        - `abi_output_kwarg` - a possibly empty dict which when non-empty contains exactly one key
            `ABIReturnSubroutine.OUTPUT_ARG_NAME` with a value that gives abi-tye information about the output

        Args:
            input_types (optional): for testing purposes - expected `TealType`s of each parameter

        Returns:
            impl_params: a map from python function implementation's argument name, to argument's parameter.
            annotations: a dict whose keys are names of type-annotated arguments,
                and values are appearing type-annotations.
            arg_types: a list of argument type inferred from python function implementation,
                containing [type[Expr]| type[ScratchVar] | abi.TypeSpec].
            by_ref_args: a list of argument names that are passed in Subroutine with by-reference mechanism.
            abi_args: a dict whose keys are names of ABI arguments, and values are their ABI type-specs.
            abi_output_kwarg (might be empty): a dict whose key is the name of ABI output keyword argument,
                and the value is the corresponding ABI type-spec.
                NOTE: this dict might be empty, when we are defining a normal subroutine,
                    but it has at most one element when we define an ABI-returning subroutine.
        """

        if not callable(self.implementation):
            raise TealInputError("Input to SubroutineDefinition is not callable")

        impl_params: MappingProxyType[str, Parameter] = signature(
            self.implementation
        ).parameters
        annotations: dict[str, type] = get_annotations(self.implementation)
        arg_types: list[type[Expr] | type[ScratchVar] | abi.TypeSpec] = []
        by_ref_args: set[str] = set()
        abi_args: dict[str, abi.TypeSpec] = {}
        abi_output_kwarg: dict[str, abi.TypeSpec] = {}

        if "return" in annotations and annotations["return"] is not Expr:
            raise TealInputError(
                f"Function has return of disallowed type {annotations['return']}. Only Expr is allowed"
            )

        for name, param in impl_params.items():
            if param.kind not in (
                Parameter.POSITIONAL_ONLY,
                Parameter.POSITIONAL_OR_KEYWORD,
            ) and not (
                param.kind is Parameter.KEYWORD_ONLY
                and self.has_abi_output
                and name == ABIReturnSubroutine.OUTPUT_ARG_NAME
            ):
                raise TealInputError(
                    f"Function has a parameter type that is not allowed in a subroutine: parameter {name} with type {param.kind}"
                )

            if param.default != Parameter.empty:
                raise TealInputError(
                    f"Function has a parameter with a default value, which is not allowed in a subroutine: {name}"
                )

            expected_arg_type = self._validate_annotation(annotations, name)

            if param.kind is Parameter.KEYWORD_ONLY:
                # this case is only entered when
                # - `self.has_abi_output is True`
                # - `name == ABIReturnSubroutine.OUTPUT_ARG_NAME`
                if not isinstance(expected_arg_type, abi.TypeSpec):
                    raise TealInputError(
                        f"Function keyword parameter {name} has type {expected_arg_type}"
                    )
                abi_output_kwarg[name] = expected_arg_type
                continue

            arg_types.append(expected_arg_type)
            if expected_arg_type is ScratchVar:
                by_ref_args.add(name)
            if isinstance(expected_arg_type, abi.TypeSpec):
                abi_args[name] = expected_arg_type

        if input_types is not None:
            input_arg_count = len(impl_params) - len(abi_output_kwarg)
            if len(input_types) != input_arg_count:
                raise TealInputError(
                    f"Provided number of input_types ({len(input_types)}) "
                    f"does not match detected number of input parameters ({input_arg_count})"
                )
            for in_type, name in zip(input_types, impl_params):
                if not isinstance(in_type, (TealType, NoneType)):
                    raise TealInputError(
                        f"Function has input type {in_type} for parameter {name} which is not a TealType"
                    )
                if in_type is None and name not in abi_args:
                    raise TealInputError(
                        f"input_type for {name} is unspecified i.e. None "
                        f"but this is only allowed for ABI arguments"
                    )

        return (
            impl_params,
            annotations,
            arg_types,
            by_ref_args,
            abi_args,
            abi_output_kwarg,
        )

    @staticmethod
    def _is_abi_annotation(obj: Any) -> bool:
        try:
            abi.type_spec_from_annotation(obj)
            return True
        except TypeError:
            return False

    @staticmethod
    def _validate_annotation(
        user_defined_annotations: dict[str, Any], parameter_name: str
    ) -> type[Expr] | type[ScratchVar] | abi.TypeSpec:
        ptype = user_defined_annotations.get(parameter_name, None)
        if ptype is None:
            # Without a type annotation, `SubroutineDefinition` presumes an implicit `Expr` declaration
            # rather than these alternatives:
            # * Throw error requiring type annotation.
            # * Defer parameter type checks until arguments provided during invocation.
            #
            # * Rationale:
            #   * Provide an upfront, best-effort type check before invocation.
            #   * Preserve backwards compatibility with TEAL programs written
            #     when `Expr` is the only supported annotation type.
            # * `invoke` type checks provided arguments against parameter types to catch mismatches.
            return Expr
        if ptype in (Expr, ScratchVar):
            return ptype
        if SubroutineDefinition._is_abi_annotation(ptype):
            return abi.type_spec_from_annotation(ptype)
        if not isclass(ptype):
            raise TealInputError(
                f"Function has parameter {parameter_name} of declared type {ptype} which is not a class"
            )
        raise TealInputError(
            f"Function has parameter {parameter_name} of disallowed type {ptype}. "
            f"Only the types {(Expr, ScratchVar, 'ABI')} are allowed"
        )

    def get_declaration(self) -> "SubroutineDeclaration":
        warnings.warn(
            "`get_declaration` is being deprecated: Please use `get_declaration_by_option` instead.",
            DeprecationWarning,
        )
        return self.declarations.get_declaration_by_option(False)

    def get_declaration_by_option(
        self,
        fp_option: bool = True,
    ) -> "SubroutineDeclaration":
        return self.declarations.get_declaration_by_option(fp_option)

    def name(self) -> str:
        return self.__name

    def argument_count(self) -> int:
        return len(self.arguments())

    def arguments(self) -> list[str]:
        syntax_args = list(self.implementation_params.keys())
        syntax_args = [
            arg_name for arg_name in syntax_args if arg_name not in self.output_kwarg
        ]
        return syntax_args

    def invoke(
        self,
        args: list[Expr | ScratchVar | abi.BaseType],
    ) -> "SubroutineCall":
        from pyteal.ast.abi.util import type_spec_is_assignable_to

        if len(args) != self.argument_count():
            raise TealInputError(
                f"Incorrect number of arguments for subroutine call. "
                f"Expected {self.arguments()} arguments, got {len(args)} arguments"
            )

        for i, arg in enumerate(args):
            arg_type = self.expected_arg_types[i]
            if arg_type is Expr and not isinstance(arg, Expr):
                raise TealInputError(
                    f"supplied argument {arg} at index {i} had type {type(arg)} but was expecting type {arg_type}"
                )
            elif arg_type is ScratchVar and not isinstance(arg, ScratchVar):
                raise TealInputError(
                    f"supplied argument {arg} at index {i} had type {type(arg)} but was expecting type {arg_type}"
                )
            elif isinstance(arg_type, abi.TypeSpec):
                if not isinstance(arg, abi.BaseType):
                    raise TealInputError(
                        f"supplied argument at index {i} should be an ABI type but got {arg}"
                    )

                if not type_spec_is_assignable_to(arg.type_spec(), arg_type):
                    raise TealInputError(
                        f"supplied argument {arg} at index {i} "
                        f"should have ABI typespec {arg_type} but got {arg.type_spec()}"
                    )

        return SubroutineCall(
            self, args, output_kwarg=OutputKwArgInfo.from_dict(self.output_kwarg)
        )

    def __str__(self):
        return f"subroutine#{self.id}"

    def __eq__(self, other):
        if isinstance(other, SubroutineDefinition):
            return self.id == other.id and self.implementation == other.implementation
        return False

    def __hash__(self):
        return hash(self.id)


SubroutineDefinition.__module__ = "pyteal"


class SubroutineDeclaration(Expr):
    def __init__(
        self,
        subroutine: SubroutineDefinition,
        body: Expr,
        deferred_expr: Expr | None = None,
    ) -> None:
        super().__init__()
        self.subroutine = subroutine
        self.body = body
        self.deferred_expr = deferred_expr
        self._sframes_container: SubroutineDefinition = subroutine

    def __teal__(self, options: "CompileOptions"):
        return self.body.__teal__(options)

    def __str__(self):
        return f'(SubroutineDeclaration "{self.subroutine.name()}" {self.body})'

    def type_of(self):
        return self.body.type_of()

    def has_return(self):
        return self.body.has_return()


SubroutineDeclaration.__module__ = "pyteal"


@dataclass
class OutputKwArgInfo:
    name: str
    abi_type: abi.TypeSpec

    @staticmethod
    def from_dict(kwarg_info: dict[str, abi.TypeSpec]) -> "OutputKwArgInfo | None":
        match list(kwarg_info.keys()):
            case []:
                return None
            case [k]:
                return OutputKwArgInfo(k, kwarg_info[k])
            case _:
                raise TealInputError(
                    f"illegal conversion kwarg_info length {len(kwarg_info)}."
                )


OutputKwArgInfo.__module__ = "pyteal"


class SubroutineCall(Expr):
    def __init__(
        self,
        subroutine: SubroutineDefinition,
        args: list[Expr | ScratchVar | abi.BaseType],
        *,
        output_kwarg: OutputKwArgInfo | None = None,
    ) -> None:
        super().__init__()
        self.subroutine = subroutine
        self.args = args
        self.output_kwarg = output_kwarg

        for i, arg in enumerate(args):
            if isinstance(arg, Expr):
                arg_type = arg.type_of()
            elif isinstance(arg, ScratchVar):
                arg_type = arg.type
            elif isinstance(arg, abi.BaseType):
                arg_type = cast(abi.BaseType, arg)._stored_value.storage_type()
            else:
                raise TealInputError(
                    f"Subroutine argument {arg} at index {i} was of unexpected Python type {type(arg)}"
                )

            if arg_type == TealType.none:
                raise TealInputError(
                    f"Subroutine argument {arg} at index {i} evaluates to TealType.none"
                )

    def __teal__(self, options: "CompileOptions"):
        """
        Generate the subroutine's start and end teal blocks.
        The subroutine's arguments are pushed on the stack to be picked up into local scratch variables.
        There are 4 cases to consider for the pushed arg expression:

        1. (by-value) In the case of typical arguments of type Expr, the expression ITSELF is evaluated for the stack
            and will be stored in a local ScratchVar for subroutine evaluation

        2. (by-reference) In the case of a by-reference argument of type ScratchVar, its SLOT INDEX is put on the stack
            and will be stored in a local DynamicScratchVar for subroutine evaluation

        3. (ABI, or a special case in by-value) In this case, the storage of an ABI value are loaded
            to the stack and will be stored in a local ABI value for subroutine evaluation

        4. (ABI output keyword argument) In this case, we do not place ABI values (encoding) on the stack.
            This is an *output-only* argument: in `evaluate_subroutine` an ABI typed instance for subroutine evaluation
            will be generated, and gets in to construct the subroutine implementation.
        """
        verifyProgramVersion(
            Op.callsub.min_version,
            options.version,
            "Program version too low to use SubroutineCall expression",
        )

        def handle_arg(arg: Expr | ScratchVar | abi.BaseType) -> Expr:
            ret_expr: Expr
            if isinstance(arg, ScratchVar):
                ret_expr = arg.index()
                ret_expr.stack_frames = self.subroutine.stack_frames
            elif isinstance(arg, Expr):
                ret_expr = arg
            elif isinstance(arg, abi.BaseType):
                ret_expr = arg._stored_value.load()
                ret_expr.stack_frames = self.subroutine.stack_frames
            else:
                raise TealInputError(
                    f"cannot handle current arg: {arg} to put it on stack"
                )

            return ret_expr

        op = TealOp(self, Op.callsub, self.subroutine)
        return TealBlock.FromOp(options, op, *[handle_arg(x) for x in self.args])

    def __str__(self):
        arg_str_list = list(map(str, self.args))
        if self.output_kwarg:
            arg_str_list.append(
                f"{self.output_kwarg.name}={str(self.output_kwarg.abi_type)}"
            )
        return f'(SubroutineCall {self.subroutine.name()} ({" ".join(arg_str_list)}))'

    def type_of(self):
        output_info = OutputKwArgInfo.from_dict(self.subroutine.output_kwarg)
        if output_info:
            return output_info.abi_type.storage_type()
        return self.subroutine.return_type

    def has_return(self):
        return False


SubroutineCall.__module__ = "pyteal"


class SubroutineFnWrapper:
    def __init__(
        self,
        fn_implementation: Callable[..., Expr],
        return_type: TealType,
        name: str | None = None,
    ) -> None:
        self.subroutine = SubroutineDefinition(
            fn_implementation,
            return_type=return_type,
            name_str=name,
        )

    def __call__(
        self, *args: Expr | ScratchVar | abi.BaseType, **kwargs: Any
    ) -> SubroutineCall:
        if len(kwargs) != 0:
            raise TealInputError(
                f"Subroutine cannot be called with keyword arguments. "
                f"Received keyword arguments: {','.join(kwargs.keys())}"
            )
        return self.subroutine.invoke(list(args))

    def name(self) -> str:
        return self.subroutine.name()

    def type_of(self):
        return self.subroutine.declarations.versions_type_of()

    def has_return(self):
        return self.subroutine.declarations.versions_has_return()


SubroutineFnWrapper.__module__ = "pyteal"


class ABIReturnSubroutine:
    """Used to create a PyTeal Subroutine (returning an ABI value) from a python function.  It's primarily intended to define ARC-4 Application entry points though it can also be used more generally.

    *Disclaimer*:  ABIReturnSubroutine is still taking shape and is subject to backwards incompatible changes.

    * For ARC-4 Application entry point definition, feel encouraged to use ABIReturnSubroutine.  Expect a best-effort attempt to minimize backwards incompatible changes along with a migration path.
    * For general purpose subroutine definition usage, use at your own risk.  Based on feedback, the API and usage patterns will change more freely and with less effort to provide migration paths.

    This class is meant to be used as a function decorator. For example:

        .. code-block:: python

            @ABIReturnSubroutine
            def abi_sum(toSum: abi.DynamicArray[abi.Uint64], *, output: abi.Uint64) -> Expr:
                i = ScratchVar(TealType.uint64)
                valueAtIndex = abi.Uint64()
                return Seq(
                    output.set(0),
                    For(i.store(Int(0)), i.load() < toSum.length(), i.store(i.load() + Int(1))).Do(
                        Seq(
                            toSum[i.load()].store_into(valueAtIndex),
                            output.set(output.get() + valueAtIndex.get()),
                        )
                    ),
                )

            program = Seq(
                (to_sum_arr := abi.make(abi.DynamicArray[abi.Uint64])).decode(
                    Txn.application_args[1]
                ),
                (res := abi.Uint64()).set(abi_sum(to_sum_arr)),
                abi.MethodReturn(res),
                Int(1),
            )
    """

    OUTPUT_ARG_NAME: Final[str] = "output"

    def __init__(
        self,
        fn_implementation: Callable[..., Expr],
        /,
        *,
        overriding_name: str | None = None,
    ) -> None:
        self.output_kwarg_info: OutputKwArgInfo | None = self._get_output_kwarg_info(
            fn_implementation
        )
        self.subroutine = SubroutineDefinition(
            fn_implementation,
            return_type=TealType.none,
            name_str=overriding_name,
            has_abi_output=self.output_kwarg_info is not None,
        )

    @staticmethod
    def name_override(name: str) -> Callable[..., "ABIReturnSubroutine"]:
        def wrapper(fn_impl: Callable[..., Expr]) -> ABIReturnSubroutine:
            return ABIReturnSubroutine(fn_impl, overriding_name=name)

        return wrapper

    @classmethod
    def _get_output_kwarg_info(
        cls, fn_implementation: Callable[..., Expr]
    ) -> OutputKwArgInfo | None:
        if not callable(fn_implementation):
            raise TealInputError("Input to ABIReturnSubroutine is not callable")
        sig = signature(fn_implementation)
        fn_annotations = get_annotations(fn_implementation)

        potential_abi_arg_names = [
            k for k, v in sig.parameters.items() if v.kind == Parameter.KEYWORD_ONLY
        ]

        match potential_abi_arg_names:
            case []:
                return None
            case [name]:
                if name != cls.OUTPUT_ARG_NAME:
                    raise TealInputError(
                        f"ABI return subroutine output-kwarg name must be `output` at this moment, "
                        f"while {name} is the keyword."
                    )
                annotation = fn_annotations.get(name, None)
                if annotation is None:
                    raise TealInputError(
                        f"ABI return subroutine output-kwarg {name} must specify ABI type"
                    )
                type_spec = abi.type_spec_from_annotation(annotation)
                return OutputKwArgInfo(name, type_spec)
            case _:
                raise TealInputError(
                    f"multiple output arguments ({len(potential_abi_arg_names)}) "
                    f"with type annotations {potential_abi_arg_names}"
                )

    def __call__(
        self, *args: Expr | ScratchVar | abi.BaseType, **kwargs
    ) -> abi.ReturnedValue | SubroutineCall:
        if len(kwargs) != 0:
            raise TealInputError(
                f"Subroutine cannot be called with keyword arguments. "
                f"Received keyword arguments: {', '.join(kwargs.keys())}"
            )

        invoked = self.subroutine.invoke(list(args))
        if self.output_kwarg_info is None:
            if invoked.type_of() != TealType.none:
                raise TealInputError(
                    "ABI subroutine with void type should be evaluated to TealType.none"
                )
            return invoked

        return abi.ReturnedValue(
            self.output_kwarg_info.abi_type,
            invoked,
        )

    def name(self) -> str:
        return self.subroutine.name()

    def method_signature(self, overriding_name: str | None = None) -> str:
        if not self.is_abi_routable():
            raise TealInputError(
                "Only registrable methods may return a method signature"
            )

        ret_type = self.type_of()
        if isinstance(ret_type, abi.TypeSpec) and abi.contains_type_spec(
            ret_type, abi.TransactionTypeSpecs + abi.ReferenceTypeSpecs
        ):
            raise TealInputError(
                f"Reference and Transaction types may not be used as return values, got {ret_type}"
            )

        args = [str(v) for v in self.subroutine.abi_args.values()]
        if overriding_name is None:
            overriding_name = self.name()
        return f"{overriding_name}({','.join(args)}){self.type_of()}"

    def method_spec(self) -> sdk_abi.Method:
        desc: str = ""
        arg_descs: dict[str, str] = {}
        return_desc: str = ""
        args: list[dict[str, str]] = []

        if self.subroutine.implementation.__doc__:
            docstring = parse_docstring(self.subroutine.implementation.__doc__)

            # Combine short and long descriptions with newline
            method_descriptions: list[str] = []
            if docstring.short_description:
                method_descriptions.append(docstring.short_description)
            if docstring.long_description:
                method_descriptions.append(docstring.long_description)

            method_desc = "\n\n".join(method_descriptions)

            # Turn double new line into single, replacing single newline with space
            desc = "\n".join(
                [
                    i.replace("\n", " ").strip()
                    for i in method_desc.split("\n\n")
                    if i.strip()
                ]
            )

            # Get the descriptions for any documented arguments
            arg_descs = {
                arg.arg_name: arg.description.replace("\n", " ").strip()
                for arg in docstring.params
                if arg.arg_name != self.OUTPUT_ARG_NAME and arg.description is not None
            }

            # Get the special return description
            return_desc = (
                ""
                if not docstring.returns or not docstring.returns.description
                else docstring.returns.description.replace("\n", " ").strip()
            )

        # Generate the ABI method object given the subroutine args
        # Add in description if one is set
        for name, val in self.subroutine.annotations.items():
            # Skip annotations for `return` and `output` in the args list
            if name in ["return", self.OUTPUT_ARG_NAME]:
                continue

            arg_obj = {
                "type": str(abi.type_spec_from_annotation(val)),
                "name": name,
            }

            if name in arg_descs:
                arg_obj["desc"] = arg_descs[name]

            args.append(arg_obj)

        # Create the return obj for the method, adding description if set
        return_obj = {"type": str(self.type_of())}
        if return_desc and return_obj["type"] != "void":
            return_obj["desc"] = return_desc

        # Create the method spec, adding description if set
        spec = {"name": self.name(), "args": args, "returns": return_obj}
        if desc:
            spec["desc"] = desc

        return sdk_abi.Method.undictify(spec)

    def type_of(self) -> str | abi.TypeSpec:
        return (
            "void"
            if self.output_kwarg_info is None
            else self.output_kwarg_info.abi_type
        )

    def is_abi_routable(self) -> bool:
        return len(self.subroutine.abi_args) == self.subroutine.argument_count()


ABIReturnSubroutine.__module__ = "pyteal"


class Subroutine:
    """Used to create a PyTeal subroutine from a Python function.

    This class is meant to be used as a function decorator. For example:

        .. code-block:: python

            @Subroutine(TealType.uint64)
            def mySubroutine(a: Expr, b: Expr) -> Expr:
                return a + b

            program = Seq([
                App.globalPut(Bytes("key"), mySubroutine(Int(1), Int(2))),
                Approve(),
            ])
    """

    def __init__(self, return_type: TealType, name: str | None = None) -> None:
        """Define a new subroutine with the given return type.

        Args:
            return_type: The type that the return value of this subroutine must conform to.
                TealType.none indicates that this subroutine does not return any value.
        """
        self.return_type = return_type
        self.name = name

    def __call__(self, fn_implementation: Callable[..., Expr]) -> SubroutineFnWrapper:
        return SubroutineFnWrapper(
            fn_implementation=fn_implementation,
            return_type=self.return_type,
            name=self.name,
        )


Subroutine.__module__ = "pyteal"


@contextmanager
def _frame_pointer_context(proto: Proto | None):
    tmp, SubroutineEval._current_proto = SubroutineEval._current_proto, proto
    yield proto
    SubroutineEval._current_proto = tmp


@dataclass
class SubroutineEval:
    """
    Puts together the data necessary to define the code for a subroutine.
    "evaluate" is used here to connote evaluating the PyTEAL AST into a SubroutineDeclaration,
    but not actually placing it at call locations. The trickiest part here is managing the subroutine's arguments.
    The arguments are needed for two different code-paths, and there are 2 different argument types to consider
    for each of the code-paths.

    2 Argument Usages / Code-Paths
    - -------- ------   ----------
    Usage (A) for run-time: "argumentVars" --reverse--> "body_ops"
        These are "store" expressions that pick up parameters that have been pre-placed on the stack prior to subroutine invocation.
        The argumentVars are stored into local scratch space to be used by the TEAL subroutine.

    Usage (B) for compile-time: "loadedArgs"
        These are expressions supplied to the user-defined PyTEAL function.
        The loadedArgs are invoked to by the subroutine to create a self-contained AST which will translate into a TEAL subroutine.

    In both usage cases, we need to handle

    4 Argument Types
    - -------- -----
    Type 1 (by-value): these have python type Expr
    Type 2 (by-reference): these have python type ScratchVar
    Type 3 (ABI): these are ABI typed variables with scratch space storage, and still pass by value
    Type 4 (ABI-output-arg): ABI typed variables with scratch space, a new ABI instance is generated inside function body,
        not one of the cases in the previous three options

    Because of the introduction of frame pointer, the "argumentVars" and "loadedArgs" are different before and after program version 8.

    "argumentVars" and "loadedArgs" before version 8 (frame pointer version)
    -------------- --- ------------ ------ ------- - -----------------------

    Usage (A) "argumentVars" - Storing pre-placed stack variables into local scratch space:
        Type 1. (by-value) use ScratchVar.store() to pick the actual value into a local scratch space
        Type 2. (by-reference) ALSO use ScratchVar.store() to pick up from the stack
            NOTE: SubroutineCall.__teal__() has placed the _SLOT INDEX_ on the stack so this is stored into the local scratch space
        Type 3. (ABI) abi_value.stored_value.store() to pick from the stack
        Type 4. (ABI-output-arg) it is not really used here, since it is only generated internal of the subroutine

    Usage (B) "loadedArgs" - Passing through to an invoked PyTEAL subroutine AST:
        Type 1. (by-value) use ScratchVar.load() to have an Expr that can be compiled in python by the PyTEAL subroutine
        Type 2. (by-reference) use a DynamicScratchVar as the user will have written the PyTEAL in a way that satisfies
            the ScratchVar API. I.e., the user will write `x.load()` and `x.store(val)` as opposed to just `x`.
        Type 3. (ABI) use abi_value itself after storing stack value into scratch space.
        Type 4. (ABI-output-arg) generates a new instance of the ABI value,
            and appends a return expression of stored value of the ABI keyword value.

    "argumentVars" and "loadedArgs" after version 8 (frame pointer version)
    -------------- --- ------------ ----- ------- - -----------------------

    Usage (A) "argumentVars" - Storing pre-placed stack variables with frame pointer:
        Type 1. (by-value) use None for we can load from stack with FrameDig() from FrameVar abstraction
        Type 2. (by-reference) use FrameDig() from FrameVar abstraction to pick up from the stack
            NOTE: SubroutineCall.__teal__() has placed the _SLOT INDEX_ on the stack so this is stored into the local scratch space
        Type 3. (ABI) use None for we can load from stack with FrameDig() from FrameVar abstraction
            NOTE: SubroutineCall.__teal__() has placed the ABI encoding on the stack, so ABI set and get methods are working over stack
        Type 4. (ABI-output-arg) it is not really used here, but we use FrameDig/Bury to interact with it

    Usage (B) "loadedArgs" - Passing through to an invoked PyTEAL subroutine AST:
        Type 1. (by-value) use FrameDig() from FrameVar abstraction, to have an Expr that can be compiled in python by the PyTEAL subroutine.
        Type 2. (by-reference) use a DynamicScratchVar as the user will have written the PyTEAL in a way that satisfies
            the ScratchVar API. I.e., the user will write `x.load()` and `x.store(val)` as opposed to just `x`.
        Type 3. (ABI) use abi_value that interface with stack data through FrameVar abstraction.
        Type 4. (ABI-output-arg) Prepare a FrameVar over the stack with frame-index 0 against current frame pointer,
            and set the ABI value's _stored_value to be using FrameVar.
    """

    var_n_loaded_method: Callable[
        [SubroutineDefinition, str, Proto | None],
        tuple[ScratchVar | None, ScratchVar | abi.BaseType | Expr],
    ]
    use_frame_pt: bool = False
    _current_proto: ClassVar[Proto | None] = None

    @staticmethod
    def _new_abi_instance_from_storage(
        spec: abi.TypeSpec, storage: FrameVar
    ) -> abi.BaseType:
        """
        This hidden method generates new ABI instance that is tied to the storage: FrameVar as follows:
        - generates new instance that is based on scratch vars
        - rewind the new instance to be using storage: FrameVar
        - rewind the state changed by scratch slot allocation
        """
        current_scratch_id = ScratchSlot.nextSlotId
        with _frame_pointer_context(None):
            instance = spec.new_instance()
        instance._stored_value = storage
        ScratchSlot.reset_slot_numbering(current_scratch_id)
        return instance

    @staticmethod
    def var_n_loaded_scratch(
        subroutine: SubroutineDefinition,
        param: str,
        _: Proto | None = None,
    ) -> tuple[ScratchVar, ScratchVar | abi.BaseType | Expr]:
        loaded_var: ScratchVar | abi.BaseType | Expr
        argument_var: ScratchVar

        if param in subroutine.by_ref_args:
            argument_var = DynamicScratchVar(TealType.anytype)
            loaded_var = argument_var
        elif param in subroutine.abi_args:
            with _frame_pointer_context(None):
                internal_abi_var = subroutine.abi_args[param].new_instance()
            argument_var = cast(ScratchVar, internal_abi_var._stored_value)
            loaded_var = internal_abi_var
        else:
            argument_var = ScratchVar(TealType.anytype)
            loaded_var = argument_var.load()

        return argument_var, loaded_var

    @staticmethod
    def var_n_loaded_fp(
        subroutine: SubroutineDefinition,
        param: str,
        proto: Proto | None,
    ) -> tuple[ScratchVar | None, ScratchVar | abi.BaseType | Expr]:
        if not proto:
            raise TealInternalError(
                "proto should be available for frame pointer based subroutine."
            )

        loaded_var: ScratchVar | abi.BaseType | Expr
        argument_var: ScratchVar | None

        if param in subroutine.by_ref_args:
            argument_var = DynamicScratchVar(TealType.anytype)
            loaded_var = argument_var
        elif param in subroutine.abi_args:
            dig_index = (
                subroutine.arguments().index(param) - subroutine.argument_count()
            )
            internal_abi_var = SubroutineEval._new_abi_instance_from_storage(
                subroutine.abi_args[param], FrameVar(proto, dig_index)
            )
            argument_var = None
            loaded_var = internal_abi_var
        else:
            dig_index = (
                subroutine.arguments().index(param) - subroutine.argument_count()
            )
            argument_var = None
            loaded_var = FrameVar(proto, dig_index).load()

        return argument_var, loaded_var

    @staticmethod
    def __proto(subroutine: SubroutineDefinition) -> Proto:
        arg_stack_types: list[TealType] = []
        for t in subroutine.expected_arg_types:
            if t is Expr:
                arg_stack_types.append(TealType.anytype)
            elif t is ScratchVar:
                arg_stack_types.append(TealType.uint64)
            else:
                arg_stack_types.append(cast(abi.TypeSpec, t).storage_type())

        num_return_allocs: int = int(subroutine.has_abi_output)

        local_stack_types: list[TealType] = []
        if subroutine.has_abi_output:
            output_info = cast(
                OutputKwArgInfo, OutputKwArgInfo.from_dict(subroutine.output_kwarg)
            )
            local_stack_types = [output_info.abi_type.storage_type()]

        layout: ProtoStackLayout = ProtoStackLayout(
            arg_stack_types, local_stack_types, num_return_allocs
        )

        # if subroutine do not have abi output, then only two cases happen:
        # - subroutine is a normal subroutine, then check subroutine body evaluates to something, rather than none
        # - subroutine is an ABIReturnSubroutine, the type is void, and its subroutine body type of is always none
        num_stack_outputs: int = (
            1
            if subroutine.has_abi_output
            else int(subroutine.return_type != TealType.none)
        )

        return Proto(subroutine.argument_count(), num_stack_outputs, mem_layout=layout)

    def evaluate(self, subroutine: SubroutineDefinition) -> SubroutineDeclaration:
        proto = self.__proto(subroutine)

        args = subroutine.arguments()
        arg_var_n_frame_index_pairs: list[tuple[ScratchVar, int]] = []
        loaded_args: list[ScratchVar | Expr | abi.BaseType] = []
        for index, arg in enumerate(args):
            arg_var, loaded_arg = self.var_n_loaded_method(subroutine, arg, proto)
            if arg_var:
                arg_var_n_frame_index_pairs.append(
                    (arg_var, index - subroutine.argument_count())
                )
            loaded_args.append(loaded_arg)

        abi_output_kwargs: dict[str, abi.BaseType] = {}
        output_kwarg_info = OutputKwArgInfo.from_dict(subroutine.output_kwarg)
        output_carrying_abi: abi.BaseType | None = None

        if output_kwarg_info:
            if not self.use_frame_pt:
                with _frame_pointer_context(None):
                    output_carrying_abi = output_kwarg_info.abi_type.new_instance()
            else:
                output_carrying_abi = SubroutineEval._new_abi_instance_from_storage(
                    output_kwarg_info.abi_type, FrameVar(proto, 0)
                )

            abi_output_kwargs[output_kwarg_info.name] = output_carrying_abi

        # Arg usage "B" supplied to build an AST from the user-defined PyTEAL function:
        subroutine_body: Expr

        with _frame_pointer_context(proto if self.use_frame_pt else None):
            subroutine_body = subroutine.implementation(
                *loaded_args, **abi_output_kwargs
            )

        if not isinstance(subroutine_body, Expr):
            raise TealInputError(
                f"Subroutine function does not return a PyTeal expression. Got type {type(subroutine_body)}."
            )

        deferred_expr: Expr | None = None

        # if there is an output keyword argument for ABI
        # place the storing on the stack with deferred expr only when compile to scratch var
        if output_carrying_abi:
            if subroutine_body.type_of() != TealType.none:
                raise TealInputError(
                    f"ABI returning subroutine definition should evaluate to TealType.none, "
                    f"while evaluate to {subroutine_body.type_of()}."
                )
            if not self.use_frame_pt:
                deferred_expr = output_carrying_abi._stored_value.load()

        if self.use_frame_pt:
            local_size = len(proto.mem_layout.local_stack_types)
            # only when we have 1 return, and with other local variables
            # we use bury to bury the result to 0 index against frame pointer
            if not abi_output_kwargs and proto.num_returns > 0 and local_size > 0:
                deferred_expr = FrameBury(Seq(), 0, inferred_type=TealType.none)

        # Arg usage "A" to be pick up and store in scratch parameters that have been placed on the stack
        # need to reverse order of argumentVars because the last argument will be on top of the stack

        body_ops: list[Expr]
        if not self.use_frame_pt:
            body_ops = [
                var.slot.store() for var, _ in arg_var_n_frame_index_pairs[::-1]
            ]
        else:
            body_ops = [proto]
            body_ops += [
                var.slot.store(FrameVar(proto, index).load())
                for var, index in arg_var_n_frame_index_pairs[::-1]
            ]

        # don't reframe the subroutine body
        subroutine.stack_frames.reframe(*body_ops)
        body_ops.append(subroutine_body)
        sd = SubroutineDeclaration(subroutine, Seq(body_ops), deferred_expr)
        sd.trace = subroutine_body.trace
        return sd

    @classmethod
    def normal_evaluator(cls) -> "SubroutineEval":
        return cls(SubroutineEval.var_n_loaded_scratch, False)

    @classmethod
    def fp_evaluator(cls) -> "SubroutineEval":
        return cls(SubroutineEval.var_n_loaded_fp, True)


SubroutineEval.__module__ = "pyteal"



================================================
FILE: pyteal/ast/substring.py
================================================
from typing import cast, TYPE_CHECKING

from pyteal.types import TealType, require_type
from pyteal.errors import TealCompileError, verifyProgramVersion
from pyteal.ir import TealOp, Op, TealBlock, TealSimpleBlock
from pyteal.ast.expr import Expr
from pyteal.ast.int import Int
from pyteal.ast.ternaryexpr import TernaryExpr

if TYPE_CHECKING:
    from pyteal.compiler import CompileOptions


class SubstringExpr(Expr):
    """An expression for taking the substring of a byte string given start and end indices"""

    def __init__(self, stringArg: Expr, startArg: Expr, endArg: Expr) -> None:
        super().__init__()

        require_type(stringArg, TealType.bytes)
        require_type(startArg, TealType.uint64)
        require_type(endArg, TealType.uint64)

        self.stringArg = stringArg
        self.startArg = startArg
        self.endArg = endArg

    # helper method for correctly populating op
    def __get_op(self, options: "CompileOptions"):
        s, e = cast(Int, self.startArg).value, cast(Int, self.endArg).value
        l = e - s

        if l < 0:
            raise TealCompileError(
                "The end index must be greater than or equal to the start index",
                self,
            )

        if l > 0 and options.version >= Op.extract.min_version:
            if s < 2**8 and l < 2**8:
                return Op.extract
            else:
                return Op.extract3
        else:
            if s < 2**8 and e < 2**8:
                return Op.substring
            else:
                return Op.substring3

    def __teal__(self, options: "CompileOptions"):
        if not isinstance(self.startArg, Int) or not isinstance(self.endArg, Int):
            return TernaryExpr(
                Op.substring3,
                (TealType.bytes, TealType.uint64, TealType.uint64),
                TealType.bytes,
                self.stringArg,
                self.startArg,
                self.endArg,
            ).__teal__(options)

        op = self.__get_op(options)

        verifyProgramVersion(
            op.min_version,
            options.version,
            "Program version too low to use op {}".format(op),
        )

        start, end = cast(Int, self.startArg).value, cast(Int, self.endArg).value
        if op == Op.extract:
            length = end - start
            return TealBlock.FromOp(
                options,
                TealOp(self, op, self.startArg.value, length),
                self.stringArg,
            )
        elif op == Op.extract3:
            length = end - start
            return TealBlock.FromOp(
                options,
                TealOp(self, op),
                self.stringArg,
                self.startArg,
                Int(length),
            )
        elif op == Op.substring:
            return TealBlock.FromOp(
                options, TealOp(self, op, start, end), self.stringArg
            )
        elif op == Op.substring3:
            return TealBlock.FromOp(
                options,
                TealOp(self, op),
                self.stringArg,
                self.startArg,
                self.endArg,
            )

    def __str__(self):
        return "(Substring {} {} {})".format(self.stringArg, self.startArg, self.endArg)

    def type_of(self):
        return TealType.bytes

    def has_return(self):
        return False


class ExtractExpr(Expr):
    """An expression for extracting a section of a byte string given a start index and length"""

    def __init__(self, stringArg: Expr, startArg: Expr, lenArg: Expr) -> None:
        super().__init__()

        require_type(stringArg, TealType.bytes)
        require_type(startArg, TealType.uint64)
        require_type(lenArg, TealType.uint64)

        self.stringArg = stringArg
        self.startArg = startArg
        self.lenArg = lenArg

    # helper method for correctly populating op
    def __get_op(self, options: "CompileOptions"):
        s, l = cast(Int, self.startArg).value, cast(Int, self.lenArg).value
        if s < 2**8 and l > 0 and l < 2**8:
            return Op.extract
        else:
            return Op.extract3

    def __teal__(self, options: "CompileOptions"):
        if not isinstance(self.startArg, Int) or not isinstance(self.lenArg, Int):
            return TernaryExpr(
                Op.extract3,
                (TealType.bytes, TealType.uint64, TealType.uint64),
                TealType.bytes,
                self.stringArg,
                self.startArg,
                self.lenArg,
            ).__teal__(options)

        op = self.__get_op(options)

        verifyProgramVersion(
            op.min_version,
            options.version,
            "Program version too low to use op {}".format(op),
        )

        s, l = cast(Int, self.startArg).value, cast(Int, self.lenArg).value
        if op == Op.extract:
            return TealBlock.FromOp(options, TealOp(self, op, s, l), self.stringArg)
        elif op == Op.extract3:
            return TealBlock.FromOp(
                options,
                TealOp(self, op),
                self.stringArg,
                self.startArg,
                self.lenArg,
            )

    def __str__(self):
        return "(Extract {} {} {})".format(self.stringArg, self.startArg, self.lenArg)

    def type_of(self):
        return TealType.bytes

    def has_return(self):
        return False


class SuffixExpr(Expr):
    """An expression for taking the suffix of a byte string given start index"""

    def __init__(
        self,
        stringArg: Expr,
        startArg: Expr,
    ) -> None:
        super().__init__()

        require_type(stringArg, TealType.bytes)
        require_type(startArg, TealType.uint64)

        self.stringArg = stringArg
        self.startArg = startArg

    # helper method for correctly populating op
    def __get_op(self, options: "CompileOptions"):
        if not isinstance(self.startArg, Int):
            return Op.substring3

        s = cast(Int, self.startArg).value
        if s < 2**8:
            return Op.extract
        else:
            return Op.substring3

    def __teal__(self, options: "CompileOptions"):
        op = self.__get_op(options)

        verifyProgramVersion(
            op.min_version,
            options.version,
            "Program version too low to use op {}".format(op),
        )

        if op == Op.extract:
            # if possible, exploit optimization in the extract opcode that takes the suffix
            # when the length argument is 0
            return TealBlock.FromOp(
                options,
                TealOp(self, op, cast(Int, self.startArg).value, 0),
                self.stringArg,
            )
        elif op == Op.substring3:
            strBlockStart, strBlockEnd = self.stringArg.__teal__(options)
            nextBlockStart, nextBlockEnd = self.startArg.__teal__(options)
            strBlockEnd.setNextBlock(nextBlockStart)

            finalBlock = TealSimpleBlock(
                [
                    TealOp(self, Op.dig, 1),
                    TealOp(self, Op.len),
                    TealOp(self, Op.substring3),
                ]
            )

            nextBlockEnd.setNextBlock(finalBlock)
            return strBlockStart, finalBlock

    def __str__(self):
        return "(Suffix {} {})".format(self.stringArg, self.startArg)

    def type_of(self):
        return TealType.bytes

    def has_return(self):
        return False


def Substring(string: Expr, start: Expr, end: Expr) -> Expr:
    """Take a substring of a byte string.

    Produces a new byte string consisting of the bytes starting at :code:`start` up to but not
    including :code:`end`.

    This expression is similar to :any:`Extract`, except this expression uses start and end indexes,
    while :code:`Extract` uses a start index and length.

    Requires program version 2 or higher.

    Args:
        string: The byte string.
        start: The starting index for the substring. Must be an integer less than or equal to
            :code:`Len(string)`.
        end: The ending index for the substring. Must be an integer greater or equal to start, but
            less than or equal to Len(string).
    """
    return SubstringExpr(
        string,
        start,
        end,
    )


def Extract(string: Expr, start: Expr, length: Expr) -> Expr:
    """Extract a section of a byte string.

    Produces a new byte string consisting of the bytes starting at :code:`start` up to but not
    including :code:`start + length`.

    This expression is similar to :any:`Substring`, except this expression uses a start index and
    length, while :code:`Substring` uses start and end indexes.

    Requires program version 5 or higher.

    Args:
        string: The byte string.
        start: The starting index for the extraction. Must be an integer less than or equal to
            :code:`Len(string)`.
        length: The number of bytes to extract. Must be an integer such that :code:`start + length <= Len(string)`.
    """
    return ExtractExpr(
        string,
        start,
        length,
    )


def Suffix(string: Expr, start: Expr) -> Expr:
    """Take a suffix of a byte string.

    Produces a new byte string consisting of the suffix of the byte string starting at :code:`start`

    This expression is similar to :any:`Substring` and :any:`Extract`, except this expression only uses a
    start index.

    Requires program version 5 or higher.

    Args:
        string: The byte string.
        start: The starting index for the suffix. Must be an integer less than or equal to :code:`Len(string)`.
    """
    return SuffixExpr(
        string,
        start,
    )



================================================
FILE: pyteal/ast/substring_test.py
================================================
import pytest

import pyteal as pt

avm2Options = pt.CompileOptions(version=2)
avm3Options = pt.CompileOptions(version=3)
avm4Options = pt.CompileOptions(version=4)
avm5Options = pt.CompileOptions(version=5)


def test_substring_immediate_v2():
    args = [pt.Bytes("my string"), pt.Int(0), pt.Int(2)]
    expr = pt.Substring(args[0], args[1], args[2])
    assert expr.type_of() == pt.TealType.bytes

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(args[0], pt.Op.byte, '"my string"'),
            pt.TealOp(expr, pt.Op.substring, 0, 2),
        ]
    )

    actual, _ = expr.__teal__(avm2Options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    assert actual == expected


def test_substring_immediate_v5():
    args = [pt.Bytes("my string"), pt.Int(1), pt.Int(2)]
    expr = pt.Substring(args[0], args[1], args[2])
    assert expr.type_of() == pt.TealType.bytes

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(args[0], pt.Op.byte, '"my string"'),
            pt.TealOp(expr, pt.Op.extract, 1, 1),
        ]
    )

    actual, _ = expr.__teal__(avm5Options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    assert actual == expected


def test_substring_to_extract():
    my_string = "a" * 257
    args = [pt.Bytes(my_string), pt.Int(255), pt.Int(257)]
    expr = pt.Substring(args[0], args[1], args[2])
    assert expr.type_of() == pt.TealType.bytes

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(args[0], pt.Op.byte, '"{my_string}"'.format(my_string=my_string)),
            pt.TealOp(expr, pt.Op.extract, 255, 2),
        ]
    )

    actual, _ = expr.__teal__(avm5Options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    with pt.TealComponent.Context.ignoreExprEquality():
        assert actual == expected


def test_substring_stack_v2():
    my_string = "a" * 257
    args = [pt.Bytes(my_string), pt.Int(256), pt.Int(257)]
    expr = pt.Substring(args[0], args[1], args[2])
    assert expr.type_of() == pt.TealType.bytes

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(args[0], pt.Op.byte, '"{my_string}"'.format(my_string=my_string)),
            pt.TealOp(args[1], pt.Op.int, 256),
            pt.TealOp(args[2], pt.Op.int, 257),
            pt.TealOp(expr, pt.Op.substring3),
        ]
    )

    actual, _ = expr.__teal__(avm2Options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    with pt.TealComponent.Context.ignoreExprEquality():
        assert actual == expected


def test_substring_stack_v5():
    my_string = "a" * 257
    args = [pt.Bytes(my_string), pt.Int(256), pt.Int(257)]
    expr = pt.Substring(args[0], args[1], args[2])
    assert expr.type_of() == pt.TealType.bytes

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(args[0], pt.Op.byte, '"{my_string}"'.format(my_string=my_string)),
            pt.TealOp(args[1], pt.Op.int, 256),
            pt.TealOp(pt.Int(1), pt.Op.int, 1),
            pt.TealOp(expr, pt.Op.extract3),
        ]
    )

    actual, _ = expr.__teal__(avm5Options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    with pt.TealComponent.Context.ignoreExprEquality():
        assert actual == expected


def test_zero_length_substring_immediate():
    my_string = "a" * 257
    args = [pt.Bytes(my_string), pt.Int(1), pt.Int(1)]
    expr = pt.Substring(args[0], args[1], args[2])
    assert expr.type_of() == pt.TealType.bytes

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(args[0], pt.Op.byte, '"{my_string}"'.format(my_string=my_string)),
            pt.TealOp(expr, pt.Op.substring, 1, 1),
        ]
    )

    actual, _ = expr.__teal__(avm5Options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    with pt.TealComponent.Context.ignoreExprEquality():
        assert actual == expected


def test_substring_invalid():
    with pytest.raises(pt.TealTypeError):
        pt.Substring(pt.Int(0), pt.Int(0), pt.Int(2))

    with pytest.raises(pt.TealTypeError):
        pt.Substring(pt.Bytes("my string"), pt.Txn.sender(), pt.Int(2))

    with pytest.raises(pt.TealTypeError):
        pt.Substring(pt.Bytes("my string"), pt.Int(0), pt.Txn.sender())

    with pytest.raises(Exception):
        pt.Substring(pt.Bytes("my string"), pt.Int(1), pt.Int(0)).__teal__(avm5Options)


def test_extract_immediate():
    args = [pt.Bytes("my string"), pt.Int(0), pt.Int(2)]
    expr = pt.Extract(args[0], args[1], args[2])
    assert expr.type_of() == pt.TealType.bytes

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(args[0], pt.Op.byte, '"my string"'),
            pt.TealOp(expr, pt.Op.extract, 0, 2),
        ]
    )

    actual, _ = expr.__teal__(avm5Options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    assert actual == expected

    with pytest.raises(pt.TealInputError):
        expr.__teal__(avm4Options)


def test_extract_zero():
    args = [pt.Bytes("my string"), pt.Int(1), pt.Int(0)]
    expr = pt.Extract(args[0], args[1], args[2])
    assert expr.type_of() == pt.TealType.bytes

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(args[0], pt.Op.byte, '"my string"'),
            pt.TealOp(args[1], pt.Op.int, 1),
            pt.TealOp(args[2], pt.Op.int, 0),
            pt.TealOp(expr, pt.Op.extract3),
        ]
    )

    actual, _ = expr.__teal__(avm5Options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    assert actual == expected

    with pytest.raises(pt.TealInputError):
        expr.__teal__(avm4Options)


def test_extract_stack():
    my_string = "*" * 257
    args = [pt.Bytes(my_string), pt.Int(256), pt.Int(257)]
    expr = pt.Extract(args[0], args[1], args[2])
    assert expr.type_of() == pt.TealType.bytes

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(args[0], pt.Op.byte, '"{my_string}"'.format(my_string=my_string)),
            pt.TealOp(args[1], pt.Op.int, 256),
            pt.TealOp(args[2], pt.Op.int, 257),
            pt.TealOp(expr, pt.Op.extract3),
        ]
    )

    actual, _ = expr.__teal__(avm5Options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    assert actual == expected

    with pytest.raises(pt.TealInputError):
        expr.__teal__(avm4Options)


def test_extract_invalid():
    with pytest.raises(pt.TealTypeError):
        pt.Extract(pt.Int(0), pt.Int(0), pt.Int(2))

    with pytest.raises(pt.TealTypeError):
        pt.Extract(pt.Bytes("my string"), pt.Txn.sender(), pt.Int(2))

    with pytest.raises(pt.TealTypeError):
        pt.Extract(pt.Bytes("my string"), pt.Int(0), pt.Txn.sender())


def test_suffix_immediate():
    args = [pt.Bytes("my string"), pt.Int(1)]
    expr = pt.Suffix(args[0], args[1])
    assert expr.type_of() == pt.TealType.bytes

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(args[0], pt.Op.byte, '"my string"'),
            pt.TealOp(expr, pt.Op.extract, 1, 0),
        ]
    )

    actual, _ = expr.__teal__(avm5Options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    assert actual == expected


def test_suffix_stack():
    my_string = "*" * 1024
    args = [pt.Bytes(my_string), pt.Int(257)]
    expr = pt.Suffix(args[0], args[1])
    assert expr.type_of() == pt.TealType.bytes

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(args[0], pt.Op.byte, '"{my_string}"'.format(my_string=my_string)),
            pt.TealOp(args[1], pt.Op.int, 257),
            pt.TealOp(expr, pt.Op.dig, 1),
            pt.TealOp(expr, pt.Op.len),
            pt.TealOp(expr, pt.Op.substring3),
        ]
    )

    actual, _ = expr.__teal__(avm2Options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    assert actual == expected


@pytest.mark.parametrize("op", [pt.Op.extract3, pt.Op.substring3])
def test_startArg_not_int(op: pt.Op):
    my_string = "*" * 257
    add = pt.Add(pt.Int(254), pt.Int(2))
    args = [pt.Bytes(my_string), add, pt.Int(257)]

    def generate_expr() -> pt.Expr:
        match op:
            case pt.Op.extract3:
                return pt.Extract(args[0], args[1], args[2])
            case pt.Op.substring3:
                return pt.Substring(args[0], args[1], args[2])
            case _:
                raise Exception(f"Unsupported {op=}")

    expr = generate_expr()
    assert expr.type_of() == pt.TealType.bytes

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(args[0], pt.Op.byte, '"{my_string}"'.format(my_string=my_string)),
            pt.TealOp(pt.Int(254), pt.Op.int, 254),
            pt.TealOp(pt.Int(2), pt.Op.int, 2),
            pt.TealOp(add, pt.Op.add),
            pt.TealOp(args[2], pt.Op.int, 257),
            pt.TealOp(None, op),
        ]
    )

    actual, _ = expr.__teal__(avm5Options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    with pt.TealComponent.Context.ignoreExprEquality():
        assert actual == expected

    if op == pt.Op.extract3:
        with pytest.raises(pt.TealInputError):
            expr.__teal__(avm4Options)


@pytest.mark.parametrize("op", [pt.Op.extract3, pt.Op.substring3])
def test_endArg_not_int(op: pt.Op):
    my_string = "*" * 257
    add = pt.Add(pt.Int(254), pt.Int(3))
    args = [pt.Bytes(my_string), pt.Int(256), add]

    def generate_expr() -> pt.Expr:
        match op:
            case pt.Op.extract3:
                return pt.Extract(args[0], args[1], args[2])
            case pt.Op.substring3:
                return pt.Substring(args[0], args[1], args[2])
            case _:
                raise Exception(f"Unsupported {op=}")

    expr = generate_expr()
    assert expr.type_of() == pt.TealType.bytes

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(args[0], pt.Op.byte, '"{my_string}"'.format(my_string=my_string)),
            pt.TealOp(args[1], pt.Op.int, 256),
            pt.TealOp(pt.Int(254), pt.Op.int, 254),
            pt.TealOp(pt.Int(3), pt.Op.int, 3),
            pt.TealOp(add, pt.Op.add),
            pt.TealOp(None, op),
        ]
    )

    actual, _ = expr.__teal__(avm5Options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    with pt.TealComponent.Context.ignoreExprEquality():
        assert actual == expected

    if op == pt.Op.extract3:
        with pytest.raises(pt.TealInputError):
            expr.__teal__(avm4Options)


def test_suffix_invalid():
    with pytest.raises(pt.TealTypeError):
        pt.Suffix(pt.Int(0), pt.Int(0))

    with pytest.raises(pt.TealTypeError):
        pt.Suffix(pt.Bytes("my string"), pt.Txn.sender())



================================================
FILE: pyteal/ast/ternaryexpr.py
================================================
from typing import Tuple, TYPE_CHECKING

from pyteal.types import TealType, require_type
from pyteal.errors import verifyProgramVersion
from pyteal.ir import TealOp, Op, TealBlock
from pyteal.ast.expr import Expr

if TYPE_CHECKING:
    from pyteal.compiler import CompileOptions


class TernaryExpr(Expr):
    """An expression with three arguments."""

    def __init__(
        self,
        op: Op,
        inputTypes: Tuple[TealType, TealType, TealType],
        outputType: TealType,
        firstArg: Expr,
        secondArg: Expr,
        thirdArg: Expr,
    ) -> None:
        super().__init__()
        require_type(firstArg, inputTypes[0])
        require_type(secondArg, inputTypes[1])
        require_type(thirdArg, inputTypes[2])

        self.op = op
        self.outputType = outputType
        self.firstArg = firstArg
        self.secondArg = secondArg
        self.thirdArg = thirdArg

    def __teal__(self, options: "CompileOptions"):
        verifyProgramVersion(
            self.op.min_version,
            options.version,
            "Program version too low to use op {}".format(self.op),
        )

        return TealBlock.FromOp(
            options, TealOp(self, self.op), self.firstArg, self.secondArg, self.thirdArg
        )

    def __str__(self):
        return "({} {} {} {})".format(
            self.op, self.firstArg, self.secondArg, self.thirdArg
        )

    def type_of(self):
        return self.outputType

    def has_return(self):
        return False


TernaryExpr.__module__ = "pyteal"


def Ed25519Verify(data: Expr, sig: Expr, key: Expr) -> TernaryExpr:
    """Verify the ed25519 signature of the concatenation ("ProgData" + hash_of_current_program + data).

    Args:
        data: The data signed by the public key. Must evaluate to bytes.
        sig: The proposed 64-byte signature of the concatenation ("ProgData" + hash_of_current_program + data).
            Must evaluate to bytes.
        key: The 32 byte public key that produced the signature. Must evaluate to bytes.
    """
    return TernaryExpr(
        Op.ed25519verify,
        (TealType.bytes, TealType.bytes, TealType.bytes),
        TealType.uint64,
        data,
        sig,
        key,
    )


def Ed25519Verify_Bare(data: Expr, sig: Expr, key: Expr) -> TernaryExpr:
    """Verify the ed25519 signature of the data against the public key.

    Args:
        data: The data signed by the public key. Must evaluate to bytes.
        sig: The proposed 64-byte signature of the data. Must evaluate to bytes.
        key: The 32 byte public key that produced the signature. Must evaluate to bytes.
    """
    return TernaryExpr(
        Op.ed25519verify_bare,
        (TealType.bytes, TealType.bytes, TealType.bytes),
        TealType.uint64,
        data,
        sig,
        key,
    )


def SetBit(value: Expr, index: Expr, newBitValue: Expr) -> TernaryExpr:
    """Set the bit value of an expression at a specific index.

    The meaning of index differs if value is an integer or a byte string.

    * For integers, bit indexing begins with low-order bits. For example, :code:`SetBit(Int(0), Int(4), Int(1))`
      yields the integer 16 (2^4). Any integer less than 64 is a valid index.

    * For byte strings, bit indexing begins at the first byte. For example, :code:`SetBit(Bytes("base16", "0x00"), Int(7), Int(1))`
      yields the byte string 0x01. Any integer less than 8*Len(value) is a valid index.

    Requires program version 3 or higher.

    Args:
        value: The value containing bits. Can evaluate to any type.
        index: The index of the bit to set. Must evaluate to uint64.
        newBitValue: The new bit value to set. Must evaluate to the integer 0 or 1.
    """
    return TernaryExpr(
        Op.setbit,
        (TealType.anytype, TealType.uint64, TealType.uint64),
        value.type_of(),
        value,
        index,
        newBitValue,
    )


def SetByte(value: Expr, index: Expr, newByteValue: Expr) -> TernaryExpr:
    """Set a single byte in a byte string from an integer value.

    Similar to SetBit, indexing begins at the first byte. For example, :code:`SetByte(Bytes("base16", "0x000000"), Int(0), Int(255))`
    yields the byte string 0xff0000.

    Requires program version 3 or higher.

    Args:
        value: The value containing the bytes. Must evaluate to bytes.
        index: The index of the byte to set. Must evaluate to an integer less than Len(value).
        newByteValue: The new byte value to set. Must evaluate to an integer less than 256.
    """
    return TernaryExpr(
        Op.setbyte,
        (TealType.bytes, TealType.uint64, TealType.uint64),
        TealType.bytes,
        value,
        index,
        newByteValue,
    )


def Divw(hi: Expr, lo: Expr, y: Expr) -> TernaryExpr:
    """
    Performs wide division by interpreting `hi` and `lo` as a uint128 value.

    Requires program version 6 or higher.

    Args:
        hi: Quotient's high 64 bits.  Must evaluate to uint64.
        lo: Quotient's low 64 bits.  Must evaluate to uint64.
        y: Divisor.  Must evaluate to uint64.

    """
    return TernaryExpr(
        Op.divw,
        (TealType.uint64, TealType.uint64, TealType.uint64),
        TealType.uint64,
        hi,
        lo,
        y,
    )



================================================
FILE: pyteal/ast/ternaryexpr_test.py
================================================
import pytest

import pyteal as pt

avm2Options = pt.CompileOptions(version=2)
avm3Options = pt.CompileOptions(version=3)
avm4Options = pt.CompileOptions(version=4)
avm5Options = pt.CompileOptions(version=5)
avm6Options = pt.CompileOptions(version=6)
avm7Options = pt.CompileOptions(version=7)


def test_ed25519verify():
    args = [pt.Bytes("data"), pt.Bytes("sig"), pt.Bytes("key")]
    expr = pt.Ed25519Verify(args[0], args[1], args[2])
    assert expr.type_of() == pt.TealType.uint64

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(args[0], pt.Op.byte, '"data"'),
            pt.TealOp(args[1], pt.Op.byte, '"sig"'),
            pt.TealOp(args[2], pt.Op.byte, '"key"'),
            pt.TealOp(expr, pt.Op.ed25519verify),
        ]
    )

    actual, _ = expr.__teal__(avm2Options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    assert actual == expected


def test_ed25519verify_invalid():
    with pytest.raises(pt.TealTypeError):
        pt.Ed25519Verify(pt.Int(0), pt.Bytes("sig"), pt.Bytes("key"))

    with pytest.raises(pt.TealTypeError):
        pt.Ed25519Verify(pt.Bytes("data"), pt.Int(0), pt.Bytes("key"))

    with pytest.raises(pt.TealTypeError):
        pt.Ed25519Verify(pt.Bytes("data"), pt.Bytes("sig"), pt.Int(0))


def test_ed25519verify_bare():
    args = [pt.Bytes("data"), pt.Bytes("sig"), pt.Bytes("key")]
    expr = pt.Ed25519Verify_Bare(args[0], args[1], args[2])
    assert expr.type_of() == pt.TealType.uint64

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(args[0], pt.Op.byte, '"data"'),
            pt.TealOp(args[1], pt.Op.byte, '"sig"'),
            pt.TealOp(args[2], pt.Op.byte, '"key"'),
            pt.TealOp(expr, pt.Op.ed25519verify_bare),
        ]
    )

    actual, _ = expr.__teal__(avm7Options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    assert actual == expected

    with pytest.raises(pt.TealInputError):
        expr.__teal__(avm6Options)


def test_ed25519verify_bare_invalid():
    with pytest.raises(pt.TealTypeError):
        pt.Ed25519Verify_Bare(pt.Int(0), pt.Bytes("sig"), pt.Bytes("key"))

    with pytest.raises(pt.TealTypeError):
        pt.Ed25519Verify_Bare(pt.Bytes("data"), pt.Int(0), pt.Bytes("key"))

    with pytest.raises(pt.TealTypeError):
        pt.Ed25519Verify_Bare(pt.Bytes("data"), pt.Bytes("sig"), pt.Int(0))


def test_set_bit_int():
    args = [pt.Int(0), pt.Int(2), pt.Int(1)]
    expr = pt.SetBit(args[0], args[1], args[2])
    assert expr.type_of() == pt.TealType.uint64

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(args[0], pt.Op.int, 0),
            pt.TealOp(args[1], pt.Op.int, 2),
            pt.TealOp(args[2], pt.Op.int, 1),
            pt.TealOp(expr, pt.Op.setbit),
        ]
    )

    actual, _ = expr.__teal__(avm3Options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    assert actual == expected

    with pytest.raises(pt.TealInputError):
        expr.__teal__(avm2Options)


def test_set_bit_bytes():
    args = [pt.Bytes("base16", "0x0000"), pt.Int(0), pt.Int(1)]
    expr = pt.SetBit(args[0], args[1], args[2])
    assert expr.type_of() == pt.TealType.bytes

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(args[0], pt.Op.byte, "0x0000"),
            pt.TealOp(args[1], pt.Op.int, 0),
            pt.TealOp(args[2], pt.Op.int, 1),
            pt.TealOp(expr, pt.Op.setbit),
        ]
    )

    actual, _ = expr.__teal__(avm3Options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    assert actual == expected

    with pytest.raises(pt.TealInputError):
        expr.__teal__(avm2Options)


def test_set_bit_invalid():
    with pytest.raises(pt.TealTypeError):
        pt.SetBit(pt.Int(3), pt.Bytes("index"), pt.Int(1))

    with pytest.raises(pt.TealTypeError):
        pt.SetBit(pt.Int(3), pt.Int(0), pt.Bytes("one"))

    with pytest.raises(pt.TealTypeError):
        pt.SetBit(pt.Bytes("base16", "0xFF"), pt.Bytes("index"), pt.Int(1))

    with pytest.raises(pt.TealTypeError):
        pt.SetBit(pt.Bytes("base16", "0xFF"), pt.Int(0), pt.Bytes("one"))


def test_set_byte():
    args = [pt.Bytes("base16", "0xFF"), pt.Int(0), pt.Int(3)]
    expr = pt.SetByte(args[0], args[1], args[2])
    assert expr.type_of() == pt.TealType.bytes

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(args[0], pt.Op.byte, "0xFF"),
            pt.TealOp(args[1], pt.Op.int, 0),
            pt.TealOp(args[2], pt.Op.int, 3),
            pt.TealOp(expr, pt.Op.setbyte),
        ]
    )

    actual, _ = expr.__teal__(avm3Options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    assert actual == expected

    with pytest.raises(pt.TealInputError):
        expr.__teal__(avm2Options)


def test_set_byte_invalid():
    with pytest.raises(pt.TealTypeError):
        pt.SetByte(pt.Int(3), pt.Int(0), pt.Int(1))

    with pytest.raises(pt.TealTypeError):
        pt.SetByte(pt.Bytes("base16", "0xFF"), pt.Bytes("index"), pt.Int(1))

    with pytest.raises(pt.TealTypeError):
        pt.SetByte(pt.Bytes("base16", "0xFF"), pt.Int(0), pt.Bytes("one"))


def test_divw():
    args = [pt.Int(0), pt.Int(90), pt.Int(30)]
    expr = pt.Divw(args[0], args[1], args[2])
    assert expr.type_of() == pt.TealType.uint64

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(args[0], pt.Op.int, args[0].value),
            pt.TealOp(args[1], pt.Op.int, args[1].value),
            pt.TealOp(args[2], pt.Op.int, args[2].value),
            pt.TealOp(expr, pt.Op.divw),
        ]
    )

    actual, _ = expr.__teal__(avm6Options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    assert actual == expected


def test_divw_invalid():
    with pytest.raises(pt.TealTypeError):
        pt.Divw(pt.Bytes("10"), pt.Int(0), pt.Int(1))

    with pytest.raises(pt.TealTypeError):
        pt.Divw(pt.Int(10), pt.Bytes("0"), pt.Int(1))

    with pytest.raises(pt.TealTypeError):
        pt.Divw(pt.Int(10), pt.Int(0), pt.Bytes("1"))



================================================
FILE: pyteal/ast/tmpl.py
================================================
from enum import Enum
from typing import TYPE_CHECKING

from algosdk.constants import ZERO_ADDRESS

from pyteal.types import TealType, valid_tmpl
from pyteal.ir import TealOp, Op, TealBlock
from pyteal.ast.leafexpr import LeafExpr

if TYPE_CHECKING:
    from pyteal.compiler import CompileOptions


class TmplKind(Enum):
    Int = 0
    Bytes = 1
    Addr = 2


class Tmpl(LeafExpr):
    """Template expression for creating placeholder values."""

    _session_templates: dict[str, TmplKind] = {}

    def __init__(self, op: Op, type: TealType, name: str, kind: TmplKind) -> None:
        super().__init__()
        valid_tmpl(name)
        self.op = op
        self.type = type
        self.name = name

        self._session_templates[name] = kind

    def __str__(self):
        return "(Tmpl {} {})".format(self.op, self.name)

    def __teal__(self, options: "CompileOptions"):
        op = TealOp(self, self.op, self.name)
        return TealBlock.FromOp(options, op)

    def type_of(self):
        return self.type

    @classmethod
    def session_templates(cls) -> list[str]:
        return list(cls._session_templates.keys())

    @classmethod
    def clear_session_templates(cls):
        """Clear all session templates."""
        cls._session_templates = {}

    @classmethod
    def Int(cls, placeholder: str):
        """Create a new Int template.

        Args:
            placeholder: The name to use for this template variable. Must start with `TMPL_` and
                only consist of uppercase alphanumeric characters and underscores.
        """
        return cls(Op.int, TealType.uint64, placeholder, TmplKind.Int)

    @classmethod
    def Bytes(cls, placeholder: str):
        """Create a new Bytes template.

        Args:
            placeholder: The name to use for this template variable. Must start with `TMPL_` and
                only consist of uppercase alphanumeric characters and underscores.
        """
        return cls(Op.byte, TealType.bytes, placeholder, TmplKind.Bytes)

    @classmethod
    def Addr(cls, placeholder: str):
        """Create a new Addr template.

        Args:
            placeholder: The name to use for this template variable. Must start with `TMPL_` and
                only consist of uppercase alphanumeric characters and underscores.
        """
        return cls(Op.addr, TealType.bytes, placeholder, TmplKind.Addr)

    @classmethod
    def zero(cls, placeholder) -> str:
        """Return a zero value for the given template placeholder."""
        if placeholder not in cls._session_templates:
            raise ValueError(f"Unknown template: {placeholder}")

        match (kind := cls._session_templates[placeholder]):
            case TmplKind.Int:
                return "0"
            case TmplKind.Bytes:
                return "0x00"
            case TmplKind.Addr:
                return ZERO_ADDRESS
            case _:
                raise ValueError(f"Unknown template kind: {kind}")


Tmpl.__module__ = "pyteal"



================================================
FILE: pyteal/ast/tmpl_test.py
================================================
import pytest

import pyteal as pt

options = pt.CompileOptions()


def test_tmpl_int():
    expr = pt.Tmpl.Int("TMPL_AMNT")
    assert expr.type_of() == pt.TealType.uint64

    expected = pt.TealSimpleBlock([pt.TealOp(expr, pt.Op.int, "TMPL_AMNT")])

    actual, _ = expr.__teal__(options)

    assert actual == expected


def test_tmpl_int_invalid():
    with pytest.raises(pt.TealInputError):
        pt.Tmpl.Int("whatever")


def test_tmpl_bytes():
    expr = pt.Tmpl.Bytes("TMPL_NOTE")
    assert expr.type_of() == pt.TealType.bytes

    expected = pt.TealSimpleBlock([pt.TealOp(expr, pt.Op.byte, "TMPL_NOTE")])

    actual, _ = expr.__teal__(options)

    assert actual == expected


def test_tmpl_bytes_invalid():
    with pytest.raises(pt.TealInputError):
        pt.Tmpl.Bytes("whatever")


def test_tmpl_addr():
    expr = pt.Tmpl.Addr("TMPL_RECEIVER0")
    assert expr.type_of() == pt.TealType.bytes

    expected = pt.TealSimpleBlock([pt.TealOp(expr, pt.Op.addr, "TMPL_RECEIVER0")])

    actual, _ = expr.__teal__(options)

    assert actual == expected


def test_tmpl_addr_invalid():
    with pytest.raises(pt.TealInputError):
        pt.Tmpl.Addr("whatever")



================================================
FILE: pyteal/ast/txn.py
================================================
from enum import Enum
from typing import Callable, Optional, Union, cast, TYPE_CHECKING

from pyteal.types import TealType, require_type
from pyteal.errors import (
    TealInputError,
    TealCompileError,
    verifyFieldVersion,
    verifyProgramVersion,
)
from pyteal.ir import TealOp, Op, TealBlock
from pyteal.ast.leafexpr import LeafExpr
from pyteal.ast.expr import Expr
from pyteal.ast.int import EnumInt
from pyteal.ast.array import Array

if TYPE_CHECKING:
    from pyteal.compiler import CompileOptions


class TxnType:
    """Enum of all possible transaction types."""

    Unknown = EnumInt("unknown")  # T2PT7
    Payment = EnumInt("pay")  # T2PT7
    KeyRegistration = EnumInt("keyreg")  # T2PT7
    AssetConfig = EnumInt("acfg")  # T2PT7
    AssetTransfer = EnumInt("axfer")  # T2PT7
    AssetFreeze = EnumInt("afrz")  # T2PT7
    ApplicationCall = EnumInt("appl")  # T2PT7


TxnType.__module__ = "pyteal"


class TxnField(Enum):
    sender = (0, "Sender", TealType.bytes, False, 2)
    fee = (1, "Fee", TealType.uint64, False, 2)
    first_valid = (2, "FirstValid", TealType.uint64, False, 2)
    first_valid_time = (3, "FirstValidTime", TealType.uint64, False, 7)
    last_valid = (4, "LastValid", TealType.uint64, False, 2)
    note = (5, "Note", TealType.bytes, False, 2)
    lease = (6, "Lease", TealType.bytes, False, 2)
    receiver = (7, "Receiver", TealType.bytes, False, 2)
    amount = (8, "Amount", TealType.uint64, False, 2)
    close_remainder_to = (9, "CloseRemainderTo", TealType.bytes, False, 2)
    vote_pk = (10, "VotePK", TealType.bytes, False, 2)
    selection_pk = (11, "SelectionPK", TealType.bytes, False, 2)
    vote_first = (12, "VoteFirst", TealType.uint64, False, 2)
    vote_last = (13, "VoteLast", TealType.uint64, False, 2)
    vote_key_dilution = (14, "VoteKeyDilution", TealType.uint64, False, 2)
    type = (15, "Type", TealType.bytes, False, 2)
    type_enum = (16, "TypeEnum", TealType.uint64, False, 2)
    xfer_asset = (17, "XferAsset", TealType.uint64, False, 2)
    asset_amount = (18, "AssetAmount", TealType.uint64, False, 2)
    asset_sender = (19, "AssetSender", TealType.bytes, False, 2)
    asset_receiver = (20, "AssetReceiver", TealType.bytes, False, 2)
    asset_close_to = (21, "AssetCloseTo", TealType.bytes, False, 2)
    group_index = (22, "GroupIndex", TealType.uint64, False, 2)
    tx_id = (23, "TxID", TealType.bytes, False, 2)
    application_id = (24, "ApplicationID", TealType.uint64, False, 2)
    on_completion = (25, "OnCompletion", TealType.uint64, False, 2)
    application_args = (26, "ApplicationArgs", TealType.bytes, True, 2)
    num_app_args = (27, "NumAppArgs", TealType.uint64, False, 2)
    accounts = (28, "Accounts", TealType.bytes, True, 2)
    num_accounts = (2, "NumAccounts", TealType.uint64, False, 2)
    approval_program = (30, "ApprovalProgram", TealType.bytes, False, 2)
    clear_state_program = (31, "ClearStateProgram", TealType.bytes, False, 2)
    rekey_to = (32, "RekeyTo", TealType.bytes, False, 2)
    config_asset = (33, "ConfigAsset", TealType.uint64, False, 2)
    config_asset_total = (34, "ConfigAssetTotal", TealType.uint64, False, 2)
    config_asset_decimals = (35, "ConfigAssetDecimals", TealType.uint64, False, 2)
    config_asset_default_frozen = (
        36,
        "ConfigAssetDefaultFrozen",
        TealType.uint64,
        False,
        2,
    )
    config_asset_unit_name = (37, "ConfigAssetUnitName", TealType.bytes, False, 2)
    config_asset_name = (38, "ConfigAssetName", TealType.bytes, False, 2)
    config_asset_url = (39, "ConfigAssetURL", TealType.bytes, False, 2)
    config_asset_metadata_hash = (
        40,
        "ConfigAssetMetadataHash",
        TealType.bytes,
        False,
        2,
    )
    config_asset_manager = (41, "ConfigAssetManager", TealType.bytes, False, 2)
    config_asset_reserve = (42, "ConfigAssetReserve", TealType.bytes, False, 2)
    config_asset_freeze = (43, "ConfigAssetFreeze", TealType.bytes, False, 2)
    config_asset_clawback = (44, "ConfigAssetClawback", TealType.bytes, False, 2)
    freeze_asset = (45, "FreezeAsset", TealType.uint64, False, 2)
    freeze_asset_account = (46, "FreezeAssetAccount", TealType.bytes, False, 2)
    freeze_asset_frozen = (47, "FreezeAssetFrozen", TealType.uint64, False, 2)
    assets = (48, "Assets", TealType.uint64, True, 3)
    num_assets = (49, "NumAssets", TealType.uint64, False, 3)
    applications = (50, "Applications", TealType.uint64, True, 3)
    num_applications = (51, "NumApplications", TealType.uint64, False, 3)
    global_num_uints = (52, "GlobalNumUint", TealType.uint64, False, 3)
    global_num_byte_slices = (53, "GlobalNumByteSlice", TealType.uint64, False, 3)
    local_num_uints = (54, "LocalNumUint", TealType.uint64, False, 3)
    local_num_byte_slices = (55, "LocalNumByteSlice", TealType.uint64, False, 3)
    extra_program_pages = (56, "ExtraProgramPages", TealType.uint64, False, 4)
    nonparticipation = (57, "Nonparticipation", TealType.uint64, False, 5)
    logs = (58, "Logs", TealType.bytes, True, 5)
    num_logs = (59, "NumLogs", TealType.uint64, False, 5)
    created_asset_id = (60, "CreatedAssetID", TealType.uint64, False, 5)
    created_application_id = (61, "CreatedApplicationID", TealType.uint64, False, 5)
    last_log = (62, "LastLog", TealType.bytes, False, 6)
    state_proof_pk = (63, "StateProofPK", TealType.bytes, False, 6)
    approval_program_pages = (64, "ApprovalProgramPages", TealType.bytes, True, 7)
    num_approval_program_pages = (
        65,
        "NumApprovalProgramPages",
        TealType.uint64,
        False,
        7,
    )
    clear_state_program_pages = (66, "ClearStateProgramPages", TealType.bytes, True, 7)
    num_clear_state_program_pages = (
        67,
        "NumClearStateProgramPages",
        TealType.uint64,
        False,
        7,
    )

    def __init__(
        self, id: int, name: str, type: TealType, is_array: bool, min_version: int
    ) -> None:
        self.id = id
        self.arg_name = name
        self.ret_type = type
        self.is_array = is_array
        self.min_version = min_version

    def type_of(self) -> TealType:
        return self.ret_type


TxnField.__module__ = "pyteal"


class TxnExpr(LeafExpr):
    """An expression that accesses a transaction field from the current transaction."""

    def __init__(self, op: Op, name: str, field: TxnField) -> None:
        super().__init__()
        if field.is_array:
            raise TealInputError("Unexpected array field: {}".format(field))
        self.op = op
        self.name = name
        self.field = field

    def __str__(self):
        return "({} {})".format(self.name, self.field.arg_name)

    def __teal__(self, options: "CompileOptions"):
        verifyFieldVersion(self.field.arg_name, self.field.min_version, options.version)
        verifyProgramVersion(
            self.op.min_version,
            options.version,
            "Program version too low to use op {}".format(self.op),
        )

        op = TealOp(self, self.op, self.field.arg_name)
        return TealBlock.FromOp(options, op)

    def type_of(self):
        return self.field.type_of()


TxnExpr.__module__ = "pyteal"


class TxnaExpr(LeafExpr):
    """An expression that accesses a transaction array field from the current transaction."""

    @staticmethod
    def __validate_index_or_throw(index: Union[int, Expr]):
        if not isinstance(index, (int, Expr)):
            raise TealInputError(
                f"Invalid index type:  Expected int or Expr, but received {index}."
            )
        if isinstance(index, Expr):
            require_type(index, TealType.uint64)

    def __init__(
        self,
        staticOp: Op,
        dynamicOp: Optional[Op],
        name: str,
        field: TxnField,
        index: Union[int, Expr],
    ) -> None:
        super().__init__()
        if not field.is_array:
            raise TealInputError("Unexpected non-array field: {}".format(field))
        self.__validate_index_or_throw(index)

        self.staticOp = staticOp
        self.dynamicOp = dynamicOp
        self.name = name
        self.field = field
        self.index = index

    def __str__(self):
        return "({} {} {})".format(self.name, self.field.arg_name, self.index)

    def __teal__(self, options: "CompileOptions"):
        verifyFieldVersion(self.field.arg_name, self.field.min_version, options.version)

        opToUse = self.staticOp if type(self.index) is int else self.dynamicOp
        if opToUse is None:
            raise TealCompileError("Dynamic array indexing not supported", self)

        verifyProgramVersion(
            opToUse.min_version,
            options.version,
            "Program version too low to use op {}".format(opToUse),
        )

        if type(self.index) is int:
            op = TealOp(self, opToUse, self.field.arg_name, self.index)
            return TealBlock.FromOp(options, op)

        op = TealOp(self, opToUse, self.field.arg_name)
        return TealBlock.FromOp(options, op, cast(Expr, self.index))

    def type_of(self):
        return self.field.type_of()


TxnaExpr.__module__ = "pyteal"


class TxnExprBuilder:
    def __init__(self, op: Op, name: str):
        self.op = op
        self.name = name

    def __call__(self, field: TxnField) -> TxnExpr:
        return TxnExpr(self.op, self.name, field)


TxnExprBuilder.__module__ = "pyteal"


class TxnaExprBuilder:
    def __init__(self, staticOp: Op, dynamicOp: Optional[Op], name: str):
        self.staticOp = staticOp
        self.dynamicOp = dynamicOp
        self.name = name

    def __call__(self, field: TxnField, index: Union[int, Expr]) -> TxnaExpr:
        return TxnaExpr(self.staticOp, self.dynamicOp, self.name, field, index)


TxnaExprBuilder.__module__ = "pyteal"


class TxnArray(Array):
    """Represents a transaction array field."""

    def __init__(
        self, txnObject: "TxnObject", accessField: TxnField, lengthField: TxnField
    ) -> None:
        self.txnObject = txnObject
        self.accessField = accessField
        self.lengthField = lengthField

    def length(self) -> TxnExpr:
        return self.txnObject.makeTxnExpr(self.lengthField)

    def __getitem__(self, index: Union[int, Expr]) -> TxnaExpr:
        if type(index) is int:
            if index < 0:
                raise TealInputError("Invalid array index: {}".format(index))
        else:
            require_type(cast(Expr, index), TealType.uint64)

        return self.txnObject.makeTxnaExpr(self.accessField, index)


TxnArray.__module__ = "pyteal"


class TxnObject:
    """Represents a transaction and its fields."""

    def __init__(
        self,
        makeTxnExpr: Callable[[TxnField], TxnExpr],
        makeTxnaExpr: Callable[[TxnField, Union[int, Expr]], TxnaExpr],
    ) -> None:
        self.makeTxnExpr = makeTxnExpr
        self.makeTxnaExpr = makeTxnaExpr

    def sender(self) -> TxnExpr:
        """Get the 32 byte address of the sender.

        For more information, see https://developer.algorand.org/docs/reference/transactions/#sender
        """
        return self.makeTxnExpr(TxnField.sender)

    def fee(self) -> TxnExpr:
        """Get the transaction fee in micro Algos.

        For more information, see https://developer.algorand.org/docs/reference/transactions/#fee
        """
        return self.makeTxnExpr(TxnField.fee)

    def first_valid(self) -> TxnExpr:
        """Get the first valid round number.

        For more information, see https://developer.algorand.org/docs/reference/transactions/#firstvalid
        """
        return self.makeTxnExpr(TxnField.first_valid)

    def first_valid_time(self) -> TxnExpr:
        """Get the UNIX timestamp of block before txn.FirstValid. Fails if negative.

        For more information, see https://developer.algorand.org/docs/reference/transactions/#firstvalidtime
        """
        return self.makeTxnExpr(TxnField.first_valid_time)

    def last_valid(self) -> TxnExpr:
        """Get the last valid round number.

        For more information, see https://developer.algorand.org/docs/reference/transactions/#lastvalid
        """
        return self.makeTxnExpr(TxnField.last_valid)

    def note(self) -> TxnExpr:
        """Get the transaction note.

        For more information, see https://developer.algorand.org/docs/reference/transactions/#note
        """
        return self.makeTxnExpr(TxnField.note)

    def lease(self) -> TxnExpr:
        """Get the transaction lease.

        For more information, see https://developer.algorand.org/docs/reference/transactions/#lease
        """
        return self.makeTxnExpr(TxnField.lease)

    def receiver(self) -> TxnExpr:
        """Get the 32 byte address of the receiver.

        Only set when :any:`type_enum()` is :any:`TxnType.Payment`.

        For more information, see https://developer.algorand.org/docs/reference/transactions/#receiver
        """
        return self.makeTxnExpr(TxnField.receiver)

    def amount(self) -> TxnExpr:
        """Get the amount of the transaction in micro Algos.

        Only set when :any:`type_enum()` is :any:`TxnType.Payment`.

        For more information, see https://developer.algorand.org/docs/reference/transactions/#amount
        """
        return self.makeTxnExpr(TxnField.amount)

    def close_remainder_to(self) -> TxnExpr:
        """Get the 32 byte address of the CloseRemainderTo field.

        Only set when :any:`type_enum()` is :any:`TxnType.Payment`.

        For more information, see https://developer.algorand.org/docs/reference/transactions/#closeremainderto
        """
        return self.makeTxnExpr(TxnField.close_remainder_to)

    def vote_pk(self) -> TxnExpr:
        """Get the root participation public key.

        Only set when :any:`type_enum()` is :any:`TxnType.KeyRegistration`.

        For more information, see https://developer.algorand.org/docs/reference/transactions/#votepk
        """
        return self.makeTxnExpr(TxnField.vote_pk)

    def selection_pk(self) -> TxnExpr:
        """Get the VRF public key.

        Only set when :any:`type_enum()` is :any:`TxnType.KeyRegistration`.

        For more information, see https://developer.algorand.org/docs/reference/transactions/#selectionpk
        """
        return self.makeTxnExpr(TxnField.selection_pk)

    def vote_first(self) -> TxnExpr:
        """Get the first round that the participation key is valid.

        Only set when :any:`type_enum()` is :any:`TxnType.KeyRegistration`.

        For more information, see https://developer.algorand.org/docs/reference/transactions/#votefirst
        """
        return self.makeTxnExpr(TxnField.vote_first)

    def vote_last(self) -> TxnExpr:
        """Get the last round that the participation key is valid.

        Only set when :any:`type_enum()` is :any:`TxnType.KeyRegistration`.

        For more information, see https://developer.algorand.org/docs/reference/transactions/#votelast
        """
        return self.makeTxnExpr(TxnField.vote_last)

    def vote_key_dilution(self) -> TxnExpr:
        """Get the dilution for the 2-level participation key.

        Only set when :any:`type_enum()` is :any:`TxnType.KeyRegistration`.

        For more information, see https://developer.algorand.org/docs/reference/transactions/#votekeydilution
        """
        return self.makeTxnExpr(TxnField.vote_key_dilution)

    def nonparticipation(self) -> TxnExpr:
        """Marks an account nonparticipating for rewards.

        Only set when :any:`type_enum()` is :any:`TxnType.KeyRegistration`.

        For more information, see https://developer.algorand.org/docs/reference/transactions/#nonparticipation

        Requires program version 5 or higher.
        """
        return self.makeTxnExpr(TxnField.nonparticipation)

    def type(self) -> TxnExpr:
        """Get the type of this transaction as a byte string.

        In most cases it is preferable to use :any:`type_enum()` instead.

        For more information, see https://developer.algorand.org/docs/reference/transactions/#type
        """
        return self.makeTxnExpr(TxnField.type)

    def type_enum(self) -> TxnExpr:
        """Get the type of this transaction.

        See :any:`TxnType` for possible values.
        """
        return self.makeTxnExpr(TxnField.type_enum)

    def xfer_asset(self) -> TxnExpr:
        """Get the ID of the asset being transferred.

        Only set when :any:`type_enum()` is :any:`TxnType.AssetTransfer`.

        For more information, see https://developer.algorand.org/docs/reference/transactions/#xferasset
        """
        return self.makeTxnExpr(TxnField.xfer_asset)

    def asset_amount(self) -> TxnExpr:
        """Get the amount of the asset being transferred, measured in the asset's units.

        Only set when :any:`type_enum()` is :any:`TxnType.AssetTransfer`.

        For more information, see https://developer.algorand.org/docs/reference/transactions/#assetamount
        """
        return self.makeTxnExpr(TxnField.asset_amount)

    def asset_sender(self) -> TxnExpr:
        """Get the 32 byte address of the subject of clawback.

        Only set when :any:`type_enum()` is :any:`TxnType.AssetTransfer`.

        For more information, see https://developer.algorand.org/docs/reference/transactions/#assetsender
        """
        return self.makeTxnExpr(TxnField.asset_sender)

    def asset_receiver(self) -> TxnExpr:
        """Get the recipient of the asset transfer.

        Only set when :any:`type_enum()` is :any:`TxnType.AssetTransfer`.

        For more information, see https://developer.algorand.org/docs/reference/transactions/#assetreceiver
        """
        return self.makeTxnExpr(TxnField.asset_receiver)

    def asset_close_to(self) -> TxnExpr:
        """Get the closeout address of the asset transfer.

        Only set when :any:`type_enum()` is :any:`TxnType.AssetTransfer`.

        For more information, see https://developer.algorand.org/docs/reference/transactions/#assetcloseto
        """
        return self.makeTxnExpr(TxnField.asset_close_to)

    def group_index(self) -> TxnExpr:
        """Get the position of the transaction within the atomic transaction group.

        A stand-alone transaction is implictly element 0 in a group of 1.

        For more information, see https://developer.algorand.org/docs/reference/transactions/#group
        """
        return self.makeTxnExpr(TxnField.group_index)

    def tx_id(self) -> TxnExpr:
        """Get the 32 byte computed ID for the transaction."""
        return self.makeTxnExpr(TxnField.tx_id)

    def application_id(self) -> TxnExpr:
        """Get the application ID from the ApplicationCall portion of the current transaction.

        Only set when :any:`type_enum()` is :any:`TxnType.ApplicationCall`.
        """
        return self.makeTxnExpr(TxnField.application_id)

    def on_completion(self) -> TxnExpr:
        """Get the on completion action from the ApplicationCall portion of the transaction.

        Only set when :any:`type_enum()` is :any:`TxnType.ApplicationCall`.
        """
        return self.makeTxnExpr(TxnField.on_completion)

    def approval_program(self) -> TxnExpr:
        """Get the approval program.

        Only set when :any:`type_enum()` is :any:`TxnType.ApplicationCall`.
        """
        return self.makeTxnExpr(TxnField.approval_program)

    def clear_state_program(self) -> TxnExpr:
        """Get the clear state program.

        Only set when :any:`type_enum()` is :any:`TxnType.ApplicationCall`.
        """
        return self.makeTxnExpr(TxnField.clear_state_program)

    def rekey_to(self) -> TxnExpr:
        """Get the sender's new 32 byte AuthAddr.

        For more information, see https://developer.algorand.org/docs/reference/transactions/#rekeyto
        """
        return self.makeTxnExpr(TxnField.rekey_to)

    def config_asset(self) -> TxnExpr:
        """Get the asset ID in asset config transaction.

        Only set when :any:`type_enum()` is :any:`TxnType.AssetConfig`.

        For more information, see https://developer.algorand.org/docs/reference/transactions/#configasset
        """
        return self.makeTxnExpr(TxnField.config_asset)

    def config_asset_total(self) -> TxnExpr:
        """Get the total number of units of this asset created.

        Only set when :any:`type_enum()` is :any:`TxnType.AssetConfig`.

        For more information, see https://developer.algorand.org/docs/reference/transactions/#total
        """
        return self.makeTxnExpr(TxnField.config_asset_total)

    def config_asset_decimals(self) -> TxnExpr:
        """Get the number of digits to display after the decimal place when displaying the asset.

        Only set when :any:`type_enum()` is :any:`TxnType.AssetConfig`.

        For more information, see https://developer.algorand.org/docs/reference/transactions/#decimals
        """
        return self.makeTxnExpr(TxnField.config_asset_decimals)

    def config_asset_default_frozen(self) -> TxnExpr:
        """Check if the asset's slots are frozen by default or not.

        Only set when :any:`type_enum()` is :any:`TxnType.AssetConfig`.

        For more information, see https://developer.algorand.org/docs/reference/transactions/#defaultfrozen
        """
        return self.makeTxnExpr(TxnField.config_asset_default_frozen)

    def config_asset_unit_name(self) -> TxnExpr:
        """Get the unit name of the asset.

        Only set when :any:`type_enum()` is :any:`TxnType.AssetConfig`.

        For more information, see https://developer.algorand.org/docs/reference/transactions/#unitname
        """
        return self.makeTxnExpr(TxnField.config_asset_unit_name)

    def config_asset_name(self) -> TxnExpr:
        """Get the asset name.

        Only set when :any:`type_enum()` is :any:`TxnType.AssetConfig`.

        For more information, see https://developer.algorand.org/docs/reference/transactions/#assetname
        """
        return self.makeTxnExpr(TxnField.config_asset_name)

    def config_asset_url(self) -> TxnExpr:
        """Get the asset URL.

        Only set when :any:`type_enum()` is :any:`TxnType.AssetConfig`.

        For more information, see https://developer.algorand.org/docs/reference/transactions/#url
        """
        return self.makeTxnExpr(TxnField.config_asset_url)

    def config_asset_metadata_hash(self) -> TxnExpr:
        """Get the 32 byte commitment to some unspecified asset metdata.

        Only set when :any:`type_enum()` is :any:`TxnType.AssetConfig`.

        For more information, see https://developer.algorand.org/docs/reference/transactions/#metadatahash
        """
        return self.makeTxnExpr(TxnField.config_asset_metadata_hash)

    def config_asset_manager(self) -> TxnExpr:
        """Get the 32 byte asset manager address.

        Only set when :any:`type_enum()` is :any:`TxnType.AssetConfig`.

        For more information, see https://developer.algorand.org/docs/reference/transactions/#manageraddr
        """
        return self.makeTxnExpr(TxnField.config_asset_manager)

    def config_asset_reserve(self) -> TxnExpr:
        """Get the 32 byte asset reserve address.

        Only set when :any:`type_enum()` is :any:`TxnType.AssetConfig`.

        For more information, see https://developer.algorand.org/docs/reference/transactions/#reserveaddr
        """
        return self.makeTxnExpr(TxnField.config_asset_reserve)

    def config_asset_freeze(self) -> TxnExpr:
        """Get the 32 byte asset freeze address.

        Only set when :any:`type_enum()` is :any:`TxnType.AssetConfig`.

        For more information, see https://developer.algorand.org/docs/reference/transactions/#freezeaddr
        """
        return self.makeTxnExpr(TxnField.config_asset_freeze)

    def config_asset_clawback(self) -> TxnExpr:
        """Get the 32 byte asset clawback address.

        Only set when :any:`type_enum()` is :any:`TxnType.AssetConfig`.

        For more information, see https://developer.algorand.org/docs/reference/transactions/#clawbackaddr
        """
        return self.makeTxnExpr(TxnField.config_asset_clawback)

    def created_asset_id(self) -> TxnExpr:
        """Get the asset ID allocated by the creation of an ASA.

        Only set when :any:`type_enum()` is :any:`TxnType.AssetConfig` and this is an asset creation transaction.

        Requires program version 5 or higher.

        * v5 - Only works on inner transactions.
        * >= v6 - Works on top-level and inner transactions.
        """
        return self.makeTxnExpr(TxnField.created_asset_id)

    def freeze_asset(self) -> TxnExpr:
        """Get the asset ID being frozen or un-frozen.

        Only set when :any:`type_enum()` is :any:`TxnType.AssetFreeze`.

        For more information, see https://developer.algorand.org/docs/reference/transactions/#freezeasset
        """
        return self.makeTxnExpr(TxnField.freeze_asset)

    def freeze_asset_account(self) -> TxnExpr:
        """Get the 32 byte address of the account whose asset slot is being frozen or un-frozen.

        Only set when :any:`type_enum()` is :any:`TxnType.AssetFreeze`.

        For more information, see https://developer.algorand.org/docs/reference/transactions/#freezeaccount
        """
        return self.makeTxnExpr(TxnField.freeze_asset_account)

    def freeze_asset_frozen(self) -> TxnExpr:
        """Get the new frozen value for the asset.

        Only set when :any:`type_enum()` is :any:`TxnType.AssetFreeze`.

        For more information, see https://developer.algorand.org/docs/reference/transactions/#assetfrozen
        """
        return self.makeTxnExpr(TxnField.freeze_asset_frozen)

    def global_num_uints(self) -> TxnExpr:
        """Get the schema count of global state integers in an application creation call.

        Only set when :any:`type_enum()` is :any:`TxnType.ApplicationCall` and this is an app creation call.

        Requires program version 3 or higher.
        """
        return self.makeTxnExpr(TxnField.global_num_uints)

    def global_num_byte_slices(self) -> TxnExpr:
        """Get the schema count of global state byte slices in an application creation call.

        Only set when :any:`type_enum()` is :any:`TxnType.ApplicationCall` and this is an app creation call.

        Requires program version 3 or higher.
        """
        return self.makeTxnExpr(TxnField.global_num_byte_slices)

    def local_num_uints(self) -> TxnExpr:
        """Get the schema count of local state integers in an application creation call.

        Only set when :any:`type_enum()` is :any:`TxnType.ApplicationCall` and this is an app creation call.

        Requires program version 3 or higher.
        """
        return self.makeTxnExpr(TxnField.local_num_uints)

    def local_num_byte_slices(self) -> TxnExpr:
        """Get the schema count of local state byte slices in an application creation call.

        Only set when :any:`type_enum()` is :any:`TxnType.ApplicationCall` and this is an app creation call.

        Requires program version 3 or higher.
        """
        return self.makeTxnExpr(TxnField.local_num_byte_slices)

    def extra_program_pages(self) -> TxnExpr:
        """Get the number of additional pages for each of the application's approval and clear state programs.

        1 additional page means 2048 more total bytes, or 1024 for each program.

        Only set when :any:`type_enum()` is :any:`TxnType.ApplicationCall` and this is an app creation call.

        Requires program version 4 or higher.
        """
        return self.makeTxnExpr(TxnField.extra_program_pages)

    def created_application_id(self) -> TxnExpr:
        """Get the application ID allocated by the creation of an application.

        Only set when :any:`type_enum()` is :any:`TxnType.ApplicationCall` and this is an app creation call.

        Requires program version 5 or higher.

        * v5 - Only works on inner transactions.
        * >= v6 - Works on top-level and inner transactions.
        """
        return self.makeTxnExpr(TxnField.created_application_id)

    def last_log(self) -> TxnExpr:
        """A convenience method for getting the last logged message from a transaction.

        Only application calls may log a message. Returns an empty string if no messages were logged.

        Only set when :any:`type_enum()` is :any:`TxnType.ApplicationCall`.

        Requires program version 6 or higher.
        """
        return self.makeTxnExpr(TxnField.last_log)

    def state_proof_pk(self) -> TxnExpr:
        """Get the state proof public key commitment from a transaction.

        Requires program version 6 or higher.
        """
        return self.makeTxnExpr(TxnField.state_proof_pk)

    @property
    def application_args(self) -> TxnArray:
        """Application call arguments array.

        :type: TxnArray
        """
        return TxnArray(self, TxnField.application_args, TxnField.num_app_args)

    @property
    def accounts(self) -> TxnArray:
        """The accounts array in an ApplicationCall transaction.

        :type: TxnArray
        """
        return TxnArray(self, TxnField.accounts, TxnField.num_accounts)

    @property
    def assets(self) -> TxnArray:
        """The foreign asset array in an ApplicationCall transaction.

        :type: TxnArray

        Requires program version 3 or higher.
        """
        return TxnArray(self, TxnField.assets, TxnField.num_assets)

    @property
    def applications(self) -> TxnArray:
        """The applications array in an ApplicationCall transaction.

        :type: TxnArray

        Requires program version 3 or higher.
        """
        return TxnArray(self, TxnField.applications, TxnField.num_applications)

    @property
    def logs(self) -> TxnArray:
        """The log messages emitted by an application call.

        :type: TxnArray

        Requires program version 5 or higher.

        * v5 - Only works on inner transactions.
        * >= v6 - Works on top-level and inner transactions.
        """
        return TxnArray(self, TxnField.logs, TxnField.num_logs)

    @property
    def approval_program_pages(self) -> TxnArray:
        """The approval program pages.

        :type: TxnArray

        Requires program version 7 or higher.
        """
        return TxnArray(
            self, TxnField.approval_program_pages, TxnField.num_approval_program_pages
        )

    @property
    def clear_state_program_pages(self) -> TxnArray:
        """The clear state program pages.

        :type: TxnArray

        Requires program version 7 or higher.
        """
        return TxnArray(
            self,
            TxnField.clear_state_program_pages,
            TxnField.num_clear_state_program_pages,
        )


TxnObject.__module__ = "pyteal"

Txn: TxnObject = TxnObject(
    TxnExprBuilder(Op.txn, "Txn"), TxnaExprBuilder(Op.txna, Op.txnas, "Txna")
)

Txn.__module__ = "pyteal"



================================================
FILE: pyteal/ast/txn_test.py
================================================
from typing import Dict, Callable

import pytest

import pyteal as pt

fieldToMethod: Dict[pt.TxnField, Callable[[pt.TxnObject], pt.Expr]] = {
    pt.TxnField.sender: lambda txn: txn.sender(),
    pt.TxnField.fee: lambda txn: txn.fee(),
    pt.TxnField.first_valid: lambda txn: txn.first_valid(),
    pt.TxnField.first_valid_time: lambda txn: txn.first_valid_time(),
    pt.TxnField.last_valid: lambda txn: txn.last_valid(),
    pt.TxnField.note: lambda txn: txn.note(),
    pt.TxnField.lease: lambda txn: txn.lease(),
    pt.TxnField.receiver: lambda txn: txn.receiver(),
    pt.TxnField.amount: lambda txn: txn.amount(),
    pt.TxnField.close_remainder_to: lambda txn: txn.close_remainder_to(),
    pt.TxnField.vote_pk: lambda txn: txn.vote_pk(),
    pt.TxnField.selection_pk: lambda txn: txn.selection_pk(),
    pt.TxnField.vote_first: lambda txn: txn.vote_first(),
    pt.TxnField.vote_last: lambda txn: txn.vote_last(),
    pt.TxnField.vote_key_dilution: lambda txn: txn.vote_key_dilution(),
    pt.TxnField.type: lambda txn: txn.type(),
    pt.TxnField.type_enum: lambda txn: txn.type_enum(),
    pt.TxnField.xfer_asset: lambda txn: txn.xfer_asset(),
    pt.TxnField.asset_amount: lambda txn: txn.asset_amount(),
    pt.TxnField.asset_sender: lambda txn: txn.asset_sender(),
    pt.TxnField.asset_receiver: lambda txn: txn.asset_receiver(),
    pt.TxnField.asset_close_to: lambda txn: txn.asset_close_to(),
    pt.TxnField.group_index: lambda txn: txn.group_index(),
    pt.TxnField.tx_id: lambda txn: txn.tx_id(),
    pt.TxnField.application_id: lambda txn: txn.application_id(),
    pt.TxnField.on_completion: lambda txn: txn.on_completion(),
    pt.TxnField.approval_program: lambda txn: txn.approval_program(),
    pt.TxnField.clear_state_program: lambda txn: txn.clear_state_program(),
    pt.TxnField.rekey_to: lambda txn: txn.rekey_to(),
    pt.TxnField.config_asset: lambda txn: txn.config_asset(),
    pt.TxnField.config_asset_total: lambda txn: txn.config_asset_total(),
    pt.TxnField.config_asset_decimals: lambda txn: txn.config_asset_decimals(),
    pt.TxnField.config_asset_default_frozen: lambda txn: txn.config_asset_default_frozen(),
    pt.TxnField.config_asset_unit_name: lambda txn: txn.config_asset_unit_name(),
    pt.TxnField.config_asset_name: lambda txn: txn.config_asset_name(),
    pt.TxnField.config_asset_url: lambda txn: txn.config_asset_url(),
    pt.TxnField.config_asset_metadata_hash: lambda txn: txn.config_asset_metadata_hash(),
    pt.TxnField.config_asset_manager: lambda txn: txn.config_asset_manager(),
    pt.TxnField.config_asset_reserve: lambda txn: txn.config_asset_reserve(),
    pt.TxnField.config_asset_freeze: lambda txn: txn.config_asset_freeze(),
    pt.TxnField.config_asset_clawback: lambda txn: txn.config_asset_clawback(),
    pt.TxnField.freeze_asset: lambda txn: txn.freeze_asset(),
    pt.TxnField.freeze_asset_account: lambda txn: txn.freeze_asset_account(),
    pt.TxnField.freeze_asset_frozen: lambda txn: txn.freeze_asset_frozen(),
    pt.TxnField.global_num_uints: lambda txn: txn.global_num_uints(),
    pt.TxnField.global_num_byte_slices: lambda txn: txn.global_num_byte_slices(),
    pt.TxnField.local_num_uints: lambda txn: txn.local_num_uints(),
    pt.TxnField.local_num_byte_slices: lambda txn: txn.local_num_byte_slices(),
    pt.TxnField.extra_program_pages: lambda txn: txn.extra_program_pages(),
    pt.TxnField.nonparticipation: lambda txn: txn.nonparticipation(),
    pt.TxnField.created_asset_id: lambda txn: txn.created_asset_id(),
    pt.TxnField.created_application_id: lambda txn: txn.created_application_id(),
    pt.TxnField.last_log: lambda txn: txn.last_log(),
    pt.TxnField.state_proof_pk: lambda txn: txn.state_proof_pk(),
}

arrayFieldToProperty: Dict[pt.TxnField, Callable[[pt.TxnObject], pt.TxnArray]] = {
    pt.TxnField.application_args: lambda txn: txn.application_args,
    pt.TxnField.accounts: lambda txn: txn.accounts,
    pt.TxnField.assets: lambda txn: txn.assets,
    pt.TxnField.applications: lambda txn: txn.applications,
    pt.TxnField.logs: lambda txn: txn.logs,
    pt.TxnField.approval_program_pages: lambda txn: txn.approval_program_pages,
    pt.TxnField.clear_state_program_pages: lambda txn: txn.clear_state_program_pages,
}

arrayFieldToLengthField: Dict[pt.TxnField, pt.TxnField] = {
    pt.TxnField.application_args: pt.TxnField.num_app_args,
    pt.TxnField.accounts: pt.TxnField.num_accounts,
    pt.TxnField.assets: pt.TxnField.num_assets,
    pt.TxnField.applications: pt.TxnField.num_applications,
    pt.TxnField.logs: pt.TxnField.num_logs,
    pt.TxnField.approval_program_pages: pt.TxnField.num_approval_program_pages,
    pt.TxnField.clear_state_program_pages: pt.TxnField.num_clear_state_program_pages,
}


def test_txn_fields():
    dynamicGtxnArg = pt.Int(0)

    txnObjects = [
        (pt.Txn, pt.Op.txn, pt.Op.txna, pt.Op.txnas, [], []),
        *[
            (pt.Gtxn[i], pt.Op.gtxn, pt.Op.gtxna, pt.Op.gtxnas, [i], [])
            for i in range(pt.MAX_GROUP_SIZE)
        ],
        (
            pt.Gtxn[dynamicGtxnArg],
            pt.Op.gtxns,
            pt.Op.gtxnsa,
            pt.Op.gtxnsas,
            [],
            [pt.TealOp(dynamicGtxnArg, pt.Op.int, 0)],
        ),
        (pt.InnerTxn, pt.Op.itxn, pt.Op.itxna, pt.Op.itxnas, [], []),
        *[
            (pt.Gitxn[i], pt.Op.gitxn, pt.Op.gitxna, pt.Op.gitxnas, [i], [])
            for i in range(pt.MAX_GROUP_SIZE)
        ],
    ]

    for (
        txnObject,
        op,
        staticArrayOp,
        dynamicArrayOp,
        immediateArgsPrefix,
        irPrefix,
    ) in txnObjects:
        for field in pt.TxnField:
            if field.is_array:
                array = arrayFieldToProperty[field](txnObject)
                lengthExpr = array.length()

                lengthFieldName = arrayFieldToLengthField[field].arg_name
                immediateArgs = immediateArgsPrefix + [lengthFieldName]
                expected = pt.TealSimpleBlock(
                    irPrefix + [pt.TealOp(lengthExpr, op, *immediateArgs)]
                )
                expected.addIncoming()
                expected = pt.TealBlock.NormalizeBlocks(expected)

                version = max(op.min_version, field.min_version)

                actual, _ = lengthExpr.__teal__(pt.CompileOptions(version=version))
                actual.addIncoming()
                actual = pt.TealBlock.NormalizeBlocks(actual)

                assert (
                    actual == expected
                ), "{}: array length for field {} does not match expected".format(
                    op, field
                )

                if version > 2:
                    with pytest.raises(pt.TealInputError):
                        lengthExpr.__teal__(pt.CompileOptions(version=version - 1))

                for i in range(32):  # just an arbitrary large int
                    elementExpr = array[i]

                    immediateArgs = immediateArgsPrefix + [field.arg_name, i]
                    expected = pt.TealSimpleBlock(
                        irPrefix
                        + [pt.TealOp(elementExpr, staticArrayOp, *immediateArgs)]
                    )
                    expected.addIncoming()
                    expected = pt.TealBlock.NormalizeBlocks(expected)

                    version = max(staticArrayOp.min_version, field.min_version)

                    actual, _ = elementExpr.__teal__(pt.CompileOptions(version=version))
                    actual.addIncoming()
                    actual = pt.TealBlock.NormalizeBlocks(actual)

                    assert (
                        actual == expected
                    ), "{}: static array field {} does not match expected".format(
                        staticArrayOp, field
                    )

                    if version > 2:
                        with pytest.raises(pt.TealInputError):
                            elementExpr.__teal__(pt.CompileOptions(version=version - 1))

                if dynamicArrayOp is not None:
                    dynamicIndex = pt.Int(2)
                    dynamicElementExpr = array[dynamicIndex]

                    immediateArgs = immediateArgsPrefix + [field.arg_name]
                    expected = pt.TealSimpleBlock(
                        irPrefix
                        + [
                            pt.TealOp(dynamicIndex, pt.Op.int, 2),
                            pt.TealOp(
                                dynamicElementExpr, dynamicArrayOp, *immediateArgs
                            ),
                        ]
                    )
                    expected.addIncoming()
                    expected = pt.TealBlock.NormalizeBlocks(expected)

                    version = max(dynamicArrayOp.min_version, field.min_version)

                    actual, _ = dynamicElementExpr.__teal__(
                        pt.CompileOptions(version=version)
                    )
                    actual.addIncoming()
                    actual = pt.TealBlock.NormalizeBlocks(actual)

                    assert (
                        actual == expected
                    ), "{}: dynamic array field {} does not match expected".format(
                        dynamicArrayOp, field
                    )

                    if version > 2:
                        with pytest.raises(pt.TealInputError):
                            dynamicElementExpr.__teal__(
                                pt.CompileOptions(version=version - 1)
                            )

                continue

            if field in arrayFieldToLengthField.values():
                # ignore length fields since they are checked with their arrays
                continue

            if field == pt.TxnField.first_valid_time:
                # ignore first_valid_time since it is not exposed on pt.TxnObject yet
                continue

            expr = fieldToMethod[field](txnObject)

            immediateArgs = immediateArgsPrefix + [field.arg_name]
            expected = pt.TealSimpleBlock(
                irPrefix + [pt.TealOp(expr, op, *immediateArgs)]
            )
            expected.addIncoming()
            expected = pt.TealBlock.NormalizeBlocks(expected)

            version = max(op.min_version, field.min_version)

            actual, _ = expr.__teal__(pt.CompileOptions(version=version))
            actual.addIncoming()
            actual = pt.TealBlock.NormalizeBlocks(actual)

            assert actual == expected, "{}: field {} does not match expected".format(
                op, field
            )

            if version > 2:
                with pytest.raises(pt.TealInputError):
                    expr.__teal__(pt.CompileOptions(version=version - 1))



================================================
FILE: pyteal/ast/unaryexpr.py
================================================
from typing import TYPE_CHECKING

from pyteal.types import TealType, require_type
from pyteal.errors import verifyProgramVersion
from pyteal.ir import TealOp, Op, TealBlock
from pyteal.ast.expr import Expr

if TYPE_CHECKING:
    from pyteal.compiler import CompileOptions


class UnaryExpr(Expr):
    """An expression with a single argument."""

    def __init__(
        self, op: Op, inputType: TealType, outputType: TealType, arg: Expr
    ) -> None:
        super().__init__()
        require_type(arg, inputType)
        self.op = op
        self.outputType = outputType
        self.arg = arg

    def __teal__(self, options: "CompileOptions"):
        verifyProgramVersion(
            self.op.min_version,
            options.version,
            "Program version too low to use op {}".format(self.op),
        )

        return TealBlock.FromOp(options, TealOp(self, self.op), self.arg)

    def __str__(self):
        return "({} {})".format(str(self.op).title().replace("_", ""), self.arg)

    def type_of(self):
        return self.outputType

    def has_return(self):
        return False


UnaryExpr.__module__ = "pyteal"


def Btoi(arg: Expr) -> UnaryExpr:
    """Convert a byte string to a uint64."""
    return UnaryExpr(Op.btoi, TealType.bytes, TealType.uint64, arg)


def Itob(arg: Expr) -> UnaryExpr:
    """Convert a uint64 string to a byte string."""
    return UnaryExpr(Op.itob, TealType.uint64, TealType.bytes, arg)


def Len(arg: Expr) -> UnaryExpr:
    """Get the length of a byte string."""
    return UnaryExpr(Op.len, TealType.bytes, TealType.uint64, arg)


def BitLen(arg: Expr) -> UnaryExpr:
    """Get the index of the highest nonzero bit in an integer.

    If the argument is 0, 0 will be returned.

    If the argument is a byte array, it is interpreted as a big-endian unsigned integer.

    Requires program version 4 or higher.
    """
    return UnaryExpr(Op.bitlen, TealType.anytype, TealType.uint64, arg)


def Sha256(arg: Expr) -> UnaryExpr:
    """Get the SHA-256 hash of a byte string."""
    return UnaryExpr(Op.sha256, TealType.bytes, TealType.bytes, arg)


def Sha512_256(arg: Expr) -> UnaryExpr:
    """Get the SHA-512/256 hash of a byte string."""
    return UnaryExpr(Op.sha512_256, TealType.bytes, TealType.bytes, arg)


def Sha3_256(arg: Expr) -> UnaryExpr:
    """Get the SHA3-256 hash of a byte string."""
    return UnaryExpr(Op.sha3_256, TealType.bytes, TealType.bytes, arg)


def Keccak256(arg: Expr) -> UnaryExpr:
    """Get the KECCAK-256 hash of a byte string."""
    return UnaryExpr(Op.keccak256, TealType.bytes, TealType.bytes, arg)


def Not(arg: Expr) -> UnaryExpr:
    """Get the logical inverse of a uint64.

    If the argument is 0, then this will produce 1. Otherwise this will produce 0.
    """
    return UnaryExpr(Op.logic_not, TealType.uint64, TealType.uint64, arg)


def BitwiseNot(arg: Expr) -> UnaryExpr:
    """Get the bitwise inverse of a uint64.

    Produces ~arg.
    """
    return UnaryExpr(Op.bitwise_not, TealType.uint64, TealType.uint64, arg)


def Sqrt(arg: Expr) -> UnaryExpr:
    """Get the integer square root of a uint64.

    This will return the largest integer X such that X^2 <= arg.

    Requires program version 4 or higher.
    """
    return UnaryExpr(Op.sqrt, TealType.uint64, TealType.uint64, arg)


def Pop(arg: Expr) -> UnaryExpr:
    """Pop a value from the stack."""
    return UnaryExpr(Op.pop, TealType.anytype, TealType.none, arg)


def Balance(account: Expr) -> UnaryExpr:
    """Get the balance of a user in microAlgos.

    Argument must be an index into Txn.Accounts that corresponds to the account to read from,
    must be evaluated to uint64 (or, since v4, an account address that appears in Txn.Accounts
    or is Txn.Sender).

    This operation is only permitted in application mode.
    """
    return UnaryExpr(Op.balance, TealType.anytype, TealType.uint64, account)


def MinBalance(account: Expr) -> UnaryExpr:
    """Get the minimum balance of a user in microAlgos.

    For more information about minimum balances, see: https://developer.algorand.org/docs/features/accounts/#minimum-balance

    Argument must be an index into Txn.Accounts that corresponds to the account to read from,
    must be evaluated to uint64 (or, since v4, an account address that appears in Txn.Accounts
    or is Txn.Sender).

    Requires program version 3 or higher. This operation is only permitted in application mode.
    """
    return UnaryExpr(Op.min_balance, TealType.anytype, TealType.uint64, account)


def BytesNot(arg: Expr) -> UnaryExpr:
    """Get the bitwise inverse of bytes.

    Produces ~arg.
    Argument must not exceed 64 bytes.

    Requires program version 4 or higher.
    """
    return UnaryExpr(Op.b_not, TealType.bytes, TealType.bytes, arg)


def BytesSqrt(arg: Expr) -> UnaryExpr:
    """Get the bytes square root of bytes.

    This will return the largest integer X such that X^2 <= arg.

    Requires program version 6 or higher.
    """
    return UnaryExpr(Op.bsqrt, TealType.bytes, TealType.bytes, arg)


def BytesZero(arg: Expr) -> UnaryExpr:
    """Get a byte-array of a specified length, containing all zero bytes.

    Argument must evaluate to uint64.

    Requires program version 4 or higher.
    """
    return UnaryExpr(Op.bzero, TealType.uint64, TealType.bytes, arg)


def Log(message: Expr) -> UnaryExpr:
    """Write a message to log state of the current application.

    This will fail if called more than :code:`MaxLogCalls` times in a program (32 as of AVM v5), or
    if the sum of the lengths of all logged messages in a program exceeds 1024 bytes.

    Args:
        message: The message to write. Must evaluate to bytes.

    Requires program version 5 or higher.
    """
    return UnaryExpr(Op.log, TealType.bytes, TealType.none, message)



================================================
FILE: pyteal/ast/unaryexpr_test.py
================================================
import pytest

import pyteal as pt

avm2Options = pt.CompileOptions(version=2)
avm3Options = pt.CompileOptions(version=3)
avm4Options = pt.CompileOptions(version=4)
avm5Options = pt.CompileOptions(version=5)
avm6Options = pt.CompileOptions(version=6)
avm7Options = pt.CompileOptions(version=7)


def test_btoi():
    arg = pt.Arg(1)
    expr = pt.Btoi(arg)
    assert expr.type_of() == pt.TealType.uint64

    expected = pt.TealSimpleBlock(
        [pt.TealOp(arg, pt.Op.arg, 1), pt.TealOp(expr, pt.Op.btoi)]
    )

    actual, _ = expr.__teal__(avm2Options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    assert actual == expected


def test_btoi_invalid():
    with pytest.raises(pt.TealTypeError):
        pt.Btoi(pt.Int(1))


def test_itob():
    arg = pt.Int(1)
    expr = pt.Itob(arg)
    assert expr.type_of() == pt.TealType.bytes

    expected = pt.TealSimpleBlock(
        [pt.TealOp(arg, pt.Op.int, 1), pt.TealOp(expr, pt.Op.itob)]
    )

    actual, _ = expr.__teal__(avm2Options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    assert actual == expected


def test_itob_invalid():
    with pytest.raises(pt.TealTypeError):
        pt.Itob(pt.Arg(1))


def test_len():
    arg = pt.Txn.receiver()
    expr = pt.Len(arg)
    assert expr.type_of() == pt.TealType.uint64

    expected = pt.TealSimpleBlock(
        [pt.TealOp(arg, pt.Op.txn, "Receiver"), pt.TealOp(expr, pt.Op.len)]
    )

    actual, _ = expr.__teal__(avm2Options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    assert actual == expected


def test_len_invalid():
    with pytest.raises(pt.TealTypeError):
        pt.Len(pt.Int(1))


def test_bitlen_int():
    arg = pt.Int(7)
    expr = pt.BitLen(arg)
    assert expr.type_of() == pt.TealType.uint64

    expected = pt.TealSimpleBlock(
        [pt.TealOp(arg, pt.Op.int, 7), pt.TealOp(expr, pt.Op.bitlen)]
    )

    actual, _ = expr.__teal__(avm4Options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    assert actual == expected


def test_bitlen_bytes():
    arg = pt.Txn.receiver()
    expr = pt.BitLen(arg)
    assert expr.type_of() == pt.TealType.uint64

    expected = pt.TealSimpleBlock(
        [pt.TealOp(arg, pt.Op.txn, "Receiver"), pt.TealOp(expr, pt.Op.bitlen)]
    )

    actual, _ = expr.__teal__(avm4Options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    assert actual == expected


def test_sha256():
    arg = pt.Arg(0)
    expr = pt.Sha256(arg)
    assert expr.type_of() == pt.TealType.bytes

    expected = pt.TealSimpleBlock(
        [pt.TealOp(arg, pt.Op.arg, 0), pt.TealOp(expr, pt.Op.sha256)]
    )

    actual, _ = expr.__teal__(avm2Options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    assert actual == expected


def test_sha256_invalid():
    with pytest.raises(pt.TealTypeError):
        pt.Sha256(pt.Int(1))


def test_sha512_256():
    arg = pt.Arg(0)
    expr = pt.Sha512_256(arg)
    assert expr.type_of() == pt.TealType.bytes

    expected = pt.TealSimpleBlock(
        [pt.TealOp(arg, pt.Op.arg, 0), pt.TealOp(expr, pt.Op.sha512_256)]
    )

    actual, _ = expr.__teal__(avm2Options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    assert actual == expected


def test_sha512_256_invalid():
    with pytest.raises(pt.TealTypeError):
        pt.Sha512_256(pt.Int(1))


def test_sha3_256():
    arg = pt.Arg(0)
    expr = pt.Sha3_256(arg)
    assert expr.type_of() == pt.TealType.bytes

    expected = pt.TealSimpleBlock(
        [pt.TealOp(arg, pt.Op.arg, 0), pt.TealOp(expr, pt.Op.sha3_256)]
    )

    actual, _ = expr.__teal__(avm7Options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    assert actual == expected


def test_sha3_256_invalid():
    with pytest.raises(pt.TealTypeError):
        pt.Sha3_256(pt.Int(1))


def test_keccak256():
    arg = pt.Arg(0)
    expr = pt.Keccak256(arg)
    assert expr.type_of() == pt.TealType.bytes

    expected = pt.TealSimpleBlock(
        [pt.TealOp(arg, pt.Op.arg, 0), pt.TealOp(expr, pt.Op.keccak256)]
    )

    actual, _ = expr.__teal__(avm2Options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    assert actual == expected


def test_keccak256_invalid():
    with pytest.raises(pt.TealTypeError):
        pt.Keccak256(pt.Int(1))


def test_not():
    arg = pt.Int(1)
    expr = pt.Not(arg)
    assert expr.type_of() == pt.TealType.uint64

    expected = pt.TealSimpleBlock(
        [pt.TealOp(arg, pt.Op.int, 1), pt.TealOp(expr, pt.Op.logic_not)]
    )

    actual, _ = expr.__teal__(avm2Options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    assert actual == expected


def test_not_invalid():
    with pytest.raises(pt.TealTypeError):
        pt.Not(pt.Txn.receiver())


def test_bitwise_not():
    arg = pt.Int(2)
    expr = pt.BitwiseNot(arg)
    assert expr.type_of() == pt.TealType.uint64

    expected = pt.TealSimpleBlock(
        [pt.TealOp(arg, pt.Op.int, 2), pt.TealOp(expr, pt.Op.bitwise_not)]
    )

    actual, _ = expr.__teal__(avm2Options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    assert actual == expected


def test_bitwise_not_overload():
    arg = pt.Int(10)
    expr = ~arg
    assert expr.type_of() == pt.TealType.uint64

    expected = pt.TealSimpleBlock(
        [pt.TealOp(arg, pt.Op.int, 10), pt.TealOp(expr, pt.Op.bitwise_not)]
    )

    actual, _ = expr.__teal__(avm2Options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    assert actual == expected


def test_bitwise_not_invalid():
    with pytest.raises(pt.TealTypeError):
        pt.BitwiseNot(pt.Txn.receiver())


def test_sqrt():
    arg = pt.Int(4)
    expr = pt.Sqrt(arg)
    assert expr.type_of() == pt.TealType.uint64

    expected = pt.TealSimpleBlock(
        [pt.TealOp(arg, pt.Op.int, 4), pt.TealOp(expr, pt.Op.sqrt)]
    )

    actual, _ = expr.__teal__(avm4Options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    assert actual == expected


def test_sqrt_invalid():
    with pytest.raises(pt.TealTypeError):
        pt.Sqrt(pt.Txn.receiver())


def test_pop():
    arg_int = pt.Int(3)
    expr_int = pt.Pop(arg_int)
    assert expr_int.type_of() == pt.TealType.none

    expected_int = pt.TealSimpleBlock(
        [pt.TealOp(arg_int, pt.Op.int, 3), pt.TealOp(expr_int, pt.Op.pop)]
    )

    actual_int, _ = expr_int.__teal__(avm2Options)
    actual_int.addIncoming()
    actual_int = pt.TealBlock.NormalizeBlocks(actual_int)

    assert actual_int == expected_int

    arg_bytes = pt.Txn.receiver()
    expr_bytes = pt.Pop(arg_bytes)
    assert expr_bytes.type_of() == pt.TealType.none

    expected_bytes = pt.TealSimpleBlock(
        [pt.TealOp(arg_bytes, pt.Op.txn, "Receiver"), pt.TealOp(expr_bytes, pt.Op.pop)]
    )

    actual_bytes, _ = expr_bytes.__teal__(avm2Options)
    actual_bytes.addIncoming()
    actual_bytes = pt.TealBlock.NormalizeBlocks(actual_bytes)

    assert actual_bytes == expected_bytes


def test_pop_invalid():
    expr = pt.Pop(pt.Int(0))
    with pytest.raises(pt.TealTypeError):
        pt.Pop(expr)


def test_balance():
    arg = pt.Int(0)
    expr = pt.Balance(arg)
    assert expr.type_of() == pt.TealType.uint64

    expected = pt.TealSimpleBlock(
        [pt.TealOp(arg, pt.Op.int, 0), pt.TealOp(expr, pt.Op.balance)]
    )

    actual, _ = expr.__teal__(avm2Options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    assert actual == expected


def test_balance_direct_ref():
    arg = pt.Txn.sender()
    expr = pt.Balance(arg)
    assert expr.type_of() == pt.TealType.uint64

    expected = pt.TealSimpleBlock(
        [pt.TealOp(arg, pt.Op.txn, "Sender"), pt.TealOp(expr, pt.Op.balance)]
    )

    actual, _ = expr.__teal__(avm2Options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    assert actual == expected


def test_balance_invalid():
    with pytest.raises(pt.TealTypeError):
        args = [pt.Txn.sender(), pt.Int(17)]
        expr = pt.AssetHolding.balance(args[0], args[1])
        pt.MinBalance(expr)


def test_min_balance():
    arg = pt.Int(0)
    expr = pt.MinBalance(arg)
    assert expr.type_of() == pt.TealType.uint64

    expected = pt.TealSimpleBlock(
        [pt.TealOp(arg, pt.Op.int, 0), pt.TealOp(expr, pt.Op.min_balance)]
    )

    actual, _ = expr.__teal__(avm3Options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    assert actual == expected


def test_min_balance_direct_ref():
    arg = pt.Txn.sender()
    expr = pt.MinBalance(arg)
    assert expr.type_of() == pt.TealType.uint64

    expected = pt.TealSimpleBlock(
        [pt.TealOp(arg, pt.Op.txn, "Sender"), pt.TealOp(expr, pt.Op.min_balance)]
    )

    actual, _ = expr.__teal__(avm3Options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    assert actual == expected


def test_min_balance_invalid():
    with pytest.raises(pt.TealTypeError):
        args = [pt.Txn.sender(), pt.Int(17)]
        expr = pt.AssetHolding.balance(args[0], args[1])
        pt.MinBalance(expr)


def test_b_not():
    arg = pt.Bytes("base16", "0xFFFFFFFFFFFFFFFFFF")
    expr = pt.BytesNot(arg)
    assert expr.type_of() == pt.TealType.bytes

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(arg, pt.Op.byte, "0xFFFFFFFFFFFFFFFFFF"),
            pt.TealOp(expr, pt.Op.b_not),
        ]
    )

    actual, _ = expr.__teal__(avm4Options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    assert actual == expected


def test_b_not_invalid():
    with pytest.raises(pt.TealTypeError):
        pt.BytesNot(pt.Int(2))


def test_bsqrt():
    arg = pt.Bytes("base16", "0xFEDCBA9876543210")
    expr = pt.BytesSqrt(arg)
    assert expr.type_of() == pt.TealType.bytes

    expected = pt.TealSimpleBlock(
        [pt.TealOp(arg, pt.Op.byte, "0xFEDCBA9876543210"), pt.TealOp(expr, pt.Op.bsqrt)]
    )

    actual, _ = expr.__teal__(avm6Options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    assert actual == expected


def test_bsqrt_invalid():
    with pytest.raises(pt.TealTypeError):
        pt.BytesSqrt(pt.Int(2**64 - 1))


def test_b_zero():
    arg = pt.Int(8)
    expr = pt.BytesZero(arg)
    assert expr.type_of() == pt.TealType.bytes

    expected = pt.TealSimpleBlock(
        [pt.TealOp(arg, pt.Op.int, 8), pt.TealOp(expr, pt.Op.bzero)]
    )

    actual, _ = expr.__teal__(avm4Options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    assert actual == expected


def test_b_zero_invalid():
    with pytest.raises(pt.TealTypeError):
        pt.BytesZero(pt.Bytes("base16", "0x11"))


def test_log():
    arg = pt.Bytes("message")
    expr = pt.Log(arg)
    assert expr.type_of() == pt.TealType.none
    assert not expr.has_return()

    expected = pt.TealSimpleBlock(
        [pt.TealOp(arg, pt.Op.byte, '"message"'), pt.TealOp(expr, pt.Op.log)]
    )

    actual, _ = expr.__teal__(avm5Options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    assert actual == expected

    with pytest.raises(pt.TealInputError):
        expr.__teal__(avm4Options)


def test_log_invalid():
    with pytest.raises(pt.TealTypeError):
        pt.Log(pt.Int(7))



================================================
FILE: pyteal/ast/voter.py
================================================
from enum import Enum
from typing import Final, TYPE_CHECKING
from pyteal.errors import verifyFieldVersion, verifyProgramVersion

from pyteal.types import TealType, require_type
from pyteal.ir import Op
from pyteal.ast.expr import Expr
from pyteal.ast.maybe import MaybeValue

if TYPE_CHECKING:
    from pyteal.compiler import CompileOptions


class VoterParamField(Enum):
    # fmt: off
    #                    id  |         name               |     type    |  min version
    balance               = (0,  "VoterBalance",            TealType.uint64, 11)  # noqa: E221
    incentive_eligible    = (1,  "VoterIncentiveEligible",  TealType.uint64, 11)  # noqa: E221
    # fmt: on

    def __init__(self, id: int, name: str, type: TealType, min_version: int) -> None:
        self.id = id
        self.arg_name = name
        self.type = type
        self.min_version = min_version

    def type_of(self) -> TealType:
        return self.type


VoterParamField.__module__ = "pyteal"


class VoterParam:
    @staticmethod
    def __makeVoterParamExpr(field: VoterParamField, acct: Expr) -> MaybeValue:
        require_type(acct, TealType.anytype)

        def field_and_program_version_check(options: "CompileOptions"):
            verifyProgramVersion(
                minVersion=Op.voter_params_get.min_version,
                version=options.version,
                msg=f"{Op.voter_params_get.value} unavailable",
            )
            verifyFieldVersion(field.arg_name, field.min_version, options.version)

        return MaybeValue(
            Op.voter_params_get,
            field.type_of(),
            immediate_args=[field.arg_name],
            args=[acct],
            compile_check=field_and_program_version_check,
        )

    @classmethod
    def balance(cls, acct: Expr) -> MaybeValue:
        """Get the balance in microalgos for an account in the balance round (current - 320).

        Args:
            acct: An index into Txn.accounts that corresponds to the application to check or an address available at runtime.
                May evaluate to uint64 or an address.
        """
        return cls.__makeVoterParamExpr(VoterParamField.balance, acct)

    @classmethod
    def incentiveEligible(cls, acct: Expr) -> MaybeValue:
        """Get account's eligibility status for block incentives as of the balance round.

        Requires program version 11 or higher.

        Args:
            acct: An index into Txn.accounts that corresponds to the application to check or an address available at runtime.
                May evaluate to uint64 or an address.
        """
        return cls.__makeVoterParamExpr(VoterParamField.incentive_eligible, acct)


VoterParam.__module__ = "pyteal"


class VoterParamObject:
    """Represents information about an account"""

    def __init__(self, account: Expr) -> None:
        """Create a new VoterParamObject for the given account.

        Args:
            account: An index into Txn.accounts that corresponds to the application to check or an
                address available at runtime. May evaluate to uint64 or bytes, respectively.
        """
        self._account: Final = account

    def balance(self) -> MaybeValue:
        """Get the current balance in microAlgos for the account"""
        return VoterParam.balance(self._account)

    def incentive_eligible(self) -> MaybeValue:
        """Get account's eligibility status for block incentives."""
        return VoterParam.incentiveEligible(self._account)


VoterParamObject.__module__ = "pyteal"



================================================
FILE: pyteal/ast/voter_test.py
================================================
import pytest

import pyteal as pt
from pyteal.ast.voter import VoterParamField
from pyteal.ast.maybe_test import assert_MaybeValue_equality

avm10Options = pt.CompileOptions(version=10)
avm11Options = pt.CompileOptions(version=11)


@pytest.mark.parametrize(
    "method_name,field_name",
    [
        ("balance", "balance"),
        ("incentiveEligible", "incentive_eligible"),
    ],
)
class TestVoterParam:
    @staticmethod
    def test_voter_param_fields_valid(method_name, field_name):
        arg = pt.Int(1)
        voter_param_method = getattr(pt.VoterParam, method_name)
        expr = voter_param_method(arg)
        assert expr.type_of() == pt.TealType.none

        voter_param_field = VoterParamField[field_name]
        assert expr.value().type_of() == voter_param_field.type_of()

        expected = pt.TealSimpleBlock(
            [
                pt.TealOp(arg, pt.Op.int, 1),
                pt.TealOp(expr, pt.Op.voter_params_get, voter_param_field.arg_name),
                pt.TealOp(None, pt.Op.store, expr.slotOk),
                pt.TealOp(None, pt.Op.store, expr.slotValue),
            ]
        )

        supported_options_version = pt.CompileOptions(
            version=voter_param_field.min_version
        )
        actual, _ = expr.__teal__(supported_options_version)
        actual.addIncoming()
        actual = pt.TealBlock.NormalizeBlocks(actual)

        with pt.TealComponent.Context.ignoreExprEquality():
            assert actual == expected

    @staticmethod
    def test_voter_param_version_checks(method_name, field_name):
        arg = pt.Int(1)
        voter_param_method = getattr(pt.VoterParam, method_name)
        expr = voter_param_method(arg)

        voter_param_field = VoterParamField[field_name]

        def test_unsupported_version(version: int, match: str | None = None):
            with pytest.raises(pt.TealInputError, match=match):
                unsupported_options_version = pt.CompileOptions(version=version)
                expr.__teal__(unsupported_options_version)

        # Test program and field version checks
        program_unsupported_version = pt.ir.Op.voter_params_get.min_version - 1
        program_error_match = "unavailable"
        test_unsupported_version(program_unsupported_version, program_error_match)

        field_unsupported_version = voter_param_field.min_version - 1

        # Since program version dominates, we conditionally check field error message or program error message
        # depending on whether the unsupported field version is less than or equal to the program unsupported
        # version.
        field_error_match = (
            "Program version too low to use field"
            if field_unsupported_version > program_unsupported_version
            else program_error_match
        )
        test_unsupported_version(field_unsupported_version, field_error_match)


def test_VoterParamObject():
    for account in (
        pt.Int(7),
        pt.Addr("QSA6K5MNJPEGO5SDSWXBM3K4UEI3Q2NCPS2OUXVJI5QPCHMVI27MFRSHKI"),
    ):
        obj = pt.VoterParamObject(account)

        assert obj._account is account

        assert_MaybeValue_equality(
            obj.balance(), pt.VoterParam.balance(account), avm11Options
        )
        assert_MaybeValue_equality(
            obj.incentive_eligible(),
            pt.VoterParam.incentiveEligible(account),
            avm11Options,
        )



================================================
FILE: pyteal/ast/vrfverify.py
================================================
from enum import Enum

from pyteal.types import TealType, require_type
from pyteal.errors import verifyFieldVersion
from pyteal.ir import Op
from pyteal.ast.multi import MultiValue
from pyteal.ast.expr import Expr


class VrfVerifyStandard(Enum):
    # fmt: off
    #           id  |   name   | min version
    algorand =  (0, "VrfAlgorand",  7)  # noqa: E222
    chainlink = (1, "VrfChainlink", 7)
    # fmt: on

    def __init__(self, id: int, name: str, min_version: int) -> None:
        self.id = id
        self.arg_name = name
        self.min_version = min_version


VrfVerifyStandard.__module__ = "pyteal"


class VrfVerify(MultiValue):
    """An expression that verifies the proof of a message against a public key."""

    def __init__(
        self, standard: VrfVerifyStandard, message: Expr, proof: Expr, public_key: Expr
    ) -> None:
        require_type(message, TealType.bytes)
        require_type(proof, TealType.bytes)
        require_type(public_key, TealType.bytes)

        self.standard = standard

        super().__init__(
            Op.vrf_verify,
            [TealType.bytes, TealType.uint64],
            immediate_args=[standard.arg_name],
            args=[message, proof, public_key],
            compile_check=lambda options: verifyFieldVersion(
                standard.arg_name, standard.min_version, options.version
            ),
        )

    def __str__(self):
        return "(VrfVerify {})".format(self.standard.arg_name)

    @classmethod
    def algorand(cls, message: Expr, proof: Expr, public_key: Expr) -> "VrfVerify":
        """Verifies the proof of a message against a public key using the Algorand VRF standard.

        Args:
            message: The message to verify.
            proof: The proof of the message.
            public_key: The public key to use to verify the proof.

        Returns:
            A MultiValue expression representing the VRF output and a verification flag.
        """
        return cls(VrfVerifyStandard.algorand, message, proof, public_key)

    @classmethod
    def chainlink(cls, message: Expr, proof: Expr, public_key: Expr) -> "VrfVerify":
        """Verifies the proof of a message against a public key using the Chainlink VRF standard.

        Args:
            message: The message to verify.
            proof: The proof of the message.
            public_key: The public key to use to verify the proof.

        Returns:
            A MultiValue expression representing the VRF output and a verification flag.
        """
        return cls(VrfVerifyStandard.chainlink, message, proof, public_key)


VrfVerify.__module__ = "pyteal"



================================================
FILE: pyteal/ast/vrfverify_test.py
================================================
import pytest

import pyteal as pt

teal6Options = pt.CompileOptions(version=6)
teal7Options = pt.CompileOptions(version=7)


def test_vrf_verify_algorand():
    args = [pt.Bytes("a"), pt.Bytes("b"), pt.Bytes("c")]
    expr = pt.VrfVerify.algorand(*args)
    assert expr.type_of() == pt.TealType.none

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(args[0], pt.Op.byte, '"a"'),
            pt.TealOp(args[1], pt.Op.byte, '"b"'),
            pt.TealOp(args[2], pt.Op.byte, '"c"'),
            pt.TealOp(expr, pt.Op.vrf_verify, "VrfAlgorand"),
            pt.TealOp(expr.output_slots[1], pt.Op.store, expr.output_slots[1]),
            pt.TealOp(expr.output_slots[0], pt.Op.store, expr.output_slots[0]),
        ]
    )

    actual, _ = expr.__teal__(teal7Options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    with pt.TealComponent.Context.ignoreExprEquality():
        assert actual == expected

    with pytest.raises(pt.TealInputError):
        expr.__teal__(teal6Options)


def test_vrf_verify_chainlink():
    args = [pt.Bytes("a"), pt.Bytes("b"), pt.Bytes("c")]
    expr = pt.VrfVerify.chainlink(*args)
    assert expr.type_of() == pt.TealType.none

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(args[0], pt.Op.byte, '"a"'),
            pt.TealOp(args[1], pt.Op.byte, '"b"'),
            pt.TealOp(args[2], pt.Op.byte, '"c"'),
            pt.TealOp(expr, pt.Op.vrf_verify, "VrfChainlink"),
            pt.TealOp(expr.output_slots[1], pt.Op.store, expr.output_slots[1]),
            pt.TealOp(expr.output_slots[0], pt.Op.store, expr.output_slots[0]),
        ]
    )

    actual, _ = expr.__teal__(teal7Options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    with pt.TealComponent.Context.ignoreExprEquality():
        assert actual == expected

    with pytest.raises(pt.TealInputError):
        expr.__teal__(teal6Options)


def test_vrf_verify_invalid():
    with pytest.raises(pt.TealTypeError):
        pt.VrfVerify.algorand(pt.Int(0), pt.Bytes("b"), pt.Bytes("c"))

    with pytest.raises(pt.TealTypeError):
        pt.VrfVerify.chainlink(pt.Bytes("a"), pt.Int(0), pt.Bytes("c"))

    with pytest.raises(pt.TealTypeError):
        pt.VrfVerify.chainlink(pt.Bytes("a"), pt.Bytes("b"), pt.Int(0))



================================================
FILE: pyteal/ast/while_.py
================================================
from typing import TYPE_CHECKING, Optional
from pyteal.ast.seq import _use_seq_if_multiple

from pyteal.errors import TealCompileError
from pyteal.types import TealType, require_type
from pyteal.ir import TealSimpleBlock, TealConditionalBlock
from pyteal.ast.expr import Expr

if TYPE_CHECKING:
    from pyteal.compiler import CompileOptions


class While(Expr):
    """While expression."""

    def __init__(self, cond: Expr) -> None:
        """Create a new While expression.

        When this While expression is executed, the condition will be evaluated, and if it produces a
        true value, doBlock will be executed and return to the start of the expression execution.
        Otherwise, no branch will be executed.

        Args:
            cond: The condition to check. Must evaluate to uint64.

        Example:
            .. code-block:: python

                i = ScratchVar()
                i.store(Int(0))
                While(i.load() < pt.Int(2))
                    .Do(Pop(Int(1)), i.store(i.load() + Int(1)))
        """
        super().__init__()
        require_type(cond, TealType.uint64)

        self.cond = cond
        self.doBlock: Optional[Expr] = None

    def __teal__(self, options: "CompileOptions"):
        if self.doBlock is None:
            raise TealCompileError("While expression must have a doBlock", self)

        options.enterLoop()

        condStart, condEnd = self.cond.__teal__(options)
        doStart, doEnd = self.doBlock.__teal__(options)
        end = TealSimpleBlock([])

        doEnd.setNextBlock(condStart)
        doEnd._sframes_container = self

        branchBlock = TealConditionalBlock([], root_expr=self)
        branchBlock.setTrueBlock(doStart)
        branchBlock.setFalseBlock(end)

        condEnd.setNextBlock(branchBlock)

        breakBlocks, continueBlocks = options.exitLoop()

        for block in breakBlocks:
            block.setNextBlock(end)

        for block in continueBlocks:
            block.setNextBlock(condStart)

        return condStart, end

    def __str__(self):
        if self.doBlock is None:
            raise TealCompileError("While expression must have a doBlock", self)

        return "(While {} {})".format(self.cond, self.doBlock)

    def type_of(self):
        if self.doBlock is None:
            raise TealCompileError("While expression must have a doBlock", self)
        return TealType.none

    def has_return(self):
        return False

    def Do(self, doBlock: Expr, *do_block_multi: Expr):
        if self.doBlock is not None:
            raise TealCompileError("While expression already has a doBlock", self)

        doBlock = _use_seq_if_multiple(doBlock, *do_block_multi)

        require_type(doBlock, TealType.none)

        self.doBlock = doBlock
        return self


While.__module__ = "pyteal"



================================================
FILE: pyteal/ast/while_test.py
================================================
import pytest

import pyteal as pt

options = pt.CompileOptions()


def test_while_compiles():
    i = pt.ScratchVar()
    expr = pt.While(pt.Int(2)).Do(pt.Seq([i.store(pt.Int(0))]))
    assert expr.type_of() == pt.TealType.none
    assert not expr.has_return()
    expr.__teal__(options)


def test_nested_whiles_compile():
    i = pt.ScratchVar()
    expr = pt.While(pt.Int(2)).Do(
        pt.Seq([pt.While(pt.Int(2)).Do(pt.Seq([i.store(pt.Int(0))]))])
    )
    assert expr.type_of() == pt.TealType.none
    assert not expr.has_return()


def test_continue_break():
    expr = pt.While(pt.Int(0)).Do(pt.Seq([pt.If(pt.Int(1), pt.Break(), pt.Continue())]))
    assert expr.type_of() == pt.TealType.none
    assert not expr.has_return()
    expr.__teal__(options)


def test_while():
    i = pt.ScratchVar()
    i.store(pt.Int(0))
    items = [i.load() < pt.Int(2), [i.store(i.load() + pt.Int(1))]]
    expr = pt.While(items[0]).Do(pt.Seq(items[1]))
    assert expr.type_of() == pt.TealType.none
    assert not expr.has_return()

    expected, condEnd = items[0].__teal__(options)
    do, doEnd = pt.Seq(items[1]).__teal__(options)
    expectedBranch = pt.TealConditionalBlock([])
    end = pt.TealSimpleBlock([])

    expectedBranch.setTrueBlock(do)
    expectedBranch.setFalseBlock(end)
    condEnd.setNextBlock(expectedBranch)
    doEnd.setNextBlock(expected)
    actual, _ = expr.__teal__(options)

    assert actual == expected


def test_while_continue():
    i = pt.ScratchVar()
    i.store(pt.Int(0))
    items = [
        i.load() < pt.Int(2),
        i.store(i.load() + pt.Int(1)),
        pt.If(i.load() == pt.Int(1), pt.Continue()),
    ]
    expr = pt.While(items[0]).Do(pt.Seq(items[1], items[2]))
    assert expr.type_of() == pt.TealType.none
    assert not expr.has_return()

    options.enterLoop()

    expected, condEnd = items[0].__teal__(options)
    do, doEnd = pt.Seq([items[1], items[2]]).__teal__(options)
    expectedBranch = pt.TealConditionalBlock([])
    end = pt.TealSimpleBlock([])

    expectedBranch.setTrueBlock(do)
    expectedBranch.setFalseBlock(end)
    condEnd.setNextBlock(expectedBranch)
    doEnd.setNextBlock(expected)

    _, continueBlocks = options.exitLoop()

    for block in continueBlocks:
        block.setNextBlock(do)

    actual, _ = expr.__teal__(options)

    assert actual == expected


def test_while_break():
    i = pt.ScratchVar()
    i.store(pt.Int(0))
    items = [
        i.load() < pt.Int(2),
        i.store(i.load() + pt.Int(1)),
        pt.If(i.load() == pt.Int(1), pt.Break()),
    ]
    expr = pt.While(items[0]).Do(pt.Seq(items[1], items[2]))
    assert expr.type_of() == pt.TealType.none
    assert not expr.has_return()

    options.enterLoop()

    expected, condEnd = items[0].__teal__(options)
    do, doEnd = pt.Seq([items[1], items[2]]).__teal__(options)
    expectedBranch = pt.TealConditionalBlock([])
    end = pt.TealSimpleBlock([])

    expectedBranch.setTrueBlock(do)
    expectedBranch.setFalseBlock(end)
    condEnd.setNextBlock(expectedBranch)
    doEnd.setNextBlock(expected)

    breakBlocks, _ = options.exitLoop()

    for block in breakBlocks:
        block.setNextBlock(end)

    actual, _ = expr.__teal__(options)

    assert actual == expected


def test_while_invalid():
    with pytest.raises(TypeError):
        expr = pt.While()

    with pytest.raises(pt.TealCompileError):
        expr = pt.While(pt.Int(2))
        expr.type_of()

    with pytest.raises(pt.TealCompileError):
        expr = pt.While(pt.Int(2))
        expr.__teal__(options)

    with pytest.raises(pt.TealCompileError):
        expr = pt.While(pt.Int(2))
        expr.type_of()

    with pytest.raises(pt.TealCompileError):
        expr = pt.While(pt.Int(2))
        expr.__str__()

    with pytest.raises(pt.TealTypeError):
        expr = pt.While(pt.Int(2)).Do(pt.Int(2))

    with pytest.raises(pt.TealTypeError):
        expr = pt.While(pt.Int(2)).Do(pt.Pop(pt.Int(2)), pt.Int(2))

    with pytest.raises(pt.TealCompileError):
        expr = pt.While(pt.Int(0)).Do(pt.Continue()).Do(pt.Continue())
        expr.__str__()


def test_while_multi():
    i = pt.ScratchVar()
    i.store(pt.Int(0))
    items = [i.load() < pt.Int(2), [pt.Pop(pt.Int(1)), i.store(i.load() + pt.Int(1))]]
    expr = pt.While(items[0]).Do(*items[1])
    assert expr.type_of() == pt.TealType.none
    assert not expr.has_return()

    expected, condEnd = items[0].__teal__(options)
    do, doEnd = pt.Seq(items[1]).__teal__(options)
    expectedBranch = pt.TealConditionalBlock([])
    end = pt.TealSimpleBlock([])

    expectedBranch.setTrueBlock(do)
    expectedBranch.setFalseBlock(end)
    condEnd.setNextBlock(expectedBranch)
    doEnd.setNextBlock(expected)
    actual, _ = expr.__teal__(options)

    assert actual == expected



================================================
FILE: pyteal/ast/widemath.py
================================================
from typing import List, Tuple, TYPE_CHECKING

from pyteal.types import TealType
from pyteal.errors import TealInternalError, TealCompileError
from pyteal.ir import TealOp, Op, TealSimpleBlock
from pyteal.ast.expr import Expr

if TYPE_CHECKING:
    from pyteal.compiler import CompileOptions


def multiplyFactors(
    expr: Expr, factors: List[Expr], options: "CompileOptions"
) -> Tuple[TealSimpleBlock, TealSimpleBlock]:
    if len(factors) == 0:
        raise TealInternalError("Received 0 factors")

    start = TealSimpleBlock([])

    fac0Start, fac0End = factors[0].__teal__(options)

    if len(factors) == 1:
        # need to use 0 as high word
        highword = TealSimpleBlock([TealOp(expr, Op.int, 0)])

        start.setNextBlock(highword)
        highword.setNextBlock(fac0Start)

        end = fac0End
    else:
        start.setNextBlock(fac0Start)

        fac1Start, fac1End = factors[1].__teal__(options)
        fac0End.setNextBlock(fac1Start)

        multiplyFirst2 = TealSimpleBlock([TealOp(expr, Op.mulw)])
        fac1End.setNextBlock(multiplyFirst2)

        end = multiplyFirst2
        for factor in factors[2:]:
            facXStart, facXEnd = factor.__teal__(options)
            end.setNextBlock(facXStart)

            # stack is [..., A, B, C], where C is current factor
            # need to pop all A,B,C from stack and push X,Y, where X and Y are:
            #       X * 2**64 + Y = (A * 2**64 + B) * C
            # <=>   X * 2**64 + Y = A * C * 2**64 + B * C
            # <=>   X = A * C + highword(B * C)
            #       Y = lowword(B * C)
            multiply = TealSimpleBlock(
                [
                    TealOp(expr, Op.uncover, 2),  # stack: [..., B, C, A]
                    TealOp(expr, Op.dig, 1),  # stack: [..., B, C, A, C]
                    TealOp(expr, Op.mul),  # stack: [..., B, C, A*C]
                    TealOp(expr, Op.cover, 2),  # stack: [..., A*C, B, C]
                    TealOp(
                        expr, Op.mulw
                    ),  # stack: [..., A*C, highword(B*C), lowword(B*C)]
                    TealOp(
                        expr, Op.cover, 2
                    ),  # stack: [..., lowword(B*C), A*C, highword(B*C)]
                    TealOp(
                        expr, Op.add
                    ),  # stack: [..., lowword(B*C), A*C+highword(B*C)]
                    TealOp(
                        expr, Op.swap
                    ),  # stack: [..., A*C+highword(B*C), lowword(B*C)]
                ]
            )

            facXEnd.setNextBlock(multiply)
            end = multiply

    return start, end


class WideRatio(Expr):
    """A class used to calculate expressions of the form :code:`(N_1 * N_2 * N_3 * ...) / (D_1 * D_2 * D_3 * ...)`

    Use this class if all inputs to the expression are uint64s, the output fits in a uint64, and all
    intermediate values fit in a uint128.
    """

    def __init__(
        self, numeratorFactors: List[Expr], denominatorFactors: List[Expr]
    ) -> None:
        """Create a new WideRatio expression with the given numerator and denominator factors.

        This will calculate :code:`(N_1 * N_2 * N_3 * ...) / (D_1 * D_2 * D_3 * ...)`, where each
        :code:`N_i` represents an element in :code:`numeratorFactors` and each :code:`D_i`
        represents an element in :code:`denominatorFactors`.

        Requires program version 5 or higher.

        Args:
            numeratorFactors: The factors in the numerator of the ratio. This list must have at
                least 1 element. If this list has exactly 1 element, then denominatorFactors must
                have more than 1 element (otherwise basic division should be used).
            denominatorFactors: The factors in the denominator of the ratio. This list must have at
                least 1 element.
        """
        super().__init__()
        if len(numeratorFactors) == 0 or len(denominatorFactors) == 0:
            raise TealInternalError(
                "At least 1 factor must be present in the numerator and denominator"
            )
        if len(numeratorFactors) == 1 and len(denominatorFactors) == 1:
            raise TealInternalError(
                "There is only a single factor in the numerator and denominator. Use basic division instead."
            )
        self.numeratorFactors = numeratorFactors
        self.denominatorFactors = denominatorFactors

    def __teal__(self, options: "CompileOptions"):
        if options.version < Op.cover.min_version:
            raise TealCompileError(
                "WideRatio requires program version {} or higher".format(
                    Op.cover.min_version
                ),
                self,
            )

        numStart, numEnd = multiplyFactors(self, self.numeratorFactors, options)
        denomStart, denomEnd = multiplyFactors(self, self.denominatorFactors, options)
        numEnd.setNextBlock(denomStart)

        combine = TealSimpleBlock(
            [
                TealOp(self, Op.divmodw),
                TealOp(self, Op.pop),  # pop remainder low word
                TealOp(self, Op.pop),  # pop remainder high word
                TealOp(self, Op.swap),  # swap quotient high and low words
                TealOp(self, Op.logic_not),
                TealOp(self, Op.assert_),  # assert quotient high word is 0
                # end with quotient low word remaining on the stack
            ]
        )
        denomEnd.setNextBlock(combine)

        return numStart, combine

    def __str__(self):
        ret_str = "(WideRatio (*"
        for f in self.numeratorFactors:
            ret_str += " " + str(f)
        ret_str += ") (*"
        for f in self.denominatorFactors:
            ret_str += " " + str(f)
        ret_str += ")"
        return ret_str

    def type_of(self):
        return TealType.uint64

    def has_return(self):
        return False


WideRatio.__module__ = "pyteal"



================================================
FILE: pyteal/ast/abi/__init__.py
================================================
from pyteal.ast.abi.string import String, StringTypeSpec
from pyteal.ast.abi.address import (
    AddressTypeSpec,
    Address,
    AddressLength,
)
from pyteal.ast.abi.type import TypeSpec, BaseType, ComputedValue, ReturnedValue
from pyteal.ast.abi.bool import BoolTypeSpec, Bool
from pyteal.ast.abi.uint import (
    UintTypeSpec,
    Uint,
    ByteTypeSpec,
    Byte,
    Uint8TypeSpec,
    Uint8,
    Uint16TypeSpec,
    Uint16,
    Uint32TypeSpec,
    Uint32,
    Uint64TypeSpec,
    Uint64,
)
from pyteal.ast.abi.tuple import (
    TupleTypeSpec,
    Tuple,
    TupleElement,
    Tuple0,
    Tuple1,
    Tuple2,
    Tuple3,
    Tuple4,
    Tuple5,
    NamedTuple,
    NamedTupleTypeSpec,
    Field,
)
from pyteal.ast.abi.array_base import ArrayTypeSpec, Array, ArrayElement
from pyteal.ast.abi.array_static import (
    StaticArrayTypeSpec,
    StaticArray,
    StaticBytesTypeSpec,
    StaticBytes,
)
from pyteal.ast.abi.array_dynamic import (
    DynamicArrayTypeSpec,
    DynamicArray,
    DynamicBytesTypeSpec,
    DynamicBytes,
)
from pyteal.ast.abi.reference_type import (
    ReferenceTypeSpec,
    ReferenceType,
    Account,
    AccountTypeSpec,
    Asset,
    AssetTypeSpec,
    Application,
    ApplicationTypeSpec,
    ReferenceTypeSpecs,
)
from pyteal.ast.abi.transaction import (
    Transaction,
    TransactionTypeSpec,
    PaymentTransaction,
    PaymentTransactionTypeSpec,
    ApplicationCallTransaction,
    ApplicationCallTransactionTypeSpec,
    AssetConfigTransaction,
    AssetConfigTransactionTypeSpec,
    AssetFreezeTransaction,
    AssetFreezeTransactionTypeSpec,
    AssetTransferTransaction,
    AssetTransferTransactionTypeSpec,
    KeyRegisterTransaction,
    KeyRegisterTransactionTypeSpec,
    TransactionTypeSpecs,
)
from pyteal.ast.abi.method_return import MethodReturn
from pyteal.ast.abi.util import (
    algosdk_from_annotation,
    algosdk_from_type_spec,
    make,
    size_of,
    type_spec_from_annotation,
    type_spec_from_algosdk,
    type_specs_from_signature,
    contains_type_spec,
)

__all__ = [
    "String",
    "StringTypeSpec",
    "Account",
    "AccountTypeSpec",
    "Asset",
    "ReferenceTypeSpec",
    "ReferenceType",
    "AssetTypeSpec",
    "Application",
    "ApplicationTypeSpec",
    "ReferenceType",
    "ReferenceTypeSpec",
    "ReferenceTypeSpecs",
    "Address",
    "AddressTypeSpec",
    "AddressLength",
    "TypeSpec",
    "BaseType",
    "ComputedValue",
    "ReturnedValue",
    "BoolTypeSpec",
    "Bool",
    "UintTypeSpec",
    "Uint",
    "ByteTypeSpec",
    "Byte",
    "Uint8TypeSpec",
    "Uint8",
    "Uint16TypeSpec",
    "Uint16",
    "Uint32TypeSpec",
    "Uint32",
    "Uint64TypeSpec",
    "Uint64",
    "TupleTypeSpec",
    "Tuple",
    "TupleElement",
    "Tuple0",
    "Tuple1",
    "Tuple2",
    "Tuple3",
    "Tuple4",
    "Tuple5",
    "NamedTuple",
    "NamedTupleTypeSpec",
    "Field",
    "ArrayTypeSpec",
    "Array",
    "ArrayElement",
    "StaticArrayTypeSpec",
    "StaticArray",
    "StaticBytesTypeSpec",
    "StaticBytes",
    "DynamicArrayTypeSpec",
    "DynamicArray",
    "DynamicBytesTypeSpec",
    "DynamicBytes",
    "MethodReturn",
    "Transaction",
    "TransactionTypeSpec",
    "PaymentTransaction",
    "PaymentTransactionTypeSpec",
    "ApplicationCallTransaction",
    "ApplicationCallTransactionTypeSpec",
    "AssetConfigTransaction",
    "AssetConfigTransactionTypeSpec",
    "AssetFreezeTransaction",
    "AssetFreezeTransactionTypeSpec",
    "AssetTransferTransaction",
    "AssetTransferTransactionTypeSpec",
    "KeyRegisterTransaction",
    "KeyRegisterTransactionTypeSpec",
    "TransactionTypeSpecs",
    "type_spec_from_annotation",
    "type_spec_from_algosdk",
    "type_specs_from_signature",
    "make",
    "size_of",
    "algosdk_from_annotation",
    "algosdk_from_type_spec",
    "contains_type_spec",
]



================================================
FILE: pyteal/ast/abi/address.py
================================================
from enum import IntEnum
from typing import Union, Sequence, Literal, cast
from collections.abc import Sequence as CollectionSequence

from pyteal.errors import TealInputError

from pyteal.ast.assert_ import Assert
from pyteal.ast.bytes import Bytes
from pyteal.ast.int import Int
from pyteal.ast.seq import Seq
from pyteal.ast.unaryexpr import Len
from pyteal.ast.addr import Addr
from pyteal.ast.abi.type import ComputedValue, BaseType
from pyteal.ast.abi.array_static import StaticArray, StaticArrayTypeSpec
from pyteal.ast.abi.uint import ByteTypeSpec, Byte
from pyteal.ast.expr import Expr


class AddressLength(IntEnum):
    String = 58
    Bytes = 32


AddressLength.__module__ = "pyteal.abi"


class AddressTypeSpec(StaticArrayTypeSpec):
    def __init__(self) -> None:
        super().__init__(ByteTypeSpec(), AddressLength.Bytes)

    def new_instance(self) -> "Address":
        return Address()

    def annotation_type(self) -> "type[Address]":
        return Address

    def __str__(self) -> str:
        return "address"

    def __eq__(self, other: object) -> bool:
        return isinstance(other, AddressTypeSpec)


AddressTypeSpec.__module__ = "pyteal.abi"


class Address(StaticArray[Byte, Literal[AddressLength.Bytes]]):
    def __init__(self) -> None:
        super().__init__(AddressTypeSpec())

    def type_spec(self) -> AddressTypeSpec:
        return AddressTypeSpec()

    def get(self) -> Expr:
        """Return the 32-byte value held by this Address as a PyTeal expression.

        The expression will have the type TealType.bytes.
        """
        return self._stored_value.load()

    def set(
        self,
        value: Union[
            str,
            bytes,
            Expr,
            Sequence[Byte],
            StaticArray[Byte, Literal[AddressLength.Bytes]],
            ComputedValue[StaticArray[Byte, Literal[AddressLength.Bytes]]],
            "Address",
            ComputedValue["Address"],
        ],
    ):
        """Set the value of this Address to the input value.

        The behavior of this method depends on the input argument type:

            * :code:`str`: set the value to the address from the encoded address string. This string must be a valid 58-character base-32 Algorand address with checksum.
            * :code:`bytes`: set the value to the raw address bytes. This byte string must have length 32.
            * :code:`Expr`: set the value to the result of a PyTeal expression, which must evaluate to a TealType.bytes. The program will fail if the evaluated byte string length is not 32.
            * :code:`Sequence[Byte]`: set the bytes of this Address to those contained in this Python sequence (e.g. a list or tuple). A compiler error will occur if the sequence length is not 32.
            * :code:`StaticArray[Byte, 32]`: copy the bytes from a StaticArray of 32 bytes.
            * :code:`ComputedValue[StaticArray[Byte, 32]]`: copy the bytes from a StaticArray of 32 bytes produced by a ComputedValue.
            * :code:`Address`: copy the value from another Address.
            * :code:`ComputedValue[Address]`: copy the value from an Address produced by a ComputedValue.

        Args:
            value: The new value this Address should take. This must follow the above constraints.

        Returns:
            An expression which stores the given value into this Address.
        """

        match value:
            case ComputedValue():
                pts = value.produced_type_spec()
                if pts == AddressTypeSpec() or pts == StaticArrayTypeSpec(
                    ByteTypeSpec(), AddressLength.Bytes
                ):
                    return value.store_into(self)

                raise TealInputError(
                    f"Got ComputedValue with type spec {pts}, expected AddressTypeSpec or StaticArray[Byte, Literal[AddressLength.Bytes]]"
                )
            case BaseType():
                if (
                    value.type_spec() == AddressTypeSpec()
                    or value.type_spec()
                    == StaticArrayTypeSpec(ByteTypeSpec(), AddressLength.Bytes)
                ):
                    return self._stored_value.store(value._stored_value.load())

                raise TealInputError(
                    f"Got {value} with type spec {value.type_spec()}, expected AddressTypeSpec"
                )
            case str():
                # Addr throws if value is invalid address
                return self._stored_value.store(Addr(value))
            case bytes():
                if len(value) == AddressLength.Bytes:
                    return self._stored_value.store(Bytes(value))
                raise TealInputError(
                    f"Got bytes with length {len(value)}, expected {AddressLength.Bytes}"
                )
            case Expr():
                return Seq(
                    self._stored_value.store(value),
                    Assert(
                        Len(self._stored_value.load()) == Int(AddressLength.Bytes.value)
                    ),
                )
            case CollectionSequence():
                if len(value) != AddressLength.Bytes:
                    raise TealInputError(
                        f"Got bytes with length {len(value)}, expected {AddressLength.Bytes}"
                    )
                return super().set(cast(Sequence[Byte], value))

        raise TealInputError(
            f"Got {type(value)}, expected Sequence, StaticArray, ComputedValue, Address, str, bytes, Expr"
        )


Address.__module__ = "pyteal.abi"



================================================
FILE: pyteal/ast/abi/address_test.py
================================================
import pytest
from typing import cast
import pyteal as pt
from pyteal import abi

from pyteal.ast.abi.address import AddressLength
from pyteal.ast.abi.type_test import ContainerType
from pyteal.ast.abi.util import substring_for_decoding


options = pt.CompileOptions(version=5)


def test_AddressTypeSpec_str():
    assert str(abi.AddressTypeSpec()) == "address"


def test_AddressTypeSpec_is_dynamic():
    assert (abi.AddressTypeSpec()).is_dynamic() is False


def test_AddressTypeSpec_byte_length_static():
    assert (abi.AddressTypeSpec()).byte_length_static() == abi.AddressLength.Bytes


def test_AddressTypeSpec_length_static():
    assert (abi.AddressTypeSpec()).length_static() == abi.AddressLength.Bytes


def test_AddressTypeSpec_new_instance():
    assert isinstance(abi.AddressTypeSpec().new_instance(), abi.Address)


def test_AddressTypeSpec_eq():
    assert abi.AddressTypeSpec() == abi.AddressTypeSpec()

    for otherType in (
        abi.ByteTypeSpec(),
        abi.StaticArrayTypeSpec(abi.ByteTypeSpec(), 32),
        abi.DynamicArrayTypeSpec(abi.ByteTypeSpec()),
    ):
        assert abi.AddressTypeSpec() != otherType


def test_Address_encode():
    value = abi.Address()
    expr = value.encode()
    assert expr.type_of() == pt.TealType.bytes
    assert expr.has_return() is False

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(
                expr,
                pt.Op.load,
                cast(pt.ScratchVar, value._stored_value).slot,
            ),
        ]
    )
    actual, _ = expr.__teal__(options)
    assert actual == expected


def test_Address_decode():
    address = bytes([0] * abi.AddressLength.Bytes)
    encoded = pt.Bytes(address)

    for start_index in (None, pt.Int(0)):
        for end_index in (None, pt.Int(1)):
            for length in (None, pt.Int(2)):
                value = abi.Address()

                if end_index is not None and length is not None:
                    with pytest.raises(pt.TealInputError):
                        value.decode(
                            encoded,
                            start_index=start_index,
                            end_index=end_index,
                            length=length,
                        )
                    continue

                expr = value.decode(
                    encoded, start_index=start_index, end_index=end_index, length=length
                )
                assert expr.type_of() == pt.TealType.none
                assert expr.has_return() is False

                expectedExpr = value._stored_value.store(
                    substring_for_decoding(
                        encoded,
                        start_index=start_index,
                        end_index=end_index,
                        length=length,
                    )
                )
                expected, _ = expectedExpr.__teal__(options)
                expected.addIncoming()
                expected = pt.TealBlock.NormalizeBlocks(expected)

                actual, _ = expr.__teal__(options)
                actual.addIncoming()
                actual = pt.TealBlock.NormalizeBlocks(actual)

                with pt.TealComponent.Context.ignoreExprEquality():
                    assert actual == expected


def test_Address_get():
    value = abi.Address()
    expr = value.get()
    assert expr.type_of() == pt.TealType.bytes
    assert expr.has_return() is False

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(
                expr,
                pt.Op.load,
                cast(pt.ScratchVar, value._stored_value).slot,
            ),
        ]
    )
    actual, _ = expr.__teal__(options)
    assert actual == expected


def test_Address_set_StaticArray():
    value_to_set = abi.StaticArray(
        abi.StaticArrayTypeSpec(abi.ByteTypeSpec(), abi.AddressLength.Bytes)
    )
    value = abi.Address()
    expr = value.set(value_to_set)
    assert expr.type_of() == pt.TealType.none
    assert not expr.has_return()

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(
                None,
                pt.Op.load,
                cast(pt.ScratchVar, value_to_set._stored_value).slot,
            ),
            pt.TealOp(
                None,
                pt.Op.store,
                cast(pt.ScratchVar, value._stored_value).slot,
            ),
        ]
    )

    actual, _ = expr.__teal__(options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    with pt.TealComponent.Context.ignoreExprEquality():
        assert actual == expected

    with pytest.raises(pt.TealInputError):
        bogus = abi.StaticArray(abi.StaticArrayTypeSpec(abi.ByteTypeSpec(), 10))
        value.set(bogus)


def test_Address_set_str():
    for value_to_set in ("CEZZTYHNTVIZFZWT6X2R474Z2P3Q2DAZAKIRTPBAHL3LZ7W4O6VBROVRQA",):
        value = abi.Address()
        expr = value.set(value_to_set)
        assert expr.type_of() == pt.TealType.none
        assert not expr.has_return()

        expected = pt.TealSimpleBlock(
            [
                pt.TealOp(None, pt.Op.addr, value_to_set),
                pt.TealOp(
                    None,
                    pt.Op.store,
                    cast(pt.ScratchVar, value._stored_value).slot,
                ),
            ]
        )

        actual, _ = expr.__teal__(options)
        actual.addIncoming()
        actual = pt.TealBlock.NormalizeBlocks(actual)

        with pt.TealComponent.Context.ignoreExprEquality():
            assert actual == expected

        with pytest.raises(pt.TealInputError):
            value.set(" " * 16)


def test_Address_set_bytes():
    for value_to_set in (bytes(32),):
        value = abi.Address()
        expr = value.set(value_to_set)
        assert expr.type_of() == pt.TealType.none
        assert not expr.has_return()

        expected = pt.TealSimpleBlock(
            [
                pt.TealOp(None, pt.Op.byte, f"0x{value_to_set.hex()}"),
                pt.TealOp(
                    None,
                    pt.Op.store,
                    cast(pt.ScratchVar, value._stored_value).slot,
                ),
            ]
        )

        actual, _ = expr.__teal__(options)
        actual.addIncoming()
        actual = pt.TealBlock.NormalizeBlocks(actual)

        with pt.TealComponent.Context.ignoreExprEquality():
            assert actual == expected

        with pytest.raises(pt.TealInputError):
            value.set(bytes(16))

        with pytest.raises(pt.TealInputError):
            value.set(16)


def test_Address_set_expr():
    for value_to_set in [pt.Global(pt.GlobalField.zero_address)]:
        value = abi.Address()
        expr = value.set(value_to_set)
        assert expr.type_of() == pt.TealType.none
        assert not expr.has_return()

        vts, _ = value_to_set.__teal__(options)
        expected = pt.TealSimpleBlock(
            [
                vts.ops[0],
                pt.TealOp(
                    None,
                    pt.Op.store,
                    cast(pt.ScratchVar, value._stored_value).slot,
                ),
                pt.TealOp(
                    None,
                    pt.Op.load,
                    cast(pt.ScratchVar, value._stored_value).slot,
                ),
                pt.TealOp(None, pt.Op.len),
                pt.TealOp(None, pt.Op.int, AddressLength.Bytes.value),
                pt.TealOp(None, pt.Op.eq),
                pt.TealOp(None, pt.Op.assert_),
            ]
        )

        actual, _ = expr.__teal__(options)
        actual.addIncoming()
        actual = pt.TealBlock.NormalizeBlocks(actual)

        with pt.TealComponent.Context.ignoreExprEquality():
            assert actual == expected


def test_Address_set_copy():
    value = abi.Address()
    other = abi.Address()
    expr = value.set(other)
    assert expr.type_of() == pt.TealType.none
    assert not expr.has_return()

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(
                None,
                pt.Op.load,
                cast(pt.ScratchVar, other._stored_value).slot,
            ),
            pt.TealOp(
                None,
                pt.Op.store,
                cast(pt.ScratchVar, value._stored_value).slot,
            ),
        ]
    )

    actual, _ = expr.__teal__(options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    with pt.TealComponent.Context.ignoreExprEquality():
        assert actual == expected

    with pytest.raises(pt.TealInputError):
        value.set(abi.String())


def test_Address_set_computed():
    av = pt.Addr("MDDKJUCTY57KA2PBFI44CLTJ5YHY5YVS4SVQUPZAWSRV2ZAVFKI33O6YPE")
    computed_value = ContainerType(abi.AddressTypeSpec(), av)

    value = abi.Address()
    expr = value.set(computed_value)
    assert expr.type_of() == pt.TealType.none
    assert not expr.has_return()

    _, byte_ops = av.__teal__(options)
    expected = pt.TealSimpleBlock(
        [
            byte_ops.ops[0],
            pt.TealOp(
                None,
                pt.Op.store,
                cast(pt.ScratchVar, value._stored_value).slot,
            ),
        ]
    )

    actual, _ = expr.__teal__(options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    with pt.TealComponent.Context.ignoreExprEquality():
        assert actual == expected

    with pytest.raises(pt.TealInputError):
        value.set(ContainerType(abi.ByteTypeSpec(), pt.Int(0x01)))



================================================
FILE: pyteal/ast/abi/array_base.py
================================================
from typing import (
    Union,
    Sequence,
    TypeVar,
    Generic,
    Final,
    cast,
)
from abc import abstractmethod

from pyteal.types import TealType, require_type
from pyteal.errors import TealInputError
from pyteal.ast.expr import Expr
from pyteal.ast.seq import Seq
from pyteal.ast.int import Int
from pyteal.ast.if_ import If
from pyteal.ast.unaryexpr import Len
from pyteal.ast.binaryexpr import ExtractUint16
from pyteal.ast.naryexpr import Concat

from pyteal.ast.abi.type import TypeSpec, BaseType, ComputedValue
from pyteal.ast.abi.tuple import _encode_tuple
from pyteal.ast.abi.bool import Bool, BoolTypeSpec
from pyteal.ast.abi.uint import Uint16, Uint16TypeSpec
from pyteal.ast.abi.util import substring_for_decoding

T = TypeVar("T", bound=BaseType)


class ArrayTypeSpec(TypeSpec, Generic[T]):
    """The abstract base class for both static and dynamic array TypeSpecs."""

    def __init__(self, value_type_spec: TypeSpec) -> None:
        super().__init__()
        self.value_spec: Final = value_type_spec

    def value_type_spec(self) -> TypeSpec:
        """Get the TypeSpec of the value type this array can hold."""
        return self.value_spec

    def storage_type(self) -> TealType:
        return TealType.bytes

    @abstractmethod
    def is_length_dynamic(self) -> bool:
        """Check if this array has a dynamic or static length."""
        pass

    def _stride(self) -> int:
        """Get the "stride" of this array.

        The stride is defined as the byte length of each element in the array's encoded "head"
        portion.

        If the underlying value type is static, then the stride is the static byte length of that
        type. Otherwise, the stride is the static byte length of a Uint16 (2 bytes).
        """
        if self.value_spec.is_dynamic():
            return Uint16TypeSpec().byte_length_static()
        return self.value_spec.byte_length_static()


ArrayTypeSpec.__module__ = "pyteal.abi"


class Array(BaseType, Generic[T]):
    """The abstract base class for both ABI static and dynamic array instances.

    This class contains basic implementations of ABI array methods, including:
      * basic array elements setting method
      * basic encoding and decoding of ABI array
      * item retrieving by index (expression or integer)
    """

    def __init__(self, spec: ArrayTypeSpec) -> None:
        super().__init__(spec)

    def type_spec(self) -> ArrayTypeSpec[T]:
        return cast(ArrayTypeSpec, super().type_spec())

    def decode(
        self,
        encoded: Expr,
        *,
        start_index: Expr | None = None,
        end_index: Expr | None = None,
        length: Expr | None = None,
    ) -> Expr:
        """Decode a substring of the passed in encoded byte string and set it as this type's value.

        Args:
            encoded: An expression containing the bytes to decode. Must evaluate to TealType.bytes.
            start_index (optional): An expression containing the index to start decoding. Must
                evaluate to TealType.uint64. Defaults to None.
            end_index (optional): An expression containing the index to stop decoding. Must evaluate
                to TealType.uint64. Defaults to None.
            length (optional): An expression containing the length of the substring to decode. Must
                evaluate to TealType.uint64. Defaults to None.

        Returns:
            An expression that partitions the needed parts from given byte strings and stores into
            the scratch variable.
        """
        extracted = substring_for_decoding(
            encoded, start_index=start_index, end_index=end_index, length=length
        )
        return self._stored_value.store(extracted)

    def set(self, values: Sequence[T]) -> Expr:
        """Set the ABI array with a sequence of ABI type variables.

        The function first type-check the argument `values` to make sure the sequence of ABI type
        variables before storing them to the underlying ScratchVar. If any of the input element does
        not match expected array element type, error would be raised about type-mismatch.

        If static length of array is not available, this function would
        * infer the array length from the sequence element number.
        * store the inferred array length in uint16 format.
        * concatenate the encoded array length at the beginning of array encoding.

        Args:
            values: The sequence of ABI type variables to store in ABI array.

        Returns:
            A PyTeal expression that stores encoded sequence of ABI values in its internal
            ScratchVar.
        """
        for index, value in enumerate(values):
            if self.type_spec().value_type_spec() != value.type_spec():
                raise TealInputError(
                    f"Cannot assign type {value.type_spec()} at index {index} to {self.type_spec().value_type_spec()}"
                )

        encoded = _encode_tuple(values)

        if self.type_spec().is_length_dynamic():
            length_tmp = Uint16()
            length_prefix = Seq(length_tmp.set(len(values)), length_tmp.encode())
            encoded = Concat(length_prefix, encoded)

        return self._stored_value.store(encoded)

    def encode(self) -> Expr:
        """Encode the ABI array to be a byte string.

        Returns:
            A PyTeal expression that encodes this ABI array to a byte string.
        """
        return self._stored_value.load()

    @abstractmethod
    def length(self) -> Expr:
        """Get the element number of this ABI array.

        Returns:
            A PyTeal expression that represents the array length.
        """
        pass

    def __getitem__(self, index: Union[int, Expr]) -> "ArrayElement[T]":
        """Retrieve an element by its index in this array.

        Indexes start at 0.

        Args:
            index: either a Python integer or a PyTeal expression that evaluates to a TealType.uint64.
                If a Python integer is used, this function will raise an error if its value is negative.
                In either case, if the index is outside of the bounds of this array, the program will
                fail at runtime.

        Returns:
            An ArrayElement that corresponds to the element at the given index. This type is a ComputedValue.
        """
        if type(index) is int:
            if index < 0:
                raise TealInputError("Index out of bounds: {}".format(index))
            index = Int(index)
        return ArrayElement(self, cast(Expr, index))


Array.__module__ = "pyteal.abi"


class ArrayElement(ComputedValue[T]):
    """The class that represents an ABI array element.

    This class requires a reference to the array that the array element belongs to, and a PyTeal
    expression (required to be TealType.uint64) which contains the array index.
    """

    def __init__(self, array: Array[T], index: Expr) -> None:
        """Creates a new ArrayElement.

        Args:
            array: The ABI array that the array element belongs to.
            index: A PyTeal expression (required to be TealType.uint64) stands for array index.
        """
        super().__init__()
        require_type(index, TealType.uint64)
        self.array = array
        self.index = index

    def produced_type_spec(self) -> TypeSpec:
        return self.array.type_spec().value_type_spec()

    def store_into(self, output: T) -> Expr:
        """Partitions the byte string of the given ABI array and stores the byte string of array
        element in the ABI value output.

        The function first checks if the output type matches with array element type, and throw
        error if type-mismatch.

        Args:
            output: An ABI typed value that the array element byte string stores into.

        Returns:
            An expression that stores the byte string of the array element into value `output`.
        """
        if output.type_spec() != self.produced_type_spec():
            raise TealInputError("Output type does not match value type")

        encodedArray = self.array.encode()
        arrayType = self.array.type_spec()

        # If the array element type is Bool, we compute the bit index
        # (if array is dynamic we add 16 to bit index for dynamic array length uint16 prefix)
        # and decode bit with given array encoding and the bit index for boolean bit.
        if output.type_spec() == BoolTypeSpec():
            bitIndex = self.index
            if arrayType.is_dynamic():
                bitIndex = bitIndex + Int(Uint16TypeSpec().bit_size())
            return cast(Bool, output).decode_bit(encodedArray, bitIndex)

        # Compute the byteIndex (first byte indicating the element encoding)
        # (If the array is dynamic, add 2 to byte index for dynamic array length uint16 prefix)
        byteIndex = Int(arrayType._stride()) * self.index
        if arrayType.is_length_dynamic():
            byteIndex = byteIndex + Int(Uint16TypeSpec().byte_length_static())

        arrayLength = self.array.length()

        # Handling case for array elements are dynamic:
        # * `byteIndex` is pointing at the uint16 byte encoding indicating the beginning offset of
        #   the array element byte encoding.
        #
        # * `valueStart` is extracted from the uint16 bytes pointed by `byteIndex`.
        #
        # * If `index == arrayLength - 1` (last element in array), `valueEnd` is pointing at the
        #   end of the array byte encoding.
        #
        # * otherwise, `valueEnd` is inferred from `nextValueStart`, which is the beginning offset
        #   of the next array element byte encoding.
        if arrayType.value_type_spec().is_dynamic():
            valueStart = ExtractUint16(encodedArray, byteIndex)
            nextValueStart = ExtractUint16(
                encodedArray, byteIndex + Int(Uint16TypeSpec().byte_length_static())
            )
            if arrayType.is_length_dynamic():
                valueStart = valueStart + Int(Uint16TypeSpec().byte_length_static())
                nextValueStart = nextValueStart + Int(
                    Uint16TypeSpec().byte_length_static()
                )

            valueEnd = (
                If(self.index + Int(1) == arrayLength)
                .Then(Len(encodedArray))
                .Else(nextValueStart)
            )

            return output.decode(
                encodedArray, start_index=valueStart, end_index=valueEnd
            )

        # Handling case for array elements are static:
        # since array._stride() is element's static byte length
        # we partition the substring for array element.
        valueStart = byteIndex
        valueLength = Int(arrayType._stride())
        return output.decode(encodedArray, start_index=valueStart, length=valueLength)


ArrayElement.__module__ = "pyteal.abi"



================================================
FILE: pyteal/ast/abi/array_base_test.py
================================================
from typing import List, cast
import pytest

import pyteal as pt
from pyteal import abi

options = pt.CompileOptions(version=5)

STATIC_TYPES: List[abi.TypeSpec] = [
    abi.BoolTypeSpec(),
    abi.Uint8TypeSpec(),
    abi.Uint16TypeSpec(),
    abi.Uint32TypeSpec(),
    abi.Uint64TypeSpec(),
    abi.TupleTypeSpec(),
    abi.TupleTypeSpec(abi.BoolTypeSpec(), abi.BoolTypeSpec(), abi.Uint64TypeSpec()),
    abi.StaticArrayTypeSpec(abi.BoolTypeSpec(), 10),
    abi.StaticArrayTypeSpec(abi.Uint8TypeSpec(), 10),
    abi.StaticArrayTypeSpec(abi.Uint16TypeSpec(), 10),
    abi.StaticArrayTypeSpec(abi.Uint32TypeSpec(), 10),
    abi.StaticArrayTypeSpec(abi.Uint64TypeSpec(), 10),
    abi.StaticArrayTypeSpec(
        abi.TupleTypeSpec(abi.BoolTypeSpec(), abi.BoolTypeSpec(), abi.Uint64TypeSpec()),
        10,
    ),
]

DYNAMIC_TYPES: List[abi.TypeSpec] = [
    abi.DynamicArrayTypeSpec(abi.BoolTypeSpec()),
    abi.DynamicArrayTypeSpec(abi.Uint8TypeSpec()),
    abi.DynamicArrayTypeSpec(abi.Uint16TypeSpec()),
    abi.DynamicArrayTypeSpec(abi.Uint32TypeSpec()),
    abi.DynamicArrayTypeSpec(abi.Uint64TypeSpec()),
    abi.DynamicArrayTypeSpec(abi.TupleTypeSpec()),
    abi.DynamicArrayTypeSpec(
        abi.TupleTypeSpec(abi.BoolTypeSpec(), abi.BoolTypeSpec(), abi.Uint64TypeSpec())
    ),
    abi.DynamicArrayTypeSpec(abi.StaticArrayTypeSpec(abi.BoolTypeSpec(), 10)),
    abi.DynamicArrayTypeSpec(abi.StaticArrayTypeSpec(abi.Uint8TypeSpec(), 10)),
    abi.DynamicArrayTypeSpec(abi.StaticArrayTypeSpec(abi.Uint16TypeSpec(), 10)),
    abi.DynamicArrayTypeSpec(abi.StaticArrayTypeSpec(abi.Uint32TypeSpec(), 10)),
    abi.DynamicArrayTypeSpec(abi.StaticArrayTypeSpec(abi.Uint64TypeSpec(), 10)),
    abi.DynamicArrayTypeSpec(
        abi.StaticArrayTypeSpec(
            abi.TupleTypeSpec(
                abi.BoolTypeSpec(), abi.BoolTypeSpec(), abi.Uint64TypeSpec()
            ),
            10,
        )
    ),
]


def test_ArrayElement_init():
    dynamicArrayType = abi.DynamicArrayTypeSpec(abi.Uint64TypeSpec())
    array = dynamicArrayType.new_instance()
    index = pt.Int(6)

    element = abi.ArrayElement(array, index)
    assert element.array is array
    assert element.index is index

    with pytest.raises(pt.TealTypeError):
        abi.ArrayElement(array, pt.Bytes("abc"))

    with pytest.raises(pt.TealTypeError):
        abi.ArrayElement(array, pt.Assert(index))


def test_ArrayElement_store_into():
    for elementType in STATIC_TYPES + DYNAMIC_TYPES:
        staticArrayType = abi.StaticArrayTypeSpec(elementType, 100)
        staticArray = staticArrayType.new_instance()
        index = pt.Int(9)

        element = abi.ArrayElement(staticArray, index)
        output = elementType.new_instance()
        expr = element.store_into(output)

        encoded = staticArray.encode()
        stride = pt.Int(staticArray.type_spec()._stride())
        expectedLength = staticArray.length()
        if elementType == abi.BoolTypeSpec():
            expectedExpr = cast(abi.Bool, output).decode_bit(encoded, index)
        elif not elementType.is_dynamic():
            expectedExpr = output.decode(
                encoded, start_index=stride * index, length=stride
            )
        else:
            expectedExpr = output.decode(
                encoded,
                start_index=pt.ExtractUint16(encoded, stride * index),
                end_index=pt.If(index + pt.Int(1) == expectedLength)
                .Then(pt.Len(encoded))
                .Else(pt.ExtractUint16(encoded, stride * index + pt.Int(2))),
            )

        expected, _ = expectedExpr.__teal__(options)
        expected.addIncoming()
        expected = pt.TealBlock.NormalizeBlocks(expected)

        actual, _ = expr.__teal__(options)
        actual.addIncoming()
        actual = pt.TealBlock.NormalizeBlocks(actual)

        with pt.TealComponent.Context.ignoreExprEquality():
            assert actual == expected

        with pytest.raises(pt.TealInputError):
            element.store_into(abi.Tuple(abi.TupleTypeSpec(elementType)))

    for elementType in STATIC_TYPES + DYNAMIC_TYPES:
        dynamicArrayType = abi.DynamicArrayTypeSpec(elementType)
        dynamicArray = dynamicArrayType.new_instance()
        index = pt.Int(9)

        element = abi.ArrayElement(dynamicArray, index)
        output = elementType.new_instance()
        expr = element.store_into(output)

        encoded = dynamicArray.encode()
        stride = pt.Int(dynamicArray.type_spec()._stride())
        expectedLength = dynamicArray.length()
        if elementType == abi.BoolTypeSpec():
            expectedExpr = cast(abi.Bool, output).decode_bit(
                encoded, index + pt.Int(16)
            )
        elif not elementType.is_dynamic():
            expectedExpr = output.decode(
                encoded, start_index=stride * index + pt.Int(2), length=stride
            )
        else:
            expectedExpr = output.decode(
                encoded,
                start_index=pt.ExtractUint16(encoded, stride * index + pt.Int(2))
                + pt.Int(2),
                end_index=pt.If(index + pt.Int(1) == expectedLength)
                .Then(pt.Len(encoded))
                .Else(
                    pt.ExtractUint16(encoded, stride * index + pt.Int(2) + pt.Int(2))
                    + pt.Int(2)
                ),
            )

        expected, _ = expectedExpr.__teal__(options)
        expected.addIncoming()
        expected = pt.TealBlock.NormalizeBlocks(expected)

        actual, _ = expr.__teal__(options)
        actual.addIncoming()
        actual = pt.TealBlock.NormalizeBlocks(actual)

        with pt.TealComponent.Context.ignoreExprEquality():
            with pt.TealComponent.Context.ignoreScratchSlotEquality():
                assert actual == expected

        assert pt.TealBlock.MatchScratchSlotReferences(
            pt.TealBlock.GetReferencedScratchSlots(actual),
            pt.TealBlock.GetReferencedScratchSlots(expected),
        )

        with pytest.raises(pt.TealInputError):
            element.store_into(abi.Tuple(abi.TupleTypeSpec(elementType)))



================================================
FILE: pyteal/ast/abi/array_dynamic.py
================================================
from typing import Union, Sequence, TypeVar, cast

from pyteal.errors import TealInputError
from pyteal.ast.expr import Expr
from pyteal.ast.seq import Seq
from pyteal.ast.int import Int
from pyteal.ast.substring import Suffix

from pyteal.ast.abi.type import ComputedValue, BaseType
from pyteal.ast.abi.uint import Uint16, Byte, ByteTypeSpec
from pyteal.ast.abi.array_base import ArrayTypeSpec, Array


T = TypeVar("T", bound=BaseType)


class DynamicArrayTypeSpec(ArrayTypeSpec[T]):
    def new_instance(self) -> "DynamicArray[T]":
        return DynamicArray(self)

    def annotation_type(self) -> type["DynamicArray[T]"]:
        return DynamicArray[self.value_type_spec().annotation_type()]  # type: ignore[misc]

    def is_length_dynamic(self) -> bool:
        return True

    def is_dynamic(self) -> bool:
        return True

    def byte_length_static(self) -> int:
        raise ValueError("Type is dynamic")

    def __eq__(self, other: object) -> bool:
        return (
            isinstance(other, DynamicArrayTypeSpec)
            and self.value_type_spec() == other.value_type_spec()
        )

    def __str__(self) -> str:
        return f"{self.value_type_spec()}[]"


DynamicArrayTypeSpec.__module__ = "pyteal.abi"


class DynamicArray(Array[T]):
    """The class that represents ABI dynamic array type."""

    def __init__(self, array_type_spec: DynamicArrayTypeSpec[T]) -> None:
        super().__init__(array_type_spec)

    def type_spec(self) -> DynamicArrayTypeSpec[T]:
        return cast(DynamicArrayTypeSpec[T], super().type_spec())

    def set(
        self,
        values: Union[Sequence[T], "DynamicArray[T]", ComputedValue["DynamicArray[T]"]],
    ) -> Expr:
        """
        Set the elements of this DynamicArray to the input values.

        The behavior of this method depends on the input argument type:

            * :code:`Sequence[T]`: set the elements of this DynamicArray to those contained in this Python sequence (e.g. a list or tuple). A compiler error will occur if any element in the sequence does not match this DynamicArray's element type.
            * :code:`DynamicArray[T]`: copy the elements from another DynamicArray. The argument's element type must exactly match this DynamicArray's element type, otherwise an error will occur.
            * :code:`ComputedValue[DynamicArray[T]]`: copy the elements from a DynamicArray produced by a ComputedValue. The element type produced by the ComputedValue must exactly match this DynamicArray's element type, otherwise an error will occur.

        Args:
            values: The new elements this DynamicArray should have. This must follow the above constraints.

        Returns:
            An expression which stores the given value into this DynamicArray.
        """

        if isinstance(values, ComputedValue):
            return self._set_with_computed_type(values)
        elif isinstance(values, BaseType):
            if self.type_spec() != values.type_spec():
                raise TealInputError(
                    f"Cannot assign type {values.type_spec()} to {self.type_spec()}"
                )
            return self._stored_value.store(values.encode())
        return super().set(values)

    def length(self) -> Expr:
        """Get the element number of this ABI dynamic array.

        The array length (element number) is encoded in the first 2 bytes of the byte encoding.

        Returns:
            A PyTeal expression that represents the dynamic array length.
        """
        output = Uint16()
        return Seq(
            output.decode(self.encode()),
            output.get(),
        )


DynamicArray.__module__ = "pyteal.abi"


class DynamicBytesTypeSpec(DynamicArrayTypeSpec[Byte]):
    def __init__(self) -> None:
        super().__init__(ByteTypeSpec())

    def new_instance(self) -> "DynamicBytes":
        return DynamicBytes()

    def annotation_type(self) -> type["DynamicBytes"]:
        return DynamicBytes

    def __str__(self) -> str:
        return "byte[]"

    def __eq__(self, other: object) -> bool:
        return isinstance(other, DynamicBytesTypeSpec)


DynamicBytesTypeSpec.__module__ = "pyteal.abi"


class DynamicBytes(DynamicArray[Byte]):
    """The convenience class that represents ABI dynamic byte array."""

    def __init__(self) -> None:
        super().__init__(DynamicBytesTypeSpec())

    def type_spec(self) -> DynamicBytesTypeSpec:
        return DynamicBytesTypeSpec()

    def set(
        self,
        values: Union[
            bytes,
            bytearray,
            Expr,
            Sequence[Byte],
            DynamicArray[Byte],
            ComputedValue[DynamicArray[Byte]],
        ],
    ) -> Expr:
        """Set the elements of this DynamicBytes to the input values.

        The behavior of this method depends on the input argument type:

            * :code:`bytes`: set the value to the Python byte string.
            * :code:`bytearray`: set the value to the Python byte array.
            * :code:`Expr`: set the value to the result of a PyTeal expression, which must evaluate to a TealType.bytes.
            * :code:`Sequence[Byte]`: set the bytes of this String to those contained in this Python sequence (e.g. a list or tuple).
            * :code:`DynamicArray[Byte]`: copy the bytes from another DynamicArray. The argument's element type must exactly match Byte, otherwise an error will occur.
            * :code:`ComputedValue[DynamicArray[Byte]]`: copy the bytes from a DynamicArray produced by a ComputedValue. The argument's element type must exactly match Byte, otherwise an error will occur.

        Args:
            values: The new elements this DynamicBytes should have. This must follow the above constraints.

        Returns:
            An expression which stores the given value into this DynamicBytes.
        """
        # NOTE: the import here is to avoid importing in partial initialized module abi
        from pyteal.ast.abi.string import (
            _encoded_byte_string,
            _store_encoded_expr_byte_string_into_var,
        )

        match values:
            case bytes() | bytearray():
                return self._stored_value.store(_encoded_byte_string(values))
            case Expr():
                return _store_encoded_expr_byte_string_into_var(
                    values, self._stored_value
                )

        return super().set(values)

    def get(self) -> Expr:
        """Get the byte encoding of this DynamicBytes.

        Dropping the uint16 encoding prefix for dynamic array length.

        Returns:
            A Pyteal expression that loads byte encoding of this DynamicBytes, and drop the first uint16 DynamicArray length encoding.
        """
        return Suffix(self._stored_value.load(), Int(2))


DynamicBytes.__module__ = "pyteal.abi"



================================================
FILE: pyteal/ast/abi/array_dynamic_test.py
================================================
from typing import List, cast

import pytest
import pyteal as pt

from algosdk.abi import ABIType
from pyteal import abi
from pyteal.ast.abi.util import substring_for_decoding
from pyteal.ast.abi.tuple import _encode_tuple
from pyteal.ast.abi.array_base_test import STATIC_TYPES, DYNAMIC_TYPES
from pyteal.ast.abi.type_test import ContainerType

options = pt.CompileOptions(version=5)


def test_DynamicArrayTypeSpec_init():
    for elementType in STATIC_TYPES:
        dynamicArrayType = abi.DynamicArrayTypeSpec(elementType)
        assert dynamicArrayType.value_type_spec() is elementType
        assert dynamicArrayType.is_length_dynamic()
        assert dynamicArrayType._stride() == elementType.byte_length_static()

    dynamicBytesType = abi.DynamicBytesTypeSpec()
    assert isinstance(dynamicBytesType.value_type_spec(), abi.ByteTypeSpec)
    assert dynamicBytesType.is_length_dynamic()
    assert dynamicBytesType._stride() == 1

    for elementType in DYNAMIC_TYPES:
        dynamicArrayType = abi.DynamicArrayTypeSpec(elementType)
        assert dynamicArrayType.value_type_spec() is elementType
        assert dynamicArrayType.is_length_dynamic()
        assert dynamicArrayType._stride() == 2


def test_DynamicArrayTypeSpec_str():
    for elementType in STATIC_TYPES + DYNAMIC_TYPES:
        dynamicArrayType = abi.DynamicArrayTypeSpec(elementType)
        assert str(dynamicArrayType) == "{}[]".format(elementType)

    assert str(abi.DynamicBytesTypeSpec()) == "byte[]"


def test_DynamicArrayTypeSpec_new_instance():
    for elementType in STATIC_TYPES + DYNAMIC_TYPES:
        dynamicArrayType = abi.DynamicArrayTypeSpec(elementType)
        instance = dynamicArrayType.new_instance()
        assert isinstance(instance, abi.DynamicArray)
        assert instance.type_spec() == dynamicArrayType

    dynamicBytesType = abi.DynamicBytesTypeSpec()
    instance = dynamicBytesType.new_instance()
    assert isinstance(instance, abi.DynamicBytes)
    assert instance.type_spec() == dynamicBytesType


def test_DynamicArrayTypeSpec_eq():
    for elementType in STATIC_TYPES + DYNAMIC_TYPES:
        dynamicArrayType = abi.DynamicArrayTypeSpec(elementType)
        assert dynamicArrayType == dynamicArrayType
        assert dynamicArrayType != abi.TupleTypeSpec(dynamicArrayType)

    dynamicBytesType = abi.DynamicBytesTypeSpec()
    assert dynamicBytesType == dynamicBytesType
    assert dynamicBytesType != abi.TupleTypeSpec(dynamicBytesType)


def test_DynamicArrayTypeSpec_is_dynamic():
    for elementType in STATIC_TYPES + DYNAMIC_TYPES:
        dynamicArrayType = abi.DynamicArrayTypeSpec(elementType)
        assert dynamicArrayType.is_dynamic()

    assert abi.DynamicBytesTypeSpec().is_dynamic()


def test_DynamicArrayTypeSpec_byte_length_static():
    for elementType in STATIC_TYPES + DYNAMIC_TYPES:
        dynamicArrayType = abi.DynamicArrayTypeSpec(elementType)
        with pytest.raises(ValueError):
            dynamicArrayType.byte_length_static()

    with pytest.raises(ValueError):
        abi.DynamicBytesTypeSpec().byte_length_static()


def test_DynamicArray_decode():
    encoded = pt.Bytes("encoded")
    dynamicArrayType = abi.DynamicArrayTypeSpec(abi.Uint64TypeSpec())
    for start_index in (None, pt.Int(1)):
        for end_index in (None, pt.Int(2)):
            for length in (None, pt.Int(3)):
                value = dynamicArrayType.new_instance()

                if end_index is not None and length is not None:
                    with pytest.raises(pt.TealInputError):
                        value.decode(
                            encoded,
                            start_index=start_index,
                            end_index=end_index,
                            length=length,
                        )
                    continue

                expr = value.decode(
                    encoded, start_index=start_index, end_index=end_index, length=length
                )
                assert expr.type_of() == pt.TealType.none
                assert not expr.has_return()

                expectedExpr = value._stored_value.store(
                    substring_for_decoding(
                        encoded,
                        start_index=start_index,
                        end_index=end_index,
                        length=length,
                    )
                )
                expected, _ = expectedExpr.__teal__(options)
                expected.addIncoming()
                expected = pt.TealBlock.NormalizeBlocks(expected)

                actual, _ = expr.__teal__(options)
                actual.addIncoming()
                actual = pt.TealBlock.NormalizeBlocks(actual)

                with pt.TealComponent.Context.ignoreExprEquality():
                    assert actual == expected


def test_DynamicArray_set_values():
    valuesToSet: List[abi.Uint64] = [
        [],
        [abi.Uint64()],
        [abi.Uint64() for _ in range(10)],
    ]

    dynamicArrayType = abi.DynamicArrayTypeSpec(abi.Uint64TypeSpec())
    for values in valuesToSet:
        value = dynamicArrayType.new_instance()
        expr = value.set(values)
        assert expr.type_of() == pt.TealType.none
        assert not expr.has_return()

        length_tmp = abi.Uint16()
        expectedExpr = value._stored_value.store(
            pt.Concat(
                pt.Seq(length_tmp.set(len(values)), length_tmp.encode()),
                _encode_tuple(values),
            )
        )
        expected, _ = expectedExpr.__teal__(options)
        expected.addIncoming()
        expected = pt.TealBlock.NormalizeBlocks(expected)

        actual, _ = expr.__teal__(options)
        actual.addIncoming()
        actual = pt.TealBlock.NormalizeBlocks(actual)

        with pt.TealComponent.Context.ignoreExprEquality():
            with pt.TealComponent.Context.ignoreScratchSlotEquality():
                assert actual == expected

        assert pt.TealBlock.MatchScratchSlotReferences(
            pt.TealBlock.GetReferencedScratchSlots(actual),
            pt.TealBlock.GetReferencedScratchSlots(expected),
        )


def test_DynamicArray_set_copy():
    dynamicArrayType = abi.DynamicArrayTypeSpec(abi.Uint64TypeSpec())
    value = dynamicArrayType.new_instance()
    otherArray = dynamicArrayType.new_instance()

    with pytest.raises(pt.TealInputError):
        value.set(abi.DynamicArray(abi.DynamicArrayTypeSpec(abi.Uint8TypeSpec())))

    with pytest.raises(pt.TealInputError):
        value.set(abi.Uint64())

    expr = value.set(otherArray)
    assert expr.type_of() == pt.TealType.none
    assert not expr.has_return()

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(
                None,
                pt.Op.load,
                cast(pt.ScratchVar, otherArray._stored_value).slot,
            ),
            pt.TealOp(
                None,
                pt.Op.store,
                cast(pt.ScratchVar, value._stored_value).slot,
            ),
        ]
    )

    actual, _ = expr.__teal__(options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    with pt.TealComponent.Context.ignoreExprEquality():
        assert actual == expected


def test_DynamicArray_set_computed():
    value = abi.DynamicArray(abi.DynamicArrayTypeSpec(abi.ByteTypeSpec()))
    computed = ContainerType(
        value.type_spec(), pt.Bytes("this should be a dynamic array")
    )
    expr = value.set(computed)
    assert expr.type_of() == pt.TealType.none
    assert not expr.has_return()

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(None, pt.Op.byte, '"this should be a dynamic array"'),
            pt.TealOp(
                None,
                pt.Op.store,
                cast(pt.ScratchVar, value._stored_value).slot,
            ),
        ]
    )
    actual, _ = expr.__teal__(options)
    actual.addIncoming()
    actual = actual.NormalizeBlocks(actual)

    with pt.TealComponent.Context.ignoreExprEquality():
        assert actual == expected

    with pytest.raises(pt.TealInputError):
        value.set(
            ContainerType(
                abi.DynamicArrayTypeSpec(abi.Uint16TypeSpec()),
                pt.Bytes("well i am trolling again"),
            )
        )


# AACS key recovery
BYTE_HEX_TEST_CASE = "09f911029d74e35bd84156c5635688c0"


BYTES_SET_TESTCASES = [
    bytes.fromhex(BYTE_HEX_TEST_CASE),
    bytearray.fromhex(BYTE_HEX_TEST_CASE),
]


@pytest.mark.parametrize("test_case", BYTES_SET_TESTCASES)
def test_DynamicBytes_set_py_bytes(test_case: bytes | bytearray):
    value = abi.DynamicBytes()

    expr = value.set(test_case)
    assert expr.type_of() == pt.TealType.none
    assert not expr.has_return()

    actual, _ = expr.__teal__(options)
    actual.addIncoming()
    actual = actual.NormalizeBlocks(actual)

    length_encoding = ABIType.from_string("uint16").encode(len(test_case)).hex()

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(None, pt.Op.byte, "0x" + length_encoding + BYTE_HEX_TEST_CASE),
            pt.TealOp(
                None,
                pt.Op.store,
                cast(pt.ScratchVar, value._stored_value).slot,
            ),
        ]
    )

    with pt.TealComponent.Context.ignoreExprEquality():
        assert actual == expected


@pytest.mark.parametrize("test_case", BYTES_SET_TESTCASES)
def test_DynamicBytes_set_expr(test_case: bytes | bytearray):
    value = abi.DynamicBytes()

    set_expr = pt.Concat(pt.Bytes(test_case), pt.Bytes(test_case))

    expr = value.set(set_expr)
    assert expr.type_of() == pt.TealType.none
    assert not expr.has_return()

    actual, _ = expr.__teal__(options)
    actual.addIncoming()
    actual = actual.NormalizeBlocks(actual)

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(None, pt.Op.byte, "0x" + BYTE_HEX_TEST_CASE),
            pt.TealOp(None, pt.Op.byte, "0x" + BYTE_HEX_TEST_CASE),
            pt.TealOp(None, pt.Op.concat),
            pt.TealOp(
                None,
                pt.Op.store,
                cast(pt.ScratchVar, value._stored_value).slot,
            ),
            pt.TealOp(
                None,
                pt.Op.load,
                cast(pt.ScratchVar, value._stored_value).slot,
            ),
            pt.TealOp(None, pt.Op.len),
            pt.TealOp(None, pt.Op.itob),
            pt.TealOp(None, pt.Op.extract, 6, 0),
            pt.TealOp(
                None,
                pt.Op.load,
                cast(pt.ScratchVar, value._stored_value).slot,
            ),
            pt.TealOp(None, pt.Op.concat),
            pt.TealOp(
                None,
                pt.Op.store,
                cast(pt.ScratchVar, value._stored_value).slot,
            ),
        ]
    )

    with pt.TealComponent.Context.ignoreExprEquality():
        assert actual == expected


def test_DynamicBytes_get():
    value = abi.DynamicBytes()

    expr = value.get()
    assert expr.type_of() == pt.TealType.bytes
    assert not expr.has_return()

    actual, _ = expr.__teal__(options)
    actual.addIncoming()
    actual = actual.NormalizeBlocks(actual)

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(
                None,
                pt.Op.load,
                cast(pt.ScratchVar, value._stored_value).slot,
            ),
            pt.TealOp(None, pt.Op.extract, 2, 0),
        ]
    )

    with pt.TealComponent.Context.ignoreExprEquality():
        assert actual == expected


def test_DynamicArray_encode():
    dynamicArrayType = abi.DynamicArrayTypeSpec(abi.Uint64TypeSpec())
    value = dynamicArrayType.new_instance()
    expr = value.encode()
    assert expr.type_of() == pt.TealType.bytes
    assert not expr.has_return()

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(
                None,
                pt.Op.load,
                cast(pt.ScratchVar, value._stored_value).slot,
            ),
        ]
    )

    actual, _ = expr.__teal__(options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    with pt.TealComponent.Context.ignoreExprEquality():
        assert actual == expected


def test_DynamicArray_length():
    dynamicArrayType = abi.DynamicArrayTypeSpec(abi.Uint64TypeSpec())
    value = dynamicArrayType.new_instance()
    expr = value.length()
    assert expr.type_of() == pt.TealType.uint64
    assert not expr.has_return()

    length_tmp = abi.Uint16()
    expectedExpr = pt.Seq(length_tmp.decode(value.encode()), length_tmp.get())
    expected, _ = expectedExpr.__teal__(options)
    expected.addIncoming()
    expected = pt.TealBlock.NormalizeBlocks(expected)

    actual, _ = expr.__teal__(options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    with pt.TealComponent.Context.ignoreExprEquality():
        with pt.TealComponent.Context.ignoreScratchSlotEquality():
            assert actual == expected

    assert pt.TealBlock.MatchScratchSlotReferences(
        pt.TealBlock.GetReferencedScratchSlots(actual),
        pt.TealBlock.GetReferencedScratchSlots(expected),
    )


def test_DynamicArray_getitem():
    dynamicArrayType = abi.DynamicArrayTypeSpec(abi.Uint64TypeSpec())
    value = dynamicArrayType.new_instance()

    for index in (0, 1, 2, 3, 1000):
        # dynamic indexes
        indexExpr = pt.Int(index)
        element = value[indexExpr]
        assert type(element) is abi.ArrayElement
        assert element.array is value
        assert element.index is indexExpr

    for index in (0, 1, 2, 3, 1000):
        # static indexes
        element = value[index]
        assert type(element) is abi.ArrayElement
        assert element.array is value
        assert type(element.index) is pt.Int
        assert element.index.value == index

    with pytest.raises(pt.TealInputError):
        value[-1]



================================================
FILE: pyteal/ast/abi/array_static.py
================================================
from typing import Final, Generic, Literal, Sequence, TypeVar, Union, cast

from pyteal.errors import TealInputError
from pyteal.ast.assert_ import Assert
from pyteal.ast.expr import Expr
from pyteal.ast.int import Int
from pyteal.ast.bytes import Bytes
from pyteal.ast.seq import Seq
from pyteal.ast.unaryexpr import Len

from pyteal.ast.abi.type import ComputedValue, TypeSpec, BaseType
from pyteal.ast.abi.bool import BoolTypeSpec, _bool_sequence_length
from pyteal.ast.abi.uint import Byte, ByteTypeSpec
from pyteal.ast.abi.array_base import ArrayTypeSpec, Array, ArrayElement

T = TypeVar("T", bound=BaseType)
N = TypeVar("N", bound=int)


class StaticArrayTypeSpec(ArrayTypeSpec[T], Generic[T, N]):
    def __init__(self, value_type_spec: TypeSpec, array_length: int) -> None:
        super().__init__(value_type_spec)
        if not isinstance(array_length, int) or array_length < 0:
            raise TypeError(f"Unsupported StaticArray length: {array_length}")

        # Casts to `int` to handle downstream usage where value is a subclass of int like `IntEnum`.
        self.array_length: Final = int(array_length)

    def new_instance(self) -> "StaticArray[T, N]":
        return StaticArray(self)

    def annotation_type(self) -> type["StaticArray[T, N]"]:
        return StaticArray[  # type: ignore[misc]
            self.value_spec.annotation_type(), Literal[self.array_length]  # type: ignore
        ]

    def length_static(self) -> int:
        """Get the size of this static array type.

        Returns:
            A Python integer that represents the static array length.
        """
        return self.array_length

    def is_length_dynamic(self) -> bool:
        return False

    def is_dynamic(self) -> bool:
        return self.value_type_spec().is_dynamic()

    def byte_length_static(self) -> int:
        if self.is_dynamic():
            raise ValueError("Type is dynamic")

        value_type = self.value_type_spec()
        length = self.length_static()

        if value_type == BoolTypeSpec():
            return _bool_sequence_length(length)
        return length * value_type.byte_length_static()

    def __eq__(self, other: object) -> bool:
        return (
            isinstance(other, StaticArrayTypeSpec)
            and self.value_type_spec() == other.value_type_spec()
            and self.length_static() == other.length_static()
        )

    def __str__(self) -> str:
        return f"{self.value_type_spec()}[{self.length_static()}]"


StaticArrayTypeSpec.__module__ = "pyteal.abi"


class StaticArray(Array[T], Generic[T, N]):
    """The class that represents ABI static array type."""

    def __init__(self, array_type_spec: StaticArrayTypeSpec[T, N]) -> None:
        super().__init__(array_type_spec)

    def type_spec(self) -> StaticArrayTypeSpec[T, N]:
        return cast(StaticArrayTypeSpec[T, N], super().type_spec())

    def set(
        self,
        values: Union[
            Sequence[T], "StaticArray[T, N]", ComputedValue["StaticArray[T, N]"]
        ],
    ) -> Expr:
        """Set the elements of this StaticArray to the input values.

        The behavior of this method depends on the input argument type:

            * :code:`Sequence[T]`: set the elements of this StaticArray to those contained in this Python sequence (e.g. a list or tuple). A compiler error will occur if any element in the sequence does not match this StaticArray's element type, or if the sequence length does not equal this StaticArray's length.
            * :code:`StaticArray[T, N]`: copy the elements from another StaticArray. The argument's element type and length must exactly match this StaticArray's element type and length, otherwise an error will occur.
            * :code:`ComputedValue[StaticArray[T, N]]`: copy the elements from a StaticArray produced by a ComputedValue. The element type and length produced by the ComputedValue must exactly match this StaticArray's element type and length, otherwise an error will occur.

        Args:
            values: The new elements this StaticArray should have. This must follow the above constraints.

        Returns:
            An expression which stores the given value into this StaticArray.
        """
        if isinstance(values, ComputedValue):
            return self._set_with_computed_type(values)
        elif isinstance(values, BaseType):
            if self.type_spec() != values.type_spec():
                raise TealInputError(
                    f"Cannot assign type {values.type_spec()} to {self.type_spec()}"
                )
            return self._stored_value.store(values.encode())

        if self.type_spec().length_static() != len(values):
            raise TealInputError(
                f"Incorrect length for values. Expected {self.type_spec()}, got {len(values)}"
            )
        return super().set(values)

    def length(self) -> Expr:
        """Get the element number of this ABI static array.

        Returns:
            A PyTeal expression that represents the static array length.
        """
        return Int(self.type_spec().length_static())

    def __getitem__(self, index: Union[int, Expr]) -> "ArrayElement[T]":
        """Retrieve an element by its index in this StaticArray.

        Indexes start at 0.

        Args:
            index: either a Python integer or a PyTeal expression that evaluates to a TealType.uint64.
                If a Python integer is used, this function will raise an error if its value is negative
                or if the index is equal to or greater than the length of this StaticArray. If a PyTeal
                expression is used, the program will fail at runtime if the index is outside of the
                bounds of this StaticArray.

        Returns:
            An ArrayElement that corresponds to the element at the given index. This type is a ComputedValue.
        """
        if type(index) is int and index >= self.type_spec().length_static():
            raise TealInputError(f"Index out of bounds: {index}")
        return super().__getitem__(index)


StaticArray.__module__ = "pyteal.abi"


class StaticBytesTypeSpec(StaticArrayTypeSpec[Byte, N], Generic[N]):
    def __init__(self, array_length: int) -> None:
        super().__init__(ByteTypeSpec(), array_length)

    def new_instance(self) -> "StaticBytes[N]":
        return StaticBytes(self)

    def annotation_type(self) -> type["StaticBytes[N]"]:
        return StaticBytes[  # type: ignore[misc]
            Literal[self.array_length]  # type: ignore
        ]


StaticBytesTypeSpec.__module__ = "pyteal.abi"


class StaticBytes(StaticArray[Byte, N], Generic[N]):
    """The convenience class that represents ABI static byte array."""

    def __init__(self, array_type_spec: StaticBytesTypeSpec[N]) -> None:
        super().__init__(array_type_spec)

    def type_spec(self) -> StaticBytesTypeSpec:
        return cast(StaticBytesTypeSpec[N], super().type_spec())

    def set(
        self,
        values: Union[
            bytes,
            bytearray,
            Expr,
            Sequence[Byte],
            StaticArray[Byte, N],
            ComputedValue[StaticArray[Byte, N]],
        ],
    ) -> Expr:
        """Set the elements of this StaticBytes to the input values.

        The behavior of this method depends on the input argument type:

            * :code:`bytes`: set the value to the Python byte string.
            * :code:`bytearray`: set the value to the Python byte array.
            * :code:`Expr`: set the value to the result of a PyTeal expression, which must evaluate to a TealType.bytes.
            * :code:`Sequence[Byte]`: set the bytes of this String to those contained in this Python sequence (e.g. a list or tuple).
            * :code:`StaticArray[Byte, N]`: copy the bytes from another StaticArray. The argument's element type and length must exactly match Byte and this StaticBytes' length, otherwise an error will occur.
            * :code:`ComputedValue[StaticArray[Byte, N]]`: copy the bytes from a StaticArray produced by a ComputedType. The argument's element type and length must exactly match Byte and this StaticBytes' length, otherwise an error will occur.

        Args:
            values: The new elements this StaticBytes should have. This must follow the above constraints.

        Returns:
            An expression which stores the given value into this StaticBytes.
        """
        match values:
            case bytes() | bytearray():
                if len(values) != self.type_spec().length_static():
                    raise TealInputError(
                        f"Got bytes with length {len(values)}, expect {self.type_spec().length_static()}"
                    )
                return self._stored_value.store(Bytes(values))
            case Expr():
                return Seq(
                    self._stored_value.store(values),
                    Assert(self.length() == Len(self._stored_value.load())),
                )

        return super().set(values)

    def get(self) -> Expr:
        """Get the byte encoding of this StaticBytes.

        Returns:
            A Pyteal expression that loads byte encoding of this StaticBytes.
        """
        return self._stored_value.load()


StaticBytes.__module__ = "pyteal.abi"



================================================
FILE: pyteal/ast/abi/array_static_test.py
================================================
import pytest
from typing import cast

import pyteal as pt
from pyteal import abi
from pyteal.ast.abi.util import substring_for_decoding
from pyteal.ast.abi.tuple import _encode_tuple
from pyteal.ast.abi.bool import _bool_sequence_length
from pyteal.ast.abi.type_test import ContainerType
from pyteal.ast.abi.array_base_test import STATIC_TYPES, DYNAMIC_TYPES

options = pt.CompileOptions(version=5)


def test_StaticArrayTypeSpec_init():
    for elementType in STATIC_TYPES:
        for length in range(256):
            staticArrayType = abi.StaticArrayTypeSpec(elementType, length)
            assert staticArrayType.value_type_spec() is elementType
            assert not staticArrayType.is_length_dynamic()
            assert staticArrayType._stride() == elementType.byte_length_static()
            assert staticArrayType.length_static() == length

        with pytest.raises(TypeError):
            abi.StaticArrayTypeSpec(elementType, -1)

    for length in range(256):
        staticBytesType = abi.StaticBytesTypeSpec(length)
        assert isinstance(staticBytesType.value_type_spec(), abi.ByteTypeSpec)
        assert not staticBytesType.is_length_dynamic()
        assert staticBytesType._stride() == 1
        assert staticBytesType.length_static() == length

    for elementType in DYNAMIC_TYPES:
        for length in range(256):
            staticArrayType = abi.StaticArrayTypeSpec(elementType, length)
            assert staticArrayType.value_type_spec() is elementType
            assert not staticArrayType.is_length_dynamic()
            assert staticArrayType._stride() == 2
            assert staticArrayType.length_static() == length

        with pytest.raises(TypeError):
            abi.StaticArrayTypeSpec(elementType, -1)


def test_StaticArrayTypeSpec_str():
    for elementType in STATIC_TYPES + DYNAMIC_TYPES:
        for length in range(256):
            staticArrayType = abi.StaticArrayTypeSpec(elementType, length)
            assert str(staticArrayType) == "{}[{}]".format(elementType, length)

    for length in range(256):
        assert str(abi.StaticBytesTypeSpec(length)) == f"byte[{length}]"


def test_StaticArrayTypeSpec_new_instance():
    for elementType in STATIC_TYPES + DYNAMIC_TYPES:
        for length in range(256):
            staticArrayType = abi.StaticArrayTypeSpec(elementType, length)
            instance = staticArrayType.new_instance()
            assert isinstance(
                instance,
                abi.StaticArray,
            )
            assert instance.type_spec() == staticArrayType

    for length in range(256):
        staticBytesType = abi.StaticBytesTypeSpec(length)
        instance = staticBytesType.new_instance()
        assert isinstance(instance, abi.StaticBytes)
        assert instance.type_spec() == staticBytesType


def test_StaticArrayTypeSpec_eq():
    for elementType in STATIC_TYPES + DYNAMIC_TYPES:
        for length in range(256):
            staticArrayType = abi.StaticArrayTypeSpec(elementType, length)
            assert staticArrayType == staticArrayType
            assert staticArrayType != abi.StaticArrayTypeSpec(elementType, length + 1)
            assert staticArrayType != abi.StaticArrayTypeSpec(
                abi.TupleTypeSpec(elementType), length
            )

    for length in range(256):
        staticBytesType = abi.StaticBytesTypeSpec(length)
        assert staticBytesType == staticBytesType
        assert staticBytesType != abi.StaticBytesTypeSpec(length + 1)
        assert staticBytesType != abi.StaticArrayTypeSpec(
            abi.TupleTypeSpec(abi.ByteTypeSpec()), length
        )


def test_StaticArrayTypeSpec_is_dynamic():
    for elementType in STATIC_TYPES:
        for length in range(256):
            staticArrayType = abi.StaticArrayTypeSpec(elementType, length)
            assert not staticArrayType.is_dynamic()

    for length in range(256):
        assert not abi.StaticBytesTypeSpec(length).is_dynamic()

    for elementType in DYNAMIC_TYPES:
        for length in range(256):
            staticArrayType = abi.StaticArrayTypeSpec(elementType, length)
            assert staticArrayType.is_dynamic()


def test_StaticArrayTypeSpec_byte_length_static():
    for elementType in STATIC_TYPES:
        for length in range(256):
            staticArrayType = abi.StaticArrayTypeSpec(elementType, length)
            actual = staticArrayType.byte_length_static()

            if elementType == abi.BoolTypeSpec():
                expected = _bool_sequence_length(length)
            else:
                expected = elementType.byte_length_static() * length

            assert (
                actual == expected
            ), "failed with element type {} and length {}".format(elementType, length)

    for length in range(256):
        staticBytesType = abi.StaticBytesTypeSpec(length)
        actual = staticBytesType.byte_length_static()
        assert (
            actual == length
        ), f"failed with element type {staticBytesType.value_type_spec()} and length {length}"

    for elementType in DYNAMIC_TYPES:
        for length in range(256):
            staticArrayType = abi.StaticArrayTypeSpec(elementType, length)
            with pytest.raises(ValueError):
                staticArrayType.byte_length_static()


def test_StaticArray_decode():
    encoded = pt.Bytes("encoded")
    for start_index in (None, pt.Int(1)):
        for end_index in (None, pt.Int(2)):
            for length in (None, pt.Int(3)):
                value = abi.StaticArray(
                    abi.StaticArrayTypeSpec(abi.Uint64TypeSpec(), 10)
                )

                if end_index is not None and length is not None:
                    with pytest.raises(pt.TealInputError):
                        value.decode(
                            encoded,
                            start_index=start_index,
                            end_index=end_index,
                            length=length,
                        )
                    continue

                expr = value.decode(
                    encoded, start_index=start_index, end_index=end_index, length=length
                )
                assert expr.type_of() == pt.TealType.none
                assert not expr.has_return()

                expectedExpr = value._stored_value.store(
                    substring_for_decoding(
                        encoded,
                        start_index=start_index,
                        end_index=end_index,
                        length=length,
                    )
                )
                expected, _ = expectedExpr.__teal__(options)
                expected.addIncoming()
                expected = pt.TealBlock.NormalizeBlocks(expected)

                actual, _ = expr.__teal__(options)
                actual.addIncoming()
                actual = pt.TealBlock.NormalizeBlocks(actual)

                with pt.TealComponent.Context.ignoreExprEquality():
                    assert actual == expected


def test_StaticArray_set_values():
    value = abi.StaticArray(abi.StaticArrayTypeSpec(abi.Uint64TypeSpec(), 10))

    with pytest.raises(pt.TealInputError):
        value.set([])

    with pytest.raises(pt.TealInputError):
        value.set([abi.Uint64()] * 9)

    with pytest.raises(pt.TealInputError):
        value.set([abi.Uint64()] * 11)

    with pytest.raises(pt.TealInputError):
        value.set([abi.Uint16()] * 10)

    with pytest.raises(pt.TealInputError):
        value.set([abi.Uint64()] * 9 + [abi.Uint16()])

    values = [abi.Uint64() for _ in range(10)]
    expr = value.set(values)
    assert expr.type_of() == pt.TealType.none
    assert not expr.has_return()

    expectedExpr = value._stored_value.store(_encode_tuple(values))
    expected, _ = expectedExpr.__teal__(options)
    expected.addIncoming()
    expected = pt.TealBlock.NormalizeBlocks(expected)

    actual, _ = expr.__teal__(options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    with pt.TealComponent.Context.ignoreExprEquality():
        assert actual == expected


def test_StaticArray_set_copy():
    value = abi.StaticArray(abi.StaticArrayTypeSpec(abi.Uint64TypeSpec(), 10))
    otherArray = abi.StaticArray(abi.StaticArrayTypeSpec(abi.Uint64TypeSpec(), 10))

    with pytest.raises(pt.TealInputError):
        value.set(abi.StaticArray(abi.StaticArrayTypeSpec(abi.Uint64TypeSpec(), 11)))

    with pytest.raises(pt.TealInputError):
        value.set(abi.StaticArray(abi.StaticArrayTypeSpec(abi.Uint8TypeSpec(), 10)))

    with pytest.raises(pt.TealInputError):
        value.set(abi.Uint64())

    expr = value.set(otherArray)
    assert expr.type_of() == pt.TealType.none
    assert not expr.has_return()

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(
                None,
                pt.Op.load,
                cast(pt.ScratchVar, otherArray._stored_value).slot,
            ),
            pt.TealOp(
                None,
                pt.Op.store,
                cast(pt.ScratchVar, value._stored_value).slot,
            ),
        ]
    )

    actual, _ = expr.__teal__(options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    with pt.TealComponent.Context.ignoreExprEquality():
        assert actual == expected


def test_StaticArray_set_computed():
    value = abi.StaticArray(abi.StaticArrayTypeSpec(abi.Uint64TypeSpec(), 10))
    computed = ContainerType(
        value.type_spec(), pt.Bytes("indeed this is hard to simulate")
    )
    expr = value.set(computed)
    assert expr.type_of() == pt.TealType.none
    assert not expr.has_return()

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(None, pt.Op.byte, '"indeed this is hard to simulate"'),
            pt.TealOp(
                None,
                pt.Op.store,
                cast(pt.ScratchVar, value._stored_value).slot,
            ),
        ]
    )
    actual, _ = expr.__teal__(options)
    actual.addIncoming()
    actual = actual.NormalizeBlocks(actual)

    with pt.TealComponent.Context.ignoreExprEquality():
        assert actual == expected

    with pytest.raises(pt.TealInputError):
        value.set(
            ContainerType(
                abi.StaticArrayTypeSpec(abi.Uint16TypeSpec(), 40),
                pt.Bytes("well i am trolling"),
            )
        )


# AACS key recovery
BYTE_HEX_TEST_CASE = "09f911029d74e35bd84156c5635688c0"

BYTES_SET_TESTCASES = [
    bytes.fromhex(BYTE_HEX_TEST_CASE),
    bytearray.fromhex(BYTE_HEX_TEST_CASE),
]


@pytest.mark.parametrize("test_case", BYTES_SET_TESTCASES)
def test_StaticBytes_set_py_bytes(test_case: bytes | bytearray):
    value: abi.StaticBytes = abi.StaticBytes(abi.StaticBytesTypeSpec(len(test_case)))

    expr = value.set(test_case)
    assert expr.type_of() == pt.TealType.none
    assert not expr.has_return()

    actual, _ = expr.__teal__(options)
    actual.addIncoming()
    actual = actual.NormalizeBlocks(actual)

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(None, pt.Op.byte, "0x" + BYTE_HEX_TEST_CASE),
            pt.TealOp(
                None,
                pt.Op.store,
                cast(pt.ScratchVar, value._stored_value).slot,
            ),
        ]
    )

    with pt.TealComponent.Context.ignoreExprEquality():
        assert actual == expected

    with pytest.raises(pt.TealInputError):
        value.set(test_case[:-1])


@pytest.mark.parametrize("test_case", BYTES_SET_TESTCASES)
def test_StaticBytes_expr(test_case: bytes | bytearray):
    value: abi.StaticBytes = abi.StaticBytes(
        abi.StaticBytesTypeSpec(len(test_case) * 2)
    )
    set_expr = pt.Concat(pt.Bytes(test_case), pt.Bytes(test_case))

    expr = value.set(set_expr)
    assert expr.type_of() == pt.TealType.none
    assert not expr.has_return()

    actual, _ = expr.__teal__(options)
    actual.addIncoming()
    actual = actual.NormalizeBlocks(actual)

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(None, pt.Op.byte, "0x" + BYTE_HEX_TEST_CASE),
            pt.TealOp(None, pt.Op.byte, "0x" + BYTE_HEX_TEST_CASE),
            pt.TealOp(None, pt.Op.concat),
            pt.TealOp(
                None,
                pt.Op.store,
                cast(pt.ScratchVar, value._stored_value).slot,
            ),
            pt.TealOp(None, pt.Op.int, 32),
            pt.TealOp(
                None,
                pt.Op.load,
                cast(pt.ScratchVar, value._stored_value).slot,
            ),
            pt.TealOp(None, pt.Op.len),
            pt.TealOp(None, pt.Op.eq),
            pt.TealOp(None, pt.Op.assert_),
        ]
    )

    with pt.TealComponent.Context.ignoreExprEquality():
        assert actual == expected


def test_StaticArray_encode():
    value = abi.StaticArray(abi.StaticArrayTypeSpec(abi.Uint64TypeSpec(), 10))
    expr = value.encode()
    assert expr.type_of() == pt.TealType.bytes
    assert not expr.has_return()

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(
                None,
                pt.Op.load,
                cast(pt.ScratchVar, value._stored_value).slot,
            ),
        ]
    )

    actual, _ = expr.__teal__(options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    with pt.TealComponent.Context.ignoreExprEquality():
        assert actual == expected


def test_StaticArray_length():
    for length in (0, 1, 2, 3, 1000):
        value = abi.StaticArray(abi.StaticArrayTypeSpec(abi.Uint64TypeSpec(), length))
        expr = value.length()
        assert expr.type_of() == pt.TealType.uint64
        assert not expr.has_return()

        expected = pt.TealSimpleBlock([pt.TealOp(None, pt.Op.int, length)])

        actual, _ = expr.__teal__(options)
        actual.addIncoming()
        actual = pt.TealBlock.NormalizeBlocks(actual)

        with pt.TealComponent.Context.ignoreExprEquality():
            assert actual == expected


def test_StaticArray_getitem():
    for length in (0, 1, 2, 3, 1000):
        value = abi.StaticArray(abi.StaticArrayTypeSpec(abi.Uint64TypeSpec(), length))

        for index in range(length):
            # dynamic indexes
            indexExpr = pt.Int(index)
            element = value[indexExpr]
            assert type(element) is abi.ArrayElement
            assert element.array is value
            assert element.index is indexExpr

        for index in range(length):
            # static indexes
            element = value[index]
            assert type(element) is abi.ArrayElement
            assert element.array is value
            assert type(element.index) is pt.Int
            assert element.index.value == index

        with pytest.raises(pt.TealInputError):
            value[-1]

        with pytest.raises(pt.TealInputError):
            value[length]



================================================
FILE: pyteal/ast/abi/bool.py
================================================
from typing import TypeVar, Union, Sequence, Callable

from pyteal.types import TealType
from pyteal.errors import TealInputError
from pyteal.ast.expr import Expr
from pyteal.ast.int import Int
from pyteal.ast.bytes import Bytes
from pyteal.ast.unaryexpr import Not
from pyteal.ast.binaryexpr import GetBit
from pyteal.ast.ternaryexpr import SetBit
from pyteal.ast.abi.type import ComputedValue, TypeSpec, BaseType
from pyteal.ast.abi.uint import NUM_BITS_IN_BYTE


class BoolTypeSpec(TypeSpec):
    def new_instance(self) -> "Bool":
        return Bool()

    def annotation_type(self) -> "type[Bool]":
        return Bool

    def is_dynamic(self) -> bool:
        # Only accurate if this value is alone, since up to 8 consecutive bools will fit into a single byte
        return False

    def byte_length_static(self) -> int:
        return 1

    def storage_type(self) -> TealType:
        return TealType.uint64

    def __eq__(self, other: object) -> bool:
        return isinstance(other, BoolTypeSpec)

    def __str__(self) -> str:
        return "bool"


BoolTypeSpec.__module__ = "pyteal.abi"


class Bool(BaseType):
    def __init__(self) -> None:
        super().__init__(BoolTypeSpec())

    def get(self) -> Expr:
        """Return the value held by this Bool as a PyTeal expression.

        If the held value is true, an expression that evaluates to 1 will be returned. Otherwise, an
        expression that evaluates to 0 will be returned. In either case, the expression will have the
        type TealType.uint64.
        """
        return self._stored_value.load()

    def set(self, value: Union[bool, Expr, "Bool", ComputedValue["Bool"]]) -> Expr:
        """Set the value of this Bool to the input value.

        The behavior of this method depends on the input argument type:

            * :code:`bool`: set the value to a Python boolean value.
            * :code:`Expr`: set the value to the result of a PyTeal expression, which must evaluate to a TealType.uint64. All values greater than 0 are considered true, while 0 is considered false.
            * :code:`Bool`: copy the value from another Bool.
            * :code:`ComputedValue[Bool]`: copy the value from a Bool produced by a ComputedValue.

        Args:
            value: The new value this Bool should take. This must follow the above constraints.

        Returns:
            An expression which stores the given value into this Bool.
        """
        if isinstance(value, ComputedValue):
            return self._set_with_computed_type(value)

        checked = False
        if type(value) is bool:
            value = Int(1 if value else 0)
            checked = True

        if isinstance(value, BaseType):
            if value.type_spec() != self.type_spec():
                raise TealInputError(
                    "Cannot set type bool to {}".format(value.type_spec())
                )
            value = value.get()
            checked = True

        if checked:
            return self._stored_value.store(value)

        # Not(Not(value)) coerces all values greater than 0 to 1
        return self._stored_value.store(Not(Not(value)))

    def decode(
        self,
        encoded: Expr,
        *,
        start_index: Expr | None = None,
        end_index: Expr | None = None,
        length: Expr | None = None
    ) -> Expr:
        if start_index is None:
            start_index = Int(0)
        return self.decode_bit(encoded, start_index * Int(NUM_BITS_IN_BYTE))

    def decode_bit(self, encoded, bit_index: Expr) -> Expr:
        return self._stored_value.store(GetBit(encoded, bit_index))

    def encode(self) -> Expr:
        return SetBit(Bytes(b"\x00"), Int(0), self.get())


Bool.__module__ = "pyteal.abi"


def _bool_aware_static_byte_length(types: Sequence[TypeSpec]) -> int:
    length = 0
    ignoreNext = 0
    for i, t in enumerate(types):
        if ignoreNext > 0:
            ignoreNext -= 1
            continue
        if t == BoolTypeSpec():
            numBools = _consecutive_bool_type_spec_num(types, i)
            ignoreNext = numBools - 1
            length += _bool_sequence_length(numBools)
            continue
        length += t.byte_length_static()
    return length


T = TypeVar("T")


def _consecutive_thing_num(
    things: Sequence[T], start_index: int, condition: Callable[[T], bool]
) -> int:
    numConsecutiveThings = 0
    for t in things[start_index:]:
        if not condition(t):
            break
        numConsecutiveThings += 1
    return numConsecutiveThings


def _consecutive_bool_type_spec_num(types: Sequence[TypeSpec], start_index: int) -> int:
    if len(types) != 0 and not isinstance(types[0], TypeSpec):
        raise TypeError("Sequence of types expected")
    return _consecutive_thing_num(types, start_index, lambda t: t == BoolTypeSpec())


def _consecutive_bool_instance_num(values: Sequence[BaseType], start_index: int) -> int:
    if len(values) != 0 and not isinstance(values[0], BaseType):
        raise TypeError(
            "Sequence of types expected, but got {}".format(type(values[0]))
        )
    return _consecutive_thing_num(
        values, start_index, lambda t: t.type_spec() == BoolTypeSpec()
    )


def _bool_sequence_length(num_bools: int) -> int:
    """Get the length in bytes of an encoding of `num_bools` consecutive booleans values."""
    return (num_bools + NUM_BITS_IN_BYTE - 1) // NUM_BITS_IN_BYTE


def _encode_bool_sequence(values: Sequence[Bool]) -> Expr:
    """Encoding a sequences of boolean values into a byte string.

    Args:
        values: The values to encode. Each must be an instance of Bool.

    Returns:
        An expression which creates an encoded byte string with the input boolean values.
    """
    length = _bool_sequence_length(len(values))
    expr: Expr = Bytes(b"\x00" * length)

    for i, value in enumerate(values):
        expr = SetBit(expr, Int(i), value.get())

    return expr



================================================
FILE: pyteal/ast/abi/bool_test.py
================================================
from typing import NamedTuple, List, cast
import pytest

import pyteal as pt
from pyteal import abi
from pyteal.ast.abi.type_test import ContainerType
from pyteal.ast.abi.bool import (
    _bool_aware_static_byte_length,
    _consecutive_bool_instance_num,
    _consecutive_bool_type_spec_num,
    _bool_sequence_length,
    _encode_bool_sequence,
)

options = pt.CompileOptions(version=5)


def test_BoolTypeSpec_str():
    assert str(abi.BoolTypeSpec()) == "bool"


def test_BoolTypeSpec_is_dynamic():
    assert not abi.BoolTypeSpec().is_dynamic()


def test_BoolTypeSpec_byte_length_static():
    assert abi.BoolTypeSpec().byte_length_static() == 1


def test_BoolTypeSpec_new_instance():
    assert isinstance(abi.BoolTypeSpec().new_instance(), abi.Bool)


def test_BoolTypeSpec_eq():
    assert abi.BoolTypeSpec() == abi.BoolTypeSpec()

    for otherType in (
        abi.ByteTypeSpec,
        abi.Uint64TypeSpec,
        abi.StaticArrayTypeSpec(abi.BoolTypeSpec(), 1),
        abi.DynamicArrayTypeSpec(abi.BoolTypeSpec()),
    ):
        assert abi.BoolTypeSpec() != otherType


def test_Bool_set_static():
    value = abi.Bool()
    for value_to_set in (True, False):
        expr = value.set(value_to_set)
        assert expr.type_of() == pt.TealType.none
        assert not expr.has_return()

        expected = pt.TealSimpleBlock(
            [
                pt.TealOp(None, pt.Op.int, 1 if value_to_set else 0),
                pt.TealOp(
                    None,
                    pt.Op.store,
                    cast(pt.ScratchVar, value._stored_value).slot,
                ),
            ]
        )

        actual, _ = expr.__teal__(options)
        actual.addIncoming()
        actual = pt.TealBlock.NormalizeBlocks(actual)

        with pt.TealComponent.Context.ignoreExprEquality():
            assert actual == expected


def test_Bool_set_expr():
    value = abi.Bool()
    expr = value.set(pt.Int(0).Or(pt.Int(1)))
    assert expr.type_of() == pt.TealType.none
    assert not expr.has_return()

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(None, pt.Op.int, 0),
            pt.TealOp(None, pt.Op.int, 1),
            pt.TealOp(None, pt.Op.logic_or),
            pt.TealOp(None, pt.Op.logic_not),
            pt.TealOp(None, pt.Op.logic_not),
            pt.TealOp(
                None,
                pt.Op.store,
                cast(pt.ScratchVar, value._stored_value).slot,
            ),
        ]
    )

    actual, _ = expr.__teal__(options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    with pt.TealComponent.Context.ignoreExprEquality():
        assert actual == expected


def test_Bool_set_copy():
    other = abi.Bool()
    value = abi.Bool()
    expr = value.set(other)
    assert expr.type_of() == pt.TealType.none
    assert not expr.has_return()

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(
                None,
                pt.Op.load,
                cast(pt.ScratchVar, other._stored_value).slot,
            ),
            pt.TealOp(
                None,
                pt.Op.store,
                cast(pt.ScratchVar, value._stored_value).slot,
            ),
        ]
    )

    actual, _ = expr.__teal__(options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    with pt.TealComponent.Context.ignoreExprEquality():
        assert actual == expected

    with pytest.raises(pt.TealInputError):
        value.set(abi.Uint16())


def test_Bool_set_computed():
    value = abi.Bool()
    computed = ContainerType(abi.BoolTypeSpec(), pt.Int(0x80))
    expr = value.set(computed)
    assert expr.type_of() == pt.TealType.none
    assert not expr.has_return()

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(None, pt.Op.int, 0x80),
            pt.TealOp(
                None,
                pt.Op.store,
                cast(pt.ScratchVar, value._stored_value).slot,
            ),
        ]
    )

    actual, _ = expr.__teal__(options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    with pt.TealComponent.Context.ignoreExprEquality():
        assert actual == expected

    with pytest.raises(pt.TealInputError):
        value.set(ContainerType(abi.Uint32TypeSpec(), pt.Int(65537)))


def test_Bool_get():
    value = abi.Bool()
    expr = value.get()
    assert expr.type_of() == pt.TealType.uint64
    assert not expr.has_return()

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(
                expr,
                pt.Op.load,
                cast(pt.ScratchVar, value._stored_value).slot,
            ),
        ]
    )

    actual, _ = expr.__teal__(options)

    assert actual == expected


def test_Bool_decode():
    value = abi.Bool()
    encoded = pt.Bytes("encoded")
    for start_index in (None, pt.Int(1)):
        for end_index in (None, pt.Int(2)):
            for length in (None, pt.Int(3)):
                expr = value.decode(
                    encoded, start_index=start_index, end_index=end_index, length=length
                )
                assert expr.type_of() == pt.TealType.none
                assert not expr.has_return()

                expected = pt.TealSimpleBlock(
                    [
                        pt.TealOp(None, pt.Op.byte, '"encoded"'),
                        pt.TealOp(None, pt.Op.int, 0 if start_index is None else 1),
                        pt.TealOp(None, pt.Op.int, 8),
                        pt.TealOp(None, pt.Op.mul),
                        pt.TealOp(None, pt.Op.getbit),
                        pt.TealOp(
                            None,
                            pt.Op.store,
                            cast(pt.ScratchVar, value._stored_value).slot,
                        ),
                    ]
                )

                actual, _ = expr.__teal__(options)
                actual.addIncoming()
                actual = pt.TealBlock.NormalizeBlocks(actual)

                with pt.TealComponent.Context.ignoreExprEquality():
                    assert actual == expected


def test_Bool_decode_bit():
    value = abi.Bool()
    bitIndex = pt.Int(17)
    encoded = pt.Bytes("encoded")
    expr = value.decode_bit(encoded, bitIndex)
    assert expr.type_of() == pt.TealType.none
    assert not expr.has_return()

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(None, pt.Op.byte, '"encoded"'),
            pt.TealOp(None, pt.Op.int, 17),
            pt.TealOp(None, pt.Op.getbit),
            pt.TealOp(
                None,
                pt.Op.store,
                cast(pt.ScratchVar, value._stored_value).slot,
            ),
        ]
    )

    actual, _ = expr.__teal__(options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    with pt.TealComponent.Context.ignoreExprEquality():
        assert actual == expected


def test_Bool_encode():
    value = abi.Bool()
    expr = value.encode()
    assert expr.type_of() == pt.TealType.bytes
    assert not expr.has_return()

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(None, pt.Op.byte, "0x00"),
            pt.TealOp(None, pt.Op.int, 0),
            pt.TealOp(
                None,
                pt.Op.load,
                cast(pt.ScratchVar, value._stored_value).slot,
            ),
            pt.TealOp(None, pt.Op.setbit),
        ]
    )

    actual, _ = expr.__teal__(options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    with pt.TealComponent.Context.ignoreExprEquality():
        assert actual == expected


def test_boolAwareStaticByteLength():
    class ByteLengthTest(NamedTuple):
        types: List[abi.TypeSpec]
        expectedLength: int

    tests: List[ByteLengthTest] = [
        ByteLengthTest(types=[], expectedLength=0),
        ByteLengthTest(types=[abi.Uint64TypeSpec()], expectedLength=8),
        ByteLengthTest(types=[abi.BoolTypeSpec()], expectedLength=1),
        ByteLengthTest(types=[abi.BoolTypeSpec()] * 8, expectedLength=1),
        ByteLengthTest(types=[abi.BoolTypeSpec()] * 9, expectedLength=2),
        ByteLengthTest(types=[abi.BoolTypeSpec()] * 16, expectedLength=2),
        ByteLengthTest(types=[abi.BoolTypeSpec()] * 17, expectedLength=3),
        ByteLengthTest(types=[abi.BoolTypeSpec()] * 100, expectedLength=13),
        ByteLengthTest(
            types=[abi.BoolTypeSpec(), abi.ByteTypeSpec(), abi.BoolTypeSpec()],
            expectedLength=3,
        ),
        ByteLengthTest(
            types=[
                abi.BoolTypeSpec(),
                abi.BoolTypeSpec(),
                abi.ByteTypeSpec(),
                abi.BoolTypeSpec(),
                abi.BoolTypeSpec(),
            ],
            expectedLength=3,
        ),
        ByteLengthTest(
            types=[abi.BoolTypeSpec()] * 16
            + [abi.ByteTypeSpec(), abi.BoolTypeSpec(), abi.BoolTypeSpec()],
            expectedLength=4,
        ),
    ]

    for i, test in enumerate(tests):
        actual = _bool_aware_static_byte_length(test.types)
        assert actual == test.expectedLength, "Test at index {} failed".format(i)


def test_consecutiveBool():
    class ConsecutiveTest(NamedTuple):
        types: List[abi.TypeSpec]
        start: int
        expected: int

    tests: List[ConsecutiveTest] = [
        ConsecutiveTest(types=[], start=0, expected=0),
        ConsecutiveTest(types=[abi.Uint16TypeSpec()], start=0, expected=0),
        ConsecutiveTest(types=[abi.BoolTypeSpec()], start=0, expected=1),
        ConsecutiveTest(types=[abi.BoolTypeSpec()], start=1, expected=0),
        ConsecutiveTest(
            types=[abi.BoolTypeSpec(), abi.BoolTypeSpec()], start=0, expected=2
        ),
        ConsecutiveTest(
            types=[abi.BoolTypeSpec(), abi.BoolTypeSpec()], start=1, expected=1
        ),
        ConsecutiveTest(
            types=[abi.BoolTypeSpec(), abi.BoolTypeSpec()], start=2, expected=0
        ),
        ConsecutiveTest(
            types=[abi.BoolTypeSpec() for _ in range(10)], start=0, expected=10
        ),
        ConsecutiveTest(
            types=[
                abi.BoolTypeSpec(),
                abi.BoolTypeSpec(),
                abi.ByteTypeSpec(),
                abi.BoolTypeSpec(),
            ],
            start=0,
            expected=2,
        ),
        ConsecutiveTest(
            types=[
                abi.BoolTypeSpec(),
                abi.BoolTypeSpec(),
                abi.ByteTypeSpec(),
                abi.BoolTypeSpec(),
            ],
            start=2,
            expected=0,
        ),
        ConsecutiveTest(
            types=[
                abi.BoolTypeSpec(),
                abi.BoolTypeSpec(),
                abi.ByteTypeSpec(),
                abi.BoolTypeSpec(),
            ],
            start=3,
            expected=1,
        ),
        ConsecutiveTest(
            types=[
                abi.ByteTypeSpec(),
                abi.BoolTypeSpec(),
                abi.BoolTypeSpec(),
                abi.ByteTypeSpec(),
            ],
            start=0,
            expected=0,
        ),
        ConsecutiveTest(
            types=[
                abi.ByteTypeSpec(),
                abi.BoolTypeSpec(),
                abi.BoolTypeSpec(),
                abi.ByteTypeSpec(),
            ],
            start=1,
            expected=2,
        ),
    ]

    for i, test in enumerate(tests):
        actual = _consecutive_bool_type_spec_num(test.types, test.start)
        assert actual == test.expected, "Test at index {} failed".format(i)

        actual = _consecutive_bool_instance_num(
            [t.new_instance() for t in test.types], test.start
        )
        assert actual == test.expected, "Test at index {} failed".format(i)


def test_boolSequenceLength():
    class SeqLengthTest(NamedTuple):
        numBools: int
        expectedLength: int

    tests: List[SeqLengthTest] = [
        SeqLengthTest(numBools=0, expectedLength=0),
        SeqLengthTest(numBools=1, expectedLength=1),
        SeqLengthTest(numBools=8, expectedLength=1),
        SeqLengthTest(numBools=9, expectedLength=2),
        SeqLengthTest(numBools=16, expectedLength=2),
        SeqLengthTest(numBools=17, expectedLength=3),
        SeqLengthTest(numBools=100, expectedLength=13),
    ]

    for i, test in enumerate(tests):
        actual = _bool_sequence_length(test.numBools)
        assert actual == test.expectedLength, "Test at index {} failed".format(i)


def test_encodeBoolSequence():
    class EncodeSeqTest(NamedTuple):
        types: List[abi.Bool]
        expectedLength: int

    tests: List[EncodeSeqTest] = [
        EncodeSeqTest(types=[], expectedLength=0),
        EncodeSeqTest(types=[abi.Bool()], expectedLength=1),
        EncodeSeqTest(types=[abi.Bool() for _ in range(4)], expectedLength=1),
        EncodeSeqTest(types=[abi.Bool() for _ in range(8)], expectedLength=1),
        EncodeSeqTest(types=[abi.Bool() for _ in range(9)], expectedLength=2),
        EncodeSeqTest(types=[abi.Bool() for _ in range(100)], expectedLength=13),
    ]

    for i, test in enumerate(tests):
        expr = _encode_bool_sequence(test.types)
        assert expr.type_of() == pt.TealType.bytes
        assert not expr.has_return()

        setBits = [
            [
                pt.TealOp(None, pt.Op.int, j),
                pt.TealOp(
                    None,
                    pt.Op.load,
                    cast(pt.ScratchVar, testType._stored_value).slot,
                ),
                pt.TealOp(None, pt.Op.setbit),
            ]
            for j, testType in enumerate(test.types)
        ]

        expected = pt.TealSimpleBlock(
            [
                pt.TealOp(None, pt.Op.byte, "0x" + ("00" * test.expectedLength)),
            ]
            + [expr for setBit in setBits for expr in setBit]
        )

        actual, _ = expr.__teal__(options)
        actual.addIncoming()
        actual = pt.TealBlock.NormalizeBlocks(actual)

        with pt.TealComponent.Context.ignoreExprEquality():
            assert actual == expected, "Test at index {} failed".format(i)



================================================
FILE: pyteal/ast/abi/method_return.py
================================================
from typing import TYPE_CHECKING, Tuple
from pyteal.ast.abi import BaseType
from pyteal.types import TealType
from pyteal.errors import TealInputError
from pyteal.ast.expr import Expr
from pyteal.ast.unaryexpr import Log
from pyteal.ast.naryexpr import Concat
from pyteal.ast.bytes import Bytes
from pyteal.config import RETURN_HASH_PREFIX
from pyteal.ir import TealBlock, TealSimpleBlock, Op
from pyteal.stack_frame import NatalStackFrame

if TYPE_CHECKING:
    from pyteal.compiler import CompileOptions


class MethodReturn(Expr):
    def __init__(self, arg: BaseType):
        super().__init__()
        if not isinstance(arg, BaseType):
            raise TealInputError(f"Expecting an ABI type argument but get {arg}")
        self.arg = arg

    def __teal__(self, options: "CompileOptions") -> Tuple[TealBlock, TealSimpleBlock]:
        if options.version < Op.log.min_version:
            raise TealInputError(
                f"current version {options.version} is lower than log's min version {Op.log.min_version}"
            )
        start, end = Log(Concat(Bytes(RETURN_HASH_PREFIX), self.arg.encode())).__teal__(
            options
        )
        NatalStackFrame.reframe_ops_in_blocks(self, start)
        return start, end

    def __str__(self) -> str:
        return f"(MethodReturn {self.arg.type_spec()})"

    def type_of(self) -> TealType:
        return TealType.none

    def has_return(self) -> bool:
        return False


MethodReturn.__module__ = "pyteal.abi"



================================================
FILE: pyteal/ast/abi/method_return_test.py
================================================
import pytest

import pyteal as pt
from pyteal import abi


POSITIVE_CASES = [
    abi.Uint16(),
    abi.Uint32(),
    abi.StaticArray(abi.StaticArrayTypeSpec(abi.BoolTypeSpec(), 12)),
]


@pytest.mark.parametrize("case", POSITIVE_CASES)
def test_method_return(case):
    m_ret = abi.MethodReturn(case)
    assert m_ret.type_of() == pt.TealType.none
    assert not m_ret.has_return()
    assert str(m_ret) == f"(MethodReturn {case.type_spec()})"


NEGATIVE_CASES = [
    pt.Int(0),
    pt.Bytes("aaaaaaa"),
    abi.Uint16,
    abi.Uint32,
]


@pytest.mark.parametrize("case", NEGATIVE_CASES)
def test_method_return_error(case):
    with pytest.raises(pt.TealInputError):
        abi.MethodReturn(case)



================================================
FILE: pyteal/ast/abi/reference_type.py
================================================
from typing import Final, TypeVar, cast
from abc import abstractmethod
from pyteal.ast.abi.type import BaseType, TypeSpec
from pyteal.ast.abi.uint import NUM_BITS_IN_BYTE, uint_decode

from pyteal.ast.expr import Expr
from pyteal.ast.txn import Txn
from pyteal.ast.acct import AccountParamObject
from pyteal.ast.asset import AssetHoldingObject, AssetParamObject
from pyteal.ast.app import AppParamObject
from pyteal.errors import TealInputError
from pyteal.types import TealType


T = TypeVar("T", bound="ReferenceType")


class ReferenceTypeSpec(TypeSpec):
    @abstractmethod
    def new_instance(self) -> "ReferenceType":
        pass

    @abstractmethod
    def annotation_type(self) -> "type[ReferenceType]":
        pass

    def bit_size(self) -> int:
        """Get the bit size of the index this reference type holds"""
        return NUM_BITS_IN_BYTE

    def is_dynamic(self) -> bool:
        return False

    def byte_length_static(self) -> int:
        return 1

    def storage_type(self) -> TealType:
        return TealType.uint64


ReferenceTypeSpec.__module__ = "pyteal.abi"


class ReferenceType(BaseType):
    @abstractmethod
    def __init__(self, spec: ReferenceTypeSpec) -> None:
        super().__init__(spec)

    def type_spec(self) -> ReferenceTypeSpec:
        return cast(ReferenceTypeSpec, super().type_spec())

    def referenced_index(self) -> Expr:
        """Get the reference index for this value.

        The three reference types (account, application, asset) contain indexes into a foreign array
        of the transaction. This method returns that index.

        If this reference type is an application or asset, note that this DOES NOT return the
        application or asset ID. See :code:`application_id()` or :code:`asset_id()` for that.
        """
        return self._stored_value.load()

    def decode(
        self,
        encoded: Expr,
        *,
        start_index: Expr | None = None,
        end_index: Expr | None = None,
        length: Expr | None = None,
    ) -> Expr:
        return uint_decode(
            self.type_spec().bit_size(),
            self._stored_value,
            encoded,
            start_index,
            end_index,
            length,
        )

    def encode(self) -> Expr:
        raise TealInputError("A ReferenceType cannot be encoded")


ReferenceType.__module__ = "pyteal.abi"


class AccountTypeSpec(ReferenceTypeSpec):
    def new_instance(self) -> "Account":
        return Account()

    def annotation_type(self) -> "type[Account]":
        return Account

    def __str__(self) -> str:
        return "account"

    def __eq__(self, other: object) -> bool:
        return isinstance(other, AccountTypeSpec)


AccountTypeSpec.__module__ = "pyteal.abi"


class Account(ReferenceType):
    def __init__(self) -> None:
        super().__init__(AccountTypeSpec())

    def address(self) -> Expr:
        """Get the address of the account."""
        return Txn.accounts[self._stored_value.load()]

    def params(self) -> AccountParamObject:
        """Get information about the account."""
        return AccountParamObject(self.referenced_index())

    def asset_holding(self, asset: "Expr | Asset") -> AssetHoldingObject:
        """Get information about an asset held by this account.

        Args:
            asset: An identifier for the asset. It must be one of the following: an abi.Asset
                reference object, an expression holding an index into Txn.ForeignAssets that
                corresponds to the asset (in which case it must evaluate to uint64), or since v4, an
                expression holding an asset ID that appears in Txn.ForeignAssets (in which case it
                must evaluate to uint64).
        """
        if isinstance(asset, Asset):
            asset_ref = asset.asset_id()
        else:
            asset_ref = asset
        return AssetHoldingObject(asset_ref, self.referenced_index())


Account.__module__ = "pyteal.abi"


class AssetTypeSpec(ReferenceTypeSpec):
    def new_instance(self) -> "Asset":
        return Asset()

    def annotation_type(self) -> "type[Asset]":
        return Asset

    def __str__(self) -> str:
        return "asset"

    def __eq__(self, other: object) -> bool:
        return isinstance(other, AssetTypeSpec)


AssetTypeSpec.__module__ = "pyteal.abi"


class Asset(ReferenceType):
    def __init__(self) -> None:
        super().__init__(AssetTypeSpec())

    def asset_id(self) -> Expr:
        """Get the ID of the asset."""
        return Txn.assets[self.referenced_index()]

    def holding(self, account: Expr | Account) -> AssetHoldingObject:
        """Get information about this asset held by an account.

        Args:
            account: An identifier for the account. It must be one of the following: an abi.Account
                reference object, an expression holding an index into Txn.Accounts that corresponds
                to the account (in which case it must evaluate to uint64), or since v4, an
                expression holding an account address that appears in Txn.Accounts or is Txn.Sender
                (in which case it must evaluate to bytes).
        """
        if isinstance(account, Account):
            account_ref = account.referenced_index()
        else:
            account_ref = account
        return AssetHoldingObject(self.asset_id(), account_ref)

    def params(self) -> AssetParamObject:
        """Get information about the asset's parameters."""
        return AssetParamObject(self.asset_id())


Asset.__module__ = "pyteal.abi"


class ApplicationTypeSpec(ReferenceTypeSpec):
    def new_instance(self) -> "Application":
        return Application()

    def annotation_type(self) -> "type[Application]":
        return Application

    def __str__(self) -> str:
        return "application"

    def __eq__(self, other: object) -> bool:
        return isinstance(other, ApplicationTypeSpec)


ApplicationTypeSpec.__module__ = "pyteal.abi"


class Application(ReferenceType):
    def __init__(self) -> None:
        super().__init__(ApplicationTypeSpec())

    def application_id(self) -> Expr:
        """Get the ID of the application."""
        return Txn.applications[self._stored_value.load()]

    def params(self) -> AppParamObject:
        """Get information about the application's parameters."""
        return AppParamObject(self.application_id())


Application.__module__ = "pyteal.abi"


ReferenceTypeSpecs: Final[list[TypeSpec]] = [
    AccountTypeSpec(),
    AssetTypeSpec(),
    ApplicationTypeSpec(),
]



================================================
FILE: pyteal/ast/abi/reference_type_test.py
================================================
import pytest
from typing import cast

import pyteal as pt
from pyteal import abi

options = pt.CompileOptions(version=5)


def test_ReferenceTypeSpecs_list():
    assert abi.ReferenceTypeSpecs == [
        abi.AccountTypeSpec(),
        abi.AssetTypeSpec(),
        abi.ApplicationTypeSpec(),
    ]


def test_ReferenceType_referenced_index():
    for value in (abi.Account(), abi.Asset(), abi.Application()):
        expr = value.referenced_index()
        assert expr.type_of() == pt.TealType.uint64
        assert expr.has_return() is False

        expected = pt.TealSimpleBlock(
            [
                pt.TealOp(
                    expr,
                    pt.Op.load,
                    cast(pt.ScratchVar, value._stored_value).slot,
                ),
            ]
        )
        actual, _ = expr.__teal__(options)
        actual.addIncoming()
        actual = pt.TealBlock.NormalizeBlocks(actual)

        with pt.TealComponent.Context.ignoreExprEquality():
            assert actual == expected


def test_ReferenceType_encode():
    for value in (abi.Account(), abi.Asset(), abi.Application()):
        with pytest.raises(
            pt.TealInputError, match=r"A ReferenceType cannot be encoded$"
        ):
            value.encode()


def test_ReferenceType_decode():
    encoded = pt.Bytes("encoded")
    for value in (abi.Account(), abi.Asset(), abi.Application()):
        for start_index in (None, pt.Int(1)):
            for end_index in (None, pt.Int(2)):
                for length in (None, pt.Int(3)):
                    expr = value.decode(
                        encoded,
                        start_index=start_index,
                        end_index=end_index,
                        length=length,
                    )
                    assert expr.type_of() == pt.TealType.none
                    assert expr.has_return() is False

                    expected_decoding = value._stored_value.store(
                        pt.GetByte(
                            encoded,
                            start_index if start_index is not None else pt.Int(0),
                        )
                    )
                    expected, _ = expected_decoding.__teal__(options)
                    expected.addIncoming()
                    expected = pt.TealBlock.NormalizeBlocks(expected)

                    actual, _ = expr.__teal__(options)
                    actual.addIncoming()
                    actual = pt.TealBlock.NormalizeBlocks(actual)

                    with pt.TealComponent.Context.ignoreExprEquality():
                        assert actual == expected


def test_Account_str():
    assert str(abi.AccountTypeSpec()) == "account"


def test_AccountTypeSpec_is_dynamic():
    assert not (abi.AccountTypeSpec()).is_dynamic()


def test_AccountTypeSpec_new_instance():
    assert isinstance(abi.AccountTypeSpec().new_instance(), abi.Account)


def test_AccountTypeSpec_eq():
    assert abi.AccountTypeSpec() == abi.AccountTypeSpec()

    for otherType in (
        abi.ByteTypeSpec(),
        abi.Uint8TypeSpec(),
        abi.AddressTypeSpec(),
    ):
        assert abi.AccountTypeSpec() != otherType


def test_Account_typespec():
    assert abi.Account().type_spec() == abi.AccountTypeSpec()


def test_Account_address():
    value = abi.Account()
    expr = value.address()
    assert expr.type_of() == pt.TealType.bytes
    assert expr.has_return() is False

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(
                None,
                pt.Op.load,
                cast(pt.ScratchVar, value._stored_value).slot,
            ),
            pt.TealOp(None, pt.Op.txnas, "Accounts"),
        ]
    )
    actual, _ = expr.__teal__(options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    with pt.TealComponent.Context.ignoreExprEquality():
        assert actual == expected


def test_Account_params():
    value = abi.Account()

    params = value.params()

    assert type(params) is pt.AccountParamObject

    expected = value.referenced_index()
    actual = params._account

    with pt.TealComponent.Context.ignoreExprEquality():
        assert actual.__teal__(options) == expected.__teal__(options)


def test_Account_asset_holding():
    value = abi.Account()

    assets = ((pt.Int(6), pt.Int(6)), (a := abi.Asset(), a.asset_id()))

    for asset, expected_asset in assets:
        holding = value.asset_holding(asset)

        assert type(holding) is pt.AssetHoldingObject

        expected_account = value.referenced_index()
        actual_account = holding._account

        actual_asset = holding._asset

        with pt.TealComponent.Context.ignoreExprEquality():
            assert actual_account.__teal__(options) == expected_account.__teal__(
                options
            )
            assert actual_asset.__teal__(options) == expected_asset.__teal__(options)


def test_Asset_str():
    assert str(abi.AssetTypeSpec()) == "asset"


def test_AssetTypeSpec_is_dynamic():
    assert not (abi.AssetTypeSpec()).is_dynamic()


def test_AssetTypeSpec_new_instance():
    assert isinstance(abi.AssetTypeSpec().new_instance(), abi.Asset)


def test_AssetTypeSpec_eq():
    assert abi.AssetTypeSpec() == abi.AssetTypeSpec()

    for otherType in (
        abi.ByteTypeSpec(),
        abi.Uint8TypeSpec(),
        abi.AddressTypeSpec(),
    ):
        assert abi.AssetTypeSpec() != otherType


def test_Asset_typespec():
    assert abi.Asset().type_spec() == abi.AssetTypeSpec()


def test_Asset_asset_id():
    value = abi.Asset()
    expr = value.asset_id()
    assert expr.type_of() == pt.TealType.uint64
    assert expr.has_return() is False

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(
                None,
                pt.Op.load,
                cast(pt.ScratchVar, value._stored_value).slot,
            ),
            pt.TealOp(None, pt.Op.txnas, "Assets"),
        ]
    )
    actual, _ = expr.__teal__(options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    with pt.TealComponent.Context.ignoreExprEquality():
        assert actual == expected


def test_Asset_holding():
    value = abi.Asset()

    accounts = (
        (pt.Int(6), pt.Int(6)),
        (
            pt.Addr("QSA6K5MNJPEGO5SDSWXBM3K4UEI3Q2NCPS2OUXVJI5QPCHMVI27MFRSHKI"),
            pt.Addr("QSA6K5MNJPEGO5SDSWXBM3K4UEI3Q2NCPS2OUXVJI5QPCHMVI27MFRSHKI"),
        ),
        (a := abi.Account(), a.referenced_index()),
    )

    for account, expected_account in accounts:
        holding = value.holding(account)

        assert type(holding) is pt.AssetHoldingObject

        expected_asset = value.asset_id()
        actual_asset = holding._asset

        actual_account = holding._account

        with pt.TealComponent.Context.ignoreExprEquality():
            assert actual_asset.__teal__(options) == expected_asset.__teal__(options)
            assert actual_account.__teal__(options) == expected_account.__teal__(
                options
            )


def test_Asset_params():
    value = abi.Asset()

    params = value.params()

    assert type(params) is pt.AssetParamObject

    expected = value.asset_id()
    actual = params._asset

    with pt.TealComponent.Context.ignoreExprEquality():
        assert actual.__teal__(options) == expected.__teal__(options)


def test_Application_str():
    assert str(abi.ApplicationTypeSpec()) == "application"


def test_ApplicationTypeSpec_is_dynamic():
    assert not (abi.ApplicationTypeSpec()).is_dynamic()


def test_ApplicationTypeSpec_new_instance():
    assert isinstance(abi.ApplicationTypeSpec().new_instance(), abi.Application)


def test_ApplicationTypeSpec_eq():
    assert abi.ApplicationTypeSpec() == abi.ApplicationTypeSpec()

    for otherType in (
        abi.ByteTypeSpec(),
        abi.Uint8TypeSpec(),
        abi.AddressTypeSpec(),
    ):
        assert abi.ApplicationTypeSpec() != otherType


def test_Application_typespec():
    assert abi.Application().type_spec() == abi.ApplicationTypeSpec()


def test_Application_application_id():
    value = abi.Application()
    expr = value.application_id()
    assert expr.type_of() == pt.TealType.uint64
    assert expr.has_return() is False

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(
                None,
                pt.Op.load,
                cast(pt.ScratchVar, value._stored_value).slot,
            ),
            pt.TealOp(None, pt.Op.txnas, "Applications"),
        ]
    )
    actual, _ = expr.__teal__(options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    with pt.TealComponent.Context.ignoreExprEquality():
        assert actual == expected


def test_Application_params():
    value = abi.Application()

    params = value.params()

    assert type(params) is pt.AppParamObject

    expected = value.application_id()
    actual = params._app

    with pt.TealComponent.Context.ignoreExprEquality():
        assert actual.__teal__(options) == expected.__teal__(options)



================================================
FILE: pyteal/ast/abi/string.py
================================================
from typing import Union, Sequence, cast
from collections.abc import Sequence as CollectionSequence

from algosdk.abi import ABIType

from pyteal.ast.abi.uint import Byte
from pyteal.ast.abi.type import ComputedValue, BaseType
from pyteal.ast.abi.array_dynamic import DynamicArray, DynamicArrayTypeSpec
from pyteal.ast.abi.uint import ByteTypeSpec, Uint16TypeSpec

from pyteal.ast.abstractvar import AbstractVar
from pyteal.ast.int import Int
from pyteal.ast.expr import Expr
from pyteal.ast.bytes import Bytes
from pyteal.ast.seq import Seq
from pyteal.ast.unaryexpr import Itob, Len
from pyteal.ast.substring import Suffix
from pyteal.ast.naryexpr import Concat

from pyteal.errors import TealInputError


def _encoded_byte_string(s: bytes | bytearray) -> Expr:
    prefix = ABIType.from_string("uint16").encode(len(s))
    return Bytes(prefix + s)


def _store_encoded_expr_byte_string_into_var(
    value: Expr, location: AbstractVar
) -> Expr:
    return Seq(
        location.store(value),
        location.store(
            Concat(Suffix(Itob(Len(location.load())), Int(6)), location.load())
        ),
    )


class StringTypeSpec(DynamicArrayTypeSpec):
    def __init__(self) -> None:
        super().__init__(ByteTypeSpec())

    def new_instance(self) -> "String":
        return String()

    def annotation_type(self) -> "type[String]":
        return String

    def __str__(self) -> str:
        return "string"

    def __eq__(self, other: object) -> bool:
        return isinstance(other, StringTypeSpec)


StringTypeSpec.__module__ = "pyteal.abi"


class String(DynamicArray[Byte]):
    def __init__(self) -> None:
        super().__init__(StringTypeSpec())

    def type_spec(self) -> StringTypeSpec:
        return StringTypeSpec()

    def get(self) -> Expr:
        """Return the value held by this String as a PyTeal expression.

        The expression will have the type TealType.bytes.
        """
        return Suffix(
            self._stored_value.load(), Int(Uint16TypeSpec().byte_length_static())
        )

    def set(
        self,
        value: Union[
            str,
            bytes,
            Expr,
            Sequence[Byte],
            DynamicArray[Byte],
            ComputedValue[DynamicArray[Byte]],
            "String",
            ComputedValue["String"],
        ],
    ) -> Expr:
        """Set the value of this String to the input value.

        The behavior of this method depends on the input argument type:

            * :code:`str`: set the value to the Python string.
            * :code:`bytes`: set the value to the Python byte string.
            * :code:`Expr`: set the value to the result of a PyTeal expression, which must evaluate to a TealType.bytes.
            * :code:`Sequence[Byte]`: set the bytes of this String to those contained in this Python sequence (e.g. a list or tuple).
            * :code:`DynamicArray[Byte]`: copy the bytes from a DynamicArray.
            * :code:`ComputedValue[DynamicArray[Byte]]`: copy the bytes from a DynamicArray produced by a ComputedValue.
            * :code:`String`: copy the value from another String.
            * :code:`ComputedValue[String]`: copy the value from a String produced by a ComputedValue.

        Args:
            value: The new value this String should take. This must follow the above constraints.

        Returns:
            An expression which stores the given value into this String.
        """

        match value:
            case ComputedValue():
                return self._set_with_computed_type(value)
            case BaseType():
                if value.type_spec() == StringTypeSpec() or (
                    value.type_spec() == DynamicArrayTypeSpec(ByteTypeSpec())
                ):
                    return self._stored_value.store(value._stored_value.load())

                raise TealInputError(
                    f"Got {value} with type spec {value.type_spec()}, expected {StringTypeSpec}"
                )
            case bytes() | bytearray():
                return self._stored_value.store(_encoded_byte_string(value))
            case str():
                return self._stored_value.store(_encoded_byte_string(value.encode()))
            case Expr():
                return _store_encoded_expr_byte_string_into_var(
                    value, self._stored_value
                )
            case CollectionSequence():
                return super().set(cast(Sequence[Byte], value))

        raise TealInputError(
            f"Got {type(value)}, expected DynamicArray, ComputedValue, String, str, bytes, Expr"
        )


String.__module__ = "pyteal.abi"



================================================
FILE: pyteal/ast/abi/string_test.py
================================================
import pytest
from typing import cast

import pyteal as pt
from pyteal import abi
from pyteal.ast.abi.util import substring_for_decoding
from pyteal.ast.abi.type_test import ContainerType

options = pt.CompileOptions(version=5)


def test_StringTypeSpec_str():
    assert str(abi.StringTypeSpec()) == "string"


def test_StringTypeSpec_is_dynamic():
    assert (abi.StringTypeSpec()).is_dynamic()


def test_StringTypeSpec_new_instance():
    assert isinstance(abi.StringTypeSpec().new_instance(), abi.String)


def test_StringTypeSpec_eq():
    assert abi.StringTypeSpec() == abi.StringTypeSpec()

    for otherType in (
        abi.ByteTypeSpec(),
        abi.StaticArrayTypeSpec(abi.ByteTypeSpec(), 1),
        abi.DynamicArrayTypeSpec(abi.Uint8TypeSpec()),
        abi.DynamicArrayTypeSpec(abi.ByteTypeSpec()),
    ):
        assert abi.StringTypeSpec() != otherType


def test_String_encode():
    value = abi.String()
    expr = value.encode()
    assert expr.type_of() == pt.TealType.bytes
    assert expr.has_return() is False

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(
                expr,
                pt.Op.load,
                cast(pt.ScratchVar, value._stored_value).slot,
            ),
        ]
    )
    actual, _ = expr.__teal__(options)
    assert actual == expected


def test_DynamicArray_decode():
    encoded = pt.Bytes("encoded")
    stringType = abi.StringTypeSpec()
    for start_index in (None, pt.Int(1)):
        for end_index in (None, pt.Int(2)):
            for length in (None, pt.Int(3)):
                value = stringType.new_instance()

                if end_index is not None and length is not None:
                    with pytest.raises(pt.TealInputError):
                        value.decode(
                            encoded,
                            start_index=start_index,
                            end_index=end_index,
                            length=length,
                        )
                    continue

                expr = value.decode(
                    encoded, start_index=start_index, end_index=end_index, length=length
                )
                assert expr.type_of() == pt.TealType.none
                assert expr.has_return() is False

                expectedExpr = value._stored_value.store(
                    substring_for_decoding(
                        encoded,
                        start_index=start_index,
                        end_index=end_index,
                        length=length,
                    )
                )
                expected, _ = expectedExpr.__teal__(options)
                expected.addIncoming()
                expected = pt.TealBlock.NormalizeBlocks(expected)

                actual, _ = expr.__teal__(options)
                actual.addIncoming()
                actual = pt.TealBlock.NormalizeBlocks(actual)

                with pt.TealComponent.Context.ignoreExprEquality():
                    assert actual == expected


def test_String_get():
    value = abi.String()
    expr = value.get()
    assert expr.type_of() == pt.TealType.bytes
    assert expr.has_return() is False

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(
                expr,
                pt.Op.load,
                cast(pt.ScratchVar, value._stored_value).slot,
            ),
            pt.TealOp(None, pt.Op.extract, 2, 0),
        ]
    )
    actual, _ = expr.__teal__(options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    with pt.TealComponent.Context.ignoreExprEquality():
        assert actual == expected


STATIC_SET_TESTCASES: list[tuple[str | bytes | bytearray, bytes]] = [
    ("stringy", b"\x00\x07stringy"),
    ("😀", b"\x00\x04\xf0\x9f\x98\x80"),
    ("0xDEADBEEF", b"\x00\x0a0xDEADBEEF"),
    (bytes(32), b"\x00\x20" + bytes(32)),
    (b"alphabet_soup", b"\x00\x0dalphabet_soup"),
    (bytearray(b"another one"), b"\x00\x0banother one"),
]


@pytest.mark.parametrize("value_to_set, value_encoded", STATIC_SET_TESTCASES)
def test_String_set_static(value_to_set, value_encoded):
    value = abi.String()
    expr = value.set(value_to_set)
    assert expr.type_of() == pt.TealType.none
    assert not expr.has_return()

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(None, pt.Op.byte, "0x" + value_encoded.hex()),
            pt.TealOp(
                None,
                pt.Op.store,
                cast(pt.ScratchVar, value._stored_value).slot,
            ),
        ]
    )

    actual, _ = expr.__teal__(options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    with pt.TealComponent.Context.ignoreExprEquality():
        assert actual == expected


def test_String_set_static_invalid():
    with pytest.raises(pt.TealInputError):
        abi.String().set(42)


def test_String_set_expr():
    for value_to_set in (pt.Bytes("hi"), pt.Bytes("base16", "0xdeadbeef")):
        value = abi.String()
        expr = value.set(value_to_set)
        assert expr.type_of() == pt.TealType.none
        assert not expr.has_return()

        value_start, value_end = value_to_set.__teal__(options)
        expected_body = pt.TealSimpleBlock(
            [
                pt.TealOp(
                    None,
                    pt.Op.store,
                    cast(pt.ScratchVar, value._stored_value).slot,
                ),
                pt.TealOp(
                    None,
                    pt.Op.load,
                    cast(pt.ScratchVar, value._stored_value).slot,
                ),
                pt.TealOp(None, pt.Op.len),
                pt.TealOp(None, pt.Op.itob),
                pt.TealOp(None, pt.Op.extract, 6, 0),
                pt.TealOp(
                    None,
                    pt.Op.load,
                    cast(pt.ScratchVar, value._stored_value).slot,
                ),
                pt.TealOp(None, pt.Op.concat),
                pt.TealOp(
                    None,
                    pt.Op.store,
                    cast(pt.ScratchVar, value._stored_value).slot,
                ),
            ]
        )
        value_end.setNextBlock(expected_body)
        expected = value_start
        expected.addIncoming()
        expected = pt.TealBlock.NormalizeBlocks(expected)

        actual, _ = expr.__teal__(options)
        actual.addIncoming()
        actual = pt.TealBlock.NormalizeBlocks(actual)

        with pt.TealComponent.Context.ignoreExprEquality():
            assert actual == expected


def test_String_set_copy():
    value = abi.String()
    other = abi.String()
    expr = value.set(other)
    assert expr.type_of() == pt.TealType.none
    assert not expr.has_return()

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(
                None,
                pt.Op.load,
                cast(pt.ScratchVar, other._stored_value).slot,
            ),
            pt.TealOp(
                None,
                pt.Op.store,
                cast(pt.ScratchVar, value._stored_value).slot,
            ),
        ]
    )

    actual, _ = expr.__teal__(options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    with pt.TealComponent.Context.ignoreExprEquality():
        assert actual == expected

    with pytest.raises(pt.TealInputError):
        value.set(abi.Address())


def test_String_set_computed():
    bv = pt.Bytes("base16", "0x0004DEADBEEF")
    computed_value = ContainerType(abi.StringTypeSpec(), bv)

    value = abi.String()
    expr = value.set(computed_value)
    assert expr.type_of() == pt.TealType.none
    assert not expr.has_return()

    _, byte_ops = bv.__teal__(options)
    expected = pt.TealSimpleBlock(
        [
            byte_ops.ops[0],
            pt.TealOp(
                None,
                pt.Op.store,
                cast(pt.ScratchVar, value._stored_value).slot,
            ),
        ]
    )

    actual, _ = expr.__teal__(options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    with pt.TealComponent.Context.ignoreExprEquality():
        assert actual == expected

    with pytest.raises(pt.TealInputError):
        value.set(ContainerType(abi.ByteTypeSpec(), pt.Int(0x01)))



================================================
FILE: pyteal/ast/abi/transaction.py
================================================
from enum import Enum
from typing import Union, cast, Final
from pyteal.ast.abi.type import BaseType, ComputedValue, TypeSpec
from pyteal.ast.expr import Expr
from pyteal.ast.int import Int
from pyteal.ast.txn import TxnObject, TxnType
from pyteal.ast.gtxn import Gtxn
from pyteal.types import TealType
from pyteal.errors import TealInputError, TealInternalError


class TransactionType(Enum):
    Any = "txn"
    Payment = "pay"
    KeyRegistration = "keyreg"
    AssetConfig = "acfg"
    AssetTransfer = "axfer"
    AssetFreeze = "afrz"
    ApplicationCall = "appl"


TransactionType.__module__ = "pyteal.abi"


class TransactionTypeSpec(TypeSpec):
    def __init__(self) -> None:
        super().__init__()

    def new_instance(self) -> "Transaction":
        return Transaction()

    def annotation_type(self) -> "type[Transaction]":
        return Transaction

    def is_dynamic(self) -> bool:
        return False

    def byte_length_static(self) -> int:
        raise TealInputError("Transaction Types don't have a static size")

    def storage_type(self) -> TealType:
        return TealType.uint64

    def txn_type_enum(self) -> Expr:
        """Get the integer transaction type value this TransactionTypeSpec represents.

        See :any:`TxnType` for the complete list.

        If this is a generic TransactionTypeSpec, i.e. type :code:`txn`, this method will raise an error, since this type does not represent a single transaction type.
        """
        raise TealInternalError(
            "abi.TransactionTypeSpec does not represent a specific transaction type"
        )

    def __eq__(self, other: object) -> bool:
        return type(self) is type(other)

    def __str__(self) -> str:
        return TransactionType.Any.value


TransactionTypeSpec.__module__ = "pyteal.abi"


class Transaction(BaseType):
    def __init__(self, spec: TransactionTypeSpec | None = None) -> None:
        if spec is None:
            super().__init__(TransactionTypeSpec())
        else:
            super().__init__(spec)

    def type_spec(self) -> TransactionTypeSpec:
        return cast(TransactionTypeSpec, super().type_spec())

    def get(self) -> TxnObject:
        return Gtxn[self.index()]

    def _set_index(
        self, value: Union[int, Expr, "Transaction", ComputedValue["Transaction"]]
    ) -> Expr:
        match value:
            case ComputedValue():
                return self._set_with_computed_type(value)
            case BaseType():
                return self._stored_value.store(self._stored_value.load())
            case int():
                return self._stored_value.store(Int(value))
            case Expr():
                return self._stored_value.store(value)
            case _:
                raise TealInputError(f"Cant store a {type(value)} in a Transaction")

    def index(self) -> Expr:
        return self._stored_value.load()

    def decode(
        self,
        encoded: Expr,
        *,
        start_index: Expr | None = None,
        end_index: Expr | None = None,
        length: Expr | None = None,
    ) -> Expr:
        raise TealInputError("A Transaction cannot be decoded")

    def encode(self) -> Expr:
        raise TealInputError("A Transaction cannot be encoded")


Transaction.__module__ = "pyteal.abi"


class PaymentTransactionTypeSpec(TransactionTypeSpec):
    def new_instance(self) -> "PaymentTransaction":
        return PaymentTransaction()

    def annotation_type(self) -> "type[PaymentTransaction]":
        return PaymentTransaction

    def txn_type_enum(self) -> Expr:
        return TxnType.Payment

    def __str__(self) -> str:
        return TransactionType.Payment.value


PaymentTransactionTypeSpec.__module__ = "pyteal.abi"


class PaymentTransaction(Transaction):
    def __init__(self):
        super().__init__(PaymentTransactionTypeSpec())


PaymentTransaction.__module__ = "pyteal.abi"


class KeyRegisterTransactionTypeSpec(TransactionTypeSpec):
    def new_instance(self) -> "KeyRegisterTransaction":
        return KeyRegisterTransaction()

    def annotation_type(self) -> "type[KeyRegisterTransaction]":
        return KeyRegisterTransaction

    def txn_type_enum(self) -> Expr:
        return TxnType.KeyRegistration

    def __str__(self) -> str:
        return TransactionType.KeyRegistration.value


KeyRegisterTransactionTypeSpec.__module__ = "pyteal.abi"


class KeyRegisterTransaction(Transaction):
    def __init__(self):
        super().__init__(KeyRegisterTransactionTypeSpec())


KeyRegisterTransaction.__module__ = "pyteal.abi"


class AssetConfigTransactionTypeSpec(TransactionTypeSpec):
    def new_instance(self) -> "AssetConfigTransaction":
        return AssetConfigTransaction()

    def annotation_type(self) -> "type[AssetConfigTransaction]":
        return AssetConfigTransaction

    def txn_type_enum(self) -> Expr:
        return TxnType.AssetConfig

    def __str__(self) -> str:
        return TransactionType.AssetConfig.value


AssetConfigTransactionTypeSpec.__module__ = "pyteal.abi"


class AssetConfigTransaction(Transaction):
    def __init__(self):
        super().__init__(AssetConfigTransactionTypeSpec())


AssetConfigTransaction.__module__ = "pyteal.abi"


class AssetFreezeTransactionTypeSpec(TransactionTypeSpec):
    def new_instance(self) -> "AssetFreezeTransaction":
        return AssetFreezeTransaction()

    def annotation_type(self) -> "type[AssetFreezeTransaction]":
        return AssetFreezeTransaction

    def txn_type_enum(self) -> Expr:
        return TxnType.AssetFreeze

    def __str__(self) -> str:
        return TransactionType.AssetFreeze.value


AssetFreezeTransactionTypeSpec.__module__ = "pyteal.abi"


class AssetFreezeTransaction(Transaction):
    def __init__(self):
        super().__init__(AssetFreezeTransactionTypeSpec())


AssetFreezeTransaction.__module__ = "pyteal.abi"


class AssetTransferTransactionTypeSpec(TransactionTypeSpec):
    def new_instance(self) -> "AssetTransferTransaction":
        return AssetTransferTransaction()

    def annotation_type(self) -> "type[AssetTransferTransaction]":
        return AssetTransferTransaction

    def txn_type_enum(self) -> Expr:
        return TxnType.AssetTransfer

    def __str__(self) -> str:
        return TransactionType.AssetTransfer.value


AssetTransferTransactionTypeSpec.__module__ = "pyteal.abi"


class AssetTransferTransaction(Transaction):
    def __init__(self):
        super().__init__(AssetTransferTransactionTypeSpec())


AssetTransferTransaction.__module__ = "pyteal.abi"


class ApplicationCallTransactionTypeSpec(TransactionTypeSpec):
    def new_instance(self) -> "ApplicationCallTransaction":
        return ApplicationCallTransaction()

    def annotation_type(self) -> "type[ApplicationCallTransaction]":
        return ApplicationCallTransaction

    def txn_type_enum(self) -> Expr:
        return TxnType.ApplicationCall

    def __str__(self) -> str:
        return TransactionType.ApplicationCall.value


ApplicationCallTransactionTypeSpec.__module__ = "pyteal.abi"


class ApplicationCallTransaction(Transaction):
    def __init__(self):
        super().__init__(ApplicationCallTransactionTypeSpec())


ApplicationCallTransaction.__module__ = "pyteal.abi"

TransactionTypeSpecs: Final[list[TypeSpec]] = [
    TransactionTypeSpec(),
    PaymentTransactionTypeSpec(),
    KeyRegisterTransactionTypeSpec(),
    AssetConfigTransactionTypeSpec(),
    AssetFreezeTransactionTypeSpec(),
    AssetTransferTransactionTypeSpec(),
    ApplicationCallTransactionTypeSpec(),
]



================================================
FILE: pyteal/ast/abi/transaction_test.py
================================================
from dataclasses import dataclass
from typing import List, cast
import pyteal as pt
from pyteal import abi
import pytest

from pyteal.errors import TealInputError

options = pt.CompileOptions(version=5)


@dataclass
class TransactionTypeTest:
    ts: abi.TransactionTypeSpec
    t: abi.Transaction
    s: str
    txn_type_enum: pt.Expr | None


TransactionValues: List[TransactionTypeTest] = [
    TransactionTypeTest(abi.TransactionTypeSpec(), abi.Transaction(), "txn", None),
    TransactionTypeTest(
        abi.KeyRegisterTransactionTypeSpec(),
        abi.KeyRegisterTransaction(),
        "keyreg",
        pt.TxnType.KeyRegistration,
    ),
    TransactionTypeTest(
        abi.PaymentTransactionTypeSpec(),
        abi.PaymentTransaction(),
        "pay",
        pt.TxnType.Payment,
    ),
    TransactionTypeTest(
        abi.AssetConfigTransactionTypeSpec(),
        abi.AssetConfigTransaction(),
        "acfg",
        pt.TxnType.AssetConfig,
    ),
    TransactionTypeTest(
        abi.AssetFreezeTransactionTypeSpec(),
        abi.AssetFreezeTransaction(),
        "afrz",
        pt.TxnType.AssetFreeze,
    ),
    TransactionTypeTest(
        abi.AssetTransferTransactionTypeSpec(),
        abi.AssetTransferTransaction(),
        "axfer",
        pt.TxnType.AssetTransfer,
    ),
    TransactionTypeTest(
        abi.ApplicationCallTransactionTypeSpec(),
        abi.ApplicationCallTransaction(),
        "appl",
        pt.TxnType.ApplicationCall,
    ),
]


def test_Transaction_str():
    for tv in TransactionValues:
        assert str(tv.ts) == tv.s


def test_TransactionTypeSpec_is_dynamic():
    for tv in TransactionValues:
        assert not (tv.ts).is_dynamic()


def test_TransactionTypeSpec_new_instance():
    for tv in TransactionValues:
        assert isinstance(tv.ts.new_instance(), abi.Transaction)


def test_TransactionTypeSpec_txn_type_enum():
    for tv in TransactionValues:
        if tv.txn_type_enum is None:
            with pytest.raises(
                pt.TealInternalError,
                match=r"abi.TransactionTypeSpec does not represent a specific transaction type$",
            ):
                tv.ts.txn_type_enum()
        else:
            assert tv.ts.txn_type_enum() is tv.txn_type_enum


def test_TransactionTypeSpec_eq():
    for tv in TransactionValues:
        assert tv.ts == tv.ts

        for otherType in (
            abi.ByteTypeSpec(),
            abi.Uint8TypeSpec(),
            abi.AddressTypeSpec(),
        ):
            assert tv.ts != otherType


def test_Transaction_typespec():
    for tv in TransactionValues:
        assert tv.t.type_spec() == tv.ts


def test_Transaction_decode():
    for tv in TransactionValues:
        with pytest.raises(TealInputError):
            tv.t.decode("")


def test_Transaction_encode():
    for tv in TransactionValues:
        with pytest.raises(TealInputError):
            tv.t.encode()


def test_Transaction_get():
    for tv in TransactionValues:
        expr = tv.t.get()
        assert isinstance(expr, pt.TxnObject)


def test_Transaction__set_index():
    for tv in TransactionValues:
        val_to_set = 2
        expr = tv.t._set_index(val_to_set)

        assert expr.type_of() == pt.TealType.none
        assert expr.has_return() is False

        expected = pt.TealSimpleBlock(
            [
                pt.TealOp(expr, pt.Op.int, val_to_set),
                pt.TealOp(
                    None,
                    pt.Op.store,
                    cast(pt.ScratchVar, tv.t._stored_value).slot,
                ),
            ]
        )
        actual, _ = expr.__teal__(options)
        actual.addIncoming()
        actual = pt.TealBlock.NormalizeBlocks(actual)

        with pt.TealComponent.Context.ignoreExprEquality():
            assert actual == expected



================================================
FILE: pyteal/ast/abi/tuple.py
================================================
from inspect import get_annotations
from typing import (
    List,
    Sequence,
    Dict,
    Generic,
    TypeVar,
    cast,
    overload,
    Any,
    TypeAlias,
    get_args,
    get_origin,
)
from collections import OrderedDict

from pyteal.types import TealType
from pyteal.errors import TealInputError, TealInternalError
from pyteal.ast.expr import Expr
from pyteal.ast.seq import Seq
from pyteal.ast.int import Int
from pyteal.ast.bytes import Bytes
from pyteal.ast.unaryexpr import Len
from pyteal.ast.binaryexpr import ExtractUint16
from pyteal.ast.naryexpr import Concat
from pyteal.ast.abstractvar import alloc_abstract_var

from pyteal.ast.abi.type import TypeSpec, BaseType, ComputedValue
from pyteal.ast.abi.bool import (
    Bool,
    BoolTypeSpec,
    _consecutive_bool_instance_num,
    _consecutive_bool_type_spec_num,
    _bool_sequence_length,
    _encode_bool_sequence,
    _bool_aware_static_byte_length,
)
from pyteal.ast.abi.uint import NUM_BITS_IN_BYTE, Uint16
from pyteal.ast.abi.util import substring_for_decoding, type_spec_from_annotation


def _encode_tuple(values: Sequence[BaseType]) -> Expr:
    heads: List[Expr] = []
    head_length_static: int = 0

    dynamicValueIndexToHeadIndex: Dict[int, int] = dict()
    ignoreNext = 0
    for i, elem in enumerate(values):
        if ignoreNext > 0:
            ignoreNext -= 1
            continue

        elemType = elem.type_spec()

        if elemType == BoolTypeSpec():
            numBools = _consecutive_bool_instance_num(values, i)
            ignoreNext = numBools - 1
            head_length_static += _bool_sequence_length(numBools)
            heads.append(
                _encode_bool_sequence(cast(Sequence[Bool], values[i : i + numBools]))
            )
            continue

        if elemType.is_dynamic():
            head_length_static += 2
            dynamicValueIndexToHeadIndex[i] = len(heads)
            heads.append(Seq())  # a placeholder
            continue

        head_length_static += elemType.byte_length_static()
        heads.append(elem.encode())

    tail_offset = Uint16()
    tail_offset_accumulator = Uint16()
    tail_holder = alloc_abstract_var(TealType.bytes)
    encoded_tail = alloc_abstract_var(TealType.bytes)

    firstDynamicTail = True
    for i, elem in enumerate(values):
        if elem.type_spec().is_dynamic():
            if firstDynamicTail:
                firstDynamicTail = False
                updateVars = Seq(
                    tail_holder.store(encoded_tail.load()),
                    tail_offset.set(head_length_static),
                )
            else:
                updateVars = Seq(
                    tail_holder.store(Concat(tail_holder.load(), encoded_tail.load())),
                    tail_offset.set(tail_offset_accumulator),
                )

            notLastDynamicValue = any(
                [nextValue.type_spec().is_dynamic() for nextValue in values[i + 1 :]]
            )
            if notLastDynamicValue:
                updateAccumulator = tail_offset_accumulator.set(
                    tail_offset.get() + Len(encoded_tail.load())
                )
            else:
                updateAccumulator = Seq()

            heads[dynamicValueIndexToHeadIndex[i]] = Seq(
                encoded_tail.store(elem.encode()),
                updateVars,
                updateAccumulator,
                tail_offset.encode(),
            )

    toConcat = heads
    if not firstDynamicTail:
        toConcat.append(tail_holder.load())

    if len(toConcat) == 0:
        return Bytes("")

    return Concat(*toConcat)


def _index_tuple(
    value_types: Sequence[TypeSpec], encoded: Expr, index: int, output: BaseType
) -> Expr:
    if not (0 <= index < len(value_types)):
        raise ValueError("Index outside of range")

    offset = 0
    ignoreNext = 0
    lastBoolStart = 0
    lastBoolLength = 0
    for i, typeBefore in enumerate(value_types[:index]):
        if ignoreNext > 0:
            ignoreNext -= 1
            continue

        if typeBefore == BoolTypeSpec():
            lastBoolStart = offset
            lastBoolLength = _consecutive_bool_type_spec_num(value_types, i)
            offset += _bool_sequence_length(lastBoolLength)
            ignoreNext = lastBoolLength - 1
            continue

        if typeBefore.is_dynamic():
            offset += 2
            continue

        offset += typeBefore.byte_length_static()

    valueType = value_types[index]
    if output.type_spec() != valueType:
        raise TypeError("Output type does not match value type")

    if type(output) is Bool:
        if ignoreNext > 0:
            # value is in the middle of a bool sequence
            bitOffsetInBoolSeq = lastBoolLength - ignoreNext
            bitOffsetInEncoded = lastBoolStart * NUM_BITS_IN_BYTE + bitOffsetInBoolSeq
        else:
            # value is the beginning of a bool sequence (or a single bool)
            bitOffsetInEncoded = offset * NUM_BITS_IN_BYTE
        return output.decode_bit(encoded, Int(bitOffsetInEncoded))

    if valueType.is_dynamic():
        hasNextDynamicValue = False
        nextDynamicValueOffset = offset + 2
        ignoreNext = 0
        for i, typeAfter in enumerate(value_types[index + 1 :], start=index + 1):
            if ignoreNext > 0:
                ignoreNext -= 1
                continue

            if type(typeAfter) is BoolTypeSpec:
                boolLength = _consecutive_bool_type_spec_num(value_types, i)
                nextDynamicValueOffset += _bool_sequence_length(boolLength)
                ignoreNext = boolLength - 1
                continue

            if typeAfter.is_dynamic():
                hasNextDynamicValue = True
                break

            nextDynamicValueOffset += typeAfter.byte_length_static()

        start_index = ExtractUint16(encoded, Int(offset))
        if not hasNextDynamicValue:
            # This is the final dynamic value, so decode the substring from start_index to the end of
            # encoded
            return output.decode(encoded, start_index=start_index)

        # There is a dynamic value after this one, and end_index is where its tail starts, so decode
        # the substring from start_index to end_index
        end_index = ExtractUint16(encoded, Int(nextDynamicValueOffset))
        return output.decode(encoded, start_index=start_index, end_index=end_index)

    start_index = Int(offset)
    length = Int(valueType.byte_length_static())

    if index + 1 == len(value_types):
        if offset == 0:
            # This is the first and only value in the tuple, so decode all of encoded
            return output.decode(encoded)
        if all(not x.is_dynamic() for x in value_types):
            # This is the last element in tuple with all elements being static typed
            return output.decode(encoded, start_index=start_index)

    if offset == 0:
        # This is the first value in the tuple, so decode the substring from 0 with length length
        return output.decode(encoded, length=length)

    # This is not the first or last value, so decode the substring from start_index with length length
    return output.decode(encoded, start_index=start_index, length=length)


class TupleTypeSpec(TypeSpec):
    def __init__(self, *value_type_specs: TypeSpec) -> None:
        super().__init__()
        self.value_specs = list(value_type_specs)

    def value_type_specs(self) -> List[TypeSpec]:
        """Get the TypeSpecs for the values of this tuple."""
        return self.value_specs

    def length_static(self) -> int:
        """Get the number of values this tuple holds."""
        return len(self.value_specs)

    def new_instance(self) -> "Tuple":
        match self.length_static():
            case 0:
                return Tuple0()
            case 1:
                return Tuple1(self)
            case 2:
                return Tuple2(self)
            case 3:
                return Tuple3(self)
            case 4:
                return Tuple4(self)
            case 5:
                return Tuple5(self)
            case _:
                return Tuple(self)

    def annotation_type(self) -> "type[Tuple]":
        vtses = self.value_type_specs()

        def annotater():
            return [x.annotation_type() for x in vtses]

        match len(vtses):
            case 0:
                return Tuple0
            case 1:
                v0 = annotater()[0]
                return Tuple1[v0]  # type: ignore[valid-type]
            case 2:
                v0, v1 = annotater()
                return Tuple2[v0, v1]  # type: ignore[valid-type]
            case 3:
                v0, v1, v2 = annotater()
                return Tuple3[v0, v1, v2]  # type: ignore[valid-type]
            case 4:
                v0, v1, v2, v3 = annotater()
                return Tuple4[v0, v1, v2, v3]  # type: ignore[valid-type]
            case 5:
                v0, v1, v2, v3, v4 = annotater()
                return Tuple5[v0, v1, v2, v3, v4]  # type: ignore[valid-type]

        raise TypeError(f"Cannot annotate tuple of length {len(vtses)}")

    def is_dynamic(self) -> bool:
        return any(type_spec.is_dynamic() for type_spec in self.value_type_specs())

    def byte_length_static(self) -> int:
        if self.is_dynamic():
            raise ValueError("Type is dynamic")
        return _bool_aware_static_byte_length(self.value_type_specs())

    def storage_type(self) -> TealType:
        return TealType.bytes

    def __eq__(self, other: object) -> bool:
        return (
            isinstance(other, TupleTypeSpec)
            and self.value_type_specs() == other.value_type_specs()
        )

    def __str__(self) -> str:
        return "({})".format(",".join(map(str, self.value_type_specs())))


TupleTypeSpec.__module__ = "pyteal.abi"


class Tuple(BaseType):
    def __init__(self, tuple_type_spec: TupleTypeSpec) -> None:
        super().__init__(tuple_type_spec)

    def type_spec(self) -> TupleTypeSpec:
        return cast(TupleTypeSpec, super().type_spec())

    def decode(
        self,
        encoded: Expr,
        *,
        start_index: Expr | None = None,
        end_index: Expr | None = None,
        length: Expr | None = None,
    ) -> Expr:
        extracted = substring_for_decoding(
            encoded, start_index=start_index, end_index=end_index, length=length
        )
        return self._stored_value.store(extracted)

    @overload
    def set(self, *values: BaseType) -> Expr:
        pass

    @overload
    def set(self, values: ComputedValue["Tuple"]) -> Expr:
        # TODO: should support values as a Tuple as well
        pass

    def set(self, *values):
        """
        set(*values: BaseType) -> pyteal.Expr
        set(values: ComputedValue[Tuple]) -> pyteal.Expr

        Set the elements of this Tuple to the input values.

        The behavior of this method depends on the input argument type:

            * Variable number of :code:`BaseType` arguments: set the elements of this Tuple to the arguments to this method. A compiler error will occur if any argument does not match this Tuple's element type at the same index, or if the total argument count does not equal this Tuple's length.
            * :code:`ComputedValue[Tuple]`: copy the elements from a Tuple produced by a ComputedValue. The element types and length produced by the ComputedValue must exactly match this Tuple's element types and length, otherwise an error will occur.

        Args:
            values: The new elements this Tuple should have. This must follow the above constraints.

        Returns:
            An expression which stores the given value into this Tuple.
        """
        if len(values) == 1 and isinstance(values[0], ComputedValue):
            return self._set_with_computed_type(values[0])

        myTypes = self.type_spec().value_type_specs()
        if len(myTypes) != len(values):
            raise TealInputError(
                f"Incorrect length for values. Expected {len(myTypes)}, got {len(values)}"
            )
        for index, (value, myType) in enumerate(zip(values, myTypes)):
            if not isinstance(value, BaseType):
                raise TealInputError(f"Expected BaseType, got {value}")
            if myType != value.type_spec():
                raise TealInputError(
                    f"Input values do not match type at {index=}: {value.type_spec()} != {myType}"
                )
        return self._stored_value.store(_encode_tuple(values))

    def encode(self) -> Expr:
        return self._stored_value.load()

    def length(self) -> Expr:
        """Get the number of values this tuple holds as an Expr."""
        return Int(self.type_spec().length_static())

    def __getitem__(self, index: int) -> "TupleElement[Any]":
        """Retrieve an element by its index in this Tuple.

        Indexes start at 0.

        Args:
            index: a Python integer containing the index to access. This function will raise an error
                if its value is negative or if the index is equal to or greater than the length of
                this Tuple.

        Returns:
            A TupleElement that corresponds to the element at the given index. This type is a
            ComputedValue. Due to Python type limitations, the parameterized type of the
            TupleElement is Any.
        """
        if not (0 <= index < self.type_spec().length_static()):
            raise TealInputError(f"Index out of bounds: {index}")
        return TupleElement(self, index)


Tuple.__module__ = "pyteal.abi"

T = TypeVar("T", bound=BaseType)


class TupleElement(ComputedValue[T]):
    """Represents the extraction of a specific element from a Tuple."""

    def __init__(self, tuple: Tuple, index: int) -> None:
        super().__init__()
        self.tuple = tuple
        self.index = index

    def produced_type_spec(self) -> TypeSpec:
        return self.tuple.type_spec().value_type_specs()[self.index]

    def store_into(self, output: T) -> Expr:
        return _index_tuple(
            self.tuple.type_spec().value_type_specs(),
            self.tuple.encode(),
            self.index,
            output,
        )


TupleElement.__module__ = "pyteal.abi"

# Until Python 3.11 is released with support for PEP 646 -- Variadic Generics, it's not possible for
# the Tuple class to take an arbitrary number of template parameters. As a workaround, we define the
# following classes for specifically sized Tuples. If needed, more classes can be added for larger
# sizes.


def _tuple_raise_arg_mismatch(expected: int, typespec: TupleTypeSpec):
    if len(typespec.value_specs) != expected:
        raise TealInputError(
            f"Expected TupleTypeSpec with {expected} elements, Got {len(typespec.value_specs)}"
        )


class Tuple0(Tuple):
    """A Tuple with 0 values."""

    def __init__(self) -> None:
        super().__init__(TupleTypeSpec())


Tuple0.__module__ = "pyteal.abi"

T1 = TypeVar("T1", bound=BaseType)


class Tuple1(Tuple, Generic[T1]):
    """A Tuple with 1 value."""

    def __init__(self, value_type_spec: TupleTypeSpec) -> None:
        _tuple_raise_arg_mismatch(1, value_type_spec)
        super().__init__(value_type_spec)


Tuple1.__module__ = "pyteal.abi"

T2 = TypeVar("T2", bound=BaseType)


class Tuple2(Tuple, Generic[T1, T2]):
    """A Tuple with 2 values."""

    def __init__(self, value_type_spec: TupleTypeSpec) -> None:
        _tuple_raise_arg_mismatch(2, value_type_spec)
        super().__init__(value_type_spec)


Tuple2.__module__ = "pyteal.abi"

T3 = TypeVar("T3", bound=BaseType)


class Tuple3(Tuple, Generic[T1, T2, T3]):
    """A Tuple with 3 values."""

    def __init__(
        self,
        value_type_spec: TupleTypeSpec,
    ) -> None:
        _tuple_raise_arg_mismatch(3, value_type_spec)
        super().__init__(value_type_spec)


Tuple3.__module__ = "pyteal.abi"

T4 = TypeVar("T4", bound=BaseType)


class Tuple4(Tuple, Generic[T1, T2, T3, T4]):
    """A Tuple with 4 values."""

    def __init__(
        self,
        value_type_spec: TupleTypeSpec,
    ) -> None:
        _tuple_raise_arg_mismatch(4, value_type_spec)
        super().__init__(value_type_spec)


Tuple4.__module__ = "pyteal.abi"

T5 = TypeVar("T5", bound=BaseType)


class Tuple5(Tuple, Generic[T1, T2, T3, T4, T5]):
    """A Tuple with 5 values."""

    def __init__(
        self,
        value_type_spec: TupleTypeSpec,
    ) -> None:
        _tuple_raise_arg_mismatch(5, value_type_spec)
        super().__init__(value_type_spec)


Tuple5.__module__ = "pyteal.abi"


Field: TypeAlias = TupleElement[T]


class NamedTupleTypeSpec(TupleTypeSpec):
    """A NamedTupleType inherits from TupleTypeSpec, allowing for more than 5 elements."""

    def __init__(
        self, instance_class: type["NamedTuple"], *value_type_specs: TypeSpec
    ) -> None:
        if instance_class == NamedTuple:
            raise TealInputError(
                "NamedTupleTypeSpec must be instanced with subclassed NamedTuple class."
            )

        self.instance_class: type["NamedTuple"] = instance_class
        super().__init__(*value_type_specs)

    def __eq__(self, other: object) -> bool:
        return (
            isinstance(other, NamedTupleTypeSpec)
            and self.instance_class == other.instance_class
            and self.value_type_specs() == other.value_type_specs()
        )

    def annotation_type(self) -> "type[NamedTuple]":
        return self.instance_class

    def new_instance(self) -> "NamedTuple":
        return self.instance_class()


NamedTupleTypeSpec.__module__ = "pyteal.abi"


class NamedTuple(Tuple):
    """A NamedTuple is a :any:`Tuple` that has named elements, inspired by Python's `typing.NamedTuple <https://docs.python.org/3/library/typing.html#typing.NamedTuple>`_.

    A new NamedTuple type can be created by subclassing this class and adding field annotations.
    Every field annotation must be an instantiable ABI type wrapped in the :code:`abi.Field` annotation.

    For example:

        .. code-block:: python

            from pyteal import *

            class User(abi.NamedTuple):
                address: abi.Field[abi.Address]
                balance: abi.Field[abi.Uint64]

            # User is equivalent to abi.Tuple2[abi.Address, abi.Uint64]

            my_user = User()

    .. automethod:: __init_subclass__
    .. automethod:: __getattr__
    """

    def __init_subclass__(cls) -> None:
        """This method ensures one only constructs directly from `NamedTuple`,
        rather than inheriting from `NamedTuple`'s inheritance.

        We want to prohibit the following examples:

            .. code-block:: python

                from pyteal import *

                class LegalInheritance(abi.NamedTuple):
                    a: abi.Field[abi.Uint64]

                # following are bad cases we guard against

                class IllegalInheritance0(LegalInheritance):
                    a: abi.Field[abi.Uint64]

                class IllegalInheritance1(LegalInheritance, abi.NamedTuple):
                    a: abi.Field[abi.Uint64]
        """
        is_named_tuple_in_bases = False

        for base_t in cls.__bases__:
            if base_t == NamedTuple:
                is_named_tuple_in_bases = True
            elif issubclass(base_t, NamedTuple):
                raise TealInternalError(
                    f"Cannot construct {cls} by inheriting {cls.__bases__}. "
                    f"Must be constructed by direct inheritance from NamedTuple"
                )

        if not is_named_tuple_in_bases:
            raise TealInternalError(
                "Unexpected: did not find NamedTuple in __bases__,"
                "did not find NamedTuple in __bases__ member's __bases__"
            )

        super().__init_subclass__()

    def __init__(self):
        if type(self) is NamedTuple:
            raise TealInputError("NamedTuple must be subclassed")

        anns = get_annotations(type(self))
        if not anns:
            raise TealInputError("Expected fields to be declared but found none")

        # NOTE: this `_ready` variable enables `__setattr__` during `__init__` execution,
        # while after `__init__`, we cannot use `__setattr__` to set fields in `NamedTuple`.
        # NOTE: If we declare variable `__ready`, then internally,
        # the variable name would be changed to `_NamedTuple__ready`, which is implicit.
        self.__ready = False
        self.__type_specs: OrderedDict[str, TypeSpec] = OrderedDict()
        self.__field_index: dict[str, int] = {}

        for index, (name, annotation) in enumerate(anns.items()):
            origin = get_origin(annotation)
            if origin is None:
                origin = annotation
            if origin is not get_origin(Field):
                raise TealInputError(
                    f'Type annotation for attribute "{name}" must be a Field. Got {origin}'
                )

            args = get_args(annotation)
            if len(args) != 1:
                raise TealInputError(
                    f'Type annotation for attribute "{name}" must have a single argument. Got {args}'
                )

            self.__type_specs[name] = type_spec_from_annotation(args[0])
            self.__field_index[name] = index

        super().__init__(
            NamedTupleTypeSpec(type(self), *list(self.__type_specs.values()))
        )

        self.__ready = True

    def __getattr__(self, field: str) -> TupleElement[Any]:
        """Retrieve an element by its field in this NamedTuple.

        For example:

        .. code-block:: python

            from pyteal import *

            class User(abi.NamedTuple):
                address: abi.Field[abi.Address]
                balance: abi.Field[abi.Uint64]

            @ABIReturnSubroutine
            def get_user_balance(user: User, *, output: abi.Uint64) -> Expr:
                return output.set(user.balance)

        Args:
            field: a Python string containing the field to access.
                This function will raise an KeyError if the field is not available in the defined NamedTuple.

        Returns:
            A TupleElement that corresponds to the element at the given field name, returning a ComputedType.
            Due to Python type limitations, the parameterized type of the TupleElement is Any.
        """
        return self.__getitem__(self.__field_index[field])

    def __setattr__(self, name: str, field: Any) -> None:
        # we allow `__setattr__` only when:
        # - we are in `__init__`: `not self.__ready`
        # - we are setting `_ready`: `name == "_NamedTuple__ready"`,
        #   it is internally changed from `__ready` to `_NamedTuple__ready`,
        #   see notes in `__init__`
        if name == "_NamedTuple__ready" or not self.__ready:
            super().__setattr__(name, field)
            return
        # NOTE this pass condition is for following scenario:
        # NamedTuple is an argument, and inside subroutine, subroutine set internal ABI value with FrameStorage
        # This used to violate `__setattr__` for not allowing any assignment to attributes
        # Now this case is lifted such that we can shift the storage scheme.
        if name == "_stored_value" and self.__ready:
            super().__setattr__(name, field)
            return
        raise TealInputError("cannot assign to NamedTuple attributes.")


NamedTuple.__module__ = "pyteal.abi"



================================================
FILE: pyteal/ast/abi/tuple_test.py
================================================
from typing import NamedTuple, List, Callable, Literal, cast
import pytest

import pyteal as pt
from pyteal import abi
from pyteal.ast.abi.tuple import _encode_tuple, _index_tuple, TupleElement
from pyteal.ast.abi.bool import _encode_bool_sequence
from pyteal.ast.abi.util import substring_for_decoding
from pyteal.ast.abi.type_test import ContainerType

options = pt.CompileOptions(version=5)


def test_encodeTuple():
    class EncodeTest(NamedTuple):
        types: List[abi.BaseType]
        expected: pt.Expr

    # variables used to construct the tests
    uint64_a = abi.Uint64()
    uint64_b = abi.Uint64()
    uint16_a = abi.Uint16()
    uint16_b = abi.Uint16()
    bool_a = abi.Bool()
    bool_b = abi.Bool()
    tuple_a = abi.Tuple(abi.TupleTypeSpec(abi.BoolTypeSpec(), abi.BoolTypeSpec()))
    dynamic_array_a = abi.DynamicArray(abi.DynamicArrayTypeSpec(abi.Uint64TypeSpec()))
    dynamic_array_b = abi.DynamicArray(abi.DynamicArrayTypeSpec(abi.Uint16TypeSpec()))
    dynamic_array_c = abi.DynamicArray(abi.DynamicArrayTypeSpec(abi.BoolTypeSpec()))
    tail_holder = pt.ScratchVar()
    encoded_tail = pt.ScratchVar()

    tests: List[EncodeTest] = [
        EncodeTest(types=[], expected=pt.Bytes("")),
        EncodeTest(types=[uint64_a], expected=uint64_a.encode()),
        EncodeTest(
            types=[uint64_a, uint64_b],
            expected=pt.Concat(uint64_a.encode(), uint64_b.encode()),
        ),
        EncodeTest(types=[bool_a], expected=bool_a.encode()),
        EncodeTest(
            types=[bool_a, bool_b], expected=_encode_bool_sequence([bool_a, bool_b])
        ),
        EncodeTest(
            types=[bool_a, bool_b, uint64_a],
            expected=pt.Concat(
                _encode_bool_sequence([bool_a, bool_b]), uint64_a.encode()
            ),
        ),
        EncodeTest(
            types=[uint64_a, bool_a, bool_b],
            expected=pt.Concat(
                uint64_a.encode(), _encode_bool_sequence([bool_a, bool_b])
            ),
        ),
        EncodeTest(
            types=[uint64_a, bool_a, bool_b, uint64_b],
            expected=pt.Concat(
                uint64_a.encode(),
                _encode_bool_sequence([bool_a, bool_b]),
                uint64_b.encode(),
            ),
        ),
        EncodeTest(
            types=[uint64_a, bool_a, uint64_b, bool_b],
            expected=pt.Concat(
                uint64_a.encode(), bool_a.encode(), uint64_b.encode(), bool_b.encode()
            ),
        ),
        EncodeTest(types=[tuple_a], expected=tuple_a.encode()),
        EncodeTest(
            types=[uint64_a, tuple_a, bool_a, bool_b],
            expected=pt.Concat(
                uint64_a.encode(),
                tuple_a.encode(),
                _encode_bool_sequence([bool_a, bool_b]),
            ),
        ),
        EncodeTest(
            types=[dynamic_array_a],
            expected=pt.Concat(
                pt.Seq(
                    encoded_tail.store(dynamic_array_a.encode()),
                    tail_holder.store(encoded_tail.load()),
                    uint16_a.set(2),
                    uint16_a.encode(),
                ),
                tail_holder.load(),
            ),
        ),
        EncodeTest(
            types=[uint64_a, dynamic_array_a],
            expected=pt.Concat(
                uint64_a.encode(),
                pt.Seq(
                    encoded_tail.store(dynamic_array_a.encode()),
                    tail_holder.store(encoded_tail.load()),
                    uint16_a.set(8 + 2),
                    uint16_a.encode(),
                ),
                tail_holder.load(),
            ),
        ),
        EncodeTest(
            types=[uint64_a, dynamic_array_a, uint64_b],
            expected=pt.Concat(
                uint64_a.encode(),
                pt.Seq(
                    encoded_tail.store(dynamic_array_a.encode()),
                    tail_holder.store(encoded_tail.load()),
                    uint16_a.set(8 + 2 + 8),
                    uint16_a.encode(),
                ),
                uint64_b.encode(),
                tail_holder.load(),
            ),
        ),
        EncodeTest(
            types=[uint64_a, dynamic_array_a, bool_a, bool_b],
            expected=pt.Concat(
                uint64_a.encode(),
                pt.Seq(
                    encoded_tail.store(dynamic_array_a.encode()),
                    tail_holder.store(encoded_tail.load()),
                    uint16_a.set(8 + 2 + 1),
                    uint16_a.encode(),
                ),
                _encode_bool_sequence([bool_a, bool_b]),
                tail_holder.load(),
            ),
        ),
        EncodeTest(
            types=[uint64_a, dynamic_array_a, uint64_b, dynamic_array_b],
            expected=pt.Concat(
                uint64_a.encode(),
                pt.Seq(
                    encoded_tail.store(dynamic_array_a.encode()),
                    tail_holder.store(encoded_tail.load()),
                    uint16_a.set(8 + 2 + 8 + 2),
                    uint16_b.set(uint16_a.get() + pt.Len(encoded_tail.load())),
                    uint16_a.encode(),
                ),
                uint64_b.encode(),
                pt.Seq(
                    encoded_tail.store(dynamic_array_b.encode()),
                    tail_holder.store(
                        pt.Concat(tail_holder.load(), encoded_tail.load())
                    ),
                    uint16_a.set(uint16_b),
                    uint16_a.encode(),
                ),
                tail_holder.load(),
            ),
        ),
        EncodeTest(
            types=[
                uint64_a,
                dynamic_array_a,
                uint64_b,
                dynamic_array_b,
                bool_a,
                bool_b,
                dynamic_array_c,
            ],
            expected=pt.Concat(
                uint64_a.encode(),
                pt.Seq(
                    encoded_tail.store(dynamic_array_a.encode()),
                    tail_holder.store(encoded_tail.load()),
                    uint16_a.set(8 + 2 + 8 + 2 + 1 + 2),
                    uint16_b.set(uint16_a.get() + pt.Len(encoded_tail.load())),
                    uint16_a.encode(),
                ),
                uint64_b.encode(),
                pt.Seq(
                    encoded_tail.store(dynamic_array_b.encode()),
                    tail_holder.store(
                        pt.Concat(tail_holder.load(), encoded_tail.load())
                    ),
                    uint16_a.set(uint16_b),
                    uint16_b.set(uint16_a.get() + pt.Len(encoded_tail.load())),
                    uint16_a.encode(),
                ),
                _encode_bool_sequence([bool_a, bool_b]),
                pt.Seq(
                    encoded_tail.store(dynamic_array_c.encode()),
                    tail_holder.store(
                        pt.Concat(tail_holder.load(), encoded_tail.load())
                    ),
                    uint16_a.set(uint16_b),
                    uint16_a.encode(),
                ),
                tail_holder.load(),
            ),
        ),
    ]

    for i, test in enumerate(tests):
        expr = _encode_tuple(test.types)
        assert expr.type_of() == pt.TealType.bytes
        assert not expr.has_return()

        expected, _ = test.expected.__teal__(options)
        expected.addIncoming()
        expected = pt.TealBlock.NormalizeBlocks(expected)

        actual, _ = expr.__teal__(options)
        actual.addIncoming()
        actual = pt.TealBlock.NormalizeBlocks(actual)

        if any(t.type_spec().is_dynamic() for t in test.types):
            with pt.TealComponent.Context.ignoreExprEquality():
                with pt.TealComponent.Context.ignoreScratchSlotEquality():
                    assert actual == expected, "Test at index {} failed".format(i)

            assert pt.TealBlock.MatchScratchSlotReferences(
                pt.TealBlock.GetReferencedScratchSlots(actual),
                pt.TealBlock.GetReferencedScratchSlots(expected),
            )
            continue

        with pt.TealComponent.Context.ignoreExprEquality():
            assert actual == expected, "Test at index {} failed".format(i)


def test_indexTuple():
    class IndexTest(NamedTuple):
        types: List[abi.TypeSpec]
        typeIndex: int
        expected: Callable[[abi.BaseType], pt.Expr]

    # variables used to construct the tests
    uint64_t = abi.Uint64TypeSpec()
    byte_t = abi.ByteTypeSpec()
    bool_t = abi.BoolTypeSpec()
    tuple_t = abi.TupleTypeSpec(abi.BoolTypeSpec(), abi.BoolTypeSpec())
    dynamic_array_t1 = abi.DynamicArrayTypeSpec(abi.Uint64TypeSpec())
    dynamic_array_t2 = abi.DynamicArrayTypeSpec(abi.Uint16TypeSpec())
    static_bytes_t = abi.StaticBytesTypeSpec(2)

    encoded = pt.Bytes("encoded")

    tests: List[IndexTest] = [
        IndexTest(
            types=[uint64_t],
            typeIndex=0,
            expected=lambda output: output.decode(encoded),
        ),
        IndexTest(
            types=[uint64_t, uint64_t],
            typeIndex=0,
            expected=lambda output: output.decode(encoded, length=pt.Int(8)),
        ),
        IndexTest(
            types=[uint64_t, uint64_t],
            typeIndex=1,
            expected=lambda output: output.decode(encoded, start_index=pt.Int(8)),
        ),
        IndexTest(
            types=[uint64_t, byte_t, uint64_t],
            typeIndex=1,
            expected=lambda output: output.decode(
                encoded, start_index=pt.Int(8), length=pt.Int(1)
            ),
        ),
        IndexTest(
            types=[uint64_t, byte_t, uint64_t],
            typeIndex=2,
            expected=lambda output: output.decode(
                encoded, start_index=pt.Int(9), length=pt.Int(8)
            ),
        ),
        IndexTest(
            types=[bool_t],
            typeIndex=0,
            expected=lambda output: output.decode_bit(encoded, pt.Int(0)),
        ),
        IndexTest(
            types=[bool_t, bool_t],
            typeIndex=0,
            expected=lambda output: output.decode_bit(encoded, pt.Int(0)),
        ),
        IndexTest(
            types=[bool_t, bool_t],
            typeIndex=1,
            expected=lambda output: output.decode_bit(encoded, pt.Int(1)),
        ),
        IndexTest(
            types=[uint64_t, bool_t],
            typeIndex=1,
            expected=lambda output: output.decode_bit(encoded, pt.Int(8 * 8)),
        ),
        IndexTest(
            types=[uint64_t, bool_t, bool_t],
            typeIndex=1,
            expected=lambda output: output.decode_bit(encoded, pt.Int(8 * 8)),
        ),
        IndexTest(
            types=[uint64_t, bool_t, bool_t],
            typeIndex=2,
            expected=lambda output: output.decode_bit(encoded, pt.Int(8 * 8 + 1)),
        ),
        IndexTest(
            types=[bool_t, uint64_t],
            typeIndex=0,
            expected=lambda output: output.decode_bit(encoded, pt.Int(0)),
        ),
        IndexTest(
            types=[bool_t, uint64_t],
            typeIndex=1,
            expected=lambda output: output.decode(encoded, start_index=pt.Int(1)),
        ),
        IndexTest(
            types=[bool_t, bool_t, uint64_t],
            typeIndex=0,
            expected=lambda output: output.decode_bit(encoded, pt.Int(0)),
        ),
        IndexTest(
            types=[bool_t, bool_t, uint64_t],
            typeIndex=1,
            expected=lambda output: output.decode_bit(encoded, pt.Int(1)),
        ),
        IndexTest(
            types=[bool_t, bool_t, uint64_t],
            typeIndex=2,
            expected=lambda output: output.decode(encoded, start_index=pt.Int(1)),
        ),
        IndexTest(
            types=[tuple_t], typeIndex=0, expected=lambda output: output.decode(encoded)
        ),
        IndexTest(
            types=[byte_t, tuple_t],
            typeIndex=1,
            expected=lambda output: output.decode(encoded, start_index=pt.Int(1)),
        ),
        IndexTest(
            types=[tuple_t, byte_t],
            typeIndex=0,
            expected=lambda output: output.decode(
                encoded,
                start_index=pt.Int(0),
                length=pt.Int(tuple_t.byte_length_static()),
            ),
        ),
        IndexTest(
            types=[byte_t, tuple_t, byte_t],
            typeIndex=1,
            expected=lambda output: output.decode(
                encoded,
                start_index=pt.Int(1),
                length=pt.Int(tuple_t.byte_length_static()),
            ),
        ),
        IndexTest(
            types=[dynamic_array_t1],
            typeIndex=0,
            expected=lambda output: output.decode(
                encoded, start_index=pt.ExtractUint16(encoded, pt.Int(0))
            ),
        ),
        IndexTest(
            types=[byte_t, dynamic_array_t1],
            typeIndex=1,
            expected=lambda output: output.decode(
                encoded, start_index=pt.ExtractUint16(encoded, pt.Int(1))
            ),
        ),
        IndexTest(
            types=[dynamic_array_t1, byte_t],
            typeIndex=0,
            expected=lambda output: output.decode(
                encoded, start_index=pt.ExtractUint16(encoded, pt.Int(0))
            ),
        ),
        IndexTest(
            types=[dynamic_array_t1, static_bytes_t],
            typeIndex=1,
            expected=lambda output: output.decode(
                encoded,
                start_index=pt.Int(2),
                length=pt.Int(2),
            ),
        ),
        IndexTest(
            types=[static_bytes_t, static_bytes_t],
            typeIndex=1,
            expected=lambda output: output.decode(
                encoded,
                start_index=pt.Int(2),
            ),
        ),
        IndexTest(
            types=[byte_t, dynamic_array_t1, byte_t],
            typeIndex=1,
            expected=lambda output: output.decode(
                encoded, start_index=pt.ExtractUint16(encoded, pt.Int(1))
            ),
        ),
        IndexTest(
            types=[byte_t, dynamic_array_t1, byte_t, dynamic_array_t2],
            typeIndex=1,
            expected=lambda output: output.decode(
                encoded,
                start_index=pt.ExtractUint16(encoded, pt.Int(1)),
                end_index=pt.ExtractUint16(encoded, pt.Int(4)),
            ),
        ),
        IndexTest(
            types=[byte_t, dynamic_array_t1, byte_t, dynamic_array_t2],
            typeIndex=3,
            expected=lambda output: output.decode(
                encoded, start_index=pt.ExtractUint16(encoded, pt.Int(4))
            ),
        ),
        IndexTest(
            types=[byte_t, dynamic_array_t1, tuple_t, dynamic_array_t2],
            typeIndex=1,
            expected=lambda output: output.decode(
                encoded,
                start_index=pt.ExtractUint16(encoded, pt.Int(1)),
                end_index=pt.ExtractUint16(encoded, pt.Int(4)),
            ),
        ),
        IndexTest(
            types=[byte_t, dynamic_array_t1, tuple_t, dynamic_array_t2],
            typeIndex=3,
            expected=lambda output: output.decode(
                encoded, start_index=pt.ExtractUint16(encoded, pt.Int(4))
            ),
        ),
        IndexTest(
            types=[byte_t, dynamic_array_t2, bool_t, bool_t, dynamic_array_t2],
            typeIndex=1,
            expected=lambda output: output.decode(
                encoded,
                start_index=pt.ExtractUint16(encoded, pt.Int(1)),
                end_index=pt.ExtractUint16(encoded, pt.Int(4)),
            ),
        ),
        IndexTest(
            types=[byte_t, dynamic_array_t1, bool_t, bool_t, dynamic_array_t2],
            typeIndex=4,
            expected=lambda output: output.decode(
                encoded, start_index=pt.ExtractUint16(encoded, pt.Int(4))
            ),
        ),
    ]

    for i, test in enumerate(tests):
        output = test.types[test.typeIndex].new_instance()
        expr = _index_tuple(test.types, encoded, test.typeIndex, output)
        assert expr.type_of() == pt.TealType.none
        assert not expr.has_return()

        expected, _ = test.expected(output).__teal__(options)
        expected.addIncoming()
        expected = pt.TealBlock.NormalizeBlocks(expected)

        actual, _ = expr.__teal__(options)
        actual.addIncoming()
        actual = pt.TealBlock.NormalizeBlocks(actual)

        with pt.TealComponent.Context.ignoreExprEquality():
            assert actual == expected, "Test at index {} failed".format(i)

        with pytest.raises(ValueError):
            _index_tuple(test.types, encoded, len(test.types), output)

        with pytest.raises(ValueError):
            _index_tuple(test.types, encoded, -1, output)

        otherType = abi.Uint64()
        if output.type_spec() == otherType.type_spec():
            otherType = abi.Uint16()

        with pytest.raises(TypeError):
            _index_tuple(test.types, encoded, test.typeIndex, otherType)


def test_TupleTypeSpec_eq():
    tupleA = abi.TupleTypeSpec(
        abi.Uint64TypeSpec(), abi.Uint32TypeSpec(), abi.BoolTypeSpec()
    )
    tupleB = abi.TupleTypeSpec(
        abi.Uint64TypeSpec(), abi.Uint32TypeSpec(), abi.BoolTypeSpec()
    )
    tupleC = abi.TupleTypeSpec(
        abi.BoolTypeSpec(), abi.Uint64TypeSpec(), abi.Uint32TypeSpec()
    )
    assert tupleA == tupleA
    assert tupleA == tupleB
    assert tupleA != tupleC


def test_TupleTypeSpec_value_type_specs():
    assert abi.TupleTypeSpec(
        abi.Uint64TypeSpec(), abi.Uint32TypeSpec(), abi.BoolTypeSpec()
    ).value_type_specs() == [
        abi.Uint64TypeSpec(),
        abi.Uint32TypeSpec(),
        abi.BoolTypeSpec(),
    ]


def test_TupleTypeSpec_length_static():
    tests: List[List[abi.TypeSpec]] = [
        [],
        [abi.Uint64TypeSpec()],
        [
            abi.TupleTypeSpec(abi.Uint64TypeSpec(), abi.Uint64TypeSpec()),
            abi.Uint64TypeSpec(),
        ],
        [abi.BoolTypeSpec()] * 8,
    ]

    for i, test in enumerate(tests):
        actual = abi.TupleTypeSpec(*test).length_static()
        expected = len(test)
        assert actual == expected, "Test at index {} failed".format(i)


def test_TupleTypeSpec_new_instance():
    assert isinstance(
        abi.TupleTypeSpec(
            abi.Uint64TypeSpec(), abi.Uint32TypeSpec(), abi.BoolTypeSpec()
        ).new_instance(),
        abi.Tuple,
    )


def test_TupleTypeSpec_is_dynamic():
    assert not abi.TupleTypeSpec().is_dynamic()
    assert not abi.TupleTypeSpec(
        abi.Uint64TypeSpec(), abi.Uint32TypeSpec(), abi.BoolTypeSpec()
    ).is_dynamic()
    assert abi.TupleTypeSpec(
        abi.Uint16TypeSpec(), abi.DynamicArrayTypeSpec(abi.Uint8TypeSpec())
    ).is_dynamic()


def test_TupleTypeSpec_str():
    assert str(abi.TupleTypeSpec()) == "()"
    assert str(abi.TupleTypeSpec(abi.TupleTypeSpec())) == "(())"
    assert str(abi.TupleTypeSpec(abi.TupleTypeSpec(), abi.TupleTypeSpec())) == "((),())"
    assert (
        str(
            abi.TupleTypeSpec(
                abi.Uint64TypeSpec(), abi.Uint32TypeSpec(), abi.BoolTypeSpec()
            )
        )
        == "(uint64,uint32,bool)"
    )
    assert (
        str(
            abi.TupleTypeSpec(
                abi.BoolTypeSpec(), abi.Uint64TypeSpec(), abi.Uint32TypeSpec()
            )
        )
        == "(bool,uint64,uint32)"
    )
    assert (
        str(
            abi.TupleTypeSpec(
                abi.Uint16TypeSpec(), abi.DynamicArrayTypeSpec(abi.Uint8TypeSpec())
            )
        )
        == "(uint16,uint8[])"
    )


def test_TupleTypeSpec_byte_length_static():
    assert abi.TupleTypeSpec().byte_length_static() == 0
    assert abi.TupleTypeSpec(abi.TupleTypeSpec()).byte_length_static() == 0
    assert (
        abi.TupleTypeSpec(abi.TupleTypeSpec(), abi.TupleTypeSpec()).byte_length_static()
        == 0
    )
    assert (
        abi.TupleTypeSpec(
            abi.Uint64TypeSpec(), abi.Uint32TypeSpec(), abi.BoolTypeSpec()
        ).byte_length_static()
        == 8 + 4 + 1
    )
    assert (
        abi.TupleTypeSpec(
            abi.Uint64TypeSpec(),
            abi.Uint32TypeSpec(),
            abi.BoolTypeSpec(),
            abi.BoolTypeSpec(),
            abi.BoolTypeSpec(),
            abi.BoolTypeSpec(),
            abi.BoolTypeSpec(),
            abi.BoolTypeSpec(),
            abi.BoolTypeSpec(),
            abi.BoolTypeSpec(),
        ).byte_length_static()
        == 8 + 4 + 1
    )
    assert (
        abi.TupleTypeSpec(
            abi.Uint64TypeSpec(),
            abi.Uint32TypeSpec(),
            abi.BoolTypeSpec(),
            abi.BoolTypeSpec(),
            abi.BoolTypeSpec(),
            abi.BoolTypeSpec(),
            abi.BoolTypeSpec(),
            abi.BoolTypeSpec(),
            abi.BoolTypeSpec(),
            abi.BoolTypeSpec(),
            abi.BoolTypeSpec(),
        ).byte_length_static()
        == 8 + 4 + 2
    )

    with pytest.raises(ValueError):
        abi.TupleTypeSpec(
            abi.Uint16TypeSpec(), abi.DynamicArrayTypeSpec(abi.Uint8TypeSpec())
        ).byte_length_static()


def test_Tuple_decode():
    encoded = pt.Bytes("encoded")
    tupleValue = abi.Tuple(abi.TupleTypeSpec(abi.Uint64TypeSpec()))
    for start_index in (None, pt.Int(1)):
        for end_index in (None, pt.Int(2)):
            for length in (None, pt.Int(3)):
                if end_index is not None and length is not None:
                    with pytest.raises(pt.TealInputError):
                        tupleValue.decode(
                            encoded,
                            start_index=start_index,
                            end_index=end_index,
                            length=length,
                        )
                    continue

                expr = tupleValue.decode(
                    encoded, start_index=start_index, end_index=end_index, length=length
                )
                assert expr.type_of() == pt.TealType.none
                assert not expr.has_return()

                expectedExpr = tupleValue._stored_value.store(
                    substring_for_decoding(
                        encoded,
                        start_index=start_index,
                        end_index=end_index,
                        length=length,
                    )
                )
                expected, _ = expectedExpr.__teal__(options)
                expected.addIncoming()
                expected = pt.TealBlock.NormalizeBlocks(expected)

                actual, _ = expr.__teal__(options)
                actual.addIncoming()
                actual = pt.TealBlock.NormalizeBlocks(actual)

                with pt.TealComponent.Context.ignoreExprEquality():
                    assert actual == expected


def test_Tuple_set():
    tupleValue = abi.Tuple(
        abi.TupleTypeSpec(
            abi.Uint8TypeSpec(), abi.Uint16TypeSpec(), abi.Uint32TypeSpec()
        )
    )
    uint8 = abi.Uint8()
    uint16 = abi.Uint16()
    uint32 = abi.Uint32()

    with pytest.raises(pt.TealInputError):
        tupleValue.set()

    with pytest.raises(pt.TealInputError):
        tupleValue.set(uint8, uint16)

    with pytest.raises(pt.TealInputError):
        tupleValue.set(uint8, uint16, uint32, uint32)

    with pytest.raises(pt.TealInputError, match="at index=1: uint32 != uint16"):
        tupleValue.set(uint8, uint32, uint16)

    with pytest.raises(pt.TealInputError):
        tupleValue.set(uint8, uint16, uint16)

    expr = tupleValue.set(uint8, uint16, uint32)
    assert expr.type_of() == pt.TealType.none
    assert not expr.has_return()

    expectedExpr = tupleValue._stored_value.store(
        _encode_tuple([uint8, uint16, uint32])
    )
    expected, _ = expectedExpr.__teal__(options)
    expected.addIncoming()
    expected = pt.TealBlock.NormalizeBlocks(expected)

    actual, _ = expr.__teal__(options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    with pt.TealComponent.Context.ignoreExprEquality():
        assert actual == expected


def test_Tuple_set_Computed():
    tupleValue = abi.Tuple(
        abi.TupleTypeSpec(
            abi.Uint8TypeSpec(), abi.Uint16TypeSpec(), abi.Uint32TypeSpec()
        )
    )
    computed = ContainerType(
        tupleValue.type_spec(), pt.Bytes("internal representation")
    )
    expr = tupleValue.set(computed)
    assert expr.type_of() == pt.TealType.none
    assert not expr.has_return()

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(None, pt.Op.byte, '"internal representation"'),
            pt.TealOp(
                None,
                pt.Op.store,
                cast(pt.ScratchVar, tupleValue._stored_value).slot,
            ),
        ]
    )
    actual, _ = expr.__teal__(options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    with pt.TealComponent.Context.ignoreExprEquality():
        assert actual == expected

    with pytest.raises(pt.TealInputError):
        tupleValue.set(computed, computed)

    with pytest.raises(pt.TealInputError):
        tupleValue.set(
            ContainerType(abi.TupleTypeSpec(abi.ByteTypeSpec()), pt.Bytes(b"a"))
        )


def test_Tuple_encode():
    tupleValue = abi.Tuple(abi.TupleTypeSpec(abi.Uint64TypeSpec()))
    expr = tupleValue.encode()
    assert expr.type_of() == pt.TealType.bytes
    assert not expr.has_return()

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(
                None,
                pt.Op.load,
                cast(pt.ScratchVar, tupleValue._stored_value).slot,
            ),
        ]
    )

    actual, _ = expr.__teal__(options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    with pt.TealComponent.Context.ignoreExprEquality():
        assert actual == expected


def test_Tuple_length():
    tests: List[List[abi.TypeSpec]] = [
        [],
        [abi.Uint64TypeSpec()],
        [
            abi.TupleTypeSpec(abi.Uint64TypeSpec(), abi.Uint64TypeSpec()),
            abi.Uint64TypeSpec(),
        ],
        [abi.BoolTypeSpec()] * 8,
    ]

    for i, test in enumerate(tests):
        tupleValue = abi.Tuple(abi.TupleTypeSpec(*test))
        expr = tupleValue.length()
        assert expr.type_of() == pt.TealType.uint64
        assert not expr.has_return()

        expectedLength = len(test)
        expected = pt.TealSimpleBlock([pt.TealOp(None, pt.Op.int, expectedLength)])

        actual, _ = expr.__teal__(options)
        actual.addIncoming()
        actual = pt.TealBlock.NormalizeBlocks(actual)

        with pt.TealComponent.Context.ignoreExprEquality():
            assert actual == expected, "Test at index {} failed".format(i)


def test_Tuple_getitem():
    tests: List[List[abi.TypeSpec]] = [
        [],
        [abi.Uint64TypeSpec()],
        [
            abi.TupleTypeSpec(abi.Uint64TypeSpec(), abi.Uint64TypeSpec()),
            abi.Uint64TypeSpec(),
        ],
        [abi.BoolTypeSpec()] * 8,
    ]

    for i, test in enumerate(tests):
        tupleValue = abi.Tuple(abi.TupleTypeSpec(*test))
        for j in range(len(test)):
            element = tupleValue[j]
            assert type(element) is TupleElement, "Test at index {} failed".format(i)
            assert element.tuple is tupleValue, "Test at index {} failed".format(i)
            assert element.index == j, "Test at index {} failed".format(i)

        with pytest.raises(pt.TealInputError):
            tupleValue[-1]

        with pytest.raises(pt.TealInputError):
            tupleValue[len(test)]


def test_TupleElement_store_into():
    tests: List[List[abi.TypeSpec]] = [
        [],
        [abi.Uint64TypeSpec()],
        [
            abi.TupleTypeSpec(abi.Uint64TypeSpec(), abi.Uint64TypeSpec()),
            abi.Uint64TypeSpec(),
        ],
        [abi.BoolTypeSpec()] * 8,
    ]

    for i, test in enumerate(tests):
        tupleValue = abi.Tuple(abi.TupleTypeSpec(*test))
        for j in range(len(test)):
            element = TupleElement(tupleValue, j)
            output = test[j].new_instance()

            expr = element.store_into(output)
            assert expr.type_of() == pt.TealType.none
            assert not expr.has_return()

            expectedExpr = _index_tuple(test, tupleValue.encode(), j, output)
            expected, _ = expectedExpr.__teal__(options)
            expected.addIncoming()
            expected = pt.TealBlock.NormalizeBlocks(expected)

            actual, _ = expr.__teal__(options)
            actual.addIncoming()
            actual = pt.TealBlock.NormalizeBlocks(actual)

            with pt.TealComponent.Context.ignoreExprEquality():
                assert actual == expected, "Test at index {} failed".format(i)


def test_NamedTuple_init():
    with pytest.raises(pt.TealInputError, match=r"NamedTuple must be subclassed$"):
        abi.NamedTuple()

    class Empty(abi.NamedTuple):
        pass

    with pytest.raises(
        pt.TealInputError, match=r"Expected fields to be declared but found none$"
    ):
        Empty()

    class ValidField(abi.NamedTuple):
        name: abi.Field[abi.Uint16]

    ValidField()

    class NoField(abi.NamedTuple):
        name: abi.Uint16

    with pytest.raises(
        pt.TealInputError,
        match=r'Type annotation for attribute "name" must be a Field. Got ',
    ):
        NoField()


class NT_0(abi.NamedTuple):
    f0: abi.Field[abi.Uint64]
    f1: abi.Field[abi.Uint32]
    f2: abi.Field[abi.Uint16]
    f3: abi.Field[abi.Uint8]


class NT_1(abi.NamedTuple):
    f0: abi.Field[abi.StaticArray[abi.Bool, Literal[4]]]
    f1: abi.Field[abi.DynamicArray[abi.String]]
    f2: abi.Field[abi.String]
    f3: abi.Field[abi.Bool]
    f4: abi.Field[abi.Address]
    f5: abi.Field[NT_0]


class NT_2(abi.NamedTuple):
    f0: abi.Field[abi.Bool]
    f1: abi.Field[abi.Bool]
    f2: abi.Field[abi.Bool]
    f3: abi.Field[abi.Bool]
    f4: abi.Field[abi.Bool]
    f5: abi.Field[abi.Bool]
    f6: abi.Field[abi.Bool]
    f7: abi.Field[abi.Bool]
    f8: abi.Field[NT_1]


class NT_3(abi.NamedTuple):
    f0: abi.Field[NT_0]
    f1: abi.Field[NT_1]
    f2: abi.Field[NT_2]


@pytest.mark.parametrize("test_case", [NT_0, NT_1, NT_2, NT_3])
def test_NamedTuple_getitem(test_case: type[abi.NamedTuple]):
    tuple_value = test_case()
    tuple_len_static = tuple_value.type_spec().length_static()
    for i in range(tuple_len_static):
        elem_by_field: abi.TupleElement = getattr(tuple_value, f"f{i}")
        elem_by_index: abi.TupleElement = tuple_value[i]

        assert (
            type(elem_by_field) is abi.TupleElement
        ), f"Test case {test_case} at field f{i} must be TupleElement"
        assert (
            type(elem_by_index) is abi.TupleElement
        ), f"Test case {test_case} at index {i} must be TupleElement"

        assert (
            elem_by_field.index == i
        ), f"Test case {test_case} at field f{i} should have index {i}."
        assert (
            elem_by_index.index == i
        ), f"Test case {test_case} at index {i} should have index {i}."

        assert (
            elem_by_field.tuple is tuple_value
        ), f"Test case {test_case} at field f{i} should have attr tuple == {test_case}."
        assert (
            elem_by_index.tuple is tuple_value
        ), f"Test case {test_case} at index {i} should have attr tuple == {test_case}."

        assert (
            elem_by_field.produced_type_spec() == elem_by_index.produced_type_spec()
        ), f"Test case {test_case} at field f{i} type spec unmatching: {elem_by_field.produced_type_spec()} != {elem_by_index.produced_type_spec()}."

    with pytest.raises(KeyError):
        tuple_value.aaaaa

    with pytest.raises(pt.TealInputError):
        tuple_value.f0 = abi.Uint64()


def test_NamedTupleTypeSpec():
    from pyteal.ast.abi.util import type_spec_is_assignable_to

    class Point(abi.NamedTuple):
        x: abi.Field[abi.Uint64]
        y: abi.Field[abi.Uint64]

    class AccountRecord(abi.NamedTuple):
        algoBalance: abi.Field[abi.Uint64]
        assetBalance: abi.Field[abi.Uint64]

    p = Point()
    ar = AccountRecord()

    assert p.type_spec() == p.type_spec()
    assert ar.type_spec() == ar.type_spec()
    assert p.type_spec() != ar.type_spec()
    assert not type_spec_is_assignable_to(p.type_spec(), ar.type_spec())
    assert not type_spec_is_assignable_to(ar.type_spec(), p.type_spec())



================================================
FILE: pyteal/ast/abi/type.py
================================================
from typing import TypeVar, Generic, Callable, Final, cast
from abc import ABC, abstractmethod

from pyteal.ast.expr import Expr
from pyteal.ast.abstractvar import AbstractVar, alloc_abstract_var
from pyteal.ast.seq import Seq
from pyteal.errors import TealInputError, TealTypeError
from pyteal.types import TealType


class TypeSpec(ABC):
    """TypeSpec represents a specification for an ABI type.

    Essentially this is a factory that can produce specific instances of ABI types.
    """

    @abstractmethod
    def new_instance(self) -> "BaseType":
        """Create a new instance of the specified type."""
        pass

    @abstractmethod
    def annotation_type(self) -> "type[BaseType]":
        """Get the annotation type associated with this spec"""
        pass

    @abstractmethod
    def is_dynamic(self) -> bool:
        """Check if this ABI type is dynamic.

        If a type is dynamic, the length of its encoding depends on its value. Otherwise, the type
        is considered static (not dynamic).
        """
        pass

    @abstractmethod
    def byte_length_static(self) -> int:
        """Get the byte length of this ABI type's encoding. Only valid for static types."""
        pass

    @abstractmethod
    def storage_type(self) -> TealType:
        """Get the TealType that the underlying ScratchVar should hold for this type."""
        pass

    @abstractmethod
    def __eq__(self, other: object) -> bool:
        """Check if this type is considered equal to another ABI type.

        Args:
            other: The object to compare to. If this is not a TypeSpec, this method will never
                return true.

        Returns:
            True if and only if self and other represent the same ABI type.
        """
        pass

    @abstractmethod
    def __str__(self) -> str:
        """Get the string representation of this ABI type, used for creating method signatures."""
        pass


TypeSpec.__module__ = "pyteal.abi"


class BaseType(ABC):
    """The abstract base class for all ABI type instances.

    The value of the type is contained in a unique ScratchVar that only this instance has access to.
    As a result, the value of an ABI type is mutable and can be efficiently referenced multiple
    times without needing to recompute it.
    """

    def __init__(self, spec: TypeSpec) -> None:
        """Create a new BaseType."""
        super().__init__()
        self._type_spec: Final[TypeSpec] = spec
        self._stored_value: AbstractVar = alloc_abstract_var(spec.storage_type())

    def type_spec(self) -> TypeSpec:
        """Get the TypeSpec for this ABI type instance."""
        return self._type_spec

    @abstractmethod
    def encode(self) -> Expr:
        """Encode this ABI type to a byte string.

        Returns:
            A PyTeal expression that encodes this type to a byte string.
        """
        pass

    @abstractmethod
    def decode(
        self,
        encoded: Expr,
        *,
        start_index: Expr | None = None,
        end_index: Expr | None = None,
        length: Expr | None = None,
    ) -> Expr:
        """Decode a substring of the passed in encoded string and set it as this type's value.

        The arguments to this function are means to be as flexible as possible for the caller.
        Multiple types of substrings can be specified based on the arguments, as listed below:

        * Entire string: if start_index, end_index, and length are all None, the entire encoded string
          is decoded.
        * Prefix: if start_index is None and one of end_index or length is provided, a prefix of the
          encoded string is decoded. The range is 0 through end_index or length (they are equivalent).
        * Suffix: if start_index is provided and end_index and length are None, a suffix of the encoded
          string is decoded. The range is start_index through the end of the string.
        * Substring specified with end_index: if start_index and end_index are provided and length is
          None, a substring of the encoded string is decoded. The range is start_index through
          end_index.
        * Substring specified with length: if start_index and length are provided and end_index is
          None, a substring of the encoded string is decoded. The range is start_index through
          start_index+length.

        Args:
            encoded: An expression containing the bytes to decode. Must evaluate to TealType.bytes.
            start_index (optional): An expression containing the index to start decoding. Must
                evaluate to TealType.uint64. Defaults to None.
            end_index (optional): An expression containing the index to stop decoding. Must evaluate
                to TealType.uint64. Defaults to None.
            length (optional): An expression containing the length of the substring to decode. Must
                evaluate to TealType.uint64. Defaults to None.

        Returns:
            An expression that performs the necessary steps in order to decode the given string into
            a value.
        """
        pass

    def _set_with_computed_type(self, value: "ComputedValue[BaseType]") -> Expr:
        target_type_spec = value.produced_type_spec()
        if self.type_spec() != target_type_spec:
            raise TealInputError(
                f"Cannot set {self.type_spec()} with ComputedType of {target_type_spec}"
            )
        return value.store_into(self)

    def __str__(self) -> str:
        return str(self.type_spec())


BaseType.__module__ = "pyteal.abi"

T_co = TypeVar("T_co", bound=BaseType, covariant=True)


class ComputedValue(ABC, Generic[T_co]):
    """Represents an ABI Type whose value must be computed by an expression."""

    @abstractmethod
    def produced_type_spec(self) -> TypeSpec:
        """Get the ABI TypeSpec that this object produces."""
        pass

    @abstractmethod
    def store_into(self, output: T_co) -> Expr:  # type: ignore[misc]
        """Compute the value and store it into an existing ABI type instance.

        NOTE: If you call this method multiple times, the computation to determine the value will be
        repeated each time. For this reason, it is recommended to only issue a single call to either
        :code:`store_into` or :code:`use`.

        Args:
            output: The object where the computed value will be stored. This object must have the
                same type as this class's produced type.

        Returns:
            An expression which stores the computed value represented by this class into the output
            object.
        """
        pass

    def use(self, action: Callable[[T_co], Expr]) -> Expr:
        """Compute the value and pass it to a callable expression.

        NOTE: If you call this method multiple times, the computation to determine the value will be
        repeated each time. For this reason, it is recommended to only issue a single call to either
        :code:`store_into` or :code:`use`.

        Args:
            action: A callable object that will receive an instance of this class's produced type
                with the computed value. The callable object may use that value as it sees fit, but
                it must return an Expr to be included in the program's AST.

        Returns:
            An expression which contains the returned expression from invoking `action` with the
            computed value.
        """
        newInstance = cast(T_co, self.produced_type_spec().new_instance())
        return Seq(self.store_into(newInstance), action(newInstance))


ComputedValue.__module__ = "pyteal.abi"


class ReturnedValue(ComputedValue):
    def __init__(self, type_spec: TypeSpec, computation_expr: Expr):
        from pyteal.ast.subroutine import SubroutineCall

        self.type_spec = type_spec
        if not isinstance(computation_expr, SubroutineCall):
            raise TealInputError(
                f"Expecting computation_expr to be SubroutineCall but get {type(computation_expr)}"
            )
        self.computation = computation_expr

    def produced_type_spec(self) -> TypeSpec:
        return self.type_spec

    def store_into(self, output: BaseType) -> Expr:
        from pyteal.ast.subroutine import SubroutineDeclaration

        if output.type_spec() != self.produced_type_spec():
            raise TealInputError(
                f"expected type_spec {self.produced_type_spec()} but get {output.type_spec()}"
            )

        # HANG NOTE! This get_declaration check applies only for pre frame pointer case
        # the post frame pointer case should not apply
        # need to somehow expose the context of evaluation

        declaration: SubroutineDeclaration | None = None
        try:
            declaration = self.computation.subroutine.get_declaration_by_option(False)
        except Exception:
            pass

        if declaration is not None:
            if declaration.deferred_expr is None:
                raise TealInputError(
                    "ABI return subroutine must have deferred_expr to be not-None."
                )
            if declaration.deferred_expr.type_of() != output.type_spec().storage_type():
                raise TealTypeError(
                    declaration.deferred_expr.type_of(),
                    output.type_spec().storage_type(),
                )

        return output._stored_value.store(self.computation)


ReturnedValue.__module__ = "pyteal.abi"



================================================
FILE: pyteal/ast/abi/type_test.py
================================================
import pyteal as pt
from pyteal import abi

options = pt.CompileOptions(version=5)


class ContainerType(abi.ComputedValue):
    def __init__(self, type_spec: abi.TypeSpec, encodings: pt.Expr):
        self.type_spec = type_spec
        self.encodings = encodings

    def produced_type_spec(self) -> abi.TypeSpec:
        return self.type_spec

    def store_into(self, output: abi.BaseType) -> pt.Expr:
        if output.type_spec() != self.type_spec:
            raise pt.TealInputError(
                f"expected type_spec {self.type_spec} but get {output.type_spec()}"
            )
        return output._stored_value.store(self.encodings)


def test_ComputedType_use():
    for value in (0, 1, 2, 3, 12345):
        dummyComputedType = ContainerType(abi.Uint64TypeSpec(), pt.Int(value))
        expr = dummyComputedType.use(lambda output: pt.Int(2) * output.get())
        assert expr.type_of() == pt.TealType.uint64
        assert not expr.has_return()

        actual, _ = expr.__teal__(options)
        actual.addIncoming()
        actual = pt.TealBlock.NormalizeBlocks(actual)

        assert type(actual) is pt.TealSimpleBlock
        assert actual.ops[1].op == pt.Op.store
        assert type(actual.ops[1].args[0]) is pt.ScratchSlot
        actualSlot = actual.ops[1].args[0]

        expected = pt.TealSimpleBlock(
            [
                pt.TealOp(None, pt.Op.int, value),
                pt.TealOp(None, pt.Op.store, actualSlot),
                pt.TealOp(None, pt.Op.int, 2),
                pt.TealOp(None, pt.Op.load, actualSlot),
                pt.TealOp(None, pt.Op.mul),
            ]
        )

        with pt.TealComponent.Context.ignoreExprEquality():
            assert actual == expected



================================================
FILE: pyteal/ast/abi/uint.py
================================================
from typing import (
    Union,
    Optional,
    Final,
    cast,
)
from abc import abstractmethod

from pyteal.types import TealType
from pyteal.errors import TealInputError
from pyteal.ast.abstractvar import AbstractVar
from pyteal.ast.expr import Expr
from pyteal.ast.seq import Seq
from pyteal.ast.assert_ import Assert
from pyteal.ast.substring import Suffix
from pyteal.ast.int import Int
from pyteal.ast.bytes import Bytes
from pyteal.ast.unaryexpr import Itob, Btoi
from pyteal.ast.binaryexpr import GetByte, ExtractUint16, ExtractUint32, ExtractUint64
from pyteal.ast.ternaryexpr import SetByte
from pyteal.ast.abi.type import ComputedValue, TypeSpec, BaseType

NUM_BITS_IN_BYTE = 8

SUPPORTED_UINT_SIZES = (8, 16, 32, 64)


def uint_storage_type(size: int) -> TealType:
    if size <= 64:
        return TealType.uint64
    return TealType.bytes


def uint_set(size: int, uint_var: AbstractVar, value: Union[int, Expr, "Uint"]) -> Expr:
    if size > 64:
        raise NotImplementedError(
            "Uint operations have not yet been implemented for bit sizes larger than 64"
        )

    checked = False
    if type(value) is int:
        if value >= 2**size:
            raise TealInputError("Value exceeds uint{} maximum: {}".format(size, value))
        value = Int(value)
        checked = True

    if isinstance(value, Uint):
        value = value.get()
        checked = True

    if checked or size == 64:
        return uint_var.store(cast(Expr, value))

    return Seq(
        uint_var.store(cast(Expr, value)),
        Assert(uint_var.load() < Int(2**size)),
    )


def uint_decode(
    size: int,
    uint_var: AbstractVar,
    encoded: Expr,
    start_index: Optional[Expr],
    end_index: Optional[Expr],
    length: Optional[Expr],
) -> Expr:
    if size > 64:
        raise NotImplementedError(
            "Uint operations have not yet been implemented for bit sizes larger than 64"
        )

    if size == 64:
        if start_index is None:
            if end_index is None and length is None:
                return uint_var.store(Btoi(encoded))
            start_index = Int(0)
        return uint_var.store(ExtractUint64(encoded, start_index))

    if start_index is None:
        start_index = Int(0)

    if size == 8:
        return uint_var.store(GetByte(encoded, start_index))
    if size == 16:
        return uint_var.store(ExtractUint16(encoded, start_index))
    if size == 32:
        return uint_var.store(ExtractUint32(encoded, start_index))

    raise ValueError("Unsupported uint size: {}".format(size))


def uint_encode(size: int, uint_var: Expr | AbstractVar) -> Expr:
    if isinstance(uint_var, AbstractVar):
        uint_var = uint_var.load()

    if size > 64:
        raise NotImplementedError(
            "Uint operations have not yet been implemented for bit sizes larger than 64"
        )

    if size == 8:
        return SetByte(Bytes(b"\x00"), Int(0), uint_var)
    if size == 16:
        return Suffix(Itob(uint_var), Int(6))
    if size == 32:
        return Suffix(Itob(uint_var), Int(4))
    if size == 64:
        return Itob(uint_var)

    raise ValueError("Unsupported uint size: {}".format(size))


class UintTypeSpec(TypeSpec):
    def __init__(self, bit_size: int) -> None:
        super().__init__()
        if bit_size not in SUPPORTED_UINT_SIZES:
            raise TypeError("Unsupported uint size: {}".format(bit_size))
        self.size: Final = bit_size

    @abstractmethod
    def new_instance(self) -> "Uint":
        pass

    @abstractmethod
    def annotation_type(self) -> "type[Uint]":
        pass

    def bit_size(self) -> int:
        """Get the bit size of this uint type"""
        return self.size

    def is_dynamic(self) -> bool:
        return False

    def byte_length_static(self) -> int:
        return self.bit_size() // NUM_BITS_IN_BYTE

    def storage_type(self) -> TealType:
        return uint_storage_type(self.bit_size())

    def __eq__(self, other: object) -> bool:
        # NOTE: by this implementation, ByteTypeSpec() != Uint8TypeSpec()
        return (
            type(self) is type(other)
            and self.bit_size() == cast(UintTypeSpec, other).bit_size()
        )

    def __str__(self) -> str:
        return "uint{}".format(self.bit_size())


UintTypeSpec.__module__ = "pyteal.abi"


class ByteTypeSpec(UintTypeSpec):
    def __init__(self) -> None:
        super().__init__(8)

    def new_instance(self) -> "Byte":
        return Byte()

    def annotation_type(self) -> "type[Byte]":
        return Byte

    def __str__(self) -> str:
        return "byte"


ByteTypeSpec.__module__ = "pyteal.abi"


class Uint8TypeSpec(UintTypeSpec):
    def __init__(self) -> None:
        super().__init__(8)

    def new_instance(self) -> "Uint8":
        return Uint8()

    def annotation_type(self) -> "type[Uint8]":
        return Uint8


Uint8TypeSpec.__module__ = "pyteal.abi"


class Uint16TypeSpec(UintTypeSpec):
    def __init__(self) -> None:
        super().__init__(16)

    def new_instance(self) -> "Uint16":
        return Uint16()

    def annotation_type(self) -> "type[Uint16]":
        return Uint16


Uint16TypeSpec.__module__ = "pyteal.abi"


class Uint32TypeSpec(UintTypeSpec):
    def __init__(self) -> None:
        super().__init__(32)

    def new_instance(self) -> "Uint32":
        return Uint32()

    def annotation_type(self) -> "type[Uint32]":
        return Uint32


Uint32TypeSpec.__module__ = "pyteal.abi"


class Uint64TypeSpec(UintTypeSpec):
    def __init__(self) -> None:
        super().__init__(64)

    def new_instance(self) -> "Uint64":
        return Uint64()

    def annotation_type(self) -> "type[Uint64]":
        return Uint64


Uint64TypeSpec.__module__ = "pyteal.abi"


class Uint(BaseType):
    @abstractmethod
    def __init__(self, spec: UintTypeSpec) -> None:
        super().__init__(spec)

    def type_spec(self) -> UintTypeSpec:
        return cast(UintTypeSpec, super().type_spec())

    def get(self) -> Expr:
        """Return the value held by this Uint as a PyTeal expression.

        The expression will have the type TealType.uint64.
        """
        return self._stored_value.load()

    def set(self, value: Union[int, Expr, "Uint", ComputedValue["Uint"]]) -> Expr:
        """Set the value of this Uint to the input value.

        There are a variety of ways to express the input value. Regardless of the type used to
        indicate the input value, this Uint type can only hold values in the range :code:`[0,2^N)`,
        where :code:`N` is the bit size of this Uint.

        The behavior of this method depends on the input argument type:

            * :code:`int`: set the value to a Python integer. A compiler error will occur if this value overflows or underflows this integer type.
            * :code:`Expr`: set the value to the result of a PyTeal expression, which must evaluate to a TealType.uint64. The program will fail if the evaluated value overflows or underflows this integer type.
            * :code:`Uint`: copy the value from another Uint. The argument's type must exactly match this integer's type, otherwise an error will occur. For example, it's not possible to set a Uint64 to a Uint8, or vice versa.
            * :code:`ComputedValue[Uint]`: copy the value from a Uint produced by a ComputedValue. The type produced by the ComputedValue must exactly match this integer's type, otherwise an error will occur.

        Args:
            value: The new value this Uint should take. This must follow the above constraints.

        Returns:
            An expression which stores the given value into this Uint.
        """
        if isinstance(value, ComputedValue):
            return self._set_with_computed_type(value)

        if isinstance(value, BaseType) and not (
            isinstance(value.type_spec(), UintTypeSpec)
            and self.type_spec().bit_size()
            == cast(UintTypeSpec, value.type_spec()).bit_size()
        ):
            raise TealInputError(
                "Type {} is not assignable to type {}".format(
                    value.type_spec(), self.type_spec()
                )
            )
        return uint_set(self.type_spec().bit_size(), self._stored_value, value)

    def decode(
        self,
        encoded: Expr,
        *,
        start_index: Expr | None = None,
        end_index: Expr | None = None,
        length: Expr | None = None,
    ) -> Expr:
        return uint_decode(
            self.type_spec().bit_size(),
            self._stored_value,
            encoded,
            start_index,
            end_index,
            length,
        )

    def encode(self) -> Expr:
        return uint_encode(self.type_spec().bit_size(), self._stored_value)


Uint.__module__ = "pyteal.abi"


class Byte(Uint):
    def __init__(self) -> None:
        super().__init__(ByteTypeSpec())


Byte.__module__ = "pyteal.abi"


class Uint8(Uint):
    def __init__(self) -> None:
        super().__init__(Uint8TypeSpec())


Uint8.__module__ = "pyteal.abi"


class Uint16(Uint):
    def __init__(self) -> None:
        super().__init__(Uint16TypeSpec())


Uint16.__module__ = "pyteal.abi"


class Uint32(Uint):
    def __init__(self) -> None:
        super().__init__(Uint32TypeSpec())


Uint32.__module__ = "pyteal.abi"


class Uint64(Uint):
    def __init__(self) -> None:
        super().__init__(Uint64TypeSpec())


Uint64.__module__ = "pyteal.abi"



================================================
FILE: pyteal/ast/abi/uint_test.py
================================================
from typing import List, Tuple, NamedTuple, Callable, Union, Optional, cast
from pyteal.ast.abi.type_test import ContainerType
import pyteal as pt
from pyteal import abi

import pytest

options = pt.CompileOptions(version=5)


class UintTestData(NamedTuple):
    uintType: abi.UintTypeSpec
    instanceType: type
    expectedBits: int
    maxValue: int
    checkUpperBound: bool
    expectedDecoding: Callable[
        [pt.Expr, Optional[pt.Expr], Optional[pt.Expr], Optional[pt.Expr]], pt.Expr
    ]
    expectedEncoding: Callable[[abi.Uint], pt.Expr]


def noneToInt0(value: Union[None, pt.Expr]):
    if value is None:
        return pt.Int(0)
    return value


testData = [
    UintTestData(
        uintType=abi.Uint8TypeSpec(),
        instanceType=abi.Uint8,
        expectedBits=8,
        maxValue=2**8 - 1,
        checkUpperBound=True,
        expectedDecoding=lambda encoded, start_index, end_index, length: pt.GetByte(
            encoded, noneToInt0(start_index)
        ),
        expectedEncoding=lambda uintType: pt.SetByte(
            pt.Bytes(b"\x00"), pt.Int(0), uintType.get()
        ),
    ),
    UintTestData(
        uintType=abi.Uint16TypeSpec(),
        instanceType=abi.Uint16,
        expectedBits=16,
        maxValue=2**16 - 1,
        checkUpperBound=True,
        expectedDecoding=lambda encoded, start_index, end_index, length: pt.ExtractUint16(
            encoded, noneToInt0(start_index)
        ),
        expectedEncoding=lambda uintType: pt.Suffix(pt.Itob(uintType.get()), pt.Int(6)),
    ),
    UintTestData(
        uintType=abi.Uint32TypeSpec(),
        instanceType=abi.Uint32,
        expectedBits=32,
        maxValue=2**32 - 1,
        checkUpperBound=True,
        expectedDecoding=lambda encoded, start_index, end_index, length: pt.ExtractUint32(
            encoded, noneToInt0(start_index)
        ),
        expectedEncoding=lambda uintType: pt.Suffix(pt.Itob(uintType.get()), pt.Int(4)),
    ),
    UintTestData(
        uintType=abi.Uint64TypeSpec(),
        instanceType=abi.Uint64,
        expectedBits=64,
        maxValue=2**64 - 1,
        checkUpperBound=False,
        expectedDecoding=lambda encoded, start_index, end_index, length: (
            pt.Btoi(encoded)
            if start_index is None and end_index is None and length is None
            else pt.ExtractUint64(encoded, noneToInt0(start_index))
        ),
        expectedEncoding=lambda uintType: pt.Itob(uintType.get()),
    ),
]


def test_UintTypeSpec_bits():
    for test in testData:
        assert test.uintType.bit_size() == test.expectedBits
        assert test.uintType.byte_length_static() * 8 == test.expectedBits


def test_UintTypeSpec_str():
    for test in testData:
        assert str(test.uintType) == "uint{}".format(test.expectedBits)
    assert str(abi.ByteTypeSpec()) == "byte"


def test_UintTypeSpec_is_dynamic():
    for test in testData:
        assert not test.uintType.is_dynamic()
    assert not abi.ByteTypeSpec().is_dynamic()


def test_UintTypeSpec_eq():
    for i, test in enumerate(testData):
        assert test.uintType == test.uintType

        for j, otherTest in enumerate(testData):
            if i == j:
                continue
            assert test.uintType != otherTest.uintType

        for otherType in (
            abi.BoolTypeSpec(),
            abi.StaticArrayTypeSpec(test.uintType, 1),
            abi.DynamicArrayTypeSpec(test.uintType),
        ):
            assert test.uintType != otherType

    assert abi.ByteTypeSpec() != abi.Uint8TypeSpec()
    assert abi.Uint8TypeSpec() != abi.ByteTypeSpec()


def test_UintTypeSpec_storage_type():
    for test in testData:
        assert test.uintType.storage_type() == pt.TealType.uint64
    assert abi.BoolTypeSpec().storage_type() == pt.TealType.uint64


def test_UintTypeSpec_new_instance():
    for test in testData:
        assert isinstance(test.uintType.new_instance(), test.instanceType)
    assert isinstance(abi.ByteTypeSpec().new_instance(), abi.Byte)


def test_Uint_set_static():
    for test in testData:
        for value_to_set in (0, 1, 100, test.maxValue):
            value = test.uintType.new_instance()
            expr = value.set(value_to_set)
            assert expr.type_of() == pt.TealType.none
            assert not expr.has_return()

            expected = pt.TealSimpleBlock(
                [
                    pt.TealOp(None, pt.Op.int, value_to_set),
                    pt.TealOp(
                        None,
                        pt.Op.store,
                        cast(pt.ScratchVar, value._stored_value).slot,
                    ),
                ]
            )

            actual, _ = expr.__teal__(options)
            actual.addIncoming()
            actual = pt.TealBlock.NormalizeBlocks(actual)

            with pt.TealComponent.Context.ignoreExprEquality():
                assert actual == expected

        with pytest.raises(pt.TealInputError):
            value.set(test.maxValue + 1)

        with pytest.raises(pt.TealInputError):
            value.set(-1)


def test_Uint_set_expr():
    for test in testData:
        value = test.uintType.new_instance()
        expr = value.set(pt.Int(10) + pt.Int(1))
        assert expr.type_of() == pt.TealType.none
        assert not expr.has_return()

        upperBoundCheck = []
        if test.checkUpperBound:
            upperBoundCheck = [
                pt.TealOp(
                    None,
                    pt.Op.load,
                    cast(pt.ScratchVar, value._stored_value).slot,
                ),
                pt.TealOp(None, pt.Op.int, test.maxValue + 1),
                pt.TealOp(None, pt.Op.lt),
                pt.TealOp(None, pt.Op.assert_),
            ]

        expected = pt.TealSimpleBlock(
            [
                pt.TealOp(None, pt.Op.int, 10),
                pt.TealOp(None, pt.Op.int, 1),
                pt.TealOp(None, pt.Op.add),
                pt.TealOp(
                    None,
                    pt.Op.store,
                    cast(pt.ScratchVar, value._stored_value).slot,
                ),
            ]
            + upperBoundCheck
        )

        actual, _ = expr.__teal__(options)
        actual.addIncoming()
        actual = pt.TealBlock.NormalizeBlocks(actual)

        with pt.TealComponent.Context.ignoreExprEquality():
            assert actual == expected


def test_Uint_set_copy():
    for test in testData:
        value = test.uintType.new_instance()
        other = test.uintType.new_instance()
        expr = value.set(other)
        assert expr.type_of() == pt.TealType.none
        assert not expr.has_return()

        expected = pt.TealSimpleBlock(
            [
                pt.TealOp(
                    None,
                    pt.Op.load,
                    cast(pt.ScratchVar, other._stored_value).slot,
                ),
                pt.TealOp(
                    None,
                    pt.Op.store,
                    cast(pt.ScratchVar, value._stored_value).slot,
                ),
            ]
        )

        actual, _ = expr.__teal__(options)
        actual.addIncoming()
        actual = pt.TealBlock.NormalizeBlocks(actual)

        with pt.TealComponent.Context.ignoreExprEquality():
            assert actual == expected

        with pytest.raises(pt.TealInputError):
            value.set(abi.Bool())


def test_Uint_set_computed():
    byte_computed_value = ContainerType(abi.ByteTypeSpec(), pt.Int(0x22))

    for test in testData:
        computed_value = ContainerType(test.uintType, pt.Int(0x44))
        value = test.uintType.new_instance()
        expr = value.set(computed_value)
        assert expr.type_of() == pt.TealType.none
        assert not expr.has_return()

        expected = pt.TealSimpleBlock(
            [
                pt.TealOp(None, pt.Op.int, 0x44),
                pt.TealOp(
                    None,
                    pt.Op.store,
                    cast(pt.ScratchVar, value._stored_value).slot,
                ),
            ]
        )

        actual, _ = expr.__teal__(options)
        actual.addIncoming()
        actual = pt.TealBlock.NormalizeBlocks(actual)

        with pt.TealComponent.Context.ignoreExprEquality():
            assert actual == expected

        with pytest.raises(pt.TealInputError):
            value.set(byte_computed_value)


def test_Uint_get():
    for test in testData:
        value = test.uintType.new_instance()
        expr = value.get()
        assert expr.type_of() == pt.TealType.uint64
        assert not expr.has_return()

        expected = pt.TealSimpleBlock(
            [
                pt.TealOp(
                    expr,
                    pt.Op.load,
                    cast(pt.ScratchVar, value._stored_value).slot,
                ),
            ]
        )

        actual, _ = expr.__teal__(options)

        assert actual == expected


def test_Uint_decode():
    encoded = pt.Bytes("encoded")
    for test in testData:
        for start_index in (None, pt.Int(1)):
            for end_index in (None, pt.Int(2)):
                for length in (None, pt.Int(3)):
                    value = test.uintType.new_instance()
                    expr = value.decode(
                        encoded,
                        start_index=start_index,
                        end_index=end_index,
                        length=length,
                    )
                    assert expr.type_of() == pt.TealType.none
                    assert not expr.has_return()

                    expectedDecoding = value._stored_value.store(
                        test.expectedDecoding(encoded, start_index, end_index, length)
                    )
                    expected, _ = expectedDecoding.__teal__(options)
                    expected.addIncoming()
                    expected = pt.TealBlock.NormalizeBlocks(expected)

                    actual, _ = expr.__teal__(options)
                    actual.addIncoming()
                    actual = pt.TealBlock.NormalizeBlocks(actual)

                    with pt.TealComponent.Context.ignoreExprEquality():
                        assert actual == expected


def test_Uint_encode():
    for test in testData:
        value = test.uintType.new_instance()
        expr = value.encode()
        assert expr.type_of() == pt.TealType.bytes
        assert not expr.has_return()

        expected, _ = test.expectedEncoding(value).__teal__(options)
        expected.addIncoming()
        expected = pt.TealBlock.NormalizeBlocks(expected)

        actual, _ = expr.__teal__(options)
        actual.addIncoming()
        actual = pt.TealBlock.NormalizeBlocks(actual)

        with pt.TealComponent.Context.ignoreExprEquality():
            assert actual == expected


def test_ByteUint8_mutual_conversion():
    cases: List[Tuple[abi.UintTypeSpec, abi.UintTypeSpec]] = [
        (abi.Uint8TypeSpec(), abi.ByteTypeSpec()),
        (abi.ByteTypeSpec(), abi.Uint8TypeSpec()),
    ]
    for type_a, type_b in cases:
        type_b_instance = type_b.new_instance()
        other = type_a.new_instance()
        expr = type_b_instance.set(other)

        assert expr.type_of() == pt.TealType.none
        assert not expr.has_return()

        expected = pt.TealSimpleBlock(
            [
                pt.TealOp(
                    None,
                    pt.Op.load,
                    cast(pt.ScratchVar, other._stored_value).slot,
                ),
                pt.TealOp(
                    None,
                    pt.Op.store,
                    cast(pt.ScratchVar, type_b_instance._stored_value).slot,
                ),
            ]
        )

        actual, _ = expr.__teal__(options)
        actual.addIncoming()
        actual = pt.TealBlock.NormalizeBlocks(actual)

        with pt.TealComponent.Context.ignoreExprEquality():
            assert actual == expected



================================================
FILE: pyteal/ast/abi/util.py
================================================
from typing import (
    Any,
    Literal,
    Optional,
    Sequence,
    TypeVar,
    Union,
    cast,
    get_args,
    get_origin,
)

import algosdk.abi

from pyteal.errors import TealInputError
from pyteal.ast.expr import Expr
from pyteal.ast.int import Int
from pyteal.ast.substring import Extract, Substring, Suffix
from pyteal.ast.abi.type import TypeSpec, BaseType


def substring_for_decoding(
    encoded: Expr,
    *,
    start_index: Expr | None = None,
    end_index: Expr | None = None,
    length: Expr | None = None,
) -> Expr:
    """A helper function for getting the substring to decode according to the rules of BaseType.decode."""
    if length is not None and end_index is not None:
        raise TealInputError("length and end_index are mutually exclusive arguments")

    if start_index is not None:
        if length is not None:
            # substring from start_index to start_index + length
            return Extract(encoded, start_index, length)

        if end_index is not None:
            # substring from start_index to end_index
            return Substring(encoded, start_index, end_index)

        # substring from start_index to end of string
        return Suffix(encoded, start_index)

    if length is not None:
        # substring from 0 to length
        return Extract(encoded, Int(0), length)

    if end_index is not None:
        # substring from 0 to end_index
        return Substring(encoded, Int(0), end_index)

    # the entire string
    return encoded


def int_literal_from_annotation(annotation: Any) -> int:
    """Extract an integer from a Literal type annotation.

    Args:
        annotation: A Literal type annotation. E.g., `Literal[4]`. This must contain only a single
            integer value.

    Returns:
        The integer that the Literal represents.
    """
    origin = get_origin(annotation)
    args = get_args(annotation)

    if origin is not Literal:
        raise TypeError("Expected literal for argument. Got: {}".format(origin))

    if len(args) != 1 or type(args[0]) is not int:
        raise TypeError(
            "Expected single integer argument for Literal. Got: {}".format(args)
        )

    return args[0]


def type_spec_from_annotation(annotation: Any) -> TypeSpec:
    """Convert an ABI type annotation into the corresponding TypeSpec.

    For example, calling this function with the input `abi.StaticArray[abi.Bool, Literal[5]]` would
    return `abi.StaticArrayTypeSpec(abi.BoolTypeSpec(), 5)`.

    Args:
        annotation: An annotation representing an ABI type instance.

    Raises:
        TypeError: if the input annotation does not represent a valid ABI type instance or its
            arguments are invalid.

    Returns:
        The TypeSpec that corresponds to the input annotation.
    """
    from pyteal.ast.abi.bool import BoolTypeSpec, Bool
    from pyteal.ast.abi.uint import (
        ByteTypeSpec,
        Byte,
        Uint8TypeSpec,
        Uint8,
        Uint16TypeSpec,
        Uint16,
        Uint32TypeSpec,
        Uint32,
        Uint64TypeSpec,
        Uint64,
    )
    from pyteal.ast.abi.array_dynamic import (
        DynamicArrayTypeSpec,
        DynamicArray,
        DynamicBytesTypeSpec,
        DynamicBytes,
    )
    from pyteal.ast.abi.array_static import (
        StaticArrayTypeSpec,
        StaticArray,
        StaticBytesTypeSpec,
        StaticBytes,
    )
    from pyteal.ast.abi.tuple import (
        TupleTypeSpec,
        Tuple,
        Tuple0,
        Tuple1,
        Tuple2,
        Tuple3,
        Tuple4,
        Tuple5,
        NamedTuple,
        NamedTupleTypeSpec,
    )
    from pyteal.ast.abi.string import StringTypeSpec, String
    from pyteal.ast.abi.address import AddressTypeSpec, Address
    from pyteal.ast.abi.transaction import (
        Transaction,
        TransactionTypeSpec,
        PaymentTransaction,
        PaymentTransactionTypeSpec,
        KeyRegisterTransaction,
        KeyRegisterTransactionTypeSpec,
        AssetConfigTransaction,
        AssetConfigTransactionTypeSpec,
        AssetFreezeTransaction,
        AssetFreezeTransactionTypeSpec,
        AssetTransferTransaction,
        AssetTransferTransactionTypeSpec,
        ApplicationCallTransaction,
        ApplicationCallTransactionTypeSpec,
    )
    from pyteal.ast.abi.reference_type import (
        AccountTypeSpec,
        Account,
        AssetTypeSpec,
        Asset,
        ApplicationTypeSpec,
        Application,
    )

    origin = get_origin(annotation)
    if origin is None:
        origin = annotation

    args = get_args(annotation)

    if origin is Account:
        if len(args) != 0:
            raise TypeError("Account expects 0 arguments. Got: {}".format(args))
        return AccountTypeSpec()

    if origin is Asset:
        if len(args) != 0:
            raise TypeError("Asset expects 0 arguments. Got: {}".format(args))
        return AssetTypeSpec()

    if origin is Application:
        if len(args) != 0:
            raise TypeError("Application expects 0 arguments. Got: {}".format(args))
        return ApplicationTypeSpec()

    if origin is Bool:
        if len(args) != 0:
            raise TypeError("Bool expects 0 type arguments. Got: {}".format(args))
        return BoolTypeSpec()

    if origin is Byte:
        if len(args) != 0:
            raise TypeError("Byte expects 0 type arguments. Got: {}".format(args))
        return ByteTypeSpec()

    if origin is Uint8:
        if len(args) != 0:
            raise TypeError("Uint8 expects 0 type arguments. Got: {}".format(args))
        return Uint8TypeSpec()

    if origin is Uint16:
        if len(args) != 0:
            raise TypeError("Uint16 expects 0 type arguments. Got: {}".format(args))
        return Uint16TypeSpec()

    if origin is Uint32:
        if len(args) != 0:
            raise TypeError("Uint32 expects 0 type arguments. Got: {}".format(args))
        return Uint32TypeSpec()

    if origin is Uint64:
        if len(args) != 0:
            raise TypeError("Uint64 expects 0 type arguments. Got: {}".format(args))
        return Uint64TypeSpec()

    if origin is String:
        if len(args) != 0:
            raise TypeError("String expects 0 arguments. Got: {}".format(args))
        return StringTypeSpec()

    if origin is Address:
        if len(args) != 0:
            raise TypeError("Address expects 0 arguments. Got: {}".format(args))
        return AddressTypeSpec()

    if origin is DynamicBytes:
        if len(args) != 0:
            raise TypeError(f"DynamicBytes expect 0 type argument. Got: {args}")
        return DynamicBytesTypeSpec()

    if origin is DynamicArray:
        if len(args) != 1:
            raise TypeError(
                "DynamicArray expects 1 type argument. Got: {}".format(args)
            )
        value_type_spec = type_spec_from_annotation(args[0])
        return DynamicArrayTypeSpec(value_type_spec)

    if origin is StaticBytes:
        if len(args) != 1:
            raise TypeError(f"StaticBytes expect 1 type argument. Got: {args}")
        array_length = int_literal_from_annotation(args[0])
        return StaticBytesTypeSpec(array_length)

    if origin is StaticArray:
        if len(args) != 2:
            raise TypeError("StaticArray expects 1 type argument. Got: {}".format(args))
        value_type_spec = type_spec_from_annotation(args[0])
        array_length = int_literal_from_annotation(args[1])
        return StaticArrayTypeSpec(value_type_spec, array_length)

    if origin is Tuple:
        return TupleTypeSpec(*(type_spec_from_annotation(arg) for arg in args))

    if issubclass(origin, NamedTuple):
        return cast(NamedTupleTypeSpec, origin().type_spec())

    if origin is Tuple0:
        if len(args) != 0:
            raise TypeError("Tuple0 expects 0 type arguments. Got: {}".format(args))
        return TupleTypeSpec()

    if origin is Tuple1:
        if len(args) != 1:
            raise TypeError("Tuple1 expects 1 type argument. Got: {}".format(args))
        return TupleTypeSpec(*(type_spec_from_annotation(arg) for arg in args))

    if origin is Tuple2:
        if len(args) != 2:
            raise TypeError("Tuple2 expects 2 type arguments. Got: {}".format(args))
        return TupleTypeSpec(*(type_spec_from_annotation(arg) for arg in args))

    if origin is Tuple3:
        if len(args) != 3:
            raise TypeError("Tuple3 expects 3 type arguments. Got: {}".format(args))
        return TupleTypeSpec(*(type_spec_from_annotation(arg) for arg in args))

    if origin is Tuple4:
        if len(args) != 4:
            raise TypeError("Tuple4 expects 4 type arguments. Got: {}".format(args))
        return TupleTypeSpec(*(type_spec_from_annotation(arg) for arg in args))

    if origin is Tuple5:
        if len(args) != 5:
            raise TypeError("Tuple5 expects 5 type arguments. Got: {}".format(args))
        return TupleTypeSpec(*(type_spec_from_annotation(arg) for arg in args))

    if origin is Transaction:
        if len(args) != 0:
            raise TypeError("Transaction expects 0 type arguments. Got {}".format(args))
        return TransactionTypeSpec()

    if origin is PaymentTransaction:
        if len(args) != 0:
            raise TypeError(
                "PaymentTransaction expects 0 type arguments. Got {}".format(args)
            )
        return PaymentTransactionTypeSpec()

    if origin is KeyRegisterTransaction:
        if len(args) != 0:
            raise TypeError(
                "KeyRegisterTransaction expects 0 type arguments. Got {}".format(args)
            )
        return KeyRegisterTransactionTypeSpec()

    if origin is AssetConfigTransaction:
        if len(args) != 0:
            raise TypeError(
                "AssetConfigTransaction expects 0 type arguments. Got {}".format(args)
            )
        return AssetConfigTransactionTypeSpec()

    if origin is AssetFreezeTransaction:
        if len(args) != 0:
            raise TypeError(
                "AssetFreezeTransaction expects 0 type arguments. Got {}".format(args)
            )
        return AssetFreezeTransactionTypeSpec()

    if origin is AssetTransferTransaction:
        if len(args) != 0:
            raise TypeError(
                "AssetTransferTransaction expects 0 type arguments. Got {}".format(args)
            )
        return AssetTransferTransactionTypeSpec()

    if origin is ApplicationCallTransaction:
        if len(args) != 0:
            raise TypeError(
                "ApplicationCallTransaction expects 0 type arguments. Got {}".format(
                    args
                )
            )
        return ApplicationCallTransactionTypeSpec()

    raise TypeError("Unknown annotation origin: {}".format(origin))


T = TypeVar("T", bound=BaseType)


def contains_type_spec(ts: TypeSpec, targets: Sequence[TypeSpec]) -> bool:
    from pyteal.ast.abi.array_dynamic import DynamicArrayTypeSpec
    from pyteal.ast.abi.array_static import StaticArrayTypeSpec
    from pyteal.ast.abi.tuple import TupleTypeSpec

    stack: list[TypeSpec] = [ts]

    while stack:
        current = stack.pop()
        if current in targets:
            return True

        match current:
            case TupleTypeSpec():
                stack.extend(current.value_type_specs())
            case DynamicArrayTypeSpec():
                stack.append(current.value_type_spec())
            case StaticArrayTypeSpec():
                stack.append(current.value_type_spec())

    return False


def size_of(t: type[T]) -> int:
    """Get the size in bytes of an ABI type. Must be a static type"""

    ts = type_spec_from_annotation(t)
    if ts.is_dynamic():
        raise TealInputError("Cannot get size of dynamic type")

    return ts.byte_length_static()


def make(t: type[T]) -> T:
    """Create a new instance of an ABI type. The type to create is determined by the input argument,
    which must be a fully-specified type's class. Fully-specified means that every generic argument
    is given a value.

    For example:
        .. code-block:: python

                # both of these are equivalent
                a = abi.make(abi.Tuple2[abi.Uint64, abi.StaticArray[abi.Bool, Literal[8]]])
                b = abi.TupleTypeSpec(abi.Uint64TypeSpec(), abi.StaticArrayTypeSpec(abi.BoolTypeSpec(), 8))

    This is purely a convenience method over instantiating the type directly, which can be cumbersome
    due to the lengthy TypeSpec class names.

    Args:
        t: A fully-specified subclass of abi.BaseType.

    Returns:
        A new instance of the given type class.
    """
    return cast(T, type_spec_from_annotation(t).new_instance())


def algosdk_from_type_spec(t: TypeSpec) -> algosdk.abi.ABIType:
    from pyteal.ast.abi import ReferenceTypeSpecs, TransactionTypeSpecs

    if t in TransactionTypeSpecs:
        raise TealInputError(
            f"cannot map ABI transaction type spec {t!r} to an appropriate algosdk ABI type"
        )

    if t in ReferenceTypeSpecs:
        raise TealInputError(
            f"cannot map ABI reference type spec {t!r} to an appropriate algosdk ABI type"
        )

    return algosdk.abi.ABIType.from_string(str(t))


def algosdk_from_annotation(t: type[T]) -> algosdk.abi.ABIType:
    return algosdk_from_type_spec(type_spec_from_annotation(t))


def type_spec_from_algosdk(t: Union[algosdk.abi.ABIType, str]) -> TypeSpec:
    from pyteal.ast.abi.reference_type import ReferenceTypeSpecs
    from pyteal.ast.abi.transaction import TransactionTypeSpecs

    from pyteal.ast.abi.array_dynamic import DynamicArrayTypeSpec
    from pyteal.ast.abi.array_static import StaticArrayTypeSpec
    from pyteal.ast.abi.tuple import TupleTypeSpec
    from pyteal.ast.abi.bool import BoolTypeSpec
    from pyteal.ast.abi.string import StringTypeSpec
    from pyteal.ast.abi.address import AddressTypeSpec
    from pyteal.ast.abi.uint import (
        ByteTypeSpec,
        Uint8TypeSpec,
        Uint16TypeSpec,
        Uint32TypeSpec,
        Uint64TypeSpec,
    )

    match t:
        # Currently reference and transaction types are only strings
        case str():
            if algosdk.abi.is_abi_reference_type(t):
                ref_dict: dict[str, TypeSpec] = {
                    str(rts): rts for rts in ReferenceTypeSpecs
                }
                if t in ref_dict:
                    return ref_dict[t]
                else:
                    raise TealInputError(f"Invalid reference type: {t}")

            elif algosdk.abi.is_abi_transaction_type(t):
                txn_dict: dict[str, TypeSpec] = {
                    str(tts): tts for tts in TransactionTypeSpecs
                }
                if t in txn_dict:
                    return txn_dict[t]
                else:
                    raise TealInputError(f"Invalid transaction type: {t}")
            else:
                raise TealInputError(f"Invalid ABI type: {t}")

        case algosdk.abi.ABIType():
            match t:
                case algosdk.abi.ArrayDynamicType():
                    return DynamicArrayTypeSpec(type_spec_from_algosdk(t.child_type))
                case algosdk.abi.ArrayStaticType():
                    return StaticArrayTypeSpec(
                        type_spec_from_algosdk(t.child_type), t.static_length
                    )
                case algosdk.abi.TupleType():
                    return TupleTypeSpec(
                        *[type_spec_from_algosdk(ct) for ct in t.child_types]
                    )
                case algosdk.abi.UintType():
                    match t.bit_size:
                        case 8:
                            return Uint8TypeSpec()
                        case 16:
                            return Uint16TypeSpec()
                        case 32:
                            return Uint32TypeSpec()
                        case 64:
                            return Uint64TypeSpec()
                case algosdk.abi.ByteType():
                    return ByteTypeSpec()
                case algosdk.abi.BoolType():
                    return BoolTypeSpec()
                case algosdk.abi.StringType():
                    return StringTypeSpec()
                case algosdk.abi.AddressType():
                    return AddressTypeSpec()
                case algosdk.abi.UfixedType():
                    raise TealInputError("Ufixed not supported")

    raise TealInputError(f"Invalid Type: {t}")


def type_specs_from_signature(sig: str) -> tuple[list[TypeSpec], Optional[TypeSpec]]:
    sdk_method = algosdk.abi.Method.from_signature(sig)

    return_type = None
    if sdk_method.returns.type != algosdk.abi.Returns.VOID:
        return_type = type_spec_from_algosdk(sdk_method.returns.type)

    return [type_spec_from_algosdk(arg.type) for arg in sdk_method.args], return_type


def type_spec_is_assignable_to(a: TypeSpec, b: TypeSpec) -> bool:
    """Decides if the value of type :code:`a` can be assigned to or interpreted as another value of type :code:`b`.

    This method return true if and only if all of the following properties hold:

        * value of type :code:`a` has identical encoding as value of type :code:`b`
        * type :code:`b` is as general as, or more general than type :code:`a`

    For `abi.NamedTuple`, we allow mutual assigning between `abi.Tuple` and `abi.NamedTuple`.
    But between `abi.NamedTuple`, we only return true when the type specs are identical, or we cannot compare against generality.

    Some examples are illustrated as following:

    =========================== =========================== ============= ====================================================================
    Type :code:`a`              Type :code:`b`              Assignable?   Reason
    =========================== =========================== ============= ====================================================================
    :code:`DynamicArray[Byte]`  :code:`DynamicBytes`        :code:`True`  :code:`DynamicBytes` is as general as :code:`DynamicArray[Byte]`
    :code:`DynamicBytes`        :code:`DynamicArray[Byte]`  :code:`True`  :code:`DynamicArray[Byte]` is as general as :code:`DynamicBytes`
    :code:`StaticArray[Byte,N]` :code:`StaticBytes[N]`      :code:`True`  :code:`StaticBytes[N]` is as general as :code:`StaticArray[Byte,N]`
    :code:`StaticBytes[N]`      :code:`StaticArray[Byte,N]` :code:`True`  :code:`StaticArray[Byte,N]` is as general as :code:`StaticBytes[N]`
    :code:`String`              :code:`DynamicBytes`        :code:`True`  :code:`DynamicBytes` is more general than :code:`String`
    :code:`DynamicBytes`        :code:`String`              :code:`False` :code:`String` is more specific than :code:`DynamicBytes`
    :code:`Address`             :code:`StaticBytes[32]`     :code:`True`  :code:`StaticBytes[32]` is more general than :code:`Address`
    :code:`StaticBytes[32]`     :code:`Address`             :code:`False` :code:`Address` is more specific than :code:`StaticBytes[32]`
    :code:`PaymentTransaction`  :code:`Transaction`         :code:`True`  :code:`Transaction` is more general than :code:`PaymentTransaction`
    :code:`Transaction`         :code:`PaymentTransaction`  :code:`False` :code:`PaymentTransaction` is more specific than :code`Transaction`
    :code:`Uint8`               :code:`Byte`                :code:`True`  :code:`Uint8` is as general as :code:`Byte`
    :code:`Byte`                :code:`Uint8`               :code:`True`  :code:`Byte` is as general as :code:`Uint8`
    =========================== =========================== ============= ====================================================================

    Args:
        a: The abi.TypeSpec of the value on the right hand side of the assignment.
        b: The abi.TypeSpec of the value on the left hand side of the assignment.

    Returns:
        A boolean result on if type :code:`a` is assignable to type :code:`b`.
    """

    from pyteal.ast.abi import (
        TupleTypeSpec,
        NamedTupleTypeSpec,
        ArrayTypeSpec,
        StaticArrayTypeSpec,
        DynamicArrayTypeSpec,
        StringTypeSpec,
        AddressTypeSpec,
        UintTypeSpec,
    )

    match a, b:
        case NamedTupleTypeSpec(), NamedTupleTypeSpec():
            return a == b
        case TupleTypeSpec(), TupleTypeSpec():
            a, b = cast(TupleTypeSpec, a), cast(TupleTypeSpec, b)
            if a.length_static() != b.length_static():
                return False
            return all(
                map(
                    lambda ab: type_spec_is_assignable_to(ab[0], ab[1]),
                    zip(a.value_type_specs(), b.value_type_specs()),
                )
            )
        case ArrayTypeSpec(), ArrayTypeSpec():
            a, b = cast(ArrayTypeSpec, a), cast(ArrayTypeSpec, b)
            if not type_spec_is_assignable_to(a.value_type_spec(), b.value_type_spec()):
                return False
            match a, b:
                case AddressTypeSpec(), StaticArrayTypeSpec():
                    a, b = cast(AddressTypeSpec, a), cast(StaticArrayTypeSpec, b)
                    return a.length_static() == b.length_static()
                case StaticArrayTypeSpec(), AddressTypeSpec():
                    return False
                case StaticArrayTypeSpec(), StaticArrayTypeSpec():
                    a, b = cast(StaticArrayTypeSpec, a), cast(StaticArrayTypeSpec, b)
                    return a.length_static() == b.length_static()
                case StringTypeSpec(), DynamicArrayTypeSpec():
                    return True
                case DynamicArrayTypeSpec(), StringTypeSpec():
                    return False
                case DynamicArrayTypeSpec(), DynamicArrayTypeSpec():
                    return True
            return False
        case UintTypeSpec(), UintTypeSpec():
            a, b = cast(UintTypeSpec, a), cast(UintTypeSpec, b)
            return a.size == b.size

    if isinstance(a, type(b)):
        return True
    elif str(a) == str(b):
        return True

    return False



================================================
FILE: pyteal/ast/abi/util_test.py
================================================
from typing import Callable, NamedTuple, Literal, Optional, Any, get_origin
from inspect import isabstract
import pytest

import algosdk.abi

import pyteal as pt
from pyteal import abi
from pyteal.ast.abi.util import (
    substring_for_decoding,
    int_literal_from_annotation,
    type_spec_from_algosdk,
    type_spec_is_assignable_to,
)

options = pt.CompileOptions(version=5)


def bfs_on_inheritance(tt: type):
    type_queue = [tt]
    visited_types = set()
    while type_queue:
        current_type = type_queue.pop()
        yield current_type
        visited_types.add(current_type)
        for child_type in current_type.__subclasses__():
            if child_type in visited_types:
                continue
            type_queue.append(child_type)


class SubstringTest(NamedTuple):
    start_index: Optional[pt.Expr]
    end_index: Optional[pt.Expr]
    length: Optional[pt.Expr]
    expected: Callable[[pt.Expr], pt.Expr | type[Exception]]


SUBSTRING_TEST_CASES: list[SubstringTest] = [
    SubstringTest(
        start_index=None, end_index=None, length=None, expected=lambda encoded: encoded
    ),
    SubstringTest(
        start_index=None,
        end_index=None,
        length=pt.Int(4),
        expected=lambda encoded: pt.Extract(encoded, pt.Int(0), pt.Int(4)),
    ),
    SubstringTest(
        start_index=None,
        end_index=pt.Int(4),
        length=None,
        expected=lambda encoded: pt.Substring(encoded, pt.Int(0), pt.Int(4)),
    ),
    SubstringTest(
        start_index=None,
        end_index=pt.Int(4),
        length=pt.Int(5),
        expected=lambda _: pt.TealInputError,
    ),
    SubstringTest(
        start_index=pt.Int(4),
        end_index=None,
        length=None,
        expected=lambda encoded: pt.Suffix(encoded, pt.Int(4)),
    ),
    SubstringTest(
        start_index=pt.Int(4),
        end_index=None,
        length=pt.Int(5),
        expected=lambda encoded: pt.Extract(encoded, pt.Int(4), pt.Int(5)),
    ),
    SubstringTest(
        start_index=pt.Int(4),
        end_index=pt.Int(5),
        length=None,
        expected=lambda encoded: pt.Substring(encoded, pt.Int(4), pt.Int(5)),
    ),
    SubstringTest(
        start_index=pt.Int(4),
        end_index=pt.Int(5),
        length=pt.Int(6),
        expected=lambda _: pt.TealInputError,
    ),
]


@pytest.mark.parametrize(
    "start_index, end_index, length, expected", SUBSTRING_TEST_CASES
)
def test_substringForDecoding(
    start_index: Optional[pt.Expr],
    end_index: Optional[pt.Expr],
    length: Optional[pt.Expr],
    expected: Callable[[pt.Expr], pt.Expr | type[Exception]],
):
    encoded = pt.Bytes("encoded")

    expected_expr = expected(encoded)

    if not isinstance(expected_expr, pt.Expr):
        with pytest.raises(expected_expr):
            substring_for_decoding(
                encoded,
                start_index=start_index,
                end_index=end_index,
                length=length,
            )
        return

    expr = substring_for_decoding(
        encoded,
        start_index=start_index,
        end_index=end_index,
        length=length,
    )
    assert expr.type_of() == pt.TealType.bytes
    assert not expr.has_return()

    expected_blocks, _ = expected_expr.__teal__(options)
    expected_blocks.addIncoming()
    expected_blocks = pt.TealBlock.NormalizeBlocks(expected_blocks)

    actual, _ = expr.__teal__(options)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)

    with pt.TealComponent.Context.ignoreExprEquality():
        assert actual == expected_blocks


class IntAnnotationTest(NamedTuple):
    annotation: Any
    expected: int | type[Exception]


IN_ANNOTATION_TEST_CASES: list[IntAnnotationTest] = [
    IntAnnotationTest(annotation=Literal[0], expected=0),
    IntAnnotationTest(annotation=Literal[1], expected=1),
    IntAnnotationTest(annotation=Literal[10], expected=10),
    IntAnnotationTest(annotation=Literal[True], expected=TypeError),
    IntAnnotationTest(annotation=Literal["test"], expected=TypeError),
    IntAnnotationTest(annotation=Literal[b"test"], expected=TypeError),
    IntAnnotationTest(annotation=Literal[None], expected=TypeError),
    IntAnnotationTest(annotation=Literal[0, 1], expected=TypeError),
    IntAnnotationTest(annotation=Literal, expected=TypeError),
]


@pytest.mark.parametrize("annotation, expected", IN_ANNOTATION_TEST_CASES)
def test_int_literal_from_annotation(annotation: Any, expected: int | type[Exception]):
    if not isinstance(expected, int):
        with pytest.raises(expected):
            int_literal_from_annotation(annotation)
        return

    actual = int_literal_from_annotation(annotation)
    assert actual == expected


class TypeAnnotationTest(NamedTuple):
    annotation: Any
    expected: abi.TypeSpec | type[Exception]


class ExampleNamedTuple(abi.NamedTuple):
    a: abi.Field[abi.Uint16]
    b: abi.Field[abi.DynamicArray[abi.Byte]]
    c: abi.Field[abi.Address]


TYPE_ANNOTATION_TEST_CASES: list[TypeAnnotationTest] = [
    TypeAnnotationTest(annotation=abi.Bool, expected=abi.BoolTypeSpec()),
    TypeAnnotationTest(annotation=abi.Byte, expected=abi.ByteTypeSpec()),
    TypeAnnotationTest(annotation=abi.Uint8, expected=abi.Uint8TypeSpec()),
    TypeAnnotationTest(annotation=abi.Uint16, expected=abi.Uint16TypeSpec()),
    TypeAnnotationTest(annotation=abi.Uint32, expected=abi.Uint32TypeSpec()),
    TypeAnnotationTest(annotation=abi.Uint64, expected=abi.Uint64TypeSpec()),
    TypeAnnotationTest(
        annotation=abi.DynamicArray[abi.Uint32],
        expected=abi.DynamicArrayTypeSpec(abi.Uint32TypeSpec()),
    ),
    TypeAnnotationTest(
        annotation=abi.DynamicArray[abi.Uint64],
        expected=abi.DynamicArrayTypeSpec(abi.Uint64TypeSpec()),
    ),
    TypeAnnotationTest(
        annotation=abi.DynamicArray[abi.DynamicArray[abi.Uint32]],
        expected=abi.DynamicArrayTypeSpec(
            abi.DynamicArrayTypeSpec(abi.Uint32TypeSpec())
        ),
    ),
    TypeAnnotationTest(
        annotation=abi.DynamicArray,
        expected=TypeError,
    ),
    TypeAnnotationTest(
        annotation=abi.StaticArray[abi.Uint32, Literal[0]],
        expected=abi.StaticArrayTypeSpec(abi.Uint32TypeSpec(), 0),
    ),
    TypeAnnotationTest(
        annotation=abi.StaticArray[abi.Uint32, Literal[10]],
        expected=abi.StaticArrayTypeSpec(abi.Uint32TypeSpec(), 10),
    ),
    TypeAnnotationTest(
        annotation=abi.StaticArray[abi.Bool, Literal[500]],
        expected=abi.StaticArrayTypeSpec(abi.BoolTypeSpec(), 500),
    ),
    TypeAnnotationTest(
        annotation=abi.StaticArray[abi.Bool, Literal[-1]],
        expected=TypeError,
    ),
    TypeAnnotationTest(
        annotation=abi.StaticArray[abi.Bool, int],
        expected=TypeError,
    ),
    TypeAnnotationTest(
        annotation=abi.StaticArray,
        expected=TypeError,
    ),
    TypeAnnotationTest(
        annotation=abi.StaticArray[abi.StaticArray[abi.Bool, Literal[500]], Literal[5]],
        expected=abi.StaticArrayTypeSpec(
            abi.StaticArrayTypeSpec(abi.BoolTypeSpec(), 500), 5
        ),
    ),
    TypeAnnotationTest(annotation=abi.Address, expected=abi.AddressTypeSpec()),
    TypeAnnotationTest(
        annotation=abi.StaticBytes[Literal[10]],
        expected=abi.StaticBytesTypeSpec(10),
    ),
    TypeAnnotationTest(
        annotation=abi.DynamicArray[abi.StaticArray[abi.Bool, Literal[500]]],
        expected=abi.DynamicArrayTypeSpec(
            abi.StaticArrayTypeSpec(abi.BoolTypeSpec(), 500)
        ),
    ),
    TypeAnnotationTest(annotation=abi.String, expected=abi.StringTypeSpec()),
    TypeAnnotationTest(
        annotation=abi.DynamicBytes,
        expected=abi.DynamicBytesTypeSpec(),
    ),
    TypeAnnotationTest(annotation=abi.Tuple, expected=abi.TupleTypeSpec()),
    TypeAnnotationTest(annotation=abi.Tuple0, expected=abi.TupleTypeSpec()),
    TypeAnnotationTest(
        annotation=abi.Tuple1[abi.Uint32],
        expected=abi.TupleTypeSpec(abi.Uint32TypeSpec()),
    ),
    TypeAnnotationTest(
        annotation=abi.Tuple1,
        expected=TypeError,
    ),
    TypeAnnotationTest(
        annotation=abi.Tuple2[abi.Uint32, abi.Uint16],
        expected=abi.TupleTypeSpec(abi.Uint32TypeSpec(), abi.Uint16TypeSpec()),
    ),
    TypeAnnotationTest(
        annotation=abi.Tuple2,
        expected=TypeError,
    ),
    TypeAnnotationTest(
        annotation=abi.Tuple3[abi.Uint32, abi.Uint16, abi.Byte],
        expected=abi.TupleTypeSpec(
            abi.Uint32TypeSpec(), abi.Uint16TypeSpec(), abi.ByteTypeSpec()
        ),
    ),
    TypeAnnotationTest(
        annotation=abi.Tuple3,
        expected=TypeError,
    ),
    TypeAnnotationTest(
        annotation=abi.Tuple3[
            abi.Tuple1[abi.Uint32],
            abi.StaticArray[abi.Bool, Literal[55]],
            abi.Tuple2[abi.Uint32, abi.Uint16],
        ],
        expected=abi.TupleTypeSpec(
            abi.TupleTypeSpec(abi.Uint32TypeSpec()),
            abi.StaticArrayTypeSpec(abi.BoolTypeSpec(), 55),
            abi.TupleTypeSpec(abi.Uint32TypeSpec(), abi.Uint16TypeSpec()),
        ),
    ),
    TypeAnnotationTest(
        annotation=abi.Tuple4[abi.Uint32, abi.Uint16, abi.Byte, abi.Bool],
        expected=abi.TupleTypeSpec(
            abi.Uint32TypeSpec(),
            abi.Uint16TypeSpec(),
            abi.ByteTypeSpec(),
            abi.BoolTypeSpec(),
        ),
    ),
    TypeAnnotationTest(
        annotation=abi.Tuple4,
        expected=TypeError,
    ),
    TypeAnnotationTest(
        annotation=abi.Tuple5[abi.Uint32, abi.Uint16, abi.Byte, abi.Bool, abi.Tuple0],
        expected=abi.TupleTypeSpec(
            abi.Uint32TypeSpec(),
            abi.Uint16TypeSpec(),
            abi.ByteTypeSpec(),
            abi.BoolTypeSpec(),
            abi.TupleTypeSpec(),
        ),
    ),
    TypeAnnotationTest(
        annotation=abi.Tuple5,
        expected=TypeError,
    ),
    TypeAnnotationTest(
        annotation=ExampleNamedTuple, expected=ExampleNamedTuple().type_spec()
    ),
    TypeAnnotationTest(
        annotation=list[abi.Uint16],
        expected=TypeError,
    ),
    TypeAnnotationTest(annotation=abi.Transaction, expected=abi.TransactionTypeSpec()),
    TypeAnnotationTest(
        annotation=abi.PaymentTransaction, expected=abi.PaymentTransactionTypeSpec()
    ),
    TypeAnnotationTest(
        annotation=abi.KeyRegisterTransaction,
        expected=abi.KeyRegisterTransactionTypeSpec(),
    ),
    TypeAnnotationTest(
        annotation=abi.AssetConfigTransaction,
        expected=abi.AssetConfigTransactionTypeSpec(),
    ),
    TypeAnnotationTest(
        annotation=abi.AssetFreezeTransaction,
        expected=abi.AssetFreezeTransactionTypeSpec(),
    ),
    TypeAnnotationTest(
        annotation=abi.AssetTransferTransaction,
        expected=abi.AssetTransferTransactionTypeSpec(),
    ),
    TypeAnnotationTest(
        annotation=abi.ApplicationCallTransaction,
        expected=abi.ApplicationCallTransactionTypeSpec(),
    ),
    TypeAnnotationTest(annotation=abi.Account, expected=abi.AccountTypeSpec()),
    TypeAnnotationTest(annotation=abi.Asset, expected=abi.AssetTypeSpec()),
    TypeAnnotationTest(annotation=abi.Application, expected=abi.ApplicationTypeSpec()),
]


@pytest.mark.parametrize("annotation, expected", TYPE_ANNOTATION_TEST_CASES)
def test_type_spec_from_annotation(
    annotation: Any, expected: abi.TypeSpec | type[Exception]
):
    if not isinstance(expected, abi.TypeSpec):
        with pytest.raises(expected):
            abi.type_spec_from_annotation(annotation)
        return

    actual = abi.type_spec_from_annotation(annotation)
    assert actual == expected

    new_instance = actual.new_instance()

    annotation_origin = get_origin(annotation)
    if annotation_origin is None:
        # get_origin will return None for annotations without generic args, e.g. `Byte`
        annotation_origin = annotation

    assert isinstance(
        new_instance, annotation_origin
    ), "TypeSpec.new_instance() returns a value that does not match the annotation type"

    assert (
        actual == new_instance.type_spec()
    ), "TypeSpec.new_instance().type_spec() does not match original TypeSpec"


@pytest.mark.parametrize("subclass", bfs_on_inheritance(abi.BaseType))
def test_type_spec_from_annotation_is_exhaustive(subclass: type):
    # This test is to make sure there are no new subclasses of BaseType that type_spec_from_annotation
    # is not aware of.

    if isabstract(subclass):
        # abstract class type annotations should not be supported
        with pytest.raises(TypeError, match=r"^Unknown annotation origin"):
            abi.type_spec_from_annotation(subclass)
        return

    if subclass is pt.abi.NamedTuple:
        with pytest.raises(pt.TealInputError, match=r"^NamedTuple must be subclassed$"):
            abi.type_spec_from_annotation(subclass)
        return

    try:
        # if subclass is not generic, this will succeed
        abi.type_spec_from_annotation(subclass)
    except TypeError as e:
        # if subclass is generic, we should get an error that is NOT "Unknown annotation origin"
        assert "Unknown annotation origin" not in str(e)

    if issubclass(subclass, pt.abi.NamedTuple):
        # ignore NamedTuple subclasses for the following check
        return

    # make sure there is a testcase for this subclass in test_type_spec_from_annotation
    assert any(
        subclass is testcase.annotation or subclass is get_origin(testcase.annotation)
        for testcase in TYPE_ANNOTATION_TEST_CASES
    ), f"Test case for subclass {subclass} is not present in TYPE_ANNOTATION_TEST_CASES"


def test_make():
    actual = abi.make(abi.Tuple2[abi.Uint64, abi.StaticArray[abi.Bool, Literal[8]]])
    expected_type_spec = abi.TupleTypeSpec(
        abi.Uint64TypeSpec(), abi.StaticArrayTypeSpec(abi.BoolTypeSpec(), 8)
    )

    assert actual.type_spec() == expected_type_spec
    assert type(actual) is abi.Tuple2


def test_size_of():
    values = [
        (abi.Uint8, 1),
        (abi.Address, 32),
        (abi.StaticArray[abi.Uint16, Literal[10]], 2 * 10),
        (abi.StaticBytes[Literal[36]], 36),
    ]

    for t, s in values:
        assert abi.size_of(t) == s

    with pytest.raises(pt.TealInputError):
        abi.size_of(abi.String)

    with pytest.raises(pt.TealInputError):
        abi.size_of(abi.DynamicBytes)


ABI_TRANSLATION_TEST_CASES = [
    # Test for byte/bool/address/strings
    (algosdk.abi.ByteType(), "byte", abi.ByteTypeSpec(), abi.Byte),
    (algosdk.abi.BoolType(), "bool", abi.BoolTypeSpec(), abi.Bool),
    (
        algosdk.abi.AddressType(),
        "address",
        abi.AddressTypeSpec(),
        abi.Address,
    ),
    (algosdk.abi.StringType(), "string", abi.StringTypeSpec(), abi.String),
    # Test for dynamic array type
    (
        algosdk.abi.ArrayDynamicType(algosdk.abi.UintType(32)),
        "uint32[]",
        abi.DynamicArrayTypeSpec(abi.Uint32TypeSpec()),
        abi.DynamicArray[abi.Uint32],
    ),
    (
        algosdk.abi.ArrayDynamicType(
            algosdk.abi.ArrayDynamicType(algosdk.abi.ByteType())
        ),
        "byte[][]",
        abi.DynamicArrayTypeSpec(abi.DynamicArrayTypeSpec(abi.ByteTypeSpec())),
        abi.DynamicArray[abi.DynamicArray[abi.Byte]],
    ),
    # TODO: Turn these tests on when PyTeal supports ufixed<N>x<M>
    # cf https://github.com/algorandfoundation/ARCs/blob/main/ARCs/arc-0004.md#types
    # (
    #     algosdk.abi.ArrayDynamicType(algosdk.abi.UfixedType(256, 64)),
    #     "ufixed256x64[]",
    #     abi.DynamicArrayTypeSpec(abi.UfixedTypeSpec(256, 64)),
    # ),
    # # Test for static array type
    # (
    #     algosdk.abi.ArrayStaticType(algosdk.abi.UfixedType(128, 10), 100),
    #     "ufixed128x10[100]",
    #     abi.ArrayStaticTypeSpec(abi.UfixedTypeSpec(128, 10), 100),
    # ),
    (
        algosdk.abi.ArrayStaticType(
            algosdk.abi.ArrayStaticType(algosdk.abi.BoolType(), 256),
            100,
        ),
        "bool[256][100]",
        abi.StaticArrayTypeSpec(
            abi.StaticArrayTypeSpec(abi.BoolTypeSpec(), 256),
            100,
        ),
        abi.StaticArray[abi.StaticArray[abi.Bool, Literal[256]], Literal[100]],
    ),
    # Test for tuple
    (algosdk.abi.TupleType([]), "()", abi.TupleTypeSpec(), abi.Tuple0),
    (
        algosdk.abi.TupleType(
            [
                algosdk.abi.UintType(16),
                algosdk.abi.TupleType(
                    [
                        algosdk.abi.ByteType(),
                        algosdk.abi.ArrayStaticType(algosdk.abi.AddressType(), 10),
                    ]
                ),
            ]
        ),
        "(uint16,(byte,address[10]))",
        abi.TupleTypeSpec(
            abi.Uint16TypeSpec(),
            abi.TupleTypeSpec(
                abi.ByteTypeSpec(),
                abi.StaticArrayTypeSpec(abi.AddressTypeSpec(), 10),
            ),
        ),
        abi.Tuple2[
            abi.Uint16,
            abi.Tuple2[
                abi.Byte,
                abi.StaticArray[abi.Address, Literal[10]],
            ],
        ],
    ),
    (
        algosdk.abi.TupleType(
            [
                algosdk.abi.UintType(64),
                algosdk.abi.TupleType(
                    [
                        algosdk.abi.ByteType(),
                        algosdk.abi.ArrayStaticType(algosdk.abi.AddressType(), 10),
                    ]
                ),
                algosdk.abi.TupleType([]),
                algosdk.abi.BoolType(),
            ]
        ),
        "(uint64,(byte,address[10]),(),bool)",
        abi.TupleTypeSpec(
            abi.Uint64TypeSpec(),
            abi.TupleTypeSpec(
                abi.ByteTypeSpec(),
                abi.StaticArrayTypeSpec(abi.AddressTypeSpec(), 10),
            ),
            abi.TupleTypeSpec(),
            abi.BoolTypeSpec(),
        ),
        abi.Tuple4[
            abi.Uint64,
            abi.Tuple2[
                abi.Byte,
                abi.StaticArray[abi.Address, Literal[10]],
            ],
            abi.Tuple,
            abi.Bool,
        ],
    ),
    # TODO: Turn the following test on when PyTeal supports ufixed<N>x<M>
    # cf https://github.com/algorandfoundation/ARCs/blob/main/ARCs/arc-0004.md#types
    # (
    #     algosdk.abi.TupleType(
    #         [
    #             algosdk.abi.UfixedType(256, 16),
    #             algosdk.abi.TupleType(
    #                 [
    #                     algosdk.abi.TupleType(
    #                         [
    #                             algosdk.abi.StringType(),
    #                         ]
    #                     ),
    #                     algosdk.abi.BoolType(),
    #                     algosdk.abi.TupleType(
    #                         [
    #                             algosdk.abi.AddressType(),
    #                             algosdk.abi.UintType(8),
    #                         ]
    #                     ),
    #                 ]
    #             ),
    #         ]
    #     ),
    #     "(ufixed256x16,((string),bool,(address,uint8)))",
    #     abi.TupleType(
    #         [
    #             abi.UfixedType(256, 16),
    #             abi.TupleType(
    #                 [
    #                     abi.TupleType(
    #                         [
    #                             abi.StringType(),
    #                         ]
    #                     ),
    #                     abi.BoolType(),
    #                     abi.TupleType(
    #                         [
    #                             abi.AddressType(),
    #                             abi.UintType(8),
    #                         ]
    #                     ),
    #                 ]
    #             ),
    #         ]
    #     ),
    # ),
    (
        "cannot map ABI transaction type spec <pyteal.abi.TransactionTypeSpec",
        "txn",
        abi.TransactionTypeSpec(),
        abi.Transaction,
    ),
    (
        "cannot map ABI transaction type spec <pyteal.abi.PaymentTransactionTypeSpec",
        "pay",
        abi.PaymentTransactionTypeSpec(),
        abi.PaymentTransaction,
    ),
    (
        "cannot map ABI transaction type spec <pyteal.abi.KeyRegisterTransactionTypeSpec",
        "keyreg",
        abi.KeyRegisterTransactionTypeSpec(),
        abi.KeyRegisterTransaction,
    ),
    (
        "cannot map ABI transaction type spec <pyteal.abi.AssetConfigTransactionTypeSpec",
        "acfg",
        abi.AssetConfigTransactionTypeSpec(),
        abi.AssetConfigTransaction,
    ),
    (
        "cannot map ABI transaction type spec <pyteal.abi.AssetTransferTransactionTypeSpec",
        "axfer",
        abi.AssetTransferTransactionTypeSpec(),
        abi.AssetTransferTransaction,
    ),
    (
        "cannot map ABI transaction type spec <pyteal.abi.AssetFreezeTransactionTypeSpec",
        "afrz",
        abi.AssetFreezeTransactionTypeSpec(),
        abi.AssetFreezeTransaction,
    ),
    (
        "cannot map ABI transaction type spec <pyteal.abi.ApplicationCallTransactionTypeSpec",
        "appl",
        abi.ApplicationCallTransactionTypeSpec(),
        abi.ApplicationCallTransaction,
    ),
    (
        "cannot map ABI reference type spec <pyteal.abi.AccountTypeSpec",
        "account",
        abi.AccountTypeSpec(),
        abi.Account,
    ),
    (
        "cannot map ABI reference type spec <pyteal.abi.ApplicationTypeSpec",
        "application",
        abi.ApplicationTypeSpec(),
        abi.Application,
    ),
    (
        "cannot map ABI reference type spec <pyteal.abi.AssetTypeSpec",
        "asset",
        abi.AssetTypeSpec(),
        abi.Asset,
    ),
]

ABI_SIGNATURE_TYPESPEC_CASES = [
    (
        "check(uint64,uint64)uint64",
        [abi.Uint64TypeSpec(), abi.Uint64TypeSpec()],
        abi.Uint64TypeSpec(),
    ),
    (
        "check(uint64[],uint64)uint64",
        [abi.DynamicArrayTypeSpec(abi.Uint64TypeSpec()), abi.Uint64TypeSpec()],
        abi.Uint64TypeSpec(),
    ),
    (
        "check(uint64[5],uint64)uint64",
        [abi.StaticArrayTypeSpec(abi.Uint64TypeSpec(), 5), abi.Uint64TypeSpec()],
        abi.Uint64TypeSpec(),
    ),
    (
        "check(uint64,uint64)uint64[]",
        [abi.Uint64TypeSpec(), abi.Uint64TypeSpec()],
        abi.DynamicArrayTypeSpec(abi.Uint64TypeSpec()),
    ),
    (
        "check(uint64,uint64)uint64[5]",
        [abi.Uint64TypeSpec(), abi.Uint64TypeSpec()],
        abi.StaticArrayTypeSpec(abi.Uint64TypeSpec(), 5),
    ),
    (
        "check((uint64,uint64),asset)string",
        [
            abi.TupleTypeSpec(abi.Uint64TypeSpec(), abi.Uint64TypeSpec()),
            abi.AssetTypeSpec(),
        ],
        abi.StringTypeSpec(),
    ),
    (
        "check(string,asset)(uint64,uint64)",
        [abi.StringTypeSpec(), abi.AssetTypeSpec()],
        abi.TupleTypeSpec(abi.Uint64TypeSpec(), abi.Uint64TypeSpec()),
    ),
    (
        "check(account,asset,application)string",
        [abi.AccountTypeSpec(), abi.AssetTypeSpec(), abi.ApplicationTypeSpec()],
        abi.StringTypeSpec(),
    ),
    (
        "check(pay,txn,appl)string",
        [
            abi.PaymentTransactionTypeSpec(),
            abi.TransactionTypeSpec(),
            abi.ApplicationCallTransactionTypeSpec(),
        ],
        abi.StringTypeSpec(),
    ),
    ("check(uint64,uint64)void", [abi.Uint64TypeSpec(), abi.Uint64TypeSpec()], None),
]


@pytest.mark.parametrize(
    "algosdk_abi, abi_string, pyteal_abi_ts, pyteal_abi",
    ABI_TRANSLATION_TEST_CASES,
)
def test_abi_type_translation(algosdk_abi, abi_string, pyteal_abi_ts, pyteal_abi):
    print(f"({algosdk_abi}, {abi_string}, {pyteal_abi_ts}),")

    assert pyteal_abi_ts == abi.type_spec_from_annotation(pyteal_abi)

    assert str(pyteal_abi_ts.new_instance()) == abi_string

    if abi_string in (
        "account",
        "application",
        "asset",
        "txn",
        "pay",
        "keyreg",
        "acfg",
        "axfer",
        "afrz",
        "appl",
    ):
        assert str(pyteal_abi_ts) == abi_string

        with pytest.raises(pt.TealInputError) as tie:
            abi.algosdk_from_type_spec(pyteal_abi_ts)
        assert str(tie.value).startswith(algosdk_abi)

        with pytest.raises(pt.TealInputError) as tie:
            abi.algosdk_from_annotation(pyteal_abi)
        assert str(tie.value).startswith(algosdk_abi)

        return

    assert str(algosdk_abi) == abi_string == str(pyteal_abi_ts)
    assert (
        algosdk_abi
        == algosdk.abi.ABIType.from_string(abi_string)
        == algosdk.abi.ABIType.from_string(str(pyteal_abi_ts))
    )
    assert algosdk_abi == abi.algosdk_from_type_spec(pyteal_abi_ts)
    assert algosdk_abi == abi.algosdk_from_annotation(pyteal_abi)


@pytest.mark.parametrize("case", ABI_TRANSLATION_TEST_CASES)
def test_sdk_abi_translation(case):
    # Errors are strings in the 0th element
    if type(case[0]) is str:
        return
    assert type_spec_from_algosdk(case[0]) == case[2]


@pytest.mark.parametrize("sig_str, sig_args, sig_rets", ABI_SIGNATURE_TYPESPEC_CASES)
def test_sdk_type_specs_from_signature(sig_str, sig_args, sig_rets):
    args, ret = abi.type_specs_from_signature(sig_str)
    assert args == sig_args
    assert ret == sig_rets


class NamedTDecl(abi.NamedTuple):
    a: abi.Field[abi.Uint64]
    b: abi.Field[
        abi.Tuple3[abi.PaymentTransaction, abi.Address, abi.StaticBytes[Literal[16]]]
    ]
    c: abi.Field[abi.Transaction]


class NamedTComp0(abi.NamedTuple):
    a0: abi.Field[abi.String]
    a1: abi.Field[abi.Address]


class NamedTComp1(abi.NamedTuple):
    b0: abi.Field[abi.DynamicBytes]
    b1: abi.Field[abi.StaticBytes[Literal[32]]]


class NamedTComp2(abi.NamedTuple):
    b1: abi.Field[abi.Address]
    b0: abi.Field[abi.DynamicBytes]


class NamedTComp2SameField(abi.NamedTuple):
    b1: abi.Field[abi.Address]
    b0: abi.Field[abi.DynamicBytes]


class SafeBidirectional(NamedTuple):
    xs: list[abi.TypeSpec]


SAFE_BIDIRECTIONAL_TEST_CASES: list[SafeBidirectional] = (
    [
        SafeBidirectional(
            [
                abi.type_spec_from_annotation(abi.StaticArray[abi.Byte, Literal[10]]),
                abi.type_spec_from_annotation(abi.StaticBytes[Literal[10]]),
            ],
        ),
        SafeBidirectional(
            [abi.DynamicArrayTypeSpec(abi.Uint8TypeSpec()), abi.DynamicBytesTypeSpec()]
        ),
        SafeBidirectional([abi.Uint8TypeSpec(), abi.ByteTypeSpec()]),
        SafeBidirectional([abi.BoolTypeSpec()]),
        SafeBidirectional([abi.StringTypeSpec()]),
        SafeBidirectional([abi.AddressTypeSpec()]),
        SafeBidirectional(
            [
                abi.type_spec_from_annotation(abi.DynamicBytes),
                abi.type_spec_from_annotation(abi.DynamicArray[abi.Byte]),
            ]
        ),
        SafeBidirectional(
            [
                abi.type_spec_from_annotation(
                    abi.Tuple3[
                        abi.Uint64,
                        abi.Tuple3[
                            abi.PaymentTransaction,
                            abi.Address,
                            abi.StaticArray[abi.Byte, Literal[16]],
                        ],
                        abi.Transaction,
                    ]
                ),
                abi.type_spec_from_annotation(NamedTDecl),
            ]
        ),
    ]
    + [
        SafeBidirectional([spec])
        for spec in abi.ReferenceTypeSpecs + abi.TransactionTypeSpecs
    ]
    + [
        SafeBidirectional([spec_t()])
        for spec_t in bfs_on_inheritance(abi.UintTypeSpec)
        if not isabstract(spec_t)
    ]
)


@pytest.mark.parametrize("tc", SAFE_BIDIRECTIONAL_TEST_CASES)
def test_type_spec_is_assignable_safe_bidirectional(tc: SafeBidirectional):
    assert len(tc.xs) > 0
    for a in tc.xs:
        for b in tc.xs:
            assert type_spec_is_assignable_to(a, b)


@pytest.mark.parametrize("ts", bfs_on_inheritance(abi.TypeSpec))
def test_type_spec_is_assignable_safe_bidirectional_full_coverage(ts: type):
    def exists_in_safe_bidirectional(_ts: type):
        for safe_bidirectional in SAFE_BIDIRECTIONAL_TEST_CASES:
            for t in safe_bidirectional.xs:
                if type(t) is _ts:
                    return True
        return False

    if isabstract(ts):
        assert not exists_in_safe_bidirectional(ts)
    else:
        assert exists_in_safe_bidirectional(ts)


class SafeAssignment(NamedTuple):
    a: abi.TypeSpec
    bs: list[abi.TypeSpec]


SAFE_ASSIGNMENT_TEST_CASES: list[SafeAssignment] = [
    SafeAssignment(
        abi.StringTypeSpec(),
        [abi.DynamicBytesTypeSpec(), abi.DynamicArrayTypeSpec(abi.ByteTypeSpec())],
    ),
    SafeAssignment(
        abi.type_spec_from_annotation(NamedTDecl),
        [
            abi.type_spec_from_annotation(
                abi.Tuple3[
                    abi.Uint64,
                    abi.Tuple3[
                        abi.Transaction,
                        abi.Address,
                        abi.StaticArray[abi.Byte, Literal[16]],
                    ],
                    abi.Transaction,
                ]
            ),
        ],
    ),
    SafeAssignment(
        abi.type_spec_from_annotation(
            abi.Tuple3[
                abi.Uint64,
                abi.Tuple3[
                    abi.PaymentTransaction,
                    abi.Address,
                    abi.StaticArray[abi.Byte, Literal[16]],
                ],
                abi.PaymentTransaction,
            ]
        ),
        [abi.type_spec_from_annotation(NamedTDecl)],
    ),
    SafeAssignment(
        abi.AddressTypeSpec(),
        [abi.StaticArrayTypeSpec(abi.ByteTypeSpec(), 32), abi.StaticBytesTypeSpec(32)],
    ),
] + [
    SafeAssignment(spec, [abi.TransactionTypeSpec()])
    for spec in abi.TransactionTypeSpecs
    if spec != abi.TransactionTypeSpec()
]


@pytest.mark.parametrize("tc", SAFE_ASSIGNMENT_TEST_CASES)
def test_type_spec_is_assignable_safe_assignment(tc: SafeAssignment):
    assert len(tc.bs) > 0
    for b in tc.bs:
        assert type_spec_is_assignable_to(tc.a, b)
        assert not type_spec_is_assignable_to(b, tc.a)


@pytest.mark.parametrize("ts", bfs_on_inheritance(abi.TypeSpec))
def test_type_spec_is_assignable_safe_assignment_full_coverage(ts: type):
    def exists_in_safe_assignment(_ts: type):
        for safe_assignment in SAFE_ASSIGNMENT_TEST_CASES:
            if type(safe_assignment.a) is _ts:
                return True
            for t in safe_assignment.bs:
                if type(t) is _ts:
                    return True
        return False

    # Abstract types and types without safe assignments should _not_ appear in test cases.
    # These typespecs are only assignable to themselves, and that forms a bidirectional assignment.
    # Otherwise, they are unsafe bidirectional with all the other non-abstract typespecs.
    if isabstract(ts) or ts in {
        abi.AccountTypeSpec,
        abi.ApplicationTypeSpec,
        abi.AssetTypeSpec,
        abi.BoolTypeSpec,
        abi.ByteTypeSpec,
        abi.Uint8TypeSpec,
        abi.Uint16TypeSpec,
        abi.Uint32TypeSpec,
        abi.Uint64TypeSpec,
    }:
        assert not exists_in_safe_assignment(ts)
    else:
        assert exists_in_safe_assignment(ts)


class UnsafeBidirectional(NamedTuple):
    xs: list[abi.TypeSpec]


UNSAFE_BIDIRECTIONAL_TEST_CASES: list[UnsafeBidirectional] = [
    UnsafeBidirectional(
        [
            abi.Uint8TypeSpec(),
            abi.Uint16TypeSpec(),
            abi.Uint32TypeSpec(),
            abi.Uint64TypeSpec(),
            abi.BoolTypeSpec(),
        ]
    ),
    UnsafeBidirectional(
        [
            abi.ByteTypeSpec(),
            abi.Uint16TypeSpec(),
            abi.Uint32TypeSpec(),
            abi.Uint64TypeSpec(),
            abi.BoolTypeSpec(),
        ]
    ),
    UnsafeBidirectional(
        [abi.DynamicBytesTypeSpec(), abi.DynamicArrayTypeSpec(abi.Uint16TypeSpec())]
    ),
    UnsafeBidirectional(
        [abi.StaticBytesTypeSpec(7), abi.StaticArrayTypeSpec(abi.ByteTypeSpec(), 11)]
    ),
    UnsafeBidirectional(
        [
            abi.StringTypeSpec(),
            abi.DynamicArrayTypeSpec(abi.Uint32TypeSpec()),
            abi.DynamicArrayTypeSpec(abi.Uint64TypeSpec()),
            abi.AddressTypeSpec(),
            abi.StaticBytesTypeSpec(33),
        ]
    ),
    UnsafeBidirectional(
        [
            abi.type_spec_from_annotation(NamedTDecl),
            abi.type_spec_from_annotation(NamedTComp0),
            abi.type_spec_from_annotation(NamedTComp1),
            abi.type_spec_from_annotation(NamedTComp2),
            abi.type_spec_from_annotation(NamedTComp2SameField),
        ]
    ),
    UnsafeBidirectional(
        [
            abi.type_spec_from_annotation(NamedTComp1),
            abi.TupleTypeSpec(
                abi.AddressTypeSpec(),
                abi.StaticArrayTypeSpec(abi.Uint16TypeSpec(), 100),
            ),
        ]
    ),
    UnsafeBidirectional(
        [spec for spec in abi.TransactionTypeSpecs if spec != abi.TransactionTypeSpec()]
        + [abi.BoolTypeSpec()]
    ),
    UnsafeBidirectional(abi.ReferenceTypeSpecs + [abi.TransactionTypeSpec()]),
]


@pytest.mark.parametrize("tc", UNSAFE_BIDIRECTIONAL_TEST_CASES)
def test_type_spec_is_assignable_unsafe_bidirectional(tc: UnsafeBidirectional):
    for ia, a in enumerate(tc.xs):
        for ib, b in enumerate(tc.xs):
            if ia == ib:
                assert type_spec_is_assignable_to(a, b)
                assert type_spec_is_assignable_to(b, a)
                continue
            assert not type_spec_is_assignable_to(a, b)


@pytest.mark.parametrize("ts", bfs_on_inheritance(abi.TypeSpec))
def test_type_spec_is_assignable_unsafe_bidirectional_full_coverage(ts: type):
    def exists_in_unsafe_bidirectional(_ts: type):
        for unsafe_bidirectional in UNSAFE_BIDIRECTIONAL_TEST_CASES:
            for t in unsafe_bidirectional.xs:
                if type(t) is _ts:
                    return True
        return False

    if isabstract(ts):
        assert not exists_in_unsafe_bidirectional(ts)
    else:
        assert exists_in_unsafe_bidirectional(ts)



================================================
FILE: pyteal/compiler/__init__.py
================================================
from pyteal.compiler.compiler import (
    MAX_TEAL_VERSION,
    MIN_TEAL_VERSION,
    DEFAULT_TEAL_VERSION,
    MAX_PROGRAM_VERSION,
    MIN_PROGRAM_VERSION,
    DEFAULT_PROGRAM_VERSION,
    CompileOptions,
    Compilation,
    CompileResults,
    compileTeal,
)
from pyteal.compiler.optimizer import OptimizeOptions
from pyteal.compiler.sourcemap import PyTealSourceMap, R3SourceMap


__all__ = [
    "MAX_TEAL_VERSION",
    "MIN_TEAL_VERSION",
    "DEFAULT_TEAL_VERSION",
    "MAX_PROGRAM_VERSION",
    "MIN_PROGRAM_VERSION",
    "DEFAULT_PROGRAM_VERSION",
    "CompileOptions",
    "Compilation",
    "CompileResults",
    "compileTeal",
    "OptimizeOptions",
    "PyTealSourceMap",
    "R3SourceMap",
]



================================================
FILE: pyteal/compiler/compiler.py
================================================
from dataclasses import dataclass
from typing import Dict, Final, List, Optional, Set, Tuple, cast

from algosdk.v2client.algod import AlgodClient

from pyteal.ast import Expr, Return, Seq, SubroutineDeclaration, SubroutineDefinition
from pyteal.compiler.constants import createConstantBlocks
from pyteal.compiler.flatten import flattenBlocks, flattenSubroutines
from pyteal.compiler.optimizer import OptimizeOptions, apply_global_optimizations
from pyteal.compiler.scratchslots import (
    assignScratchSlotsToSubroutines,
    collect_unoptimized_slots,
)
from pyteal.compiler.sort import sortBlocks
from pyteal.compiler.sourcemap import (
    _PyTealSourceMapper,
    PyTealSourceMap,
)
from pyteal.compiler.subroutines import (
    resolveSubroutines,
    spillLocalSlotsDuringRecursion,
)
from pyteal.errors import SourceMapDisabledError, TealInputError, TealInternalError
from pyteal.ir import (
    Mode,
    Op,
    TealBlock,
    TealComponent,
    TealOp,
    TealPragma,
    TealSimpleBlock,
)
from pyteal.stack_frame import NatalStackFrame, sourcemapping_off_context
from pyteal.types import TealType
from pyteal.util import algod_with_assertion


MAX_PROGRAM_VERSION = 10
FRAME_POINTERS_VERSION = 8
DEFAULT_SCRATCH_SLOT_OPTIMIZE_VERSION = 9
MIN_PROGRAM_VERSION = 2
DEFAULT_PROGRAM_VERSION = MIN_PROGRAM_VERSION


"""Deprecated. Use MAX_PROGRAM_VERSION instead."""
MAX_TEAL_VERSION = MAX_PROGRAM_VERSION
"""Deprecated. Use MIN_PROGRAM_VERSION instead."""
MIN_TEAL_VERSION = MIN_PROGRAM_VERSION
"""Deprecated. Use DEFAULT_PROGRAM_VERSION instead."""
DEFAULT_TEAL_VERSION = DEFAULT_PROGRAM_VERSION


class CompileOptions:
    def __init__(
        self,
        *,
        mode: Mode = Mode.Signature,
        version: int = DEFAULT_PROGRAM_VERSION,
        optimize: Optional[OptimizeOptions] = None,
    ) -> None:
        self.mode: Final[Mode] = mode
        self.version: Final[int] = version
        self.optimize: Final[OptimizeOptions] = optimize or OptimizeOptions()
        self.use_frame_pointers: Final[bool] = self.optimize.use_frame_pointers(
            self.version
        )

        self.currentSubroutine: Optional[SubroutineDefinition] = None

        self.breakBlocksStack: List[List[TealSimpleBlock]] = []
        self.continueBlocksStack: List[List[TealSimpleBlock]] = []

    def setSubroutine(self, subroutine: Optional[SubroutineDefinition]) -> None:
        self.currentSubroutine = subroutine

    def enterLoop(self) -> None:
        self.breakBlocksStack.append([])
        self.continueBlocksStack.append([])

    def isInLoop(self) -> bool:
        return len(self.breakBlocksStack) != 0

    def addLoopBreakBlock(self, block: TealSimpleBlock) -> None:
        if len(self.breakBlocksStack) == 0:
            raise TealInternalError("Cannot add break block when no loop is active")
        self.breakBlocksStack[-1].append(block)

    def addLoopContinueBlock(self, block: TealSimpleBlock) -> None:
        if len(self.continueBlocksStack) == 0:
            raise TealInternalError("Cannot add continue block when no loop is active")
        self.continueBlocksStack[-1].append(block)

    def exitLoop(self) -> Tuple[List[TealSimpleBlock], List[TealSimpleBlock]]:
        if len(self.breakBlocksStack) == 0 or len(self.continueBlocksStack) == 0:
            raise TealInternalError("Cannot exit loop when no loop is active")
        return self.breakBlocksStack.pop(), self.continueBlocksStack.pop()


def verifyOpsForVersion(teal: List[TealComponent], version: int):
    """Verify that all TEAL operations are allowed in the specified version.

    Args:
        teal: Code to check.
        mode: The version to check against.

    Raises:
        TealInputError: if teal contains an operation not allowed in version.
    """
    for stmt in teal:
        if isinstance(stmt, TealOp):
            op = stmt.getOp()
            if op.min_version > version:
                raise TealInputError(
                    "Op not supported in program version {}: {}. Minimum required version is {}".format(
                        version, op, op.min_version
                    )
                )


def verifyOpsForMode(teal: List[TealComponent], mode: Mode):
    """Verify that all TEAL operations are allowed in mode.

    Args:
        teal: Code to check.
        mode: The mode to check against.

    Raises:
        TealInputError: if teal contains an operation not allowed in mode.
    """
    for stmt in teal:
        if isinstance(stmt, TealOp):
            op = stmt.getOp()
            if not op.mode & mode:
                raise TealInputError(
                    "Op not supported in {} mode: {}".format(mode.name, op)
                )


def compileSubroutine(
    ast: Expr,
    options: CompileOptions,
    subroutineGraph: Dict[SubroutineDefinition, Set[SubroutineDefinition]],
    subroutine_start_blocks: Dict[Optional[SubroutineDefinition], TealBlock],
    subroutine_end_blocks: Dict[Optional[SubroutineDefinition], TealBlock],
) -> None:
    currentSubroutine = (
        cast(SubroutineDeclaration, ast).subroutine
        if isinstance(ast, SubroutineDeclaration)
        else None
    )

    ret_expr: Optional[Expr] = None
    if not ast.has_return():
        if ast.type_of() == TealType.none:
            ret_expr = Return()  # T2PT2
            ret_expr.trace = ast.trace
            seq_expr = Seq([ast, ret_expr])
            seq_expr.trace = ret_expr.trace
            ast = seq_expr
        else:
            ret_expr = Return(ast)  # T2PT3
            ret_expr.trace = ast.trace
            ast = ret_expr

    options.setSubroutine(currentSubroutine)

    start, end = ast.__teal__(options)
    start.addIncoming()
    start.validateTree()
    if currentSubroutine:
        decl = currentSubroutine.get_declaration_by_option(options.use_frame_pointers)
        if end.ops:
            end.ops[0]._sframes_container = decl

        if deferred_expr := decl.deferred_expr:
            # this represents code that should be inserted before each retsub op
            for block in TealBlock.Iterate(start):
                if not any(op.getOp() == Op.retsub for op in block.ops):
                    continue

                if len(block.ops) != 1:
                    # we expect all retsub ops to be in their own block at this point since
                    # TealBlock.NormalizeBlocks has not yet been used
                    raise TealInternalError(
                        f"Expected retsub to be the only op in the block, but there are {len(block.ops)} ops"
                    )

                # we invoke __teal__ here and not outside of this loop because the same block cannot be
                # added in multiple places to the control flow graph
                deferred_start, deferred_end = deferred_expr.__teal__(options)
                deferred_start.addIncoming()
                deferred_start.validateTree()

                # insert deferred blocks between the previous block(s) and this one
                deferred_start.incoming = block.incoming
                block.incoming = [deferred_end]
                deferred_end.nextBlock = block

                for prev in deferred_start.incoming:
                    prev.replaceOutgoing(block, deferred_start)

                if block is start:
                    # this is the start block, replace start
                    start = deferred_start

    start.validateTree()

    start = TealBlock.NormalizeBlocks(start)
    start.validateTree()

    subroutine_start_blocks[currentSubroutine] = start
    subroutine_end_blocks[currentSubroutine] = end

    referencedSubroutines: Set[SubroutineDefinition] = set()
    for block in TealBlock.Iterate(start):
        for stmt in block.ops:
            for subroutine in stmt.getSubroutines():
                referencedSubroutines.add(subroutine)

    if currentSubroutine is not None:
        subroutineGraph[currentSubroutine] = referencedSubroutines

    newSubroutines = referencedSubroutines - subroutine_start_blocks.keys()
    for subroutine in sorted(newSubroutines, key=lambda subroutine: subroutine.id):
        compileSubroutine(
            subroutine.get_declaration_by_option(options.use_frame_pointers),  # T2PT4
            options,
            subroutineGraph,
            subroutine_start_blocks,
            subroutine_end_blocks,
        )


def sort_subroutine_blocks(
    subroutine_start_blocks: Dict[Optional[SubroutineDefinition], TealBlock],
    subroutine_end_blocks: Dict[Optional[SubroutineDefinition], TealBlock],
) -> Dict[Optional[SubroutineDefinition], List[TealComponent]]:
    subroutine_mapping: Dict[Optional[SubroutineDefinition], List[TealComponent]] = (
        dict()
    )
    for subroutine, start in subroutine_start_blocks.items():
        order = sortBlocks(start, subroutine_end_blocks[subroutine])
        subroutine_mapping[subroutine] = flattenBlocks(order)

    return subroutine_mapping


@dataclass(frozen=True)
class CompileResults:
    """Summary of compilation"""

    teal: str
    sourcemap: PyTealSourceMap | None = None


CompileResults.__module__ = "pyteal"


@dataclass
class _FullCompilationBundle:
    """
    Private class that groups together various artifacts required and produced by the compiler.

    The following artifacts should _NOT_ be returned to the user, as they could
    interfere with the compiler's idempotency. For example, keeping these
    artifacts around could make it difficult to guarantee that scratchslots
    are allocated as efficiently as possible, and assuming that such artifacts
    might continue existing after compilation interferes with the goal of making
    the compiler as reliable and efficient as possible:
    * teal_chunks
    * components

    NOTE: `annotated_teal` can grow quite large and become unsuitable for compilation as algod's compile
    endpoint may throw a "request body too large" error.
    Therefore, it is recommended that `teal` be used for algod compilation purposes.
    """

    ast: Expr
    mode: Mode
    version: int
    assemble_constants: bool
    optimize: Optional[OptimizeOptions]
    teal: str
    teal_chunks: list[str]
    components: list[TealComponent]
    sourcemapper: _PyTealSourceMapper | None = None
    annotated_teal: str | None = None

    def get_results(self) -> CompileResults:
        sourcemap: PyTealSourceMap | None = None
        if self.sourcemapper:
            sourcemap = self.sourcemapper.get_sourcemap(self.teal)

        return CompileResults(self.teal, sourcemap)


class Compilation:
    """
    A class that encapsulates the data needed to compile a PyTeal expression
    """

    def __init__(
        self,
        ast: Expr,
        mode: Mode,
        *,
        version: int = DEFAULT_PROGRAM_VERSION,
        assemble_constants: bool = False,
        assembly_type_track: bool = True,
        optimize: OptimizeOptions | None = None,
    ):
        """
        Instantiate a Compilation object providing the necessary data to compile a PyTeal expression.

        Args:
            ast: The PyTeal expression to assemble
            mode: The program's mode for execution. Either :any:`Mode.Signature` or :any:`Mode.Application`
            version (optional):  The program version used to assemble the program. This will determine which
                expressions and fields are able to be used in the program and how expressions compile to
                TEAL opcodes. Defaults to 2 if not included.
            assembleConstants (optional): When `True`, the compiler will produce a program with fully
                assembled constants, rather than using the pseudo-ops `int`, `byte`, and `addr`. These
                constants will be assembled in the most space-efficient way, so enabling this may reduce
                the compiled program's size. Enabling this option requires a minimum program version of 3.
                Defaults to `False`.
            assembly_type_track (optional): When `True`, the compiler will produce a program with type
                checking at assembly time (default behavior). When `False`, the compiler will turn off
                type checking at assembly time. This is only useful if PyTeal is producing incorrect
                TEAL code, or the assembler is producing incorrect type errors. Defaults to `True`.
            optimize (optional): `OptimizeOptions` that determine which optimizations will be applied.
        """
        self.ast = ast
        self.mode = mode
        self.version = version
        self.assemble_constants = assemble_constants
        self.assembly_type_track = assembly_type_track
        self.optimize: OptimizeOptions = optimize or OptimizeOptions()

    def compile(
        self,
        *,
        with_sourcemap: bool = False,
        teal_filename: str | None = None,
        pcs_in_sourcemap: bool = False,
        algod_client: AlgodClient | None = None,
        annotate_teal: bool = False,
        annotate_teal_headers: bool = False,
        annotate_teal_concise: bool = False,
    ) -> CompileResults:
        """Compile the PyTeal :code:`ast` to produce a TEAL program and other artifacts.

        Args:
            with_sourcemap (optional): When `True`, the compiler will produce a source map that associates
                each line of the generated TEAL program back to the original PyTeal source code. Defaults to `False`.
            teal_filename (optional): The filename to use in the sourcemap. Defaults to `None`.
            pcs_in_sourcemap (optional): When `True`, the compiler will include the program counter in
                relevant sourcemap artifacts. This requires an `AlgodClient` (see next param). Defaults to `False`.
            algod_client (optional): An `AlgodClient` to use to fetch program counters. Defaults to `None`.
                When `pcs_in_sourcemap` is `True` and `algod_client` is not provided, the compiler will
                assume that an Algorand Sandbox algod client is running on the default port (4001) and -if
                this is not the case- will raise an exception.
            annotate_teal (optional): When `True`, the compiler will produce a TEAL program with comments
                that describe the PyTeal source code that generated each line of the program. Defaults to `False`.
            annotate_teal_headers (optional): When `True` along with `annotate_teal` being `True`, a header
                line with column names will be added at the top of the annotated teal. Defaults to `False`.
            annotate_teal_concise (optional): When `True` along with `annotate_teal` being `True`, the compiler
                will provide fewer columns in the annotated teal. Defaults to `False`.

        Returns:
            A `CompileResults` object with the following data:
            * teal: the TEAL program
            * sourcemap (optional): if `with_sourcemap` is `True`, the following source map data is provided:
                * teal_filename (optional): the TEAL filename, if this was provided
                * r3_sourcemap: an `R3SourceMap` object that maps the generated TEAL program back to the original PyTeal source code and conforms to the specs of the `Source Map Revision 3 Proposal <https://sourcemaps.info/spec.html>`_
                * pc_sourcemap (optional): if `pcs_in_sourcemap` is `True`, a `PCSourceMap` object that maps the program counters assembled by the `AlgodClient` which was utilized in the compilation back to the TEAL program which was generated by the compiler. This conforms to the specs of the `Source Map Revision 3 Proposal <https://sourcemaps.info/spec.html>`_
                * annotated_teal (optional): if `annotate_teal` is `True`, the TEAL program with comments that describe the PyTeal source code that generated each line of the program

        Raises:
            TealInputError: if an operation in ast is not supported by the supplied mode and version.
            TealInternalError: if an internal error is encountered during compilation.
        """
        return self._compile_impl(
            with_sourcemap=with_sourcemap,
            teal_filename=teal_filename,
            pcs_in_sourcemap=pcs_in_sourcemap,
            algod_client=algod_client,
            annotate_teal=annotate_teal,
            annotate_teal_headers=annotate_teal_headers,
            annotate_teal_concise=annotate_teal_concise,
        ).get_results()

    def _compile_impl(
        self,
        with_sourcemap: bool = True,
        teal_filename: str | None = None,
        pcs_in_sourcemap: bool = False,
        algod_client: AlgodClient | None = None,
        annotate_teal: bool = False,
        annotate_teal_headers: bool = False,
        annotate_teal_concise: bool = True,
    ) -> _FullCompilationBundle:
        if (
            not (MIN_PROGRAM_VERSION <= self.version <= MAX_PROGRAM_VERSION)
            or type(self.version) is not int
        ):
            raise TealInputError(
                "Unsupported program version: {}. Excepted an integer in the range [{}, {}]".format(
                    self.version, MIN_PROGRAM_VERSION, MAX_PROGRAM_VERSION
                )
            )

        if with_sourcemap and NatalStackFrame.sourcemapping_is_off():
            raise SourceMapDisabledError()

        if annotate_teal and not with_sourcemap:
            raise ValueError(
                "In order annotate generated teal source, must set with_sourcemap True"
            )

        if pcs_in_sourcemap:
            # bootstrap an algod_client if not provided, and in either case, run a healthcheck
            algod_client = algod_with_assertion(
                algod_client, msg="Adding PC's to sourcemap requires live Algod"
            )

        options = CompileOptions(
            mode=self.mode, version=self.version, optimize=self.optimize
        )

        subroutineGraph: Dict[SubroutineDefinition, Set[SubroutineDefinition]] = dict()
        subroutine_start_blocks: Dict[Optional[SubroutineDefinition], TealBlock] = (
            dict()
        )
        subroutine_end_blocks: Dict[Optional[SubroutineDefinition], TealBlock] = dict()
        compileSubroutine(
            self.ast,
            options,
            subroutineGraph,
            subroutine_start_blocks,
            subroutine_end_blocks,
        )

        # note: optimizations are off by default, in which case, apply_global_optimizations
        # won't make any changes. Because the optimizer is invoked on a subroutine's
        # control flow graph, the optimizer requires context across block boundaries. This
        # is necessary for the dependency checking of local slots. Global slots, slots
        # used by DynamicScratchVar, and reserved slots are not optimized.
        if options.optimize.optimize_scratch_slots(self.version):
            options.optimize._skip_slots = collect_unoptimized_slots(
                subroutine_start_blocks
            )
            for start in subroutine_start_blocks.values():
                apply_global_optimizations(start, options.optimize, self.version)

        localSlotAssignments: Dict[Optional[SubroutineDefinition], Set[int]] = (
            assignScratchSlotsToSubroutines(subroutine_start_blocks)
        )

        subroutineMapping: Dict[Optional[SubroutineDefinition], List[TealComponent]] = (
            sort_subroutine_blocks(subroutine_start_blocks, subroutine_end_blocks)
        )

        spillLocalSlotsDuringRecursion(
            self.version, subroutineMapping, subroutineGraph, localSlotAssignments
        )

        subroutineLabels = resolveSubroutines(subroutineMapping)
        components: list[TealComponent] = flattenSubroutines(
            subroutineMapping, subroutineLabels, options
        )

        verifyOpsForVersion(components, options.version)
        verifyOpsForMode(components, options.mode)

        if self.assemble_constants:
            if self.version < 3:
                raise TealInternalError(
                    f"The minimum program version required to enable assembleConstants is 3. The current version is {self.version}."
                )
            components = createConstantBlocks(components)

        componentsPrefix: list[TealComponent] = [TealPragma(version=self.version)]
        if not self.assembly_type_track:
            componentsPrefix.append(TealPragma(type_track=False))

        components = componentsPrefix + components  # T2PT0
        teal_chunks = [tl.assemble() for tl in components]
        teal_code = "\n".join(teal_chunks)

        full_cpb = _FullCompilationBundle(
            ast=self.ast,
            mode=self.mode,
            version=self.version,
            assemble_constants=self.assemble_constants,
            optimize=self.optimize,
            teal=teal_code,
            teal_chunks=teal_chunks,
            components=components,
        )
        if not with_sourcemap:
            return full_cpb

        # Below is purely for the source mapper:

        source_mapper = _PyTealSourceMapper(
            teal_chunks=teal_chunks,
            components=components,
            build=True,
            teal_filename=teal_filename,
            include_pcs=pcs_in_sourcemap,
            algod=algod_client,
            annotate_teal=annotate_teal,
            annotate_teal_headers=annotate_teal_headers,
            annotate_teal_concise=annotate_teal_concise,
        )
        full_cpb.sourcemapper = source_mapper

        # run a second time without, and assert that the same teal is produced
        with sourcemapping_off_context():
            assert NatalStackFrame.sourcemapping_is_off()

            # implicitly recursive call!!
            teal_code_wo = compileTeal(
                self.ast,
                self.mode,
                version=self.version,
                assembleConstants=self.assemble_constants,
                optimize=self.optimize,
            )

            _PyTealSourceMapper._validate_teal_identical(
                teal_code_wo,
                teal_code,
                msg="FATAL ERROR. Program without sourcemaps (LEFT) differs from Program with (RIGHT)",
            )

        return full_cpb


Compilation.__module__ = "pyteal"


def compileTeal(
    ast: Expr,
    mode: Mode,
    *,
    version: int = DEFAULT_PROGRAM_VERSION,
    assembleConstants: bool = False,
    assembly_type_track: bool = True,
    optimize: OptimizeOptions | None = None,
) -> str:
    """Compile a PyTeal expression into TEAL assembly.

    Args:
        ast: The PyTeal expression to assemble.
        mode: The mode of the program to assemble. Must be Signature or Application.
        version (optional): The program version used to assemble the program. This will determine which
            expressions and fields are able to be used in the program and how expressions compile to
            TEAL opcodes. Defaults to 2 if not included.
        assembleConstants (optional): When true, the compiler will produce a program with fully
            assembled constants, rather than using the pseudo-ops `int`, `byte`, and `addr`. These
            constants will be assembled in the most space-efficient way, so enabling this may reduce
            the compiled program's size. Enabling this option requires a minimum program version of 3.
            Defaults to false.
        assembly_type_track (optional): When `True`, the compiler will produce a program with type
            checking at assembly time (default behavior). When `False`, the compiler will turn off
            type checking at assembly time. This is only useful if PyTeal is producing incorrect
            TEAL code, or the assembler is producing incorrect type errors. Defaults to `True`.
        optimize (optional): OptimizeOptions that determine which optimizations will be applied.

    Returns:
        A TEAL assembly program compiled from the input expression.

    Raises:
        TealInputError: if an operation in ast is not supported by the supplied mode and version.
        TealInternalError: if an internal error is encountered during compilation.
    """
    bundle = Compilation(
        ast,
        mode,
        version=version,
        assemble_constants=assembleConstants,
        assembly_type_track=assembly_type_track,
        optimize=optimize,
    )._compile_impl(with_sourcemap=False)
    return bundle.teal



================================================
FILE: pyteal/compiler/compiler_test.py
================================================
from pathlib import Path

import pytest

import pyteal as pt

ROUTER_FIXTURES = Path.cwd() / "tests" / "teal" / "router"


def test_compile_single():
    expr = pt.Int(1)

    expected = """
#pragma version 2
int 1
return
""".strip()
    actual_application = pt.compileTeal(expr, pt.Mode.Application)
    actual_signature = pt.compileTeal(expr, pt.Mode.Signature)

    assert actual_application == actual_signature
    assert actual_application == expected


def test_compile_sequence():
    expr = pt.Seq([pt.Pop(pt.Int(1)), pt.Pop(pt.Int(2)), pt.Int(3) + pt.Int(4)])

    expected = """
#pragma version 2
int 1
pop
int 2
pop
int 3
int 4
+
return
""".strip()
    actual_application = pt.compileTeal(expr, pt.Mode.Application)
    actual_signature = pt.compileTeal(expr, pt.Mode.Signature)

    assert actual_application == actual_signature
    assert actual_application == expected


def test_compile_branch():
    expr = pt.If(pt.Int(1)).Then(pt.Int(2)).Else(pt.Int(3))

    expected = """
#pragma version 2
int 1
bnz main_l2
int 3
b main_l3
main_l2:
int 2
main_l3:
return
""".strip()
    actual_application = pt.compileTeal(expr, pt.Mode.Application)
    actual_signature = pt.compileTeal(expr, pt.Mode.Signature)

    assert actual_application == actual_signature
    assert actual_application == expected


def test_compile_branch_multiple():
    expr = (
        pt.If(pt.Int(1))
        .Then(pt.Int(2))
        .ElseIf(pt.Int(3))
        .Then(pt.Int(4))
        .Else(pt.Int(5))
    )

    expected = """
#pragma version 2
int 1
bnz main_l4
int 3
bnz main_l3
int 5
b main_l5
main_l3:
int 4
b main_l5
main_l4:
int 2
main_l5:
return
""".strip()
    actual_application = pt.compileTeal(expr, pt.Mode.Application)
    actual_signature = pt.compileTeal(expr, pt.Mode.Signature)

    assert actual_application == actual_signature
    assert actual_application == expected


def test_empty_branch():
    program = pt.Seq(
        [
            pt.If(pt.Txn.application_id() == pt.Int(0)).Then(pt.Seq()),
            pt.Approve(),
        ]
    )

    expected = """#pragma version 5
txn ApplicationID
int 0
==
bnz main_l1
main_l1:
int 1
return
    """.strip()
    actual = pt.compileTeal(
        program, pt.Mode.Application, version=5, assembleConstants=False
    )
    assert actual == expected


def test_compile_mode():
    expr = pt.App.globalGet(pt.Bytes("key"))

    expected = """
#pragma version 2
byte "key"
app_global_get
return
""".strip()
    actual_application = pt.compileTeal(expr, pt.Mode.Application)

    assert actual_application == expected

    with pytest.raises(pt.TealInputError):
        pt.compileTeal(expr, pt.Mode.Signature)


def test_compile_version_invalid():
    expr = pt.Int(1)

    with pytest.raises(pt.TealInputError):
        pt.compileTeal(expr, pt.Mode.Signature, version=1)  # too small

    with pytest.raises(pt.TealInputError):
        pt.compileTeal(
            expr, pt.Mode.Signature, version=pt.MAX_PROGRAM_VERSION + 1
        )  # too large

    with pytest.raises(pt.TealInputError):
        pt.compileTeal(expr, pt.Mode.Signature, version=2.0)  # decimal


def test_compile_version_2():
    expr = pt.Int(1)

    expected = """
#pragma version 2
int 1
return
""".strip()
    actual = pt.compileTeal(expr, pt.Mode.Signature, version=2)
    assert actual == expected


def test_compile_version_default():
    expr = pt.Int(1)

    actual_default = pt.compileTeal(expr, pt.Mode.Signature)
    actual_version_2 = pt.compileTeal(expr, pt.Mode.Signature, version=2)
    assert actual_default == actual_version_2


def test_compile_version_3():
    expr = pt.Int(1)

    expected = """
#pragma version 3
int 1
return
""".strip()
    actual = pt.compileTeal(expr, pt.Mode.Signature, version=3)
    assert actual == expected


def test_compile_version_4():
    expr = pt.Int(1)

    expected = """
#pragma version 4
int 1
return
""".strip()
    actual = pt.compileTeal(expr, pt.Mode.Signature, version=4)
    assert actual == expected


def test_compile_version_5():
    expr = pt.Int(1)
    expected = """
#pragma version 5
int 1
return
""".strip()
    actual = pt.compileTeal(expr, pt.Mode.Signature, version=5)
    assert actual == expected


def test_compile_version_6():
    expr = pt.Int(1)
    expected = """
#pragma version 6
int 1
return
""".strip()
    actual = pt.compileTeal(expr, pt.Mode.Signature, version=6)
    assert actual == expected


def test_compile_no_assembly_type_tracking():
    expr = pt.Int(1)
    expected = """
#pragma version 6
#pragma typetrack false
int 1
return
""".strip()
    actual = pt.compileTeal(
        expr, pt.Mode.Signature, version=6, assembly_type_track=False
    )
    assert actual == expected


def test_slot_load_before_store():
    program = pt.AssetHolding.balance(pt.Int(0), pt.Int(0)).value()
    with pytest.raises(pt.TealInternalError):
        pt.compileTeal(program, pt.Mode.Application, version=2)

    program = pt.AssetHolding.balance(pt.Int(0), pt.Int(0)).hasValue()
    with pytest.raises(pt.TealInternalError):
        pt.compileTeal(program, pt.Mode.Application, version=2)

    program = pt.App.globalGetEx(pt.Int(0), pt.Bytes("key")).value()
    with pytest.raises(pt.TealInternalError):
        pt.compileTeal(program, pt.Mode.Application, version=2)

    program = pt.App.globalGetEx(pt.Int(0), pt.Bytes("key")).hasValue()
    with pytest.raises(pt.TealInternalError):
        pt.compileTeal(program, pt.Mode.Application, version=2)

    program = pt.ScratchVar().load()
    with pytest.raises(pt.TealInternalError):
        pt.compileTeal(program, pt.Mode.Application, version=2)


def test_assign_scratch_slots():
    myScratch = pt.ScratchVar(pt.TealType.uint64)
    otherScratch = pt.ScratchVar(pt.TealType.uint64, 1)
    anotherScratch = pt.ScratchVar(pt.TealType.uint64, 0)
    lastScratch = pt.ScratchVar(pt.TealType.uint64)
    prog = pt.Seq(
        [
            myScratch.store(pt.Int(5)),  # Slot 2
            otherScratch.store(pt.Int(0)),  # Slot 1
            anotherScratch.store(pt.Int(7)),  # Slot 0
            lastScratch.store(pt.Int(9)),  # Slot 3
            pt.Approve(),
        ]
    )

    expected = """
#pragma version 4
int 5
store 2
int 0
store 1
int 7
store 0
int 9
store 3
int 1
return
""".strip()
    actual = pt.compileTeal(prog, mode=pt.Mode.Signature, version=4)
    assert actual == expected


def test_scratchvar_double_assign_invalid():
    myvar = pt.ScratchVar(pt.TealType.uint64, 10)
    otherVar = pt.ScratchVar(pt.TealType.uint64, 10)
    prog = pt.Seq([myvar.store(pt.Int(5)), otherVar.store(pt.Int(0)), pt.Approve()])
    with pytest.raises(pt.TealInternalError):
        pt.compileTeal(prog, mode=pt.Mode.Signature, version=4)


def test_assembleConstants():
    program = pt.Itob(pt.Int(1) + pt.Int(1) + pt.Tmpl.Int("TMPL_VAR")) == pt.Concat(
        pt.Bytes("test"), pt.Bytes("test"), pt.Bytes("test2")
    )

    expectedNoAssemble = """
#pragma version 3
int 1
int 1
+
int TMPL_VAR
+
itob
byte "test"
byte "test"
concat
byte "test2"
concat
==
return
""".strip()
    actualNoAssemble = pt.compileTeal(
        program, pt.Mode.Application, version=3, assembleConstants=False
    )
    assert expectedNoAssemble == actualNoAssemble

    expectedAssemble = """
#pragma version 3
intcblock 1
bytecblock 0x74657374
intc_0 // 1
intc_0 // 1
+
pushint TMPL_VAR // TMPL_VAR
+
itob
bytec_0 // "test"
bytec_0 // "test"
concat
pushbytes 0x7465737432 // "test2"
concat
==
return
""".strip()
    actualAssemble = pt.compileTeal(
        program, pt.Mode.Application, version=3, assembleConstants=True
    )
    assert expectedAssemble == actualAssemble

    with pytest.raises(pt.TealInternalError):
        pt.compileTeal(program, pt.Mode.Application, version=2, assembleConstants=True)


def test_compile_while():
    i = pt.ScratchVar()
    program = pt.Seq(
        [
            i.store(pt.Int(0)),
            pt.While(i.load() < pt.Int(2)).Do(pt.Seq([i.store(i.load() + pt.Int(1))])),
            pt.Approve(),
        ]
    )

    expected = """
    #pragma version 4
int 0
store 0
main_l1:
load 0
int 2
<
bz main_l3
load 0
int 1
+
store 0
b main_l1
main_l3:
int 1
return
    """.strip()
    actual = pt.compileTeal(
        program, pt.Mode.Application, version=4, assembleConstants=False
    )
    assert expected == actual

    # nested
    i = pt.ScratchVar()
    j = pt.ScratchVar()

    program = pt.Seq(
        [
            i.store(pt.Int(0)),
            pt.While(i.load() < pt.Int(2)).Do(
                pt.Seq(
                    [
                        j.store(pt.Int(0)),
                        pt.While(j.load() < pt.Int(5)).Do(
                            pt.Seq([j.store(j.load() + pt.Int(1))])
                        ),
                        i.store(i.load() + pt.Int(1)),
                    ]
                )
            ),
            pt.Approve(),
        ]
    )

    expected = """#pragma version 4
int 0
store 0
main_l1:
load 0
int 2
<
bz main_l6
int 0
store 1
main_l3:
load 1
int 5
<
bnz main_l5
load 0
int 1
+
store 0
b main_l1
main_l5:
load 1
int 1
+
store 1
b main_l3
main_l6:
int 1
return
    """.strip()

    actual = pt.compileTeal(
        program, pt.Mode.Application, version=4, assembleConstants=False
    )
    assert expected == actual


def test_compile_for():
    i = pt.ScratchVar()
    program = pt.Seq(
        [
            pt.For(
                i.store(pt.Int(0)), i.load() < pt.Int(10), i.store(i.load() + pt.Int(1))
            ).Do(pt.Seq([pt.App.globalPut(pt.Itob(i.load()), i.load() * pt.Int(2))])),
            pt.Approve(),
        ]
    )

    expected = """#pragma version 4
int 0
store 0
main_l1:
load 0
int 10
<
bz main_l3
load 0
itob
load 0
int 2
*
app_global_put
load 0
int 1
+
store 0
b main_l1
main_l3:
int 1
return
    """.strip()
    actual = pt.compileTeal(
        program, pt.Mode.Application, version=4, assembleConstants=False
    )
    assert expected == actual

    # nested
    i = pt.ScratchVar()
    j = pt.ScratchVar()
    program = pt.Seq(
        [
            pt.For(
                i.store(pt.Int(0)), i.load() < pt.Int(10), i.store(i.load() + pt.Int(1))
            ).Do(
                pt.Seq(
                    [
                        pt.For(
                            j.store(pt.Int(0)),
                            j.load() < pt.Int(4),
                            j.store(j.load() + pt.Int(2)),
                        ).Do(
                            pt.Seq(
                                [
                                    pt.App.globalPut(
                                        pt.Itob(j.load()), j.load() * pt.Int(2)
                                    )
                                ]
                            )
                        )
                    ]
                )
            ),
            pt.Approve(),
        ]
    )

    expected = """#pragma version 4
int 0
store 0
main_l1:
load 0
int 10
<
bz main_l6
int 0
store 1
main_l3:
load 1
int 4
<
bnz main_l5
load 0
int 1
+
store 0
b main_l1
main_l5:
load 1
itob
load 1
int 2
*
app_global_put
load 1
int 2
+
store 1
b main_l3
main_l6:
int 1
return
    """.strip()
    actual = pt.compileTeal(
        program, pt.Mode.Application, version=4, assembleConstants=False
    )
    assert expected == actual


def test_compile_break():
    # pt.While
    i = pt.ScratchVar()
    program = pt.Seq(
        [
            i.store(pt.Int(0)),
            pt.While(i.load() < pt.Int(3)).Do(
                pt.Seq(
                    [
                        pt.If(i.load() == pt.Int(2), pt.Break()),
                        i.store(i.load() + pt.Int(1)),
                    ]
                )
            ),
            pt.Approve(),
        ]
    )

    expected = """#pragma version 4
int 0
store 0
main_l1:
load 0
int 3
<
bz main_l4
load 0
int 2
==
bnz main_l4
load 0
int 1
+
store 0
b main_l1
main_l4:
int 1
return
            """.strip()
    actual = pt.compileTeal(
        program, pt.Mode.Application, version=4, assembleConstants=False
    )
    assert expected == actual

    # pt.For
    i = pt.ScratchVar()
    program = pt.Seq(
        [
            pt.For(
                i.store(pt.Int(0)), i.load() < pt.Int(10), i.store(i.load() + pt.Int(1))
            ).Do(
                pt.Seq(
                    [
                        pt.If(i.load() == pt.Int(4), pt.Break()),
                        pt.App.globalPut(pt.Itob(i.load()), i.load() * pt.Int(2)),
                    ]
                )
            ),
            pt.Approve(),
        ]
    )

    expected = """#pragma version 4
int 0
store 0
main_l1:
load 0
int 10
<
bz main_l4
load 0
int 4
==
bnz main_l4
load 0
itob
load 0
int 2
*
app_global_put
load 0
int 1
+
store 0
b main_l1
main_l4:
int 1
return
        """.strip()
    actual = pt.compileTeal(
        program, pt.Mode.Application, version=4, assembleConstants=False
    )
    assert expected == actual


def test_compile_continue():
    # pt.While
    i = pt.ScratchVar()
    program = pt.Seq(
        [
            i.store(pt.Int(0)),
            pt.While(i.load() < pt.Int(3)).Do(
                pt.Seq(
                    [
                        pt.If(i.load() == pt.Int(2), pt.Continue()),
                        i.store(i.load() + pt.Int(1)),
                    ]
                )
            ),
            pt.Approve(),
        ]
    )

    expected = """#pragma version 4
int 0
store 0
main_l1:
load 0
int 3
<
bz main_l4
load 0
int 2
==
bnz main_l1
load 0
int 1
+
store 0
b main_l1
main_l4:
int 1
return
    """.strip()
    actual = pt.compileTeal(
        program, pt.Mode.Application, version=4, assembleConstants=False
    )
    assert expected == actual

    # pt.While
    program = pt.Seq(
        i.store(pt.Int(0)),
        pt.While(i.load() < pt.Int(30)).Do(
            pt.Seq(
                i.store(i.load() + pt.Int(1)),
                pt.Continue(),
            )
        ),
        pt.Return(pt.Int(1)),
    )

    expected = """#pragma version 4
int 0
store 0
main_l1:
load 0
int 30
<
bz main_l3
load 0
int 1
+
store 0
b main_l1
main_l3:
int 1
return
    """.strip()
    actual = pt.compileTeal(
        program, pt.Mode.Application, version=4, assembleConstants=False
    )
    assert expected == actual

    # pt.For
    i = pt.ScratchVar()
    program = pt.Seq(
        [
            pt.For(
                i.store(pt.Int(0)), i.load() < pt.Int(10), i.store(i.load() + pt.Int(1))
            ).Do(
                pt.Seq(
                    [
                        pt.If(i.load() == pt.Int(4), pt.Continue()),
                        pt.App.globalPut(pt.Itob(i.load()), i.load() * pt.Int(2)),
                    ]
                )
            ),
            pt.Approve(),
        ]
    )

    expected = """#pragma version 4
int 0
store 0
main_l1:
load 0
int 10
<
bz main_l5
load 0
int 4
==
bnz main_l4
load 0
itob
load 0
int 2
*
app_global_put
main_l4:
load 0
int 1
+
store 0
b main_l1
main_l5:
int 1
return
            """.strip()
    actual = pt.compileTeal(
        program, pt.Mode.Application, version=4, assembleConstants=False
    )
    assert expected == actual


def test_compile_continue_break_nested():
    i = pt.ScratchVar()
    program = pt.Seq(
        [
            i.store(pt.Int(0)),
            pt.While(i.load() < pt.Int(10)).Do(
                pt.Seq(
                    [
                        i.store(i.load() + pt.Int(1)),
                        pt.If(i.load() < pt.Int(4), pt.Continue(), pt.Break()),
                    ]
                )
            ),
            pt.Approve(),
        ]
    )

    expected = """#pragma version 4
int 0
store 0
main_l1:
load 0
int 10
<
bz main_l3
load 0
int 1
+
store 0
load 0
int 4
<
bnz main_l1
main_l3:
int 1
return
    """.strip()
    actual = pt.compileTeal(
        program, pt.Mode.Application, version=4, assembleConstants=False
    )
    assert expected == actual

    i = pt.ScratchVar()
    program = pt.Seq(
        [
            i.store(pt.Int(0)),
            pt.While(i.load() < pt.Int(10)).Do(
                pt.Seq(
                    [
                        pt.If(i.load() == pt.Int(8), pt.Break()),
                        pt.While(i.load() < pt.Int(6)).Do(
                            pt.Seq(
                                [
                                    pt.If(i.load() == pt.Int(3), pt.Break()),
                                    i.store(i.load() + pt.Int(1)),
                                ]
                            )
                        ),
                        pt.If(i.load() < pt.Int(5), pt.Continue()),
                        i.store(i.load() + pt.Int(1)),
                    ]
                )
            ),
            pt.Approve(),
        ]
    )

    expected = """#pragma version 4
int 0
store 0
main_l1:
load 0
int 10
<
bz main_l8
load 0
int 8
==
bnz main_l8
main_l3:
load 0
int 6
<
bnz main_l6
main_l4:
load 0
int 5
<
bnz main_l1
load 0
int 1
+
store 0
b main_l1
main_l6:
load 0
int 3
==
bnz main_l4
load 0
int 1
+
store 0
b main_l3
main_l8:
int 1
return
""".strip()
    actual = pt.compileTeal(
        program, pt.Mode.Application, version=4, assembleConstants=False
    )
    assert expected == actual


def test_compile_subroutine_unsupported():
    @pt.Subroutine(pt.TealType.none)
    def storeValue(value: pt.Expr) -> pt.Expr:
        return pt.App.globalPut(pt.Bytes("key"), value)

    program = pt.Seq(
        [
            pt.If(pt.Txn.sender() == pt.Global.creator_address()).Then(
                storeValue(pt.Txn.application_args[0])
            ),
            pt.Approve(),
        ]
    )

    with pytest.raises(pt.TealInputError):
        pt.compileTeal(program, pt.Mode.Application, version=3)


def test_compile_subroutine_no_return():
    @pt.Subroutine(pt.TealType.none)
    def storeValue(value: pt.Expr) -> pt.Expr:
        return pt.App.globalPut(pt.Bytes("key"), value)

    program = pt.Seq(
        [
            pt.If(pt.Txn.sender() == pt.Global.creator_address()).Then(
                storeValue(pt.Txn.application_args[0])
            ),
            pt.Approve(),
        ]
    )

    expected = """#pragma version 4
txn Sender
global CreatorAddress
==
bz main_l2
txna ApplicationArgs 0
callsub storeValue_0
main_l2:
int 1
return

// storeValue
storeValue_0:
store 0
byte "key"
load 0
app_global_put
retsub
    """.strip()
    actual = pt.compileTeal(
        program, pt.Mode.Application, version=4, assembleConstants=False
    )
    assert actual == expected


def test_compile_subroutine_with_return():
    @pt.Subroutine(pt.TealType.none)
    def storeValue(value: pt.Expr) -> pt.Expr:
        return pt.App.globalPut(pt.Bytes("key"), value)

    @pt.Subroutine(pt.TealType.bytes)
    def getValue() -> pt.Expr:
        return pt.App.globalGet(pt.Bytes("key"))

    program = pt.Seq(
        [
            pt.If(pt.Txn.sender() == pt.Global.creator_address()).Then(
                storeValue(pt.Txn.application_args[0])
            ),
            pt.If(getValue() == pt.Bytes("fail")).Then(pt.Reject()),
            pt.Approve(),
        ]
    )

    expected = """#pragma version 4
txn Sender
global CreatorAddress
==
bnz main_l3
main_l1:
callsub getValue_1
byte "fail"
==
bz main_l4
int 0
return
main_l3:
txna ApplicationArgs 0
callsub storeValue_0
b main_l1
main_l4:
int 1
return

// storeValue
storeValue_0:
store 0
byte "key"
load 0
app_global_put
retsub

// getValue
getValue_1:
byte "key"
app_global_get
retsub
    """.strip()
    actual = pt.compileTeal(
        program, pt.Mode.Application, version=4, assembleConstants=False
    )
    assert actual == expected


def test_compile_subroutine_many_args():
    @pt.Subroutine(pt.TealType.uint64)
    def calculateSum(
        a1: pt.Expr, a2: pt.Expr, a3: pt.Expr, a4: pt.Expr, a5: pt.Expr, a6: pt.Expr
    ) -> pt.Expr:
        return a1 + a2 + a3 + a4 + a5 + a6

    program = pt.Return(
        calculateSum(pt.Int(1), pt.Int(2), pt.Int(3), pt.Int(4), pt.Int(5), pt.Int(6))
        == pt.Int(1 + 2 + 3 + 4 + 5 + 6)
    )

    expected = """#pragma version 4
int 1
int 2
int 3
int 4
int 5
int 6
callsub calculateSum_0
int 21
==
return

// calculateSum
calculateSum_0:
store 5
store 4
store 3
store 2
store 1
store 0
load 0
load 1
+
load 2
+
load 3
+
load 4
+
load 5
+
retsub
    """.strip()
    actual = pt.compileTeal(
        program, pt.Mode.Application, version=4, assembleConstants=False
    )
    assert actual == expected


def test_compile_subroutine_recursive():
    @pt.Subroutine(pt.TealType.uint64)
    def isEven(i: pt.Expr) -> pt.Expr:
        return (
            pt.If(i == pt.Int(0))
            .Then(pt.Int(1))
            .ElseIf(i == pt.Int(1))
            .Then(pt.Int(0))
            .Else(isEven(i - pt.Int(2)))
        )

    program = pt.Return(isEven(pt.Int(6)))

    expected = """#pragma version 4
int 6
callsub isEven_0
return

// isEven
isEven_0:
store 0
load 0
int 0
==
bnz isEven_0_l4
load 0
int 1
==
bnz isEven_0_l3
load 0
int 2
-
load 0
dig 1
callsub isEven_0
swap
store 0
swap
pop
b isEven_0_l5
isEven_0_l3:
int 0
b isEven_0_l5
isEven_0_l4:
int 1
isEven_0_l5:
retsub
    """.strip()
    actual = pt.compileTeal(
        program, pt.Mode.Application, version=4, assembleConstants=False
    )
    assert actual == expected


def test_compile_subroutine_recursive_5():
    @pt.Subroutine(pt.TealType.uint64)
    def isEven(i: pt.Expr) -> pt.Expr:
        return (
            pt.If(i == pt.Int(0))
            .Then(pt.Int(1))
            .ElseIf(i == pt.Int(1))
            .Then(pt.Int(0))
            .Else(isEven(i - pt.Int(2)))
        )

    program = pt.Return(isEven(pt.Int(6)))

    expected = """#pragma version 5
int 6
callsub isEven_0
return

// isEven
isEven_0:
store 0
load 0
int 0
==
bnz isEven_0_l4
load 0
int 1
==
bnz isEven_0_l3
load 0
int 2
-
load 0
swap
callsub isEven_0
swap
store 0
b isEven_0_l5
isEven_0_l3:
int 0
b isEven_0_l5
isEven_0_l4:
int 1
isEven_0_l5:
retsub
    """.strip()
    actual = pt.compileTeal(
        program, pt.Mode.Application, version=5, assembleConstants=False
    )
    assert actual == expected


def test_compile_subroutine_recursive_multiple_args():
    @pt.Subroutine(pt.TealType.uint64)
    def multiplyByAdding(a, b):
        return (
            pt.If(a == pt.Int(0))
            .Then(pt.Return(pt.Int(0)))
            .Else(pt.Return(b + multiplyByAdding(a - pt.Int(1), b)))
        )

    program = pt.Return(multiplyByAdding(pt.Int(3), pt.Int(5)))

    expected = """#pragma version 4
int 3
int 5
callsub multiplyByAdding_0
return

// multiplyByAdding
multiplyByAdding_0:
store 1
store 0
load 0
int 0
==
bnz multiplyByAdding_0_l2
load 1
load 0
int 1
-
load 1
load 0
load 1
dig 3
dig 3
callsub multiplyByAdding_0
store 0
store 1
load 0
swap
store 0
swap
pop
swap
pop
+
retsub
multiplyByAdding_0_l2:
int 0
retsub
    """.strip()
    actual = pt.compileTeal(
        program, pt.Mode.Application, version=4, assembleConstants=False
    )
    assert actual == expected


def test_compile_subroutine_recursive_multiple_args_5():
    @pt.Subroutine(pt.TealType.uint64)
    def multiplyByAdding(a, b):
        return (
            pt.If(a == pt.Int(0))
            .Then(pt.Return(pt.Int(0)))
            .Else(pt.Return(b + multiplyByAdding(a - pt.Int(1), b)))
        )

    program = pt.Return(multiplyByAdding(pt.Int(3), pt.Int(5)))

    expected = """#pragma version 5
int 3
int 5
callsub multiplyByAdding_0
return

// multiplyByAdding
multiplyByAdding_0:
store 1
store 0
load 0
int 0
==
bnz multiplyByAdding_0_l2
load 1
load 0
int 1
-
load 1
load 0
load 1
uncover 3
uncover 3
callsub multiplyByAdding_0
cover 2
store 1
store 0
+
retsub
multiplyByAdding_0_l2:
int 0
retsub
    """.strip()
    actual = pt.compileTeal(
        program, pt.Mode.Application, version=5, assembleConstants=False
    )
    assert actual == expected


def test_compile_subroutine_mutually_recursive_4():
    @pt.Subroutine(pt.TealType.uint64)
    def isEven(i: pt.Expr) -> pt.Expr:
        return pt.If(i == pt.Int(0), pt.Int(1), pt.Not(isOdd(i - pt.Int(1))))

    @pt.Subroutine(pt.TealType.uint64)
    def isOdd(i: pt.Expr) -> pt.Expr:
        return pt.If(i == pt.Int(0), pt.Int(0), pt.Not(isEven(i - pt.Int(1))))

    program = pt.Return(isEven(pt.Int(6)))

    expected = """#pragma version 4
int 6
callsub isEven_0
return

// isEven
isEven_0:
store 0
load 0
int 0
==
bnz isEven_0_l2
load 0
int 1
-
load 0
dig 1
callsub isOdd_1
swap
store 0
swap
pop
!
b isEven_0_l3
isEven_0_l2:
int 1
isEven_0_l3:
retsub

// isOdd
isOdd_1:
store 1
load 1
int 0
==
bnz isOdd_1_l2
load 1
int 1
-
load 1
dig 1
callsub isEven_0
swap
store 1
swap
pop
!
b isOdd_1_l3
isOdd_1_l2:
int 0
isOdd_1_l3:
retsub
    """.strip()
    actual = pt.compileTeal(
        program, pt.Mode.Application, version=4, assembleConstants=False
    )
    assert actual == expected


def test_compile_subroutine_mutually_recursive_5():
    @pt.Subroutine(pt.TealType.uint64)
    def isEven(i: pt.Expr) -> pt.Expr:
        return pt.If(i == pt.Int(0), pt.Int(1), pt.Not(isOdd(i - pt.Int(1))))

    @pt.Subroutine(pt.TealType.uint64)
    def isOdd(i: pt.Expr) -> pt.Expr:
        return pt.If(i == pt.Int(0), pt.Int(0), pt.Not(isEven(i - pt.Int(1))))

    program = pt.Return(isEven(pt.Int(6)))

    expected = """#pragma version 5
int 6
callsub isEven_0
return

// isEven
isEven_0:
store 0
load 0
int 0
==
bnz isEven_0_l2
load 0
int 1
-
load 0
swap
callsub isOdd_1
swap
store 0
!
b isEven_0_l3
isEven_0_l2:
int 1
isEven_0_l3:
retsub

// isOdd
isOdd_1:
store 1
load 1
int 0
==
bnz isOdd_1_l2
load 1
int 1
-
load 1
swap
callsub isEven_0
swap
store 1
!
b isOdd_1_l3
isOdd_1_l2:
int 0
isOdd_1_l3:
retsub
    """.strip()
    actual = pt.compileTeal(
        program, pt.Mode.Application, version=5, assembleConstants=False
    )
    assert actual == expected


def test_compile_subroutine_mutually_recursive_different_arg_count_4():
    @pt.Subroutine(pt.TealType.uint64)
    def factorial(i: pt.Expr) -> pt.Expr:
        return pt.If(
            i <= pt.Int(1),
            pt.Int(1),
            factorial_intermediate(i - pt.Int(1), pt.Bytes("inconsequential")) * i,
        )

    @pt.Subroutine(pt.TealType.uint64)
    def factorial_intermediate(i: pt.Expr, j: pt.Expr) -> pt.Expr:
        return pt.Seq(pt.Pop(j), factorial(i))

    program = pt.Return(factorial(pt.Int(4)) == pt.Int(24))

    expected = """#pragma version 4
int 4
callsub factorial_0
int 24
==
return

// factorial
factorial_0:
store 0
load 0
int 1
<=
bnz factorial_0_l2
load 0
int 1
-
byte "inconsequential"
load 0
dig 2
dig 2
callsub factorialintermediate_1
swap
store 0
swap
pop
swap
pop
load 0
*
b factorial_0_l3
factorial_0_l2:
int 1
factorial_0_l3:
retsub

// factorial_intermediate
factorialintermediate_1:
store 2
store 1
load 2
pop
load 1
load 1
load 2
dig 2
callsub factorial_0
store 1
store 2
load 1
swap
store 1
swap
pop
retsub
    """.strip()
    actual = pt.compileTeal(
        program, pt.Mode.Application, version=4, assembleConstants=False
    )
    assert actual == expected


def test_compile_subroutine_mutually_recursive_different_arg_count_5():
    @pt.Subroutine(pt.TealType.uint64)
    def factorial(i: pt.Expr) -> pt.Expr:
        return pt.If(
            i <= pt.Int(1),
            pt.Int(1),
            factorial_intermediate(i - pt.Int(1), pt.Bytes("inconsequential")) * i,
        )

    @pt.Subroutine(pt.TealType.uint64)
    def factorial_intermediate(i: pt.Expr, j: pt.Expr) -> pt.Expr:
        return pt.Seq(pt.Log(j), factorial(i))

    program = pt.Return(factorial(pt.Int(4)) == pt.Int(24))

    expected = """#pragma version 5
int 4
callsub factorial_0
int 24
==
return

// factorial
factorial_0:
store 0
load 0
int 1
<=
bnz factorial_0_l2
load 0
int 1
-
byte "inconsequential"
load 0
cover 2
callsub factorialintermediate_1
swap
store 0
load 0
*
b factorial_0_l3
factorial_0_l2:
int 1
factorial_0_l3:
retsub

// factorial_intermediate
factorialintermediate_1:
store 2
store 1
load 2
log
load 1
load 1
load 2
uncover 2
callsub factorial_0
cover 2
store 2
store 1
retsub
    """.strip()
    actual = pt.compileTeal(
        program, pt.Mode.Application, version=5, assembleConstants=False
    )
    assert actual == expected


def test_compile_loop_in_subroutine():
    @pt.Subroutine(pt.TealType.none)
    def setState(value: pt.Expr) -> pt.Expr:
        i = pt.ScratchVar()
        return pt.For(
            i.store(pt.Int(0)), i.load() < pt.Int(10), i.store(i.load() + pt.Int(1))
        ).Do(pt.App.globalPut(pt.Itob(i.load()), value))

    program = pt.Seq([setState(pt.Bytes("value")), pt.Approve()])

    expected = """#pragma version 4
byte "value"
callsub setState_0
int 1
return

// setState
setState_0:
store 0
int 0
store 1
setState_0_l1:
load 1
int 10
<
bz setState_0_l3
load 1
itob
load 0
app_global_put
load 1
int 1
+
store 1
b setState_0_l1
setState_0_l3:
retsub
    """.strip()
    actual = pt.compileTeal(
        program, pt.Mode.Application, version=4, assembleConstants=False
    )
    assert actual == expected


def test_compile_subroutine_invalid_name():
    def tmp() -> pt.Expr:
        return pt.Int(1)

    tmp.__name__ = "invalid-;)"

    program = pt.Subroutine(pt.TealType.uint64)(tmp)()
    expected = """#pragma version 4
callsub invalid_0
return

// invalid-;)
invalid_0:
int 1
retsub
    """.strip()
    actual = pt.compileTeal(
        program, pt.Mode.Application, version=4, assembleConstants=False
    )
    assert actual == expected


def test_compile_subroutine_assemble_constants():
    @pt.Subroutine(pt.TealType.none)
    def storeValue(key: pt.Expr, t1: pt.Expr, t2: pt.Expr, t3: pt.Expr) -> pt.Expr:
        return pt.App.globalPut(key, t1 + t2 + t3 + pt.Int(10))

    program = pt.Seq(
        [
            pt.If(pt.Txn.application_id() == pt.Int(0)).Then(
                storeValue(
                    pt.Concat(pt.Bytes("test"), pt.Bytes("test"), pt.Bytes("a")),
                    pt.Int(1),
                    pt.Int(1),
                    pt.Int(3),
                )
            ),
            pt.Approve(),
        ]
    )

    expected = """#pragma version 4
intcblock 1
bytecblock 0x74657374
txn ApplicationID
pushint 0 // 0
==
bz main_l2
bytec_0 // "test"
bytec_0 // "test"
concat
pushbytes 0x61 // "a"
concat
intc_0 // 1
intc_0 // 1
pushint 3 // 3
callsub storeValue_0
main_l2:
intc_0 // 1
return

// storeValue
storeValue_0:
store 3
store 2
store 1
store 0
load 0
load 1
load 2
+
load 3
+
pushint 10 // 10
+
app_global_put
retsub
    """.strip()
    actual = pt.compileTeal(
        program, pt.Mode.Application, version=4, assembleConstants=True
    )
    assert actual == expected


def test_compile_subroutine_deferred_expr():
    @pt.Subroutine(pt.TealType.none)
    def deferredExample(value: pt.Expr) -> pt.Expr:
        return pt.Seq(
            pt.If(value == pt.Int(0)).Then(pt.Return()),
            pt.If(value == pt.Int(1)).Then(pt.Approve()),
            pt.If(value == pt.Int(2)).Then(pt.Reject()),
            pt.If(value == pt.Int(3)).Then(pt.Err()),
        )

    program = pt.Seq(deferredExample(pt.Int(10)), pt.Approve())

    expected_no_deferred = """#pragma version 6
int 10
callsub deferredExample_0
int 1
return

// deferredExample
deferredExample_0:
store 0
load 0
int 0
==
bnz deferredExample_0_l7
load 0
int 1
==
bnz deferredExample_0_l6
load 0
int 2
==
bnz deferredExample_0_l5
load 0
int 3
==
bz deferredExample_0_l8
err
deferredExample_0_l5:
int 0
return
deferredExample_0_l6:
int 1
return
deferredExample_0_l7:
retsub
deferredExample_0_l8:
retsub
    """.strip()
    actual_no_deferred = pt.compileTeal(
        program, pt.Mode.Application, version=6, assembleConstants=False
    )
    assert actual_no_deferred == expected_no_deferred

    # manually add deferred expression to SubroutineDefinition
    declaration = deferredExample.subroutine.get_declaration_by_option(False)
    declaration.deferred_expr = pt.Pop(pt.Bytes("deferred"))

    expected_deferred = """#pragma version 6
int 10
callsub deferredExample_0
int 1
return

// deferredExample
deferredExample_0:
store 0
load 0
int 0
==
bnz deferredExample_0_l7
load 0
int 1
==
bnz deferredExample_0_l6
load 0
int 2
==
bnz deferredExample_0_l5
load 0
int 3
==
bz deferredExample_0_l8
err
deferredExample_0_l5:
int 0
return
deferredExample_0_l6:
int 1
return
deferredExample_0_l7:
byte "deferred"
pop
retsub
deferredExample_0_l8:
byte "deferred"
pop
retsub
    """.strip()
    actual_deferred = pt.compileTeal(
        program, pt.Mode.Application, version=6, assembleConstants=False
    )
    assert actual_deferred == expected_deferred


def test_compile_subroutine_deferred_expr_empty():
    @pt.Subroutine(pt.TealType.none)
    def empty() -> pt.Expr:
        return pt.Return()

    program = pt.Seq(empty(), pt.Approve())

    expected_no_deferred = """#pragma version 6
callsub empty_0
int 1
return

// empty
empty_0:
retsub
    """.strip()
    actual_no_deferred = pt.compileTeal(
        program, pt.Mode.Application, version=6, assembleConstants=False
    )
    assert actual_no_deferred == expected_no_deferred

    # manually add deferred expression to SubroutineDefinition
    declaration = empty.subroutine.get_declaration_by_option(False)
    declaration.deferred_expr = pt.Pop(pt.Bytes("deferred"))

    expected_deferred = """#pragma version 6
callsub empty_0
int 1
return

// empty
empty_0:
byte "deferred"
pop
retsub
    """.strip()
    actual_deferred = pt.compileTeal(
        program, pt.Mode.Application, version=6, assembleConstants=False
    )
    assert actual_deferred == expected_deferred


def test_compileSubroutine_deferred_block_malformed():
    class BadRetsub(pt.Expr):
        def type_of(self) -> pt.TealType:
            return pt.TealType.none

        def has_return(self) -> bool:
            return True

        def __str__(self) -> str:
            return "(BadRetsub)"

        def __teal__(
            self, options: pt.CompileOptions
        ) -> tuple[pt.TealBlock, pt.TealSimpleBlock]:
            block = pt.TealSimpleBlock(
                [
                    pt.TealOp(self, pt.Op.int, 1),
                    pt.TealOp(self, pt.Op.pop),
                    pt.TealOp(self, pt.Op.retsub),
                ]
            )

            return block, block

    @pt.Subroutine(pt.TealType.none)
    def bad() -> pt.Expr:
        return BadRetsub()

    program = pt.Seq(bad(), pt.Approve())

    # manually add deferred expression to SubroutineDefinition
    declaration = bad.subroutine.get_declaration_by_option(False)
    declaration.deferred_expr = pt.Pop(pt.Bytes("deferred"))

    with pytest.raises(
        pt.TealInternalError,
        match=r"^Expected retsub to be the only op in the block, but there are 3 ops$",
    ):
        pt.compileTeal(program, pt.Mode.Application, version=6, assembleConstants=False)


def test_compile_wide_ratio():
    cases = (
        (
            pt.WideRatio([pt.Int(2), pt.Int(100)], [pt.Int(5)]),
            """#pragma version 5
int 2
int 100
mulw
int 0
int 5
divmodw
pop
pop
swap
!
assert
return
""",
        ),
        (
            pt.WideRatio([pt.Int(2), pt.Int(100)], [pt.Int(10), pt.Int(5)]),
            """#pragma version 5
int 2
int 100
mulw
int 10
int 5
mulw
divmodw
pop
pop
swap
!
assert
return
""",
        ),
        (
            pt.WideRatio([pt.Int(2), pt.Int(100), pt.Int(3)], [pt.Int(10), pt.Int(5)]),
            """#pragma version 5
int 2
int 100
mulw
int 3
uncover 2
dig 1
*
cover 2
mulw
cover 2
+
swap
int 10
int 5
mulw
divmodw
pop
pop
swap
!
assert
return
""",
        ),
        (
            pt.WideRatio(
                [pt.Int(2), pt.Int(100), pt.Int(3)], [pt.Int(10), pt.Int(5), pt.Int(6)]
            ),
            """#pragma version 5
int 2
int 100
mulw
int 3
uncover 2
dig 1
*
cover 2
mulw
cover 2
+
swap
int 10
int 5
mulw
int 6
uncover 2
dig 1
*
cover 2
mulw
cover 2
+
swap
divmodw
pop
pop
swap
!
assert
return
""",
        ),
        (
            pt.WideRatio(
                [pt.Int(2), pt.Int(100), pt.Int(3), pt.Int(4)],
                [pt.Int(10), pt.Int(5), pt.Int(6)],
            ),
            """#pragma version 5
int 2
int 100
mulw
int 3
uncover 2
dig 1
*
cover 2
mulw
cover 2
+
swap
int 4
uncover 2
dig 1
*
cover 2
mulw
cover 2
+
swap
int 10
int 5
mulw
int 6
uncover 2
dig 1
*
cover 2
mulw
cover 2
+
swap
divmodw
pop
pop
swap
!
assert
return
""",
        ),
    )

    for program, expected in cases:
        actual = pt.compileTeal(
            program, pt.Mode.Application, version=5, assembleConstants=False
        )
        assert actual == expected.strip()


def test_compile_abi_subroutine_return():
    @pt.ABIReturnSubroutine
    def abi_sum(
        toSum: pt.abi.DynamicArray[pt.abi.Uint64], *, output: pt.abi.Uint64
    ) -> pt.Expr:
        i = pt.ScratchVar(pt.TealType.uint64)
        valueAtIndex = pt.abi.Uint64()
        return pt.Seq(
            output.set(0),
            pt.For(
                i.store(pt.Int(0)),
                i.load() < toSum.length(),
                i.store(i.load() + pt.Int(1)),
            ).Do(
                pt.Seq(
                    toSum[i.load()].store_into(valueAtIndex),
                    output.set(output.get() + valueAtIndex.get()),
                )
            ),
        )

    program = pt.Seq(
        (to_sum_arr := pt.abi.make(pt.abi.DynamicArray[pt.abi.Uint64])).decode(
            pt.Txn.application_args[1]
        ),
        (res := pt.abi.Uint64()).set(abi_sum(to_sum_arr)),
        pt.abi.MethodReturn(res),
        pt.Approve(),
    )

    expected_sum = """#pragma version 6
txna ApplicationArgs 1
store 0
load 0
callsub abisum_0
store 1
byte 0x151f7c75
load 1
itob
concat
log
int 1
return

// abi_sum
abisum_0:
store 2
int 0
store 3
int 0
store 4
abisum_0_l1:
load 4
load 2
int 0
extract_uint16
store 6
load 6
<
bz abisum_0_l3
load 2
int 8
load 4
*
int 2
+
extract_uint64
store 5
load 3
load 5
+
store 3
load 4
int 1
+
store 4
b abisum_0_l1
abisum_0_l3:
load 3
retsub
    """.strip()

    actual_sum = pt.compileTeal(program, pt.Mode.Application, version=6)
    assert expected_sum == actual_sum

    @pt.ABIReturnSubroutine
    def conditional_factorial(
        _factor: pt.abi.Uint64, *, output: pt.abi.Uint64
    ) -> pt.Expr:
        i = pt.ScratchVar(pt.TealType.uint64)

        return pt.Seq(
            output.set(1),
            pt.If(_factor.get() <= pt.Int(1))
            .Then(pt.Return())
            .Else(
                pt.For(
                    i.store(_factor.get()),
                    i.load() > pt.Int(1),
                    i.store(i.load() - pt.Int(1)),
                ).Do(output.set(output.get() * i.load())),
            ),
        )

    program_cond_factorial = pt.Seq(
        (factor := pt.abi.Uint64()).decode(pt.Txn.application_args[1]),
        (res := pt.abi.Uint64()).set(conditional_factorial(factor)),
        pt.abi.MethodReturn(res),
        pt.Approve(),
    )

    expected_conditional_factorial = """#pragma version 6
txna ApplicationArgs 1
btoi
store 0
load 0
callsub conditionalfactorial_0
store 1
byte 0x151f7c75
load 1
itob
concat
log
int 1
return

// conditional_factorial
conditionalfactorial_0:
store 2
int 1
store 3
load 2
int 1
<=
bnz conditionalfactorial_0_l4
load 2
store 4
conditionalfactorial_0_l2:
load 4
int 1
>
bz conditionalfactorial_0_l5
load 3
load 4
*
store 3
load 4
int 1
-
store 4
b conditionalfactorial_0_l2
conditionalfactorial_0_l4:
load 3
retsub
conditionalfactorial_0_l5:
load 3
retsub
    """.strip()

    actual_conditional_factorial = pt.compileTeal(
        program_cond_factorial, pt.Mode.Application, version=6
    )
    assert actual_conditional_factorial == expected_conditional_factorial

    @pt.ABIReturnSubroutine
    def load_b4_set(*, output: pt.abi.Bool):
        return pt.Return()

    program_load_b4_set_broken = pt.Seq(
        (_ := pt.abi.Bool()).set(load_b4_set()), pt.Approve()
    )

    with pytest.raises(pt.TealInternalError):
        pt.compileTeal(program_load_b4_set_broken, pt.Mode.Application, version=6)

    @pt.ABIReturnSubroutine
    def access_b4_store(magic_num: pt.abi.Uint64, *, output: pt.abi.Uint64):
        return pt.Seq(output.set(output.get() ^ magic_num.get()))

    program_access_b4_store_broken = pt.Seq(
        (other_party_magic := pt.abi.Uint64()).decode(pt.Txn.application_args[1]),
        (_ := pt.abi.Uint64()).set(access_b4_store(other_party_magic)),
        pt.Approve(),
    )

    with pytest.raises(pt.TealInternalError):
        pt.compileTeal(program_access_b4_store_broken, pt.Mode.Application, version=6)


def add_methods_to_router(router: pt.Router):
    @pt.ABIReturnSubroutine
    def add(a: pt.abi.Uint64, b: pt.abi.Uint64, *, output: pt.abi.Uint64) -> pt.Expr:
        return output.set(a.get() + b.get())

    meth = router.add_method_handler(add)
    assert meth.method_signature() == "add(uint64,uint64)uint64"

    @pt.ABIReturnSubroutine
    def sub(a: pt.abi.Uint64, b: pt.abi.Uint64, *, output: pt.abi.Uint64) -> pt.Expr:
        return output.set(a.get() - b.get())

    meth = router.add_method_handler(sub)
    assert meth.method_signature() == "sub(uint64,uint64)uint64"

    @pt.ABIReturnSubroutine
    def mul(a: pt.abi.Uint64, b: pt.abi.Uint64, *, output: pt.abi.Uint64) -> pt.Expr:
        return output.set(a.get() * b.get())

    meth = router.add_method_handler(mul)
    assert meth.method_signature() == "mul(uint64,uint64)uint64"

    @pt.ABIReturnSubroutine
    def div(a: pt.abi.Uint64, b: pt.abi.Uint64, *, output: pt.abi.Uint64) -> pt.Expr:
        return output.set(a.get() / b.get())

    meth = router.add_method_handler(div)
    assert meth.method_signature() == "div(uint64,uint64)uint64"

    @pt.ABIReturnSubroutine
    def mod(a: pt.abi.Uint64, b: pt.abi.Uint64, *, output: pt.abi.Uint64) -> pt.Expr:
        return output.set(a.get() % b.get())

    meth = router.add_method_handler(mod)
    assert meth.method_signature() == "mod(uint64,uint64)uint64"

    @pt.ABIReturnSubroutine
    def all_laid_to_args(
        _a: pt.abi.Uint64,
        _b: pt.abi.Uint64,
        _c: pt.abi.Uint64,
        _d: pt.abi.Uint64,
        _e: pt.abi.Uint64,
        _f: pt.abi.Uint64,
        _g: pt.abi.Uint64,
        _h: pt.abi.Uint64,
        _i: pt.abi.Uint64,
        _j: pt.abi.Uint64,
        _k: pt.abi.Uint64,
        _l: pt.abi.Uint64,
        _m: pt.abi.Uint64,
        _n: pt.abi.Uint64,
        _o: pt.abi.Uint64,
        _p: pt.abi.Uint64,
        *,
        output: pt.abi.Uint64,
    ):
        return output.set(
            _a.get()
            + _b.get()
            + _c.get()
            + _d.get()
            + _e.get()
            + _f.get()
            + _g.get()
            + _h.get()
            + _i.get()
            + _j.get()
            + _k.get()
            + _l.get()
            + _m.get()
            + _n.get()
            + _o.get()
            + _p.get()
        )

    meth = router.add_method_handler(all_laid_to_args)
    assert (
        meth.method_signature()
        == "all_laid_to_args(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)uint64"
    )

    @pt.ABIReturnSubroutine
    def empty_return_subroutine() -> pt.Expr:
        return pt.Log(pt.Bytes("appear in both approval and clear state"))

    meth = router.add_method_handler(
        empty_return_subroutine,
        method_config=pt.MethodConfig(
            no_op=pt.CallConfig.CALL,
            opt_in=pt.CallConfig.ALL,
        ),
    )
    assert meth.method_signature() == "empty_return_subroutine()void"

    @pt.ABIReturnSubroutine
    def log_1(*, output: pt.abi.Uint64) -> pt.Expr:
        return output.set(1)

    meth = router.add_method_handler(
        log_1,
        method_config=pt.MethodConfig(
            no_op=pt.CallConfig.CALL,
            opt_in=pt.CallConfig.CALL,
        ),
    )

    assert meth.method_signature() == "log_1()uint64"

    @pt.ABIReturnSubroutine
    def log_creation(*, output: pt.abi.String) -> pt.Expr:
        return output.set("logging creation")

    meth = router.add_method_handler(
        log_creation, method_config=pt.MethodConfig(no_op=pt.CallConfig.CREATE)
    )
    assert meth.method_signature() == "log_creation()string"


ON_COMPLETION_ACTIONS = pt.BareCallActions(
    opt_in=pt.OnCompleteAction.call_only(pt.Log(pt.Bytes("optin call"))),
)

FIRST_ROUTER = pt.Router(
    "ASimpleQuestionablyRobustContract",
    ON_COMPLETION_ACTIONS,
    clear_state=pt.Approve(),
)
add_methods_to_router(FIRST_ROUTER)


def router_app_tester() -> tuple[list[pt.Router], dict[str, str]]:
    routers = []
    sources = {}

    def append_router_info(rinfo, programs):
        assert len(rinfo) == 3
        assert len(programs) == 2
        routers.append(rinfo)
        sources[rinfo[:2]] = programs

    # V6 not ready for Frame Pointers:
    with pytest.raises(pt.TealInputError) as e:
        pt.Router("will-error", ON_COMPLETION_ACTIONS).compile_program(
            version=6, optimize=pt.OptimizeOptions(frame_pointers=True)
        )
    assert "Frame pointers aren't available" in str(e.value)

    def router_compilarison(router, version, fixture_ap, fixture_csp, key):
        actual_ap, actual_csp, _ = router.compile_program(version=version)

        with open(ROUTER_FIXTURES / fixture_ap) as f:
            expected_ap_with_oc = f.read()
        with open(ROUTER_FIXTURES / fixture_csp) as f:
            expected_csp_with_oc = f.read()
        assert expected_ap_with_oc == actual_ap
        assert expected_csp_with_oc == actual_csp
        append_router_info(
            (
                key,
                version,
                router,
            ),
            (
                actual_ap,
                actual_csp,
            ),
        )

    # QUESTIONABLE V6:
    _router_with_oc = FIRST_ROUTER
    router_compilarison(
        _router_with_oc,
        6,
        "questionable_approval_v6.teal",
        "questionable_clear_v6.teal",
        "questionable",
    )

    # YACC V6:
    _router_without_oc = pt.Router(
        "yetAnotherContractConstructedFromRouter", clear_state=pt.Approve()
    )
    add_methods_to_router(_router_without_oc)
    router_compilarison(
        _router_without_oc, 6, "yacc_approval_v6.teal", "yacc_clear_v6.teal", "yacc"
    )

    # QUESTIONABLE FP V8:
    _router_with_oc = pt.Router(
        "QuestionableRouterGenerateCodeWithFramePointer",
        ON_COMPLETION_ACTIONS,
        clear_state=pt.Approve(),
    )
    add_methods_to_router(_router_with_oc)
    router_compilarison(
        _router_with_oc,
        8,
        "questionableFP_approval_v8.teal",
        "questionableFP_clear_v8.teal",
        "questionable",
    )

    # YACC FP V8:
    _router_without_oc = pt.Router(
        "yetAnotherContractConstructedFromRouterWithFramePointer",
        clear_state=pt.Approve(),
    )
    add_methods_to_router(_router_without_oc)
    router_compilarison(
        _router_without_oc,
        8,
        "yaccFP_approval_v8.teal",
        "yaccFP_clear_v8.teal",
        "yacc",
    )

    non_trivial = pt.Seq(
        pt.Cond(
            [pt.Txn.application_args.length() < pt.Int(2), pt.Approve()],
            [pt.Txn.application_args[0] != pt.Bytes("CLEANUP"), pt.Approve()],
            [pt.Txn.application_args[1] != pt.Bytes("ABORTING"), pt.Approve()],
            [pt.Int(1), pt.Reject()],
        ),
    )
    _router_with_nontriv_clear = pt.Router(
        "QuestionableRouterWithNontrivialClear",
        bare_calls=ON_COMPLETION_ACTIONS,
        clear_state=non_trivial,
    )
    add_methods_to_router(_router_with_nontriv_clear)

    router_compilarison(
        _router_with_nontriv_clear,
        6,
        "nontriv_clear_approval_v6.teal",
        "nontriv_clear_clear_v6.teal",
        "nontriv_clear",
    )

    router_compilarison(
        _router_with_nontriv_clear,
        8,
        "nontriv_clear_approval_v8.teal",
        "nontriv_clear_clear_v8.teal",
        "nontriv_clear",
    )

    return routers, sources


def test_router_app():
    # TODO: this test is redundant as router_app_tester is imported and run by
    # tests/integration/abi_router_test.py's setup
    router_app_tester()



================================================
FILE: pyteal/compiler/constants.py
================================================
import base64

from typing import Union, List, Dict, cast
from collections import OrderedDict
from algosdk import encoding

from pyteal.ir import (
    Op,
    TealOp,
    TealComponent,
)
from pyteal.util import unescapeStr, correctBase32Padding
from pyteal.errors import TealInternalError

intEnumValues = {
    # OnComplete values
    "NoOp": 0,
    "OptIn": 1,
    "CloseOut": 2,
    "ClearState": 3,
    "UpdateApplication": 4,
    "DeleteApplication": 5,
    # TxnType values
    "unknown": 0,
    "pay": 1,
    "keyreg": 2,
    "acfg": 3,
    "axfer": 4,
    "afrz": 5,
    "appl": 6,
}


def extractIntValue(op: TealOp) -> Union[str, int]:
    """Extract the constant value being loaded by a TealOp whose op is Op.int.

    Returns:
        If the op is loading a template variable, returns the name of the variable as a string.
        Otherwise, returns the integer that the op is loading.
    """
    if len(op.args) != 1 or type(op.args[0]) not in (int, str):
        raise TealInternalError("Unexpected args in int opcode: {}".format(op.args))

    value = cast(Union[str, int], op.args[0])
    if type(value) is int or cast(str, value).startswith("TMPL_"):
        return value
    if value not in intEnumValues:
        raise TealInternalError("Int constant not recognized: {}".format(value))
    return intEnumValues[cast(str, value)]


def extractBytesValue(op: TealOp) -> Union[str, bytes]:
    """Extract the constant value being loaded by a TealOp whose op is Op.byte.

    Returns:
        If the op is loading a template variable, returns the name of the variable as a string.
        Otherwise, returns the byte string that the op is loading.
    """
    if len(op.args) != 1 or type(op.args[0]) is not str:
        raise TealInternalError("Unexpected args in byte opcode: {}".format(op.args))

    value = op.args[0]
    if value.startswith("TMPL_"):
        return value
    if value.startswith('"') and value.endswith('"'):
        return unescapeStr(value).encode("utf-8")
    if value.startswith("0x"):
        return bytes.fromhex(value[2:])
    if value.startswith("base32(") and value.endswith(")"):
        return base64.b32decode(correctBase32Padding(value[len("base32(") : -1]))
    if value.startswith("base64(") and value.endswith(")"):
        return base64.b64decode(value[len("base64(") : -1])

    raise TealInternalError("Unexpected format for byte value: {}".format(value))


def extractAddrValue(op: TealOp) -> Union[str, bytes]:
    """Extract the constant value being loaded by a TealOp whose op is Op.addr.

    Returns:
        If the op is loading a template variable, returns the name of the variable as a string.
        Otherwise, returns the bytes of the public key of the address that the op is loading.
    """
    if len(op.args) != 1 or type(op.args[0]) is not str:
        raise TealInternalError("Unexpected args in addr opcode: {}".format(op.args))

    value = cast(str, op.args[0])
    if not value.startswith("TMPL_"):
        value = encoding.decode_address(value)
    return value


def extractMethodSigValue(op: TealOp) -> bytes:
    """Extract the constant value being loaded by a TealOp whose op is Op.method.

    Returns:
        The bytes of method selector computed from the method signature that the op is loading.
    """
    if len(op.args) != 1 or type(op.args[0]) is not str:
        raise TealInternalError("Unexpected args in method opcode: {}".format(op.args))

    methodSignature = cast(str, op.args[0])
    if methodSignature[0] == methodSignature[-1] and methodSignature.startswith('"'):
        methodSignature = methodSignature[1:-1]
    else:
        raise TealInternalError(
            "Method signature opcode error: signature {} not wrapped with double-quotes".format(
                methodSignature
            )
        )
    methodSelector = encoding.checksum(bytes(methodSignature, "utf-8"))[:4]
    return methodSelector


def createConstantBlocks(ops: List[TealComponent]) -> List[TealComponent]:
    """Convert TEAL code from using pseudo-ops for constants to using assembled constant blocks.

    This conversion will assemble constants to be as space-efficient as possible.

    Args:
        ops: A list of TealComponents to convert.

    Returns:
        A list of TealComponent that are functionally the same as the input, but with all constants
        loaded either through blocks or the `pushint`/`pushbytes` single-use ops.
    """
    intFreqs: Dict[Union[str, int], int] = OrderedDict()
    byteFreqs: Dict[Union[str, bytes], int] = OrderedDict()

    for op in ops:
        if not isinstance(op, TealOp):
            continue

        basicOp = op.getOp()

        if basicOp == Op.int:
            intValue = extractIntValue(op)
            intFreqs[intValue] = intFreqs.get(intValue, 0) + 1
        elif basicOp == Op.byte:
            byteValue = extractBytesValue(op)
            byteFreqs[byteValue] = byteFreqs.get(byteValue, 0) + 1
        elif basicOp == Op.addr:
            addrValue = extractAddrValue(op)
            byteFreqs[addrValue] = byteFreqs.get(addrValue, 0) + 1
        elif basicOp == Op.method_signature:
            methodValue = extractMethodSigValue(op)
            byteFreqs[methodValue] = byteFreqs.get(methodValue, 0) + 1

    assembled: List[TealComponent] = []

    # because we used OrderedDicts and python sorting is stable, constants with the same frequency
    # will remain in the same order, i.e. first defined, first in block
    sortedInts = sorted(intFreqs, key=lambda x: intFreqs[x], reverse=True)
    sortedBytes = sorted(byteFreqs, key=lambda x: byteFreqs[x], reverse=True)

    # Use Op.pushint if the constant does not occur in the top 4 most frequent and is smaller than
    # 2 ** 7 to improve performance and save block space.
    intBlock = [
        val
        for i, val in enumerate(sortedInts)
        if intFreqs[val] > 1 and (i < 4 or isinstance(val, str) or val >= 2**7)
    ]

    byteBlock = [
        ("0x" + b.hex()) if type(b) is bytes else cast(str, b)
        for b in sortedBytes
        if byteFreqs[b] > 1
    ]

    if len(intBlock) != 0:
        assembled.append(TealOp(None, Op.intcblock, *intBlock))

    if len(byteBlock) != 0:
        assembled.append(TealOp(None, Op.bytecblock, *byteBlock))

    for op in ops:
        if isinstance(op, TealOp):
            basicOp = op.getOp()

            if basicOp == Op.int:
                intValue = extractIntValue(op)
                if intValue not in intBlock:
                    assembled.append(
                        TealOp(op.expr, Op.pushint, intValue, "//", *op.args)
                    )
                    continue

                index = intBlock.index(intValue)
                if index == 0:
                    assembled.append(TealOp(op.expr, Op.intc_0, "//", *op.args))
                elif index == 1:
                    assembled.append(TealOp(op.expr, Op.intc_1, "//", *op.args))
                elif index == 2:
                    assembled.append(TealOp(op.expr, Op.intc_2, "//", *op.args))
                elif index == 3:
                    assembled.append(TealOp(op.expr, Op.intc_3, "//", *op.args))
                else:
                    assembled.append(TealOp(op.expr, Op.intc, index, "//", *op.args))
                continue

            if (
                basicOp == Op.byte
                or basicOp == Op.addr
                or basicOp == Op.method_signature
            ):
                if basicOp == Op.byte:
                    byteValue = extractBytesValue(op)
                elif basicOp == Op.addr:
                    byteValue = extractAddrValue(op)
                elif basicOp == Op.method_signature:
                    byteValue = extractMethodSigValue(op)
                else:
                    raise TealInternalError(
                        "Expect a byte-like constant opcode, get {}".format(op)
                    )

                if byteFreqs[byteValue] == 1:
                    encodedValue = (
                        ("0x" + byteValue.hex())
                        if type(byteValue) is bytes
                        else cast(str, byteValue)
                    )
                    assembled.append(
                        TealOp(op.expr, Op.pushbytes, encodedValue, "//", *op.args)
                    )
                    continue

                index = sortedBytes.index(byteValue)
                if index == 0:
                    assembled.append(TealOp(op.expr, Op.bytec_0, "//", *op.args))
                elif index == 1:
                    assembled.append(TealOp(op.expr, Op.bytec_1, "//", *op.args))
                elif index == 2:
                    assembled.append(TealOp(op.expr, Op.bytec_2, "//", *op.args))
                elif index == 3:
                    assembled.append(TealOp(op.expr, Op.bytec_3, "//", *op.args))
                else:
                    assembled.append(TealOp(op.expr, Op.bytec, index, "//", *op.args))
                continue

        assembled.append(op)

    return assembled



================================================
FILE: pyteal/compiler/constants_test.py
================================================
import pyteal as pt

from pyteal.compiler.constants import (
    extractIntValue,
    extractBytesValue,
    extractAddrValue,
    createConstantBlocks,
    extractMethodSigValue,
)


def test_extractIntValue():
    tests = [
        (pt.TealOp(None, pt.Op.int, 0), 0),
        (pt.TealOp(None, pt.Op.int, 5), 5),
        (pt.TealOp(None, pt.Op.int, "pay"), 1),
        (pt.TealOp(None, pt.Op.int, "NoOp"), 0),
        (pt.TealOp(None, pt.Op.int, "UpdateApplication"), 4),
        (pt.TealOp(None, pt.Op.int, "TMPL_NAME"), "TMPL_NAME"),
    ]

    for op, expected in tests:
        actual = extractIntValue(op)
        assert actual == expected


def test_extractBytesValue():
    tests = [
        (pt.TealOp(None, pt.Op.byte, '""'), b""),
        (pt.TealOp(None, pt.Op.byte, '"test"'), b"test"),
        (pt.TealOp(None, pt.Op.byte, '"\\t\\n\\\\\\""'), b'\t\n\\"'),
        (pt.TealOp(None, pt.Op.byte, "0x"), b""),
        (pt.TealOp(None, pt.Op.byte, "0x00"), b"\x00"),
        (pt.TealOp(None, pt.Op.byte, "0xFF00"), b"\xff\x00"),
        (pt.TealOp(None, pt.Op.byte, "0xff00"), b"\xff\x00"),
        (pt.TealOp(None, pt.Op.byte, "base32()"), b""),
        (pt.TealOp(None, pt.Op.byte, "base32(ORSXG5A)"), b"test"),
        (pt.TealOp(None, pt.Op.byte, "base32(ORSXG5A=)"), b"test"),
        (pt.TealOp(None, pt.Op.byte, "base64()"), b""),
        (pt.TealOp(None, pt.Op.byte, "base64(dGVzdA==)"), b"test"),
        (pt.TealOp(None, pt.Op.byte, "TMPL_NAME"), "TMPL_NAME"),
    ]

    for op, expected in tests:
        actual = extractBytesValue(op)
        assert actual == expected


def test_extractAddrValue():
    tests = [
        (
            pt.TealOp(
                None,
                pt.Op.byte,
                "WSJHNPJ6YCLX5K4GUMQ4ISPK3ABMS3AL3F6CSVQTCUI5F4I65PWEMCWT3M",
            ),
            b"\xb4\x92v\xbd>\xc0\x97~\xab\x86\xa3!\xc4I\xea\xd8\x02\xc9l\x0b\xd9|)V\x13\x15\x11\xd2\xf1\x1e\xeb\xec",
        ),
        (pt.TealOp(None, pt.Op.addr, "TMPL_NAME"), "TMPL_NAME"),
    ]

    for op, expected in tests:
        actual = extractAddrValue(op)
        assert actual == expected


# test case came from: https://gist.github.com/jasonpaulos/99e4f8a75f2fc2ec9b8073c064530359
def test_extractMethodValue():
    tests = [
        (
            pt.TealOp(None, pt.Op.method_signature, '"create(uint64)uint64"'),
            b"\x43\x46\x41\x01",
        ),
        (
            pt.TealOp(None, pt.Op.method_signature, '"update()void"'),
            b"\xa0\xe8\x18\x72",
        ),
        (
            pt.TealOp(None, pt.Op.method_signature, '"optIn(string)string"'),
            b"\xcf\xa6\x8e\x36",
        ),
        (
            pt.TealOp(None, pt.Op.method_signature, '"closeOut()string"'),
            b"\xa9\xf4\x2b\x3d",
        ),
        (
            pt.TealOp(None, pt.Op.method_signature, '"delete()void"'),
            b"\x24\x37\x8d\x3c",
        ),
        (
            pt.TealOp(None, pt.Op.method_signature, '"add(uint64,uint64)uint64"'),
            b"\xfe\x6b\xdf\x69",
        ),
        (pt.TealOp(None, pt.Op.method_signature, '"empty()void"'), b"\xa8\x8c\x26\xa5"),
        (
            pt.TealOp(None, pt.Op.method_signature, '"payment(pay,uint64)bool"'),
            b"\x3e\x3b\x3d\x28",
        ),
        (
            pt.TealOp(
                None,
                pt.Op.method_signature,
                '"referenceTest(account,application,account,asset,account,asset,asset,application,application)uint8[9]"',
            ),
            b"\x0d\xf0\x05\x0f",
        ),
    ]

    for op, expected in tests:
        actual = extractMethodSigValue(op)
        assert actual == expected


def test_createConstantBlocks_empty():
    ops = []

    expected = ops[:]

    actual = createConstantBlocks(ops)
    assert actual == expected


def test_createConstantBlocks_no_consts():
    ops = [
        pt.TealOp(None, pt.Op.txn, "Sender"),
        pt.TealOp(None, pt.Op.txn, "Receiver"),
        pt.TealOp(None, pt.Op.eq),
    ]

    expected = ops[:]

    actual = createConstantBlocks(ops)
    assert actual == expected


def test_createConstantBlocks_pushint():
    ops = [
        pt.TealOp(None, pt.Op.int, 0),
        pt.TealOp(None, pt.Op.int, "OptIn"),
        pt.TealOp(None, pt.Op.add),
    ]

    expected = [
        pt.TealOp(None, pt.Op.pushint, 0, "//", 0),
        pt.TealOp(None, pt.Op.pushint, 1, "//", "OptIn"),
        pt.TealOp(None, pt.Op.add),
    ]

    actual = createConstantBlocks(ops)
    assert actual == expected


def test_createConstantBlocks_intblock_single():
    ops = [
        pt.TealOp(None, pt.Op.int, 1),
        pt.TealOp(None, pt.Op.int, "OptIn"),
        pt.TealOp(None, pt.Op.add),
    ]

    expected = [
        pt.TealOp(None, pt.Op.intcblock, 1),
        pt.TealOp(None, pt.Op.intc_0, "//", 1),
        pt.TealOp(None, pt.Op.intc_0, "//", "OptIn"),
        pt.TealOp(None, pt.Op.add),
    ]

    actual = createConstantBlocks(ops)
    assert actual == expected


def test_createConstantBlocks_intblock_multiple():
    ops = [
        pt.TealOp(None, pt.Op.int, 1),
        pt.TealOp(None, pt.Op.int, "OptIn"),
        pt.TealOp(None, pt.Op.add),
        pt.TealOp(None, pt.Op.int, 2),
        pt.TealOp(None, pt.Op.int, "keyreg"),
        pt.TealOp(None, pt.Op.add),
        pt.TealOp(None, pt.Op.int, 3),
        pt.TealOp(None, pt.Op.int, "ClearState"),
        pt.TealOp(None, pt.Op.add),
    ]

    expected = [
        pt.TealOp(None, pt.Op.intcblock, 1, 2, 3),
        pt.TealOp(None, pt.Op.intc_0, "//", 1),
        pt.TealOp(None, pt.Op.intc_0, "//", "OptIn"),
        pt.TealOp(None, pt.Op.add),
        pt.TealOp(None, pt.Op.intc_1, "//", 2),
        pt.TealOp(None, pt.Op.intc_1, "//", "keyreg"),
        pt.TealOp(None, pt.Op.add),
        pt.TealOp(None, pt.Op.intc_2, "//", 3),
        pt.TealOp(None, pt.Op.intc_2, "//", "ClearState"),
        pt.TealOp(None, pt.Op.add),
    ]

    actual = createConstantBlocks(ops)
    assert actual == expected


def test_createConstantBlocks_intblock_pushint():
    ops = [
        pt.TealOp(None, pt.Op.int, 1),
        pt.TealOp(None, pt.Op.int, "OptIn"),
        pt.TealOp(None, pt.Op.add),
        pt.TealOp(None, pt.Op.int, 2),
        pt.TealOp(None, pt.Op.int, 3),
        pt.TealOp(None, pt.Op.add),
        pt.TealOp(None, pt.Op.int, 3),
        pt.TealOp(None, pt.Op.int, "ClearState"),
        pt.TealOp(None, pt.Op.add),
    ]

    expected = [
        pt.TealOp(None, pt.Op.intcblock, 3, 1),
        pt.TealOp(None, pt.Op.intc_1, "//", 1),
        pt.TealOp(None, pt.Op.intc_1, "//", "OptIn"),
        pt.TealOp(None, pt.Op.add),
        pt.TealOp(None, pt.Op.pushint, 2, "//", 2),
        pt.TealOp(None, pt.Op.intc_0, "//", 3),
        pt.TealOp(None, pt.Op.add),
        pt.TealOp(None, pt.Op.intc_0, "//", 3),
        pt.TealOp(None, pt.Op.intc_0, "//", "ClearState"),
        pt.TealOp(None, pt.Op.add),
    ]

    actual = createConstantBlocks(ops)
    assert actual == expected


def test_createConstantBlocks_pushbytes():
    ops = [
        pt.TealOp(None, pt.Op.byte, "0x0102"),
        pt.TealOp(None, pt.Op.byte, "0x0103"),
        pt.TealOp(None, pt.Op.method_signature, '"empty()void"'),
        pt.TealOp(None, pt.Op.concat),
    ]

    expected = [
        pt.TealOp(None, pt.Op.pushbytes, "0x0102", "//", "0x0102"),
        pt.TealOp(None, pt.Op.pushbytes, "0x0103", "//", "0x0103"),
        pt.TealOp(None, pt.Op.pushbytes, "0xa88c26a5", "//", '"empty()void"'),
        pt.TealOp(None, pt.Op.concat),
    ]

    actual = createConstantBlocks(ops)
    assert actual == expected


def test_createConstantBlocks_byteblock_single():
    ops = [
        pt.TealOp(None, pt.Op.byte, "0x0102"),
        pt.TealOp(None, pt.Op.byte, "base64(AQI=)"),
        pt.TealOp(None, pt.Op.concat),
        pt.TealOp(None, pt.Op.byte, "base32(AEBA====)"),
        pt.TealOp(None, pt.Op.concat),
    ]

    expected = [
        pt.TealOp(None, pt.Op.bytecblock, "0x0102"),
        pt.TealOp(None, pt.Op.bytec_0, "//", "0x0102"),
        pt.TealOp(None, pt.Op.bytec_0, "//", "base64(AQI=)"),
        pt.TealOp(None, pt.Op.concat),
        pt.TealOp(None, pt.Op.bytec_0, "//", "base32(AEBA====)"),
        pt.TealOp(None, pt.Op.concat),
    ]

    actual = createConstantBlocks(ops)
    assert actual == expected


def test_createConstantBlocks_byteblock_multiple():
    ops = [
        pt.TealOp(None, pt.Op.byte, "0x0102"),
        pt.TealOp(None, pt.Op.byte, "base64(AQI=)"),
        pt.TealOp(None, pt.Op.concat),
        pt.TealOp(None, pt.Op.byte, "base32(AEBA====)"),
        pt.TealOp(None, pt.Op.concat),
        pt.TealOp(None, pt.Op.byte, '"test"'),
        pt.TealOp(None, pt.Op.concat),
        pt.TealOp(None, pt.Op.byte, "base32(ORSXG5A=)"),
        pt.TealOp(None, pt.Op.concat),
        pt.TealOp(
            None,
            pt.Op.byte,
            "0xb49276bd3ec0977eab86a321c449ead802c96c0bd97c2956131511d2f11eebec",
        ),
        pt.TealOp(None, pt.Op.concat),
        pt.TealOp(
            None,
            pt.Op.addr,
            "WSJHNPJ6YCLX5K4GUMQ4ISPK3ABMS3AL3F6CSVQTCUI5F4I65PWEMCWT3M",
        ),
        pt.TealOp(None, pt.Op.concat),
        pt.TealOp(None, pt.Op.method_signature, '"closeOut()string"'),
        pt.TealOp(None, pt.Op.concat),
        pt.TealOp(None, pt.Op.byte, "base64(qfQrPQ==)"),
    ]

    expected = [
        pt.TealOp(
            None,
            pt.Op.bytecblock,
            "0x0102",
            "0x74657374",
            "0xb49276bd3ec0977eab86a321c449ead802c96c0bd97c2956131511d2f11eebec",
            "0xa9f42b3d",
        ),
        pt.TealOp(None, pt.Op.bytec_0, "//", "0x0102"),
        pt.TealOp(None, pt.Op.bytec_0, "//", "base64(AQI=)"),
        pt.TealOp(None, pt.Op.concat),
        pt.TealOp(None, pt.Op.bytec_0, "//", "base32(AEBA====)"),
        pt.TealOp(None, pt.Op.concat),
        pt.TealOp(None, pt.Op.bytec_1, "//", '"test"'),
        pt.TealOp(None, pt.Op.concat),
        pt.TealOp(None, pt.Op.bytec_1, "//", "base32(ORSXG5A=)"),
        pt.TealOp(None, pt.Op.concat),
        pt.TealOp(
            None,
            pt.Op.bytec_2,
            "//",
            "0xb49276bd3ec0977eab86a321c449ead802c96c0bd97c2956131511d2f11eebec",
        ),
        pt.TealOp(None, pt.Op.concat),
        pt.TealOp(
            None,
            pt.Op.bytec_2,
            "//",
            "WSJHNPJ6YCLX5K4GUMQ4ISPK3ABMS3AL3F6CSVQTCUI5F4I65PWEMCWT3M",
        ),
        pt.TealOp(None, pt.Op.concat),
        pt.TealOp(None, pt.Op.bytec_3, "//", '"closeOut()string"'),
        pt.TealOp(None, pt.Op.concat),
        pt.TealOp(None, pt.Op.bytec_3, "//", "base64(qfQrPQ==)"),
    ]

    actual = createConstantBlocks(ops)
    assert actual == expected


def test_createConstantBlocks_byteblock_pushbytes():
    ops = [
        pt.TealOp(None, pt.Op.byte, "0x0102"),
        pt.TealOp(None, pt.Op.byte, "base64(AQI=)"),
        pt.TealOp(None, pt.Op.concat),
        pt.TealOp(None, pt.Op.byte, "base32(AEBA====)"),
        pt.TealOp(None, pt.Op.concat),
        pt.TealOp(None, pt.Op.byte, '"test"'),
        pt.TealOp(None, pt.Op.concat),
        pt.TealOp(None, pt.Op.byte, "base32(ORSXG5A=)"),
        pt.TealOp(None, pt.Op.concat),
        pt.TealOp(
            None,
            pt.Op.addr,
            "WSJHNPJ6YCLX5K4GUMQ4ISPK3ABMS3AL3F6CSVQTCUI5F4I65PWEMCWT3M",
        ),
        pt.TealOp(None, pt.Op.concat),
    ]

    expected = [
        pt.TealOp(None, pt.Op.bytecblock, "0x0102", "0x74657374"),
        pt.TealOp(None, pt.Op.bytec_0, "//", "0x0102"),
        pt.TealOp(None, pt.Op.bytec_0, "//", "base64(AQI=)"),
        pt.TealOp(None, pt.Op.concat),
        pt.TealOp(None, pt.Op.bytec_0, "//", "base32(AEBA====)"),
        pt.TealOp(None, pt.Op.concat),
        pt.TealOp(None, pt.Op.bytec_1, "//", '"test"'),
        pt.TealOp(None, pt.Op.concat),
        pt.TealOp(None, pt.Op.bytec_1, "//", "base32(ORSXG5A=)"),
        pt.TealOp(None, pt.Op.concat),
        pt.TealOp(
            None,
            pt.Op.pushbytes,
            "0xb49276bd3ec0977eab86a321c449ead802c96c0bd97c2956131511d2f11eebec",
            "//",
            "WSJHNPJ6YCLX5K4GUMQ4ISPK3ABMS3AL3F6CSVQTCUI5F4I65PWEMCWT3M",
        ),
        pt.TealOp(None, pt.Op.concat),
    ]

    actual = createConstantBlocks(ops)
    assert actual == expected


def test_createConstantBlocks_all():
    ops = [
        pt.TealOp(None, pt.Op.byte, "0x0102"),
        pt.TealOp(None, pt.Op.byte, "base64(AQI=)"),
        pt.TealOp(None, pt.Op.concat),
        pt.TealOp(None, pt.Op.byte, "base32(AEBA====)"),
        pt.TealOp(None, pt.Op.concat),
        pt.TealOp(None, pt.Op.byte, '"test"'),
        pt.TealOp(None, pt.Op.concat),
        pt.TealOp(None, pt.Op.byte, "base32(ORSXG5A=)"),
        pt.TealOp(None, pt.Op.concat),
        pt.TealOp(
            None,
            pt.Op.addr,
            "WSJHNPJ6YCLX5K4GUMQ4ISPK3ABMS3AL3F6CSVQTCUI5F4I65PWEMCWT3M",
        ),
        pt.TealOp(None, pt.Op.concat),
        pt.TealOp(None, pt.Op.int, 1),
        pt.TealOp(None, pt.Op.int, "OptIn"),
        pt.TealOp(None, pt.Op.add),
        pt.TealOp(None, pt.Op.int, 2),
        pt.TealOp(None, pt.Op.int, 3),
        pt.TealOp(None, pt.Op.add),
        pt.TealOp(None, pt.Op.int, 3),
        pt.TealOp(None, pt.Op.int, "ClearState"),
        pt.TealOp(None, pt.Op.add),
    ]

    expected = [
        pt.TealOp(None, pt.Op.intcblock, 3, 1),
        pt.TealOp(None, pt.Op.bytecblock, "0x0102", "0x74657374"),
        pt.TealOp(None, pt.Op.bytec_0, "//", "0x0102"),
        pt.TealOp(None, pt.Op.bytec_0, "//", "base64(AQI=)"),
        pt.TealOp(None, pt.Op.concat),
        pt.TealOp(None, pt.Op.bytec_0, "//", "base32(AEBA====)"),
        pt.TealOp(None, pt.Op.concat),
        pt.TealOp(None, pt.Op.bytec_1, "//", '"test"'),
        pt.TealOp(None, pt.Op.concat),
        pt.TealOp(None, pt.Op.bytec_1, "//", "base32(ORSXG5A=)"),
        pt.TealOp(None, pt.Op.concat),
        pt.TealOp(
            None,
            pt.Op.pushbytes,
            "0xb49276bd3ec0977eab86a321c449ead802c96c0bd97c2956131511d2f11eebec",
            "//",
            "WSJHNPJ6YCLX5K4GUMQ4ISPK3ABMS3AL3F6CSVQTCUI5F4I65PWEMCWT3M",
        ),
        pt.TealOp(None, pt.Op.concat),
        pt.TealOp(None, pt.Op.intc_1, "//", 1),
        pt.TealOp(None, pt.Op.intc_1, "//", "OptIn"),
        pt.TealOp(None, pt.Op.add),
        pt.TealOp(None, pt.Op.pushint, 2, "//", 2),
        pt.TealOp(None, pt.Op.intc_0, "//", 3),
        pt.TealOp(None, pt.Op.add),
        pt.TealOp(None, pt.Op.intc_0, "//", 3),
        pt.TealOp(None, pt.Op.intc_0, "//", "ClearState"),
        pt.TealOp(None, pt.Op.add),
    ]

    actual = createConstantBlocks(ops)
    assert actual == expected


def test_createConstantBlocks_tmpl_int():
    ops = [
        pt.TealOp(None, pt.Op.int, "TMPL_INT_1"),
        pt.TealOp(None, pt.Op.int, "TMPL_INT_1"),
        pt.TealOp(None, pt.Op.eq),
        pt.TealOp(None, pt.Op.int, "TMPL_INT_2"),
        pt.TealOp(None, pt.Op.add),
    ]

    expected = [
        pt.TealOp(None, pt.Op.intcblock, "TMPL_INT_1"),
        pt.TealOp(None, pt.Op.intc_0, "//", "TMPL_INT_1"),
        pt.TealOp(None, pt.Op.intc_0, "//", "TMPL_INT_1"),
        pt.TealOp(None, pt.Op.eq),
        pt.TealOp(None, pt.Op.pushint, "TMPL_INT_2", "//", "TMPL_INT_2"),
        pt.TealOp(None, pt.Op.add),
    ]

    actual = createConstantBlocks(ops)
    assert actual == expected


def test_createConstantBlocks_tmpl_int_mixed():
    ops = [
        pt.TealOp(None, pt.Op.int, "TMPL_INT_1"),
        pt.TealOp(None, pt.Op.int, "TMPL_INT_1"),
        pt.TealOp(None, pt.Op.eq),
        pt.TealOp(None, pt.Op.int, "TMPL_INT_2"),
        pt.TealOp(None, pt.Op.add),
        pt.TealOp(None, pt.Op.int, 0),
        pt.TealOp(None, pt.Op.int, 0),
        pt.TealOp(None, pt.Op.add),
        pt.TealOp(None, pt.Op.int, 1),
        pt.TealOp(None, pt.Op.add),
    ]

    expected = [
        pt.TealOp(None, pt.Op.intcblock, "TMPL_INT_1", 0),
        pt.TealOp(None, pt.Op.intc_0, "//", "TMPL_INT_1"),
        pt.TealOp(None, pt.Op.intc_0, "//", "TMPL_INT_1"),
        pt.TealOp(None, pt.Op.eq),
        pt.TealOp(None, pt.Op.pushint, "TMPL_INT_2", "//", "TMPL_INT_2"),
        pt.TealOp(None, pt.Op.add),
        pt.TealOp(None, pt.Op.intc_1, "//", 0),
        pt.TealOp(None, pt.Op.intc_1, "//", 0),
        pt.TealOp(None, pt.Op.add),
        pt.TealOp(None, pt.Op.pushint, 1, "//", 1),
        pt.TealOp(None, pt.Op.add),
    ]

    actual = createConstantBlocks(ops)
    assert actual == expected


def test_createConstantBlocks_tmpl_bytes():
    ops = [
        pt.TealOp(None, pt.Op.byte, "TMPL_BYTES_1"),
        pt.TealOp(None, pt.Op.byte, "TMPL_BYTES_1"),
        pt.TealOp(None, pt.Op.eq),
        pt.TealOp(None, pt.Op.byte, "TMPL_BYTES_2"),
        pt.TealOp(None, pt.Op.concat),
    ]

    expected = [
        pt.TealOp(None, pt.Op.bytecblock, "TMPL_BYTES_1"),
        pt.TealOp(None, pt.Op.bytec_0, "//", "TMPL_BYTES_1"),
        pt.TealOp(None, pt.Op.bytec_0, "//", "TMPL_BYTES_1"),
        pt.TealOp(None, pt.Op.eq),
        pt.TealOp(None, pt.Op.pushbytes, "TMPL_BYTES_2", "//", "TMPL_BYTES_2"),
        pt.TealOp(None, pt.Op.concat),
    ]

    actual = createConstantBlocks(ops)
    assert actual == expected


def test_createConstantBlocks_tmpl_bytes_mixed():
    ops = [
        pt.TealOp(None, pt.Op.byte, "TMPL_BYTES_1"),
        pt.TealOp(None, pt.Op.byte, "TMPL_BYTES_1"),
        pt.TealOp(None, pt.Op.eq),
        pt.TealOp(None, pt.Op.byte, "TMPL_BYTES_2"),
        pt.TealOp(None, pt.Op.concat),
        pt.TealOp(None, pt.Op.byte, "0x00"),
        pt.TealOp(None, pt.Op.byte, "0x00"),
        pt.TealOp(None, pt.Op.concat),
        pt.TealOp(None, pt.Op.byte, "0x01"),
        pt.TealOp(None, pt.Op.concat),
    ]

    expected = [
        pt.TealOp(None, pt.Op.bytecblock, "TMPL_BYTES_1", "0x00"),
        pt.TealOp(None, pt.Op.bytec_0, "//", "TMPL_BYTES_1"),
        pt.TealOp(None, pt.Op.bytec_0, "//", "TMPL_BYTES_1"),
        pt.TealOp(None, pt.Op.eq),
        pt.TealOp(None, pt.Op.pushbytes, "TMPL_BYTES_2", "//", "TMPL_BYTES_2"),
        pt.TealOp(None, pt.Op.concat),
        pt.TealOp(None, pt.Op.bytec_1, "//", "0x00"),
        pt.TealOp(None, pt.Op.bytec_1, "//", "0x00"),
        pt.TealOp(None, pt.Op.concat),
        pt.TealOp(None, pt.Op.pushbytes, "0x01", "//", "0x01"),
        pt.TealOp(None, pt.Op.concat),
    ]

    actual = createConstantBlocks(ops)
    assert actual == expected


def test_createConstantBlocks_tmpl_all():
    ops = [
        pt.TealOp(None, pt.Op.byte, "TMPL_BYTES_1"),
        pt.TealOp(None, pt.Op.byte, "TMPL_BYTES_1"),
        pt.TealOp(None, pt.Op.eq),
        pt.TealOp(None, pt.Op.byte, "TMPL_BYTES_2"),
        pt.TealOp(None, pt.Op.concat),
        pt.TealOp(None, pt.Op.byte, "0x00"),
        pt.TealOp(None, pt.Op.byte, "0x00"),
        pt.TealOp(None, pt.Op.concat),
        pt.TealOp(None, pt.Op.byte, "0x01"),
        pt.TealOp(None, pt.Op.concat),
        pt.TealOp(None, pt.Op.len),
        pt.TealOp(None, pt.Op.int, "TMPL_INT_1"),
        pt.TealOp(None, pt.Op.int, "TMPL_INT_1"),
        pt.TealOp(None, pt.Op.eq),
        pt.TealOp(None, pt.Op.int, "TMPL_INT_2"),
        pt.TealOp(None, pt.Op.add),
        pt.TealOp(None, pt.Op.int, 0),
        pt.TealOp(None, pt.Op.int, 0),
        pt.TealOp(None, pt.Op.add),
        pt.TealOp(None, pt.Op.int, 1),
        pt.TealOp(None, pt.Op.add),
        pt.TealOp(None, pt.Op.eq),
    ]

    expected = [
        pt.TealOp(None, pt.Op.intcblock, "TMPL_INT_1", 0),
        pt.TealOp(None, pt.Op.bytecblock, "TMPL_BYTES_1", "0x00"),
        pt.TealOp(None, pt.Op.bytec_0, "//", "TMPL_BYTES_1"),
        pt.TealOp(None, pt.Op.bytec_0, "//", "TMPL_BYTES_1"),
        pt.TealOp(None, pt.Op.eq),
        pt.TealOp(None, pt.Op.pushbytes, "TMPL_BYTES_2", "//", "TMPL_BYTES_2"),
        pt.TealOp(None, pt.Op.concat),
        pt.TealOp(None, pt.Op.bytec_1, "//", "0x00"),
        pt.TealOp(None, pt.Op.bytec_1, "//", "0x00"),
        pt.TealOp(None, pt.Op.concat),
        pt.TealOp(None, pt.Op.pushbytes, "0x01", "//", "0x01"),
        pt.TealOp(None, pt.Op.concat),
        pt.TealOp(None, pt.Op.len),
        pt.TealOp(None, pt.Op.intc_0, "//", "TMPL_INT_1"),
        pt.TealOp(None, pt.Op.intc_0, "//", "TMPL_INT_1"),
        pt.TealOp(None, pt.Op.eq),
        pt.TealOp(None, pt.Op.pushint, "TMPL_INT_2", "//", "TMPL_INT_2"),
        pt.TealOp(None, pt.Op.add),
        pt.TealOp(None, pt.Op.intc_1, "//", 0),
        pt.TealOp(None, pt.Op.intc_1, "//", 0),
        pt.TealOp(None, pt.Op.add),
        pt.TealOp(None, pt.Op.pushint, 1, "//", 1),
        pt.TealOp(None, pt.Op.add),
        pt.TealOp(None, pt.Op.eq),
    ]

    actual = createConstantBlocks(ops)
    assert actual == expected


def test_createConstantBlocks_intc():
    """Test scenario where there are more than 4 constants in the intcblock.
    pt.If the 4th constant can't fit in one varuint byte (more than 2**7) it
    should be referenced with the pt.Op.intc 4 command.
    """

    ops = [
        pt.TealOp(None, pt.Op.int, 0),
        pt.TealOp(None, pt.Op.int, 0),
        pt.TealOp(None, pt.Op.int, 1),
        pt.TealOp(None, pt.Op.int, 1),
        pt.TealOp(None, pt.Op.int, 2),
        pt.TealOp(None, pt.Op.int, 2),
        pt.TealOp(None, pt.Op.int, 3),
        pt.TealOp(None, pt.Op.int, 3),
        pt.TealOp(None, pt.Op.int, 2**7),
        pt.TealOp(None, pt.Op.int, 2**7),
    ]

    expected = [
        pt.TealOp(None, pt.Op.intcblock, 0, 1, 2, 3, 2**7),
        pt.TealOp(None, pt.Op.intc_0, "//", 0),
        pt.TealOp(None, pt.Op.intc_0, "//", 0),
        pt.TealOp(None, pt.Op.intc_1, "//", 1),
        pt.TealOp(None, pt.Op.intc_1, "//", 1),
        pt.TealOp(None, pt.Op.intc_2, "//", 2),
        pt.TealOp(None, pt.Op.intc_2, "//", 2),
        pt.TealOp(None, pt.Op.intc_3, "//", 3),
        pt.TealOp(None, pt.Op.intc_3, "//", 3),
        pt.TealOp(None, pt.Op.intc, 4, "//", 2**7),
        pt.TealOp(None, pt.Op.intc, 4, "//", 2**7),
    ]

    actual = createConstantBlocks(ops)
    assert actual == expected


def test_createConstantBlocks_small_constant():
    """pt.If a constant cannot be referenced using the intc_[0..3] commands
    and it can be stored in one varuint it byte then pt.Op.pushint is used.
    """

    for cur in range(4, 2**7):
        ops = [
            pt.TealOp(None, pt.Op.int, 0),
            pt.TealOp(None, pt.Op.int, 0),
            pt.TealOp(None, pt.Op.int, 1),
            pt.TealOp(None, pt.Op.int, 1),
            pt.TealOp(None, pt.Op.int, 2),
            pt.TealOp(None, pt.Op.int, 2),
            pt.TealOp(None, pt.Op.int, 3),
            pt.TealOp(None, pt.Op.int, 3),
            pt.TealOp(None, pt.Op.int, cur),
            pt.TealOp(None, pt.Op.int, cur),
        ]

        expected = [
            pt.TealOp(None, pt.Op.intcblock, 0, 1, 2, 3),
            pt.TealOp(None, pt.Op.intc_0, "//", 0),
            pt.TealOp(None, pt.Op.intc_0, "//", 0),
            pt.TealOp(None, pt.Op.intc_1, "//", 1),
            pt.TealOp(None, pt.Op.intc_1, "//", 1),
            pt.TealOp(None, pt.Op.intc_2, "//", 2),
            pt.TealOp(None, pt.Op.intc_2, "//", 2),
            pt.TealOp(None, pt.Op.intc_3, "//", 3),
            pt.TealOp(None, pt.Op.intc_3, "//", 3),
            pt.TealOp(None, pt.Op.pushint, cur, "//", cur),
            pt.TealOp(None, pt.Op.pushint, cur, "//", cur),
        ]

        actual = createConstantBlocks(ops)
        assert actual == expected



================================================
FILE: pyteal/compiler/flatten.py
================================================
from collections import defaultdict

from pyteal.ast import Expr, SubroutineDeclaration, SubroutineDefinition
from pyteal import compiler
from pyteal.errors import TealInternalError, TealInputError
from pyteal.ir import (
    Op,
    TealOp,
    TealLabel,
    TealComponent,
    TealBlock,
    TealSimpleBlock,
    TealConditionalBlock,
    LabelReference,
)


def flattenBlocks(blocks: list[TealBlock]) -> list[TealComponent]:
    """Lowers a list of TealBlocks into a list of TealComponents.

    Args:
        blocks: The blocks to lower.
    """
    codeblocks: list[list[TealOp]] = []
    references: defaultdict[int, int] = defaultdict(int)
    referer: dict[int, int] = {}

    def add_if_new(nextIndex, i):
        if nextIndex not in referer:
            referer[nextIndex] = i

    labelRefs: dict[int, LabelReference] = dict()

    def indexToLabel(index: int) -> LabelReference:
        if index not in labelRefs:
            labelRefs[index] = LabelReference("l{}".format(index))
        return labelRefs[index]

    def blockIndexByReference(block: TealBlock) -> int:
        for i, b in enumerate(blocks):
            if block is b:
                return i
        raise ValueError("Block not present in list: {}".format(block))

    root_expr: Expr | None = None
    for i, block in enumerate(blocks):
        code = list(block.ops)
        codeblocks.append(code)
        if block.isTerminal():
            continue

        root_expr = block._sframes_container

        if type(block) is TealSimpleBlock:
            assert block.nextBlock is not None

            nextIndex = blockIndexByReference(block.nextBlock)

            if nextIndex != i + 1:
                references[nextIndex] += 1
                add_if_new(nextIndex, i)
                code.append(TealOp(root_expr, Op.b, indexToLabel(nextIndex)))  # T2PT5

        elif type(block) is TealConditionalBlock:
            assert block.trueBlock is not None
            assert block.falseBlock is not None

            trueIndex = blockIndexByReference(block.trueBlock)
            falseIndex = blockIndexByReference(block.falseBlock)

            if falseIndex == i + 1:
                references[trueIndex] += 1
                add_if_new(trueIndex, i)
                code.append(TealOp(root_expr, Op.bnz, indexToLabel(trueIndex)))  # T2PT5
                continue

            if trueIndex == i + 1:
                references[falseIndex] += 1
                add_if_new(falseIndex, i)
                code.append(TealOp(root_expr, Op.bz, indexToLabel(falseIndex)))  # T2PT5
                continue

            references[trueIndex] += 1
            add_if_new(trueIndex, i)
            code.append(TealOp(root_expr, Op.bnz, indexToLabel(trueIndex)))  # T2PT5

            references[falseIndex] += 1
            add_if_new(falseIndex, i)
            code.append(TealOp(root_expr, Op.b, indexToLabel(falseIndex)))  # T2PT5
        else:
            raise TealInternalError("Unrecognized block type: {}".format(type(block)))

    teal: list[TealComponent] = []
    root_expr = None
    for i, code in enumerate(codeblocks):
        if references[i] != 0:
            root_expr = (
                blocks[i]._sframes_container
                or blocks[referer[i]]._sframes_container
                or root_expr
            )
            teal.append(TealLabel(root_expr, indexToLabel(i)))  # T2PT6
        teal += code

    return teal


def flattenSubroutines(
    subroutineMapping: dict[SubroutineDefinition | None, list[TealComponent]],
    subroutineToLabel: dict[SubroutineDefinition, str],
    options: "compiler.CompileOptions",
) -> list[TealComponent]:
    """Combines each subroutine's list of TealComponents into a single list of TealComponents that
    represents the entire program.

    Args:
        subroutineMapping: A dictionary containing a list of TealComponents for every subroutine in
            a program. The key None is taken to indicate the main program routine.
        subroutineToLabel: An ordered dictionary which resolves each subroutine to a string label.

    Returns:
        A single list of TealComponents representing the entire program.
    """
    combinedOps: list[TealComponent] = []

    # By default all branch labels in each subroutine will start from "l0". To
    # make each subroutine have unique labels, we prefix "main_" to the ones
    # from the main routine, and "subX_" (the subroutine label) to the
    # ones from each subroutine

    mainRoutine = subroutineMapping[None]
    for stmt in mainRoutine:
        if isinstance(stmt, TealLabel):
            stmt.getLabelRef().addPrefix("main_")
    combinedOps += mainRoutine

    for subroutine, label in subroutineToLabel.items():
        comment = subroutine.name()
        labelPrefix = label + "_"

        subroutineOps = subroutineMapping[subroutine]
        for stmt in subroutineOps:
            if isinstance(stmt, TealLabel):
                stmt.getLabelRef().addPrefix(labelPrefix)

        # this is needed for source map generation
        dexpr: SubroutineDeclaration | None
        try:
            dexpr = subroutine.get_declaration_by_option(options.use_frame_pointers)
        except TealInputError:
            dexpr = None

        combinedOps.append(TealLabel(dexpr, LabelReference(label), comment))  # T2PT1
        combinedOps += subroutineOps

    return combinedOps



================================================
FILE: pyteal/compiler/flatten_test.py
================================================
from collections import OrderedDict

import pyteal as pt

from pyteal.compiler.flatten import flattenBlocks, flattenSubroutines


def test_flattenBlocks_none():
    blocks = []

    expected = []
    actual = flattenBlocks(blocks)

    assert actual == expected


def test_flattenBlocks_single_empty():
    blocks = [pt.TealSimpleBlock([])]

    expected = []
    actual = flattenBlocks(blocks)

    assert actual == expected


def test_flattenBlocks_single_one():
    blocks = [pt.TealSimpleBlock([pt.TealOp(None, pt.Op.int, 1)])]

    expected = [pt.TealOp(None, pt.Op.int, 1)]
    actual = flattenBlocks(blocks)

    assert actual == expected


def test_flattenBlocks_single_many():
    blocks = [
        pt.TealSimpleBlock(
            [
                pt.TealOp(None, pt.Op.int, 1),
                pt.TealOp(None, pt.Op.int, 2),
                pt.TealOp(None, pt.Op.int, 3),
                pt.TealOp(None, pt.Op.add),
                pt.TealOp(None, pt.Op.add),
            ]
        )
    ]

    expected = [
        pt.TealOp(None, pt.Op.int, 1),
        pt.TealOp(None, pt.Op.int, 2),
        pt.TealOp(None, pt.Op.int, 3),
        pt.TealOp(None, pt.Op.add),
        pt.TealOp(None, pt.Op.add),
    ]
    actual = flattenBlocks(blocks)

    assert actual == expected


def test_flattenBlocks_sequence():
    block5 = pt.TealSimpleBlock([pt.TealOp(None, pt.Op.int, 5)])
    block4 = pt.TealSimpleBlock([pt.TealOp(None, pt.Op.int, 4)])
    block4.setNextBlock(block5)
    block3 = pt.TealSimpleBlock([pt.TealOp(None, pt.Op.int, 3)])
    block3.setNextBlock(block4)
    block2 = pt.TealSimpleBlock([pt.TealOp(None, pt.Op.int, 2)])
    block2.setNextBlock(block3)
    block1 = pt.TealSimpleBlock([pt.TealOp(None, pt.Op.int, 1)])
    block1.setNextBlock(block2)
    block1.addIncoming()
    block1.validateTree()
    blocks = [block1, block2, block3, block4, block5]

    expected = [
        pt.TealOp(None, pt.Op.int, 1),
        pt.TealOp(None, pt.Op.int, 2),
        pt.TealOp(None, pt.Op.int, 3),
        pt.TealOp(None, pt.Op.int, 4),
        pt.TealOp(None, pt.Op.int, 5),
    ]
    actual = flattenBlocks(blocks)

    assert actual == expected


def test_flattenBlocks_branch():
    blockTrue = pt.TealSimpleBlock(
        [pt.TealOp(None, pt.Op.byte, '"true"'), pt.TealOp(None, pt.Op.return_)]
    )
    blockFalse = pt.TealSimpleBlock(
        [pt.TealOp(None, pt.Op.byte, '"false"'), pt.TealOp(None, pt.Op.return_)]
    )
    block = pt.TealConditionalBlock([pt.TealOp(None, pt.Op.int, 1)])
    block.setTrueBlock(blockTrue)
    block.setFalseBlock(blockFalse)
    block.addIncoming()
    block.validateTree()
    blocks = [block, blockFalse, blockTrue]

    expected = [
        pt.TealOp(None, pt.Op.int, 1),
        pt.TealOp(None, pt.Op.bnz, pt.LabelReference("l2")),
        pt.TealOp(None, pt.Op.byte, '"false"'),
        pt.TealOp(None, pt.Op.return_),
        pt.TealLabel(None, pt.LabelReference("l2")),
        pt.TealOp(None, pt.Op.byte, '"true"'),
        pt.TealOp(None, pt.Op.return_),
    ]
    actual = flattenBlocks(blocks)

    assert actual == expected


def test_flattenBlocks_branch_equal_end_nodes():
    blockTrueEnd = pt.TealSimpleBlock([pt.TealOp(None, pt.Op.return_)])
    blockTrue = pt.TealSimpleBlock([pt.TealOp(None, pt.Op.byte, '"true"')])
    blockTrue.setNextBlock(blockTrueEnd)
    blockFalseEnd = pt.TealSimpleBlock([pt.TealOp(None, pt.Op.return_)])
    blockFalse = pt.TealSimpleBlock([pt.TealOp(None, pt.Op.byte, '"false"')])
    blockFalse.setNextBlock(blockFalseEnd)
    block = pt.TealConditionalBlock([pt.TealOp(None, pt.Op.int, 1)])
    block.setTrueBlock(blockTrue)
    block.setFalseBlock(blockFalse)
    block.addIncoming()
    block.validateTree()
    blocks = [block, blockFalse, blockFalseEnd, blockTrue, blockTrueEnd]

    expected = [
        pt.TealOp(None, pt.Op.int, 1),
        pt.TealOp(None, pt.Op.bnz, pt.LabelReference("l3")),
        pt.TealOp(None, pt.Op.byte, '"false"'),
        pt.TealOp(None, pt.Op.return_),
        pt.TealLabel(None, pt.LabelReference("l3")),
        pt.TealOp(None, pt.Op.byte, '"true"'),
        pt.TealOp(None, pt.Op.return_),
    ]
    actual = flattenBlocks(blocks)

    assert actual == expected


def test_flattenBlocks_branch_converge():
    blockEnd = pt.TealSimpleBlock([pt.TealOp(None, pt.Op.return_)])
    blockTrue = pt.TealSimpleBlock([pt.TealOp(None, pt.Op.byte, '"true"')])
    blockTrue.setNextBlock(blockEnd)
    blockFalse = pt.TealSimpleBlock([pt.TealOp(None, pt.Op.byte, '"false"')])
    blockFalse.setNextBlock(blockEnd)
    block = pt.TealConditionalBlock([pt.TealOp(None, pt.Op.int, 1)])
    block.setTrueBlock(blockTrue)
    block.setFalseBlock(blockFalse)
    block.addIncoming()
    block.validateTree()
    blocks = [block, blockFalse, blockTrue, blockEnd]

    expected = [
        pt.TealOp(None, pt.Op.int, 1),
        pt.TealOp(None, pt.Op.bnz, pt.LabelReference("l2")),
        pt.TealOp(None, pt.Op.byte, '"false"'),
        pt.TealOp(None, pt.Op.b, pt.LabelReference("l3")),
        pt.TealLabel(None, pt.LabelReference("l2")),
        pt.TealOp(None, pt.Op.byte, '"true"'),
        pt.TealLabel(None, pt.LabelReference("l3")),
        pt.TealOp(None, pt.Op.return_),
    ]
    actual = flattenBlocks(blocks)

    assert actual == expected


def test_flattenBlocks_multiple_branch():
    blockTrueTrue = pt.TealSimpleBlock(
        [pt.TealOp(None, pt.Op.byte, '"true true"'), pt.TealOp(None, pt.Op.return_)]
    )
    blockTrueFalse = pt.TealSimpleBlock(
        [pt.TealOp(None, pt.Op.byte, '"true false"'), pt.TealOp(None, pt.Op.err)]
    )
    blockTrueBranch = pt.TealConditionalBlock([])
    blockTrueBranch.setTrueBlock(blockTrueTrue)
    blockTrueBranch.setFalseBlock(blockTrueFalse)
    blockTrue = pt.TealSimpleBlock([pt.TealOp(None, pt.Op.byte, '"true"')])
    blockTrue.setNextBlock(blockTrueBranch)
    blockFalse = pt.TealSimpleBlock(
        [pt.TealOp(None, pt.Op.byte, '"false"'), pt.TealOp(None, pt.Op.return_)]
    )
    block = pt.TealConditionalBlock([pt.TealOp(None, pt.Op.int, 1)])
    block.setTrueBlock(blockTrue)
    block.setFalseBlock(blockFalse)
    block.addIncoming()
    block.validateTree()
    blocks = [
        block,
        blockFalse,
        blockTrue,
        blockTrueBranch,
        blockTrueFalse,
        blockTrueTrue,
    ]

    expected = [
        pt.TealOp(None, pt.Op.int, 1),
        pt.TealOp(None, pt.Op.bnz, pt.LabelReference("l2")),
        pt.TealOp(None, pt.Op.byte, '"false"'),
        pt.TealOp(None, pt.Op.return_),
        pt.TealLabel(None, pt.LabelReference("l2")),
        pt.TealOp(None, pt.Op.byte, '"true"'),
        pt.TealOp(None, pt.Op.bnz, pt.LabelReference("l5")),
        pt.TealOp(None, pt.Op.byte, '"true false"'),
        pt.TealOp(None, pt.Op.err),
        pt.TealLabel(None, pt.LabelReference("l5")),
        pt.TealOp(None, pt.Op.byte, '"true true"'),
        pt.TealOp(None, pt.Op.return_),
    ]
    actual = flattenBlocks(blocks)

    assert actual == expected


def test_flattenBlocks_multiple_branch_converge():
    blockEnd = pt.TealSimpleBlock([pt.TealOp(None, pt.Op.return_)])
    blockTrueTrue = pt.TealSimpleBlock([pt.TealOp(None, pt.Op.byte, '"true true"')])
    blockTrueTrue.setNextBlock(blockEnd)
    blockTrueFalse = pt.TealSimpleBlock(
        [pt.TealOp(None, pt.Op.byte, '"true false"'), pt.TealOp(None, pt.Op.err)]
    )
    blockTrueBranch = pt.TealConditionalBlock([])
    blockTrueBranch.setTrueBlock(blockTrueTrue)
    blockTrueBranch.setFalseBlock(blockTrueFalse)
    blockTrue = pt.TealSimpleBlock([pt.TealOp(None, pt.Op.byte, '"true"')])
    blockTrue.setNextBlock(blockTrueBranch)
    blockFalse = pt.TealSimpleBlock([pt.TealOp(None, pt.Op.byte, '"false"')])
    blockFalse.setNextBlock(blockEnd)
    block = pt.TealConditionalBlock([pt.TealOp(None, pt.Op.int, 1)])
    block.setTrueBlock(blockTrue)
    block.setFalseBlock(blockFalse)
    block.addIncoming()
    block.validateTree()
    blocks = [
        block,
        blockFalse,
        blockTrue,
        blockTrueBranch,
        blockTrueFalse,
        blockTrueTrue,
        blockEnd,
    ]

    expected = [
        pt.TealOp(None, pt.Op.int, 1),
        pt.TealOp(None, pt.Op.bnz, pt.LabelReference("l2")),
        pt.TealOp(None, pt.Op.byte, '"false"'),
        pt.TealOp(None, pt.Op.b, pt.LabelReference("l6")),
        pt.TealLabel(None, pt.LabelReference("l2")),
        pt.TealOp(None, pt.Op.byte, '"true"'),
        pt.TealOp(None, pt.Op.bnz, pt.LabelReference("l5")),
        pt.TealOp(None, pt.Op.byte, '"true false"'),
        pt.TealOp(None, pt.Op.err),
        pt.TealLabel(None, pt.LabelReference("l5")),
        pt.TealOp(None, pt.Op.byte, '"true true"'),
        pt.TealLabel(None, pt.LabelReference("l6")),
        pt.TealOp(None, pt.Op.return_),
    ]
    actual = flattenBlocks(blocks)

    assert actual == expected


def test_flattenSubroutines_no_subroutines():
    subroutineToLabel = OrderedDict()

    l1Label = pt.LabelReference("l1")
    mainOps = [
        pt.TealOp(None, pt.Op.txn, "Fee"),
        pt.TealOp(None, pt.Op.int, 0),
        pt.TealOp(None, pt.Op.eq),
        pt.TealOp(None, pt.Op.bz, l1Label),
        pt.TealOp(None, pt.Op.int, 1),
        pt.TealOp(None, pt.Op.return_),
        pt.TealLabel(None, l1Label),
        pt.TealOp(None, pt.Op.int, 0),
        pt.TealOp(None, pt.Op.return_),
    ]

    subroutineMapping = {None: mainOps}

    expectedL1Label = pt.LabelReference("main_l1")
    expected = [
        pt.TealOp(None, pt.Op.txn, "Fee"),
        pt.TealOp(None, pt.Op.int, 0),
        pt.TealOp(None, pt.Op.eq),
        pt.TealOp(None, pt.Op.bz, expectedL1Label),
        pt.TealOp(None, pt.Op.int, 1),
        pt.TealOp(None, pt.Op.return_),
        pt.TealLabel(None, expectedL1Label),
        pt.TealOp(None, pt.Op.int, 0),
        pt.TealOp(None, pt.Op.return_),
    ]

    opts = pt.CompileOptions()
    actual = flattenSubroutines(subroutineMapping, subroutineToLabel, opts)

    assert actual == expected


def without_expr(comp):
    if isinstance(comp, pt.TealOp):
        return pt.TealOp(None, comp.op, *comp.args)
    if isinstance(comp, pt.TealLabel):
        return pt.TealLabel(None, comp.label, comp.comment)

    assert False, "should never get here"


def test_flattenSubroutines_1_subroutine():
    subroutine = pt.SubroutineDefinition(
        lambda: pt.Int(1) + pt.Int(2) + pt.Int(3), pt.TealType.uint64
    )

    subroutineToLabel = OrderedDict()
    subroutineToLabel[subroutine] = "sub0"

    subroutineLabel = pt.LabelReference(subroutineToLabel[subroutine])
    subroutineOps = [
        pt.TealOp(None, pt.Op.int, 1),
        pt.TealOp(None, pt.Op.int, 2),
        pt.TealOp(None, pt.Op.int, 3),
        pt.TealOp(None, pt.Op.add),
        pt.TealOp(None, pt.Op.add),
        pt.TealOp(None, pt.Op.retsub),
    ]

    l1Label = pt.LabelReference("l1")
    mainOps = [
        pt.TealOp(None, pt.Op.txn, "Fee"),
        pt.TealOp(None, pt.Op.int, 0),
        pt.TealOp(None, pt.Op.eq),
        pt.TealOp(None, pt.Op.bz, l1Label),
        pt.TealOp(None, pt.Op.callsub, subroutineLabel),
        pt.TealOp(None, pt.Op.return_),
        pt.TealLabel(None, l1Label),
        pt.TealOp(None, pt.Op.int, 0),
        pt.TealOp(None, pt.Op.return_),
    ]

    subroutineMapping = {None: mainOps, subroutine: subroutineOps}

    expectedL1Label = pt.LabelReference("main_l1")
    expectedSubroutineLabel = pt.LabelReference("sub0")
    expected = [
        pt.TealOp(None, pt.Op.txn, "Fee"),
        pt.TealOp(None, pt.Op.int, 0),
        pt.TealOp(None, pt.Op.eq),
        pt.TealOp(None, pt.Op.bz, expectedL1Label),
        pt.TealOp(None, pt.Op.callsub, expectedSubroutineLabel),
        pt.TealOp(None, pt.Op.return_),
        pt.TealLabel(None, expectedL1Label),
        pt.TealOp(None, pt.Op.int, 0),
        pt.TealOp(None, pt.Op.return_),
        pt.TealLabel(None, expectedSubroutineLabel, "<lambda>"),
        pt.TealOp(None, pt.Op.int, 1),
        pt.TealOp(None, pt.Op.int, 2),
        pt.TealOp(None, pt.Op.int, 3),
        pt.TealOp(None, pt.Op.add),
        pt.TealOp(None, pt.Op.add),
        pt.TealOp(None, pt.Op.retsub),
    ]

    opts = pt.CompileOptions()
    actual = flattenSubroutines(subroutineMapping, subroutineToLabel, opts)

    assert list(map(without_expr, actual)) == expected


def test_flattenSubroutines_multiple_subroutines():
    def sub1Impl():
        return None

    def sub2Impl(a1):
        return None

    def sub3Impl(a1, a2, a3):
        return None

    subroutine1 = pt.SubroutineDefinition(sub1Impl, pt.TealType.uint64)
    subroutine2 = pt.SubroutineDefinition(sub2Impl, pt.TealType.bytes)
    subroutine3 = pt.SubroutineDefinition(sub3Impl, pt.TealType.none)

    subroutineToLabel = OrderedDict()
    subroutineToLabel[subroutine1] = "sub0"
    subroutineToLabel[subroutine2] = "sub1"
    subroutineToLabel[subroutine3] = "sub2"

    subroutine1Label = pt.LabelReference(subroutineToLabel[subroutine1])
    subroutine1Ops = [
        pt.TealOp(None, pt.Op.int, 1),
        pt.TealOp(None, pt.Op.int, 2),
        pt.TealOp(None, pt.Op.int, 3),
        pt.TealOp(None, pt.Op.add),
        pt.TealOp(None, pt.Op.add),
        pt.TealOp(None, pt.Op.retsub),
    ]

    subroutine2Label = pt.LabelReference(subroutineToLabel[subroutine2])
    subroutine2L1Label = pt.LabelReference("l1")
    subroutine2L2Label = pt.LabelReference("l2")
    subroutine2L3Label = pt.LabelReference("l3")
    subroutine2L4Label = pt.LabelReference("l4")
    subroutine2Ops = [
        pt.TealOp(None, pt.Op.dup),
        pt.TealOp(None, pt.Op.int, 1),
        pt.TealOp(None, pt.Op.eq),
        pt.TealOp(None, pt.Op.bnz, subroutine2L1Label),
        pt.TealOp(None, pt.Op.dup),
        pt.TealOp(None, pt.Op.int, 2),
        pt.TealOp(None, pt.Op.eq),
        pt.TealOp(None, pt.Op.bnz, subroutine2L2Label),
        pt.TealOp(None, pt.Op.dup),
        pt.TealOp(None, pt.Op.int, 3),
        pt.TealOp(None, pt.Op.eq),
        pt.TealOp(None, pt.Op.bnz, subroutine2L3Label),
        pt.TealOp(None, pt.Op.dup),
        pt.TealOp(None, pt.Op.int, 4),
        pt.TealOp(None, pt.Op.eq),
        pt.TealOp(None, pt.Op.bnz, subroutine2L4Label),
        pt.TealOp(None, pt.Op.err),
        pt.TealLabel(None, subroutine2L1Label),
        pt.TealOp(None, pt.Op.pop),
        pt.TealOp(None, pt.Op.byte, '"1"'),
        pt.TealOp(None, pt.Op.retsub),
        pt.TealLabel(None, subroutine2L2Label),
        pt.TealOp(None, pt.Op.pop),
        pt.TealOp(None, pt.Op.byte, '"2"'),
        pt.TealOp(None, pt.Op.retsub),
        pt.TealLabel(None, subroutine2L3Label),
        pt.TealOp(None, pt.Op.pop),
        pt.TealOp(None, pt.Op.byte, '"3"'),
        pt.TealOp(None, pt.Op.retsub),
        pt.TealLabel(None, subroutine2L4Label),
        pt.TealOp(None, pt.Op.pop),
        pt.TealOp(None, pt.Op.byte, '"4"'),
        pt.TealOp(None, pt.Op.retsub),
    ]

    subroutine3Label = pt.LabelReference(subroutineToLabel[subroutine3])
    subroutine3L1Label = pt.LabelReference("l1")
    subroutine3Ops = [
        pt.TealLabel(None, subroutine3L1Label),
        pt.TealOp(None, pt.Op.app_local_put),
        pt.TealOp(None, pt.Op.retsub),
        pt.TealOp(None, pt.Op.b, subroutine3L1Label),
    ]

    l1Label = pt.LabelReference("l1")
    mainOps = [
        pt.TealOp(None, pt.Op.byte, '"account"'),
        pt.TealOp(None, pt.Op.byte, '"key"'),
        pt.TealOp(None, pt.Op.byte, '"value"'),
        pt.TealOp(None, pt.Op.callsub, subroutine3Label),
        pt.TealOp(None, pt.Op.txn, "Fee"),
        pt.TealOp(None, pt.Op.int, 0),
        pt.TealOp(None, pt.Op.eq),
        pt.TealOp(None, pt.Op.bz, l1Label),
        pt.TealOp(None, pt.Op.int, 3),
        pt.TealOp(None, pt.Op.callsub, subroutine2Label),
        pt.TealOp(None, pt.Op.pop),
        pt.TealOp(None, pt.Op.callsub, subroutine1Label),
        pt.TealOp(None, pt.Op.return_),
        pt.TealLabel(None, l1Label),
        pt.TealOp(None, pt.Op.int, 0),
        pt.TealOp(None, pt.Op.return_),
    ]

    subroutineMapping = {
        None: mainOps,
        subroutine1: subroutine1Ops,
        subroutine2: subroutine2Ops,
        subroutine3: subroutine3Ops,
    }

    expectedL1Label = pt.LabelReference("main_l1")
    expectedSubroutine1Label = pt.LabelReference("sub0")
    expectedSubroutine2Label = pt.LabelReference("sub1")
    expectedSubroutine2L1Label = pt.LabelReference("sub1_l1")
    expectedSubroutine2L2Label = pt.LabelReference("sub1_l2")
    expectedSubroutine2L3Label = pt.LabelReference("sub1_l3")
    expectedSubroutine2L4Label = pt.LabelReference("sub1_l4")
    expectedSubroutine3Label = pt.LabelReference("sub2")
    expectedSubroutine3L1Label = pt.LabelReference("sub2_l1")
    expected = [
        pt.TealOp(None, pt.Op.byte, '"account"'),
        pt.TealOp(None, pt.Op.byte, '"key"'),
        pt.TealOp(None, pt.Op.byte, '"value"'),
        pt.TealOp(None, pt.Op.callsub, subroutine3Label),
        pt.TealOp(None, pt.Op.txn, "Fee"),
        pt.TealOp(None, pt.Op.int, 0),
        pt.TealOp(None, pt.Op.eq),
        pt.TealOp(None, pt.Op.bz, expectedL1Label),
        pt.TealOp(None, pt.Op.int, 3),
        pt.TealOp(None, pt.Op.callsub, subroutine2Label),
        pt.TealOp(None, pt.Op.pop),
        pt.TealOp(None, pt.Op.callsub, subroutine1Label),
        pt.TealOp(None, pt.Op.return_),
        pt.TealLabel(None, expectedL1Label),
        pt.TealOp(None, pt.Op.int, 0),
        pt.TealOp(None, pt.Op.return_),
        pt.TealLabel(None, expectedSubroutine1Label, "sub1Impl"),
        pt.TealOp(None, pt.Op.int, 1),
        pt.TealOp(None, pt.Op.int, 2),
        pt.TealOp(None, pt.Op.int, 3),
        pt.TealOp(None, pt.Op.add),
        pt.TealOp(None, pt.Op.add),
        pt.TealOp(None, pt.Op.retsub),
        pt.TealLabel(None, expectedSubroutine2Label, "sub2Impl"),
        pt.TealOp(None, pt.Op.dup),
        pt.TealOp(None, pt.Op.int, 1),
        pt.TealOp(None, pt.Op.eq),
        pt.TealOp(None, pt.Op.bnz, expectedSubroutine2L1Label),
        pt.TealOp(None, pt.Op.dup),
        pt.TealOp(None, pt.Op.int, 2),
        pt.TealOp(None, pt.Op.eq),
        pt.TealOp(None, pt.Op.bnz, expectedSubroutine2L2Label),
        pt.TealOp(None, pt.Op.dup),
        pt.TealOp(None, pt.Op.int, 3),
        pt.TealOp(None, pt.Op.eq),
        pt.TealOp(None, pt.Op.bnz, expectedSubroutine2L3Label),
        pt.TealOp(None, pt.Op.dup),
        pt.TealOp(None, pt.Op.int, 4),
        pt.TealOp(None, pt.Op.eq),
        pt.TealOp(None, pt.Op.bnz, expectedSubroutine2L4Label),
        pt.TealOp(None, pt.Op.err),
        pt.TealLabel(None, expectedSubroutine2L1Label),
        pt.TealOp(None, pt.Op.pop),
        pt.TealOp(None, pt.Op.byte, '"1"'),
        pt.TealOp(None, pt.Op.retsub),
        pt.TealLabel(None, expectedSubroutine2L2Label),
        pt.TealOp(None, pt.Op.pop),
        pt.TealOp(None, pt.Op.byte, '"2"'),
        pt.TealOp(None, pt.Op.retsub),
        pt.TealLabel(None, expectedSubroutine2L3Label),
        pt.TealOp(None, pt.Op.pop),
        pt.TealOp(None, pt.Op.byte, '"3"'),
        pt.TealOp(None, pt.Op.retsub),
        pt.TealLabel(None, expectedSubroutine2L4Label),
        pt.TealOp(None, pt.Op.pop),
        pt.TealOp(None, pt.Op.byte, '"4"'),
        pt.TealOp(None, pt.Op.retsub),
        pt.TealLabel(None, expectedSubroutine3Label, "sub3Impl"),
        pt.TealLabel(None, expectedSubroutine3L1Label),
        pt.TealOp(None, pt.Op.app_local_put),
        pt.TealOp(None, pt.Op.retsub),
        pt.TealOp(None, pt.Op.b, expectedSubroutine3L1Label),
    ]

    opts = pt.CompileOptions()
    actual = flattenSubroutines(subroutineMapping, subroutineToLabel, opts)

    assert actual == expected



================================================
FILE: pyteal/compiler/scratchslots.py
================================================
from typing import Tuple, Set, Dict, Optional, cast

from pyteal.ast import ScratchSlot, SubroutineDefinition
from pyteal.ir import TealBlock, Op
from pyteal.errors import TealInternalError
from pyteal.config import NUM_SLOTS


def collect_unoptimized_slots(
    subroutineBlocks: Dict[Optional[SubroutineDefinition], TealBlock]
) -> Set[ScratchSlot]:
    """Find and return all referenced ScratchSlots that need to be skipped
    during optimization.

    Args:
        subroutineBlocks: A mapping from subroutine to the subroutine's control flow graph.
        The key None is taken to mean the main program routine.

    Returns:
        A set which contains the slots used by DynamicScratchVars, all the reserved slots,
            and all global slots.
    """

    unoptimized_slots: Set[ScratchSlot] = set()

    def collectSlotsFromBlock(block: TealBlock):
        for op in block.ops:
            for slot in op.getSlots():
                # dynamic slot or reserved slot
                if op.op == Op.int or slot.isReservedSlot:
                    unoptimized_slots.add(slot)

    for _, start in subroutineBlocks.items():
        for block in TealBlock.Iterate(start):
            collectSlotsFromBlock(block)

    global_slots, _ = collectScratchSlots(subroutineBlocks)
    unoptimized_slots.update(global_slots)
    return unoptimized_slots


def collectScratchSlots(
    subroutineBlocks: Dict[Optional[SubroutineDefinition], TealBlock]
) -> Tuple[Set[ScratchSlot], Dict[Optional[SubroutineDefinition], Set[ScratchSlot]]]:
    """Find and return all referenced ScratchSlots for each subroutine.

    Args:
        subroutineBlocks: A mapping from subroutine to the subroutine's control flow graph.
        The key None is taken to mean the main program routine.

    Returns:
        A tuple of a set containing all global slots and a dictionary whose keys are the
            same as subroutineBlocks, and whose values are the local slots of that
            subroutine.
    """

    subroutineSlots: Dict[Optional[SubroutineDefinition], Set[ScratchSlot]] = dict()

    def collectSlotsFromBlock(block: TealBlock, slots: Set[ScratchSlot]):
        for op in block.ops:
            for slot in op.getSlots():
                slots.add(slot)

    for subroutine, start in subroutineBlocks.items():
        slots: Set[ScratchSlot] = set()
        for block in TealBlock.Iterate(start):
            collectSlotsFromBlock(block, slots)

        subroutineSlots[subroutine] = slots

    # all scratch slots referenced by more than 1 subroutine
    global_slots: Set[ScratchSlot] = set()

    # all scratch slots referenced by only 1 subroutine
    local_slots: Dict[Optional[SubroutineDefinition], Set[ScratchSlot]] = dict()

    for subroutine, slots in subroutineSlots.items():
        allOtherSlots: Set[ScratchSlot] = set()

        for otherSubroutine, otherSubroutineSlots in subroutineSlots.items():
            if subroutine is not otherSubroutine:
                allOtherSlots |= otherSubroutineSlots

        global_slots |= slots & allOtherSlots
        local_slots[subroutine] = slots - global_slots

    return global_slots, local_slots


def assignScratchSlotsToSubroutines(
    subroutineBlocks: Dict[Optional[SubroutineDefinition], TealBlock],
) -> Dict[Optional[SubroutineDefinition], Set[int]]:
    """Assign scratch slot values for an entire program.

    Args:
        subroutineBlocks: A mapping from subroutine to the control flow graph of the subroutine's
            blocks. The key None is taken to mean the main program routine. The values of this
            map will be modified in order to assign specific slot values to all referenced scratch
            slots.

    Raises:
        TealInternalError: if the scratch slots referenced by the program do not fit into 256 slots,
            or if multiple ScratchSlots request the same slot ID.

    Returns:
        A dictionary whose keys are the same as subroutineBlocks, and whose values are sets of
        integers representing the assigned IDs of slots which appear only in that subroutine
        (subroutine local slots).
    """
    global_slots, local_slots = collectScratchSlots(subroutineBlocks)
    # all scratch slots referenced by the program
    allSlots: Set[ScratchSlot] = global_slots | cast(Set[ScratchSlot], set()).union(
        *local_slots.values()
    )

    slotAssignments: Dict[ScratchSlot, int] = dict()
    slotIds: Set[int] = set()

    for slot in allSlots:
        if not slot.isReservedSlot:
            continue

        # If there are two unique slots with same IDs, raise an error
        if slot.id in slotIds:
            raise TealInternalError(
                "Slot ID {} has been assigned multiple times".format(slot.id)
            )
        slotIds.add(slot.id)

    if len(allSlots) > NUM_SLOTS:
        # TODO: identify which slots can be reused
        # subroutines which never invoke each other can use the same slot ID for local slots
        raise TealInternalError(
            "Too many slots in use: {}, maximum is {}".format(len(allSlots), NUM_SLOTS)
        )

    # verify that all local slots are assigned to before being loaded.
    # TODO: for simplicity, the current implementation does not perform this check with global slots
    # as well, but that would be a good improvement
    for subroutine, start in subroutineBlocks.items():
        errors = start.validateSlots(slotsInUse=global_slots)
        if len(errors) > 0:
            msg = "Encountered {} error{} when assigning slots to subroutine".format(
                len(errors), "s" if len(errors) != 1 else ""
            )
            raise TealInternalError(msg) from errors[0]

    nextSlotIndex = 0
    for slot in sorted(allSlots, key=lambda slot: slot.id):
        # Find next vacant slot that compiler can assign to
        while nextSlotIndex in slotIds:
            nextSlotIndex += 1

        if slot.isReservedSlot:
            # Slot ids under 256 are manually reserved slots
            slotAssignments[slot] = slot.id
        else:
            slotAssignments[slot] = nextSlotIndex
            slotIds.add(nextSlotIndex)

    for start in subroutineBlocks.values():
        for block in TealBlock.Iterate(start):
            for op in block.ops:
                for slot in op.getSlots():
                    op.assignSlot(slot, slotAssignments[slot])

    assignedLocalSlots: Dict[Optional[SubroutineDefinition], Set[int]] = dict()
    for subroutine, slots in local_slots.items():
        assignedLocalSlots[subroutine] = set(slotAssignments[slot] for slot in slots)

    return assignedLocalSlots



================================================
FILE: pyteal/compiler/scratchslots_test.py
================================================
import pytest

import pyteal as pt

from pyteal.compiler.scratchslots import (
    collectScratchSlots,
    assignScratchSlotsToSubroutines,
)


def test_collectScratchSlots():
    def sub1Impl():
        return None

    def sub2Impl(a1):
        return None

    def sub3Impl(a1, a2, a3):
        return None

    subroutine1 = pt.SubroutineDefinition(sub1Impl, pt.TealType.uint64)
    subroutine2 = pt.SubroutineDefinition(sub2Impl, pt.TealType.bytes)
    subroutine3 = pt.SubroutineDefinition(sub3Impl, pt.TealType.none)

    globalSlot1 = pt.ScratchSlot()

    subroutine1Slot1 = pt.ScratchSlot()
    subroutine1Slot2 = pt.ScratchSlot()
    subroutine1Ops = [
        pt.TealOp(None, pt.Op.int, 1),
        pt.TealOp(None, pt.Op.store, subroutine1Slot1),
        pt.TealOp(None, pt.Op.int, 3),
        pt.TealOp(None, pt.Op.store, subroutine1Slot2),
        pt.TealOp(None, pt.Op.load, globalSlot1),
        pt.TealOp(None, pt.Op.retsub),
    ]

    subroutine2Slot1 = pt.ScratchSlot()
    subroutine2Ops = [
        pt.TealOp(None, pt.Op.byte, '"value"'),
        pt.TealOp(None, pt.Op.store, subroutine2Slot1),
        pt.TealOp(None, pt.Op.load, subroutine2Slot1),
        pt.TealOp(None, pt.Op.retsub),
    ]

    subroutine3Ops = [
        pt.TealOp(None, pt.Op.retsub),
    ]

    mainSlot1 = pt.ScratchSlot()
    mainSlot2 = pt.ScratchSlot()
    mainOps = [
        pt.TealOp(None, pt.Op.int, 7),
        pt.TealOp(None, pt.Op.store, globalSlot1),
        pt.TealOp(None, pt.Op.int, 1),
        pt.TealOp(None, pt.Op.store, mainSlot1),
        pt.TealOp(None, pt.Op.int, 2),
        pt.TealOp(None, pt.Op.store, mainSlot2),
        pt.TealOp(None, pt.Op.load, mainSlot1),
        pt.TealOp(None, pt.Op.return_),
    ]

    subroutineBlocks = {
        None: pt.TealSimpleBlock(mainOps),
        subroutine1: pt.TealSimpleBlock(subroutine1Ops),
        subroutine2: pt.TealSimpleBlock(subroutine2Ops),
        subroutine3: pt.TealSimpleBlock(subroutine3Ops),
    }

    expected_global = {globalSlot1}

    expected_local = {
        None: {mainSlot1, mainSlot2},
        subroutine1: {subroutine1Slot1, subroutine1Slot2},
        subroutine2: {subroutine2Slot1},
        subroutine3: set(),
    }

    actual_global, actual_local = collectScratchSlots(subroutineBlocks)

    assert actual_global == expected_global
    assert actual_local == expected_local


def test_assignScratchSlotsToSubroutines_no_requested_ids():
    def sub1Impl():
        return None

    def sub2Impl(a1):
        return None

    def sub3Impl(a1, a2, a3):
        return None

    subroutine1 = pt.SubroutineDefinition(sub1Impl, pt.TealType.uint64)
    subroutine2 = pt.SubroutineDefinition(sub2Impl, pt.TealType.bytes)
    subroutine3 = pt.SubroutineDefinition(sub3Impl, pt.TealType.none)

    globalSlot1 = pt.ScratchSlot()

    subroutine1Slot1 = pt.ScratchSlot()
    subroutine1Slot2 = pt.ScratchSlot()
    subroutine1Ops = [
        pt.TealOp(None, pt.Op.int, 1),
        pt.TealOp(None, pt.Op.store, subroutine1Slot1),
        pt.TealOp(None, pt.Op.int, 3),
        pt.TealOp(None, pt.Op.store, subroutine1Slot2),
        pt.TealOp(None, pt.Op.load, globalSlot1),
        pt.TealOp(None, pt.Op.retsub),
    ]

    subroutine2Slot1 = pt.ScratchSlot()
    subroutine2Ops = [
        pt.TealOp(None, pt.Op.byte, '"value"'),
        pt.TealOp(None, pt.Op.store, subroutine2Slot1),
        pt.TealOp(None, pt.Op.load, subroutine2Slot1),
        pt.TealOp(None, pt.Op.retsub),
    ]

    subroutine3Ops = [
        pt.TealOp(None, pt.Op.retsub),
    ]

    mainSlot1 = pt.ScratchSlot()
    mainSlot2 = pt.ScratchSlot()
    mainOps = [
        pt.TealOp(None, pt.Op.int, 7),
        pt.TealOp(None, pt.Op.store, globalSlot1),
        pt.TealOp(None, pt.Op.int, 1),
        pt.TealOp(None, pt.Op.store, mainSlot1),
        pt.TealOp(None, pt.Op.int, 2),
        pt.TealOp(None, pt.Op.store, mainSlot2),
        pt.TealOp(None, pt.Op.load, mainSlot1),
        pt.TealOp(None, pt.Op.return_),
    ]

    subroutineBlocks = {
        None: pt.TealSimpleBlock(mainOps),
        subroutine1: pt.TealSimpleBlock(subroutine1Ops),
        subroutine2: pt.TealSimpleBlock(subroutine2Ops),
        subroutine3: pt.TealSimpleBlock(subroutine3Ops),
    }

    expectedAssignments = {
        globalSlot1: 0,
        subroutine1Slot1: 1,
        subroutine1Slot2: 2,
        subroutine2Slot1: 3,
        mainSlot1: 4,
        mainSlot2: 5,
    }

    expected = {
        None: {expectedAssignments[mainSlot1], expectedAssignments[mainSlot2]},
        subroutine1: {
            expectedAssignments[subroutine1Slot1],
            expectedAssignments[subroutine1Slot2],
        },
        subroutine2: {expectedAssignments[subroutine2Slot1]},
        subroutine3: set(),
    }

    actual = assignScratchSlotsToSubroutines(subroutineBlocks)

    assert actual == expected

    assert subroutine1Ops == [
        pt.TealOp(None, pt.Op.int, 1),
        pt.TealOp(None, pt.Op.store, expectedAssignments[subroutine1Slot1]),
        pt.TealOp(None, pt.Op.int, 3),
        pt.TealOp(None, pt.Op.store, expectedAssignments[subroutine1Slot2]),
        pt.TealOp(None, pt.Op.load, expectedAssignments[globalSlot1]),
        pt.TealOp(None, pt.Op.retsub),
    ]

    assert subroutine2Ops == [
        pt.TealOp(None, pt.Op.byte, '"value"'),
        pt.TealOp(None, pt.Op.store, expectedAssignments[subroutine2Slot1]),
        pt.TealOp(None, pt.Op.load, expectedAssignments[subroutine2Slot1]),
        pt.TealOp(None, pt.Op.retsub),
    ]

    assert subroutine3Ops == [
        pt.TealOp(None, pt.Op.retsub),
    ]

    assert mainOps == [
        pt.TealOp(None, pt.Op.int, 7),
        pt.TealOp(None, pt.Op.store, expectedAssignments[globalSlot1]),
        pt.TealOp(None, pt.Op.int, 1),
        pt.TealOp(None, pt.Op.store, expectedAssignments[mainSlot1]),
        pt.TealOp(None, pt.Op.int, 2),
        pt.TealOp(None, pt.Op.store, expectedAssignments[mainSlot2]),
        pt.TealOp(None, pt.Op.load, expectedAssignments[mainSlot1]),
        pt.TealOp(None, pt.Op.return_),
    ]


def test_assignScratchSlotsToSubroutines_with_requested_ids():
    def sub1Impl():
        return None

    def sub2Impl(a1):
        return None

    def sub3Impl(a1, a2, a3):
        return None

    subroutine1 = pt.SubroutineDefinition(sub1Impl, pt.TealType.uint64)
    subroutine2 = pt.SubroutineDefinition(sub2Impl, pt.TealType.bytes)
    subroutine3 = pt.SubroutineDefinition(sub3Impl, pt.TealType.none)

    globalSlot1 = pt.ScratchSlot(requestedSlotId=8)

    subroutine1Slot1 = pt.ScratchSlot()
    subroutine1Slot2 = pt.ScratchSlot(requestedSlotId=5)
    subroutine1Ops = [
        pt.TealOp(None, pt.Op.int, 1),
        pt.TealOp(None, pt.Op.store, subroutine1Slot1),
        pt.TealOp(None, pt.Op.int, 3),
        pt.TealOp(None, pt.Op.store, subroutine1Slot2),
        pt.TealOp(None, pt.Op.load, globalSlot1),
        pt.TealOp(None, pt.Op.retsub),
    ]

    subroutine2Slot1 = pt.ScratchSlot()
    subroutine2Ops = [
        pt.TealOp(None, pt.Op.byte, '"value"'),
        pt.TealOp(None, pt.Op.store, subroutine2Slot1),
        pt.TealOp(None, pt.Op.load, subroutine2Slot1),
        pt.TealOp(None, pt.Op.retsub),
    ]

    subroutine3Ops = [
        pt.TealOp(None, pt.Op.retsub),
    ]

    mainSlot1 = pt.ScratchSlot()
    mainSlot2 = pt.ScratchSlot(requestedSlotId=100)
    mainOps = [
        pt.TealOp(None, pt.Op.int, 7),
        pt.TealOp(None, pt.Op.store, globalSlot1),
        pt.TealOp(None, pt.Op.int, 1),
        pt.TealOp(None, pt.Op.store, mainSlot1),
        pt.TealOp(None, pt.Op.int, 2),
        pt.TealOp(None, pt.Op.store, mainSlot2),
        pt.TealOp(None, pt.Op.load, mainSlot1),
        pt.TealOp(None, pt.Op.return_),
    ]

    subroutineBlocks = {
        None: pt.TealSimpleBlock(mainOps),
        subroutine1: pt.TealSimpleBlock(subroutine1Ops),
        subroutine2: pt.TealSimpleBlock(subroutine2Ops),
        subroutine3: pt.TealSimpleBlock(subroutine3Ops),
    }

    expectedAssignments = {
        globalSlot1: 8,
        subroutine1Slot1: 0,
        subroutine1Slot2: 5,
        subroutine2Slot1: 1,
        mainSlot1: 2,
        mainSlot2: 100,
    }

    expected = {
        None: {expectedAssignments[mainSlot1], expectedAssignments[mainSlot2]},
        subroutine1: {
            expectedAssignments[subroutine1Slot1],
            expectedAssignments[subroutine1Slot2],
        },
        subroutine2: {expectedAssignments[subroutine2Slot1]},
        subroutine3: set(),
    }

    actual = assignScratchSlotsToSubroutines(subroutineBlocks)

    assert actual == expected

    assert subroutine1Ops == [
        pt.TealOp(None, pt.Op.int, 1),
        pt.TealOp(None, pt.Op.store, expectedAssignments[subroutine1Slot1]),
        pt.TealOp(None, pt.Op.int, 3),
        pt.TealOp(None, pt.Op.store, expectedAssignments[subroutine1Slot2]),
        pt.TealOp(None, pt.Op.load, expectedAssignments[globalSlot1]),
        pt.TealOp(None, pt.Op.retsub),
    ]

    assert subroutine2Ops == [
        pt.TealOp(None, pt.Op.byte, '"value"'),
        pt.TealOp(None, pt.Op.store, expectedAssignments[subroutine2Slot1]),
        pt.TealOp(None, pt.Op.load, expectedAssignments[subroutine2Slot1]),
        pt.TealOp(None, pt.Op.retsub),
    ]

    assert subroutine3Ops == [
        pt.TealOp(None, pt.Op.retsub),
    ]

    assert mainOps == [
        pt.TealOp(None, pt.Op.int, 7),
        pt.TealOp(None, pt.Op.store, expectedAssignments[globalSlot1]),
        pt.TealOp(None, pt.Op.int, 1),
        pt.TealOp(None, pt.Op.store, expectedAssignments[mainSlot1]),
        pt.TealOp(None, pt.Op.int, 2),
        pt.TealOp(None, pt.Op.store, expectedAssignments[mainSlot2]),
        pt.TealOp(None, pt.Op.load, expectedAssignments[mainSlot1]),
        pt.TealOp(None, pt.Op.return_),
    ]


def test_assignScratchSlotsToSubroutines_invalid_requested_id():
    def sub1Impl():
        return None

    def sub2Impl(a1):
        return None

    def sub3Impl(a1, a2, a3):
        return None

    subroutine1 = pt.SubroutineDefinition(sub1Impl, pt.TealType.uint64)
    subroutine2 = pt.SubroutineDefinition(sub2Impl, pt.TealType.bytes)
    subroutine3 = pt.SubroutineDefinition(sub3Impl, pt.TealType.none)

    globalSlot1 = pt.ScratchSlot(requestedSlotId=8)

    subroutine1Slot1 = pt.ScratchSlot()
    subroutine1Slot2 = pt.ScratchSlot(requestedSlotId=5)
    subroutine1Ops = [
        pt.TealOp(None, pt.Op.int, 1),
        pt.TealOp(None, pt.Op.store, subroutine1Slot1),
        pt.TealOp(None, pt.Op.int, 3),
        pt.TealOp(None, pt.Op.store, subroutine1Slot2),
        pt.TealOp(None, pt.Op.load, globalSlot1),
        pt.TealOp(None, pt.Op.retsub),
    ]

    subroutine2Slot1 = pt.ScratchSlot(requestedSlotId=100)
    subroutine2Ops = [
        pt.TealOp(None, pt.Op.byte, '"value"'),
        pt.TealOp(None, pt.Op.store, subroutine2Slot1),
        pt.TealOp(None, pt.Op.load, subroutine2Slot1),
        pt.TealOp(None, pt.Op.retsub),
    ]

    subroutine3Ops = [
        pt.TealOp(None, pt.Op.retsub),
    ]

    mainSlot1 = pt.ScratchSlot()
    mainSlot2 = pt.ScratchSlot(requestedSlotId=100)
    mainOps = [
        pt.TealOp(None, pt.Op.int, 7),
        pt.TealOp(None, pt.Op.store, globalSlot1),
        pt.TealOp(None, pt.Op.int, 1),
        pt.TealOp(None, pt.Op.store, mainSlot1),
        pt.TealOp(None, pt.Op.int, 2),
        pt.TealOp(None, pt.Op.store, mainSlot2),
        pt.TealOp(None, pt.Op.load, mainSlot1),
        pt.TealOp(None, pt.Op.return_),
    ]

    subroutineBlocks = {
        None: pt.TealSimpleBlock(mainOps),
        subroutine1: pt.TealSimpleBlock(subroutine1Ops),
        subroutine2: pt.TealSimpleBlock(subroutine2Ops),
        subroutine3: pt.TealSimpleBlock(subroutine3Ops),
    }

    # mainSlot2 and subroutine2Slot1 request the same ID, 100
    with pytest.raises(pt.TealInternalError):
        assignScratchSlotsToSubroutines(subroutineBlocks)


def test_assignScratchSlotsToSubroutines_slot_used_before_assignment():
    def sub1Impl():
        return None

    def sub2Impl(a1):
        return None

    def sub3Impl(a1, a2, a3):
        return None

    subroutine1 = pt.SubroutineDefinition(sub1Impl, pt.TealType.uint64)
    subroutine2 = pt.SubroutineDefinition(sub2Impl, pt.TealType.bytes)
    subroutine3 = pt.SubroutineDefinition(sub3Impl, pt.TealType.none)

    globalSlot1 = pt.ScratchSlot()

    subroutine1Slot1 = pt.ScratchSlot()
    subroutine1Slot2 = pt.ScratchSlot()
    subroutine1Ops = [
        pt.TealOp(None, pt.Op.int, 1),
        pt.TealOp(None, pt.Op.store, subroutine1Slot1),
        pt.TealOp(None, pt.Op.int, 3),
        pt.TealOp(None, pt.Op.store, subroutine1Slot2),
        pt.TealOp(None, pt.Op.load, globalSlot1),
        pt.TealOp(None, pt.Op.retsub),
    ]

    subroutine2Slot1 = pt.ScratchSlot()
    subroutine2Ops = [
        pt.TealOp(None, pt.Op.byte, '"value"'),
        pt.TealOp(None, pt.Op.store, subroutine2Slot1),
        pt.TealOp(None, pt.Op.load, subroutine2Slot1),
        pt.TealOp(None, pt.Op.retsub),
    ]

    subroutine3Ops = [
        pt.TealOp(None, pt.Op.retsub),
    ]

    mainSlot1 = pt.ScratchSlot()
    mainSlot2 = pt.ScratchSlot()
    mainOps = [
        pt.TealOp(None, pt.Op.int, 7),
        pt.TealOp(None, pt.Op.store, globalSlot1),
        pt.TealOp(None, pt.Op.int, 2),
        pt.TealOp(None, pt.Op.store, mainSlot2),
        pt.TealOp(None, pt.Op.load, mainSlot1),
        pt.TealOp(None, pt.Op.return_),
    ]

    subroutineBlocks = {
        None: pt.TealSimpleBlock(mainOps),
        subroutine1: pt.TealSimpleBlock(subroutine1Ops),
        subroutine2: pt.TealSimpleBlock(subroutine2Ops),
        subroutine3: pt.TealSimpleBlock(subroutine3Ops),
    }

    with pytest.raises(pt.TealInternalError):
        assignScratchSlotsToSubroutines(subroutineBlocks)



================================================
FILE: pyteal/compiler/sort.py
================================================
from typing import List

from pyteal.ir import TealBlock
from pyteal.errors import TealInternalError


def sortBlocks(start: TealBlock, end: TealBlock) -> List[TealBlock]:
    """Topologically sort the graph which starts with the input TealBlock.

    Args:
        start: The starting point of the graph to sort.

    Returns:
        An ordered list of TealBlocks that is sorted such that every block is guaranteed to appear
        in the list before all of its outgoing blocks.
    """
    S = [start]
    order = []
    visited = set()  # I changed visited to a set to be more efficient
    while len(S) != 0:
        n = S.pop()

        if id(n) in visited:
            continue

        S += n.getOutgoing()

        order.append(n)
        visited.add(id(n))

    endIndex = -1
    for i, block in enumerate(order):
        if block is end:
            endIndex = i
            break

    if endIndex == -1:
        raise TealInternalError("End block not present")

    order.pop(endIndex)
    order.append(end)

    return order



================================================
FILE: pyteal/compiler/sort_test.py
================================================
import pyteal as pt

from pyteal.compiler.sort import sortBlocks


def test_sort_single():
    block = pt.TealSimpleBlock([pt.TealOp(None, pt.Op.int, 1)])
    block.addIncoming()
    block.validateTree()

    expected = [block]
    actual = sortBlocks(block, block)

    assert actual == expected


def test_sort_sequence():
    block5 = pt.TealSimpleBlock([pt.TealOp(None, pt.Op.int, 5)])
    block4 = pt.TealSimpleBlock([pt.TealOp(None, pt.Op.int, 4)])
    block4.setNextBlock(block5)
    block3 = pt.TealSimpleBlock([pt.TealOp(None, pt.Op.int, 3)])
    block3.setNextBlock(block4)
    block2 = pt.TealSimpleBlock([pt.TealOp(None, pt.Op.int, 2)])
    block2.setNextBlock(block3)
    block1 = pt.TealSimpleBlock([pt.TealOp(None, pt.Op.int, 1)])
    block1.setNextBlock(block2)
    block1.addIncoming()
    block1.validateTree()

    expected = [block1, block2, block3, block4, block5]
    actual = sortBlocks(block1, block5)

    assert actual == expected


def test_sort_branch():
    blockTrue = pt.TealSimpleBlock([pt.TealOp(None, pt.Op.byte, '"true"')])
    blockFalse = pt.TealSimpleBlock([pt.TealOp(None, pt.Op.byte, '"false"')])
    block = pt.TealConditionalBlock([pt.TealOp(None, pt.Op.int, 1)])
    block.setTrueBlock(blockTrue)
    block.setFalseBlock(blockFalse)
    block.addIncoming()
    block.validateTree()

    expected = [block, blockTrue, blockFalse]
    actual = sortBlocks(block, blockFalse)

    assert actual == expected


def test_sort_multiple_branch():
    blockTrueTrue = pt.TealSimpleBlock([pt.TealOp(None, pt.Op.byte, '"true true"')])
    blockTrueFalse = pt.TealSimpleBlock([pt.TealOp(None, pt.Op.byte, '"true false"')])
    blockTrueBranch = pt.TealConditionalBlock([])
    blockTrueBranch.setTrueBlock(blockTrueTrue)
    blockTrueBranch.setFalseBlock(blockTrueFalse)
    blockTrue = pt.TealSimpleBlock([pt.TealOp(None, pt.Op.byte, '"true"')])
    blockTrue.setNextBlock(blockTrueBranch)
    blockFalse = pt.TealSimpleBlock([pt.TealOp(None, pt.Op.byte, '"false"')])
    block = pt.TealConditionalBlock([pt.TealOp(None, pt.Op.int, 1)])
    block.setTrueBlock(blockTrue)
    block.setFalseBlock(blockFalse)
    block.addIncoming()
    block.validateTree()

    expected = [
        block,
        blockTrue,
        blockTrueBranch,
        blockTrueFalse,
        blockTrueTrue,
        blockFalse,
    ]
    actual = sortBlocks(block, blockFalse)

    assert actual == expected


def test_sort_branch_converge():
    blockEnd = pt.TealSimpleBlock([pt.TealOp(None, pt.Op.return_)])
    blockTrue = pt.TealSimpleBlock([pt.TealOp(None, pt.Op.byte, '"true"')])
    blockTrue.setNextBlock(blockEnd)
    blockFalse = pt.TealSimpleBlock([pt.TealOp(None, pt.Op.byte, '"false"')])
    blockFalse.setNextBlock(blockEnd)
    block = pt.TealConditionalBlock([pt.TealOp(None, pt.Op.int, 1)])
    block.setTrueBlock(blockTrue)
    block.setFalseBlock(blockFalse)
    block.addIncoming()
    block.validateTree()

    expected = [block, blockFalse, blockTrue, blockEnd]
    actual = sortBlocks(block, blockEnd)

    assert actual == expected



================================================
FILE: pyteal/compiler/subroutines.py
================================================
import re
from typing import List, Dict, Set, Optional, TypeVar
from collections import OrderedDict

from pyteal.errors import TealInputError
from pyteal.types import TealType
from pyteal.ast import SubroutineDefinition
from pyteal.ir import TealComponent, TealOp, Op

# generic type variable
Node = TypeVar("Node")


def graph_search(graph: Dict[Node, Set[Node]], start: Node, end: Node) -> bool:
    """Check whether a path between start and end exists in the graph.

    This works even if start == end, in which case True is only returned if the
    node belongs to a cycle.
    """
    visited: Set[Node] = set()
    stack: List[Node] = list(graph[start])

    while len(stack) != 0:
        current = stack.pop()
        if current in visited:
            continue
        visited.add(current)
        if end == current:
            return True
        stack += list(graph[current])

    return False


def findRecursionPoints(
    subroutineGraph: Dict[SubroutineDefinition, Set[SubroutineDefinition]]
) -> Dict[SubroutineDefinition, Set[SubroutineDefinition]]:
    """Find all subroutine calls which may result in the current subroutine being called again
    recursively.

    Args:
        subroutineGraph: A graph of subroutines. Each key is a subroutine (the main routine should
            be present), which represents a node in the graph. Each value is a set of all
            subroutines that specific subroutine calls, which represent directional edges in the
            graph.

    Returns:
        A dictionary whose keys are the same as subroutineGraph, and whose values are a subset of
        the key's values from subroutineGraph. Each element in this subset represents a subroutine
        which may reenter the calling subroutine.
    """
    reentryPoints: Dict[SubroutineDefinition, Set[SubroutineDefinition]] = dict()

    for subroutine in subroutineGraph.keys():
        # perform a depth first search to see which callers (if any) have a path to invoke the calling subroutine again
        reentryPoints[subroutine] = set(
            callee
            for callee in subroutineGraph[subroutine]
            if graph_search(subroutineGraph, callee, subroutine)
        )

    return reentryPoints


def find_recursive_path(
    subroutine_graph: Dict[SubroutineDefinition, Set[SubroutineDefinition]],
    subroutine: SubroutineDefinition,
) -> List[SubroutineDefinition]:
    visited = set()
    loop = []

    def dfs(x):
        if x in visited:
            return False

        visited.add(x)
        loop.append(x)
        for y in subroutine_graph[x]:
            if y == subroutine:
                loop.append(y)
                return True
            if dfs(y):
                return True
        loop.pop()
        return False

    found = dfs(subroutine)
    return loop if found else []


def spillLocalSlotsDuringRecursion(
    version: int,
    subroutineMapping: Dict[Optional[SubroutineDefinition], List[TealComponent]],
    subroutineGraph: Dict[SubroutineDefinition, Set[SubroutineDefinition]],
    localSlots: Dict[Optional[SubroutineDefinition], Set[int]],
) -> None:
    """In order to prevent recursion from modifying the local scratch slots a subroutine uses,
    subroutines must "spill" their local slots to the stack before calling any other subroutine
    which may invoke the calling subroutine.

    "Spill to stack" means loading all local slots onto the stack, invoking the subroutine which may
    result in recursion, then restoring all local slots from the stack. This prevents the local
    slots from being modifying by a new recursive invocation of the current subroutine.

    Args:
        version: The current program version being assembled.
        subroutineMapping: A dictionary containing a list of TealComponents for every subroutine in
            a program. The key None is taken to indicate the main program routine. This input may be
            modified by this function in order to spill subroutine slots.
        subroutineGraph: A graph of subroutines. Each key is a subroutine (the main routine should
            not be present), which represents a node in the graph. Each value is a set of all
            subroutines that specific subroutine calls, which represent directional edges in the
            graph.
        localSlots: The output from the function `assignScratchSlotsToSubroutines`, which indicates
            the local slots which must be spilled for each subroutine.
    """
    recursivePoints = findRecursionPoints(subroutineGraph)

    recursive_byref = None
    for k, v in recursivePoints.items():
        if v and k.by_ref_args:
            recursive_byref = k
            break

    if recursive_byref:
        msg = "ScratchVar arguments not allowed in recursive subroutines, but a recursive call-path was detected: {}()"
        raise TealInputError(
            msg.format(
                "()-->".join(
                    f.name()
                    for f in find_recursive_path(subroutineGraph, recursive_byref)
                )
            )
        )

    coverAvailable = version >= Op.cover.min_version

    for subroutine, reentryPoints in recursivePoints.items():
        slots = list(sorted(slot for slot in localSlots[subroutine]))

        if len(reentryPoints) == 0 or len(slots) == 0:
            # no need to spill slots
            continue

        ops = subroutineMapping[subroutine]
        newOps: List[TealComponent] = []

        for stmt in ops:
            before: List[TealComponent] = []
            after: List[TealComponent] = []

            calledSubroutines = stmt.getSubroutines()
            # the only opcode that references subroutines is callsub, and it should only ever
            # reference one subroutine at a time
            assert (
                len(calledSubroutines) <= 1
            ), "Multiple subroutines are called from the same TealComponent"

            reentrySubroutineCalls = list(reentryPoints.intersection(calledSubroutines))
            if len(reentrySubroutineCalls) != 0:
                # A subroutine is being called which may reenter the current subroutine, so insert
                # ops to spill local slots to the stack before calling the subroutine and also to
                # restore the local slots after returning from the subroutine. This prevents a
                # reentry into the current subroutine from modifying variables we are currently
                # using.

                # reentrySubroutineCalls should have a length of 1, since calledSubroutines has a
                # maximum length of 1
                reentrySubroutineCall = reentrySubroutineCalls[0]
                numArgs = reentrySubroutineCall.argument_count()

                digArgs = True
                coverSpilledSlots = False
                uncoverArgs = False
                if coverAvailable:
                    digArgs = False
                    if len(slots) < numArgs:
                        coverSpilledSlots = True
                    else:
                        uncoverArgs = True

                for slot in slots:
                    # spill local slots to the stack
                    before.append(TealOp(None, Op.load, slot))

                    if coverSpilledSlots:
                        # numArgs is guaranteed to be at least 2 here (since numArgs > len(slots)
                        # and len(slots) must be at least 1 for the code to get this far), so no
                        # need to replace this with swap if numArgs is 1
                        before.append(TealOp(None, Op.cover, numArgs))

                for _ in range(numArgs):
                    # pull the subroutine arguments to the top of the stack, above the just spilled
                    # local slots, if needed

                    stackDistance = len(slots) + numArgs - 1

                    if uncoverArgs:
                        if stackDistance == 1:
                            before.append(TealOp(None, Op.swap))
                        else:
                            before.append(TealOp(None, Op.uncover, stackDistance))

                    if digArgs:
                        before.append(
                            TealOp(
                                None,
                                Op.dig,
                                stackDistance,
                            )
                        )
                        # because we are stuck using dig instead of uncover in AVM 4, we'll need to
                        # pop all of the dug up arguments after the function returns

                hideReturnValueInFirstSlot = False

                if subroutine.return_type != TealType.none:
                    # if the subroutine returns a value on the stack, we need to preserve this after
                    # restoring all local slots.

                    if len(slots) == 1:
                        after.append(TealOp(None, Op.swap))
                    elif coverAvailable:
                        after.append(TealOp(None, Op.cover, len(slots)))
                    else:
                        # Store the return value into slots[0] temporarily
                        hideReturnValueInFirstSlot = True
                        after.append(TealOp(None, Op.store, slots[0]))

                for slot in slots[::-1]:
                    # restore slots, iterating in reverse because slots[-1] is at the top of the stack
                    if hideReturnValueInFirstSlot and slot is slots[0]:
                        # time to restore the return value to the top of the stack

                        # slots[0] is being used to store the return value, so load it again
                        after.append(TealOp(None, Op.load, slot))

                        # swap the return value with the actual value of slot[0] on the stack
                        after.append(TealOp(None, Op.swap))

                    after.append(TealOp(None, Op.store, slot))

                if digArgs:
                    for _ in range(numArgs):
                        # clear out the duplicate arguments that were dug up previously, since dig
                        # does not pop the dug values -- once we use cover/uncover to properly set up
                        # the spilled slots, this will no longer be necessary
                        if subroutine.return_type != TealType.none:
                            # if there is a return value on top of the stack, we need to preserve
                            # it, so swap it with the subroutine argument that's below it on the
                            # stack
                            after.append(TealOp(None, Op.swap))
                        after.append(TealOp(None, Op.pop))

            newOps += before
            newOps.append(stmt)
            newOps += after

        subroutineMapping[subroutine] = newOps


def resolveSubroutines(
    subroutineMapping: Dict[Optional[SubroutineDefinition], List[TealComponent]]
) -> Dict[SubroutineDefinition, str]:
    """Resolve referenced subroutines for an entire program.

    Args:
        subroutineMapping: A dictionary containing a list of TealComponents for every subroutine in
            a program. The key None is taken to indicate the main program routine. This input will
            be modified by this function in order to assign labels to subroutines.

    Returns:
        An ordered dictionary whose keys are the same as subroutineMapping, minus the None key. The
        values of this dictionary will be the resolved label for each subroutine. The order of this
        dictionary is taken to be the official ordering of the subroutines, which should be used in
        later code generation steps.
    """
    allButMainRoutine = (
        subroutine for subroutine in subroutineMapping.keys() if subroutine is not None
    )

    subroutineOrder = sorted(allButMainRoutine, key=lambda subroutine: subroutine.id)
    subroutineToLabel: Dict[SubroutineDefinition, str] = OrderedDict()
    for index, subroutine in enumerate(subroutineOrder):
        safer_name = re.sub(r"[^A-Za-z0-9]", "", subroutine.name())
        subroutineToLabel[subroutine] = "{}_{}".format(safer_name, index)

    for subroutine, label in subroutineToLabel.items():
        for ops in subroutineMapping.values():
            for stmt in ops:
                stmt.resolveSubroutine(subroutine, label)

    return subroutineToLabel



================================================
FILE: pyteal/compiler/optimizer/__init__.py
================================================
from pyteal.compiler.optimizer.optimizer import (
    OptimizeOptions,
    apply_global_optimizations,
)



================================================
FILE: pyteal/compiler/optimizer/optimizer.py
================================================
from typing import Final, Optional, Set

from pyteal.ast import ScratchSlot
from pyteal.errors import TealInternalError, verifyProgramVersion
from pyteal.ir import Op, TealBlock, TealOp


class OptimizeOptions:
    """An object which specifies the optimizations to be performed and relevant context.

    _skip_slots: the slots that should be skipped during optimization. At the moment this includes:
            1. reserved slots because they may have dependencies outside
            the current application. For example, the 'gloads' opcode can
            access the slots of other applications in the tx group.
            2. global slots because they're outside the scope of global
            optimizations, which only apply to the control flow graph of
            a single subroutine.
            3. slots used with dynamic scratch vars. These slots use
            indirection by means of the 'stores' opcode and dependencies
            can only be determined at runtime.

    Args:

        scratch_slots (optional): cancel contiguous store/load operations
            that have no load dependencies elsewhere. Starting with program version 9, defaults to optimizing.
        frame_pointers (optional): employ frame pointers instead of scratch slots during compilation.
            Available only starting in program version 8. Defaults to optimizing starting in program version 8.
    """

    def __init__(
        self,
        *,
        scratch_slots: Optional[bool] = None,
        frame_pointers: Optional[bool] = None,
    ):
        self._scratch_slots: Final[Optional[bool]] = scratch_slots
        self._frame_pointers: Final[Optional[bool]] = frame_pointers

        self._skip_slots: Set[ScratchSlot] = set()

    def optimize_scratch_slots(self, version: int) -> bool:
        from pyteal.compiler.compiler import DEFAULT_SCRATCH_SLOT_OPTIMIZE_VERSION

        if self._scratch_slots is None:
            return version >= DEFAULT_SCRATCH_SLOT_OPTIMIZE_VERSION

        return self._scratch_slots

    def use_frame_pointers(self, version: int) -> bool:
        from pyteal.compiler.compiler import FRAME_POINTERS_VERSION

        if self._frame_pointers is None:
            return version >= FRAME_POINTERS_VERSION

        if self._frame_pointers:
            verifyProgramVersion(
                FRAME_POINTERS_VERSION,
                version,
                f"Frame pointers aren't available when compiling to program version {version}",
            )

        return self._frame_pointers


def _remove_extraneous_slot_access(start: TealBlock, remove: Set[ScratchSlot]):
    def keep_op(op: TealOp) -> bool:
        if type(op) is not TealOp or (op.op != Op.store and op.op != Op.load):
            return True

        return not set(op.getSlots()).issubset(remove)

    for block in TealBlock.Iterate(start):
        block.ops = list(filter(keep_op, block.ops))


# Very dumb, overly eager dependency checking. A "dependency" is considered
# any time the slot is loaded from in the entire control flow graph. This
# can definitely be improved in the future.
def _has_load_dependencies(
    cur_block: TealBlock, start: TealBlock, slot: ScratchSlot, pos: int
) -> bool:
    for block in TealBlock.Iterate(start):
        for i, op in enumerate(block.ops):
            if block == cur_block and i == pos:
                continue

            if type(op) is TealOp and op.op == Op.load and slot in set(op.getSlots()):
                return True

    return False


def _apply_slot_to_stack(
    cur_block: TealBlock, start: TealBlock, skip_slots: Set[ScratchSlot]
):
    slots_to_remove = set()
    # surprisingly, this slicing is totally safe - even if the list is empty.
    for i, op in enumerate(cur_block.ops[:-1]):
        if type(op) is not TealOp or op.op != Op.store:
            continue

        if set(op.getSlots()).issubset(skip_slots):
            continue

        next_op = cur_block.ops[i + 1]
        if type(next_op) is not TealOp or next_op.op != Op.load:
            continue

        cur_slots, next_slots = op.getSlots(), next_op.getSlots()
        if len(cur_slots) != 1 or len(next_slots) != 1:
            raise TealInternalError(
                "load/store op does not have exactly one slot argument"
            )
        if cur_slots[0] != next_slots[0]:
            continue

        if not _has_load_dependencies(cur_block, start, cur_slots[0], i + 1):
            slots_to_remove.add(cur_slots[0])

    _remove_extraneous_slot_access(start, slots_to_remove)


def apply_global_optimizations(
    start: TealBlock, options: OptimizeOptions, version: int
) -> TealBlock:
    # limit number of iterations to length of teal program to avoid potential
    # infinite loops.
    for block in TealBlock.Iterate(start):
        for _ in range(len(block.ops)):
            prev_ops = block.ops.copy()
            if options.optimize_scratch_slots(version):
                _apply_slot_to_stack(block, start, options._skip_slots)

            if prev_ops == block.ops:
                break

    return start


OptimizeOptions.__module__ = "pyteal"



================================================
FILE: pyteal/compiler/optimizer/optimizer_test.py
================================================
import pytest

from pyteal.compiler.optimizer.optimizer import OptimizeOptions, _apply_slot_to_stack

import pyteal as pt


def test_optimize_single_block():
    slot1 = pt.ScratchSlot(1)
    slot2 = pt.ScratchSlot(2)

    # empty check
    empty_block = pt.TealSimpleBlock([])
    _apply_slot_to_stack(empty_block, empty_block, {})

    expected = pt.TealSimpleBlock([])
    assert empty_block == expected

    # basic optimization
    block = pt.TealSimpleBlock(
        [
            pt.TealOp(None, pt.Op.store, slot1),
            pt.TealOp(None, pt.Op.load, slot1),
        ]
    )
    _apply_slot_to_stack(block, block, {})

    expected = pt.TealSimpleBlock([])
    assert block == expected

    # iterate optimization
    block = pt.TealSimpleBlock(
        [
            pt.TealOp(None, pt.Op.store, slot1),
            pt.TealOp(None, pt.Op.store, slot2),
            pt.TealOp(None, pt.Op.load, slot2),
            pt.TealOp(None, pt.Op.load, slot1),
        ]
    )
    _apply_slot_to_stack(block, block, {})

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(None, pt.Op.store, slot1),
            pt.TealOp(None, pt.Op.load, slot1),
        ]
    )
    assert block == expected

    _apply_slot_to_stack(block, block, {})
    expected = pt.TealSimpleBlock([])
    assert block == expected

    # remove extraneous stores
    block = pt.TealSimpleBlock(
        [
            pt.TealOp(None, pt.Op.store, slot1),
            pt.TealOp(None, pt.Op.load, slot1),
            pt.TealOp(None, pt.Op.store, slot1),
        ]
    )
    _apply_slot_to_stack(block, block, {})

    expected = pt.TealSimpleBlock([])
    assert block == expected


def test_optimize_subroutine():
    @pt.Subroutine(pt.TealType.uint64)
    def add(a1: pt.Expr, a2: pt.Expr) -> pt.Expr:
        return a1 + a2

    program = pt.Seq(
        [
            pt.If(pt.Txn.sender() == pt.Global.creator_address()).Then(
                pt.Pop(add(pt.Int(1), pt.Int(2)))
            ),
            pt.Approve(),
        ]
    )

    optimize_options = OptimizeOptions()

    # unoptimized
    expected = """#pragma version 4
txn Sender
global CreatorAddress
==
bz main_l2
int 1
int 2
callsub add_0
pop
main_l2:
int 1
return

// add
add_0:
store 1
store 0
load 0
load 1
+
retsub
    """.strip()
    actual = pt.compileTeal(
        program, version=4, mode=pt.Mode.Application, optimize=optimize_options
    )
    assert actual == expected

    # optimized
    expected = """#pragma version 4
txn Sender
global CreatorAddress
==
bz main_l2
int 1
int 2
callsub add_0
pop
main_l2:
int 1
return

// add
add_0:
+
retsub
    """.strip()
    optimize_options = OptimizeOptions(scratch_slots=True)
    actual = pt.compileTeal(
        program, version=4, mode=pt.Mode.Application, optimize=optimize_options
    )
    assert actual == expected


def test_optimize_subroutine_with_scratchvar_arg():
    @pt.Subroutine(pt.TealType.uint64)
    def add(a1: pt.ScratchVar, a2: pt.Expr) -> pt.Expr:
        return a1.load() + a2

    arg = pt.ScratchVar(pt.TealType.uint64)

    program = pt.Seq(
        [
            arg.store(pt.Int(1)),
            pt.If(pt.Txn.sender() == pt.Global.creator_address()).Then(
                pt.Pop(add(arg, pt.Int(2)))
            ),
            pt.Approve(),
        ]
    )

    optimize_options = OptimizeOptions()

    # unoptimized
    expected = """#pragma version 5
int 1
store 0
txn Sender
global CreatorAddress
==
bz main_l2
int 0
int 2
callsub add_0
pop
main_l2:
int 1
return

// add
add_0:
store 2
store 1
load 1
loads
load 2
+
retsub""".strip()
    actual = pt.compileTeal(
        program, version=5, mode=pt.Mode.Application, optimize=optimize_options
    )
    assert actual == expected

    # optimized
    expected = """#pragma version 5
int 1
store 0
txn Sender
global CreatorAddress
==
bz main_l2
int 0
int 2
callsub add_0
pop
main_l2:
int 1
return

// add
add_0:
store 1
loads
load 1
+
retsub""".strip()
    optimize_options = OptimizeOptions(scratch_slots=True)
    actual = pt.compileTeal(
        program, version=5, mode=pt.Mode.Application, optimize=optimize_options
    )
    assert actual == expected


def test_optimize_subroutine_with_local_var():
    local_var = pt.ScratchVar(pt.TealType.uint64)

    @pt.Subroutine(pt.TealType.uint64)
    def add(a1: pt.Expr) -> pt.Expr:
        return pt.Seq(local_var.store(pt.Int(2)), local_var.load() + a1)

    program = pt.Seq(
        [
            pt.If(pt.Txn.sender() == pt.Global.creator_address()).Then(
                pt.Pop(add(pt.Int(1)))
            ),
            pt.Approve(),
        ]
    )

    optimize_options = OptimizeOptions()

    # unoptimized
    expected = """#pragma version 4
txn Sender
global CreatorAddress
==
bz main_l2
int 1
callsub add_0
pop
main_l2:
int 1
return

// add
add_0:
store 1
int 2
store 0
load 0
load 1
+
retsub
    """.strip()
    actual = pt.compileTeal(
        program, version=4, mode=pt.Mode.Application, optimize=optimize_options
    )
    assert actual == expected

    # optimized
    expected = """#pragma version 4
txn Sender
global CreatorAddress
==
bz main_l2
int 1
callsub add_0
pop
main_l2:
int 1
return

// add
add_0:
store 0
int 2
load 0
+
retsub
    """.strip()
    optimize_options = OptimizeOptions(scratch_slots=True)
    actual = pt.compileTeal(
        program, version=4, mode=pt.Mode.Application, optimize=optimize_options
    )
    assert actual == expected


def test_optimize_subroutine_with_global_var():
    global_var = pt.ScratchVar(pt.TealType.uint64)

    @pt.Subroutine(pt.TealType.uint64)
    def add(a1: pt.Expr) -> pt.Expr:
        return pt.Seq(global_var.store(pt.Int(2)), global_var.load() + a1)

    program = pt.Seq(
        [
            pt.If(pt.Txn.sender() == pt.Global.creator_address()).Then(
                pt.Pop(add(pt.Int(1)))
            ),
            global_var.store(pt.Int(5)),
            pt.Approve(),
        ]
    )

    optimize_options = OptimizeOptions()

    # unoptimized
    expected = """#pragma version 4
txn Sender
global CreatorAddress
==
bz main_l2
int 1
callsub add_0
pop
main_l2:
int 5
store 0
int 1
return

// add
add_0:
store 1
int 2
store 0
load 0
load 1
+
retsub
    """.strip()
    actual = pt.compileTeal(
        program, version=4, mode=pt.Mode.Application, optimize=optimize_options
    )
    assert actual == expected

    # optimization should not apply to global vars
    optimize_options = OptimizeOptions(scratch_slots=True)
    actual = pt.compileTeal(
        program, version=4, mode=pt.Mode.Application, optimize=optimize_options
    )
    assert actual == expected


def test_optimize_subroutine_with_reserved_local_var():
    local_var = pt.ScratchVar(pt.TealType.uint64, 0)

    @pt.Subroutine(pt.TealType.uint64)
    def add(a1: pt.Expr) -> pt.Expr:
        return pt.Seq(local_var.store(pt.Int(2)), local_var.load() + a1)

    program = pt.Seq(
        [
            pt.If(pt.Txn.sender() == pt.Global.creator_address()).Then(
                pt.Pop(add(pt.Int(1)))
            ),
            pt.Approve(),
        ]
    )

    optimize_options = OptimizeOptions()

    # unoptimized
    expected = """#pragma version 4
txn Sender
global CreatorAddress
==
bz main_l2
int 1
callsub add_0
pop
main_l2:
int 1
return

// add
add_0:
store 1
int 2
store 0
load 0
load 1
+
retsub
    """.strip()
    actual = pt.compileTeal(
        program, version=4, mode=pt.Mode.Application, optimize=optimize_options
    )
    assert actual == expected

    # The optimization must skip over the reserved slot id so the expected result
    # hasn't changed.
    optimize_options = OptimizeOptions(scratch_slots=True)
    actual = pt.compileTeal(
        program, version=4, mode=pt.Mode.Application, optimize=optimize_options
    )
    assert actual == expected


def test_optimize_subroutine_with_load_dependency():
    @pt.Subroutine(pt.TealType.uint64)
    def add(a1: pt.Expr, a2: pt.Expr) -> pt.Expr:
        return pt.Seq(pt.Pop(a1 + a2), a2)

    program = pt.Seq(
        [
            pt.If(pt.Txn.sender() == pt.Global.creator_address()).Then(
                pt.Pop(add(pt.Int(1), pt.Int(2)))
            ),
            pt.Approve(),
        ]
    )

    optimize_options = OptimizeOptions()

    # unoptimized
    expected = """#pragma version 4
txn Sender
global CreatorAddress
==
bz main_l2
int 1
int 2
callsub add_0
pop
main_l2:
int 1
return

// add
add_0:
store 1
store 0
load 0
load 1
+
pop
load 1
retsub""".strip()
    actual = pt.compileTeal(
        program, version=4, mode=pt.Mode.Application, optimize=optimize_options
    )
    assert actual == expected

    # slot 0 will get optimized but slot 1 won't because it has
    # a load dependency.
    expected = """#pragma version 4
txn Sender
global CreatorAddress
==
bz main_l2
int 1
int 2
callsub add_0
pop
main_l2:
int 1
return

// add
add_0:
store 0
load 0
+
pop
load 0
retsub""".strip()
    optimize_options = OptimizeOptions(scratch_slots=True)
    actual = pt.compileTeal(
        program, version=4, mode=pt.Mode.Application, optimize=optimize_options
    )
    assert actual == expected


def test_optimize_multi_value():
    # note: this is incorrect usage of the app_global_get_ex opcode
    program = pt.Seq(
        pt.MultiValue(
            pt.Op.app_global_get_ex,
            [pt.TealType.uint64, pt.TealType.uint64],
            immediate_args=[],
            args=[pt.Int(0), pt.Int(1)],
        ).outputReducer(lambda value, hasValue: pt.Pop(value + hasValue)),
        pt.Approve(),
    )

    optimize_options = OptimizeOptions()

    # unoptimized
    expected = """#pragma version 4
int 0
int 1
app_global_get_ex
store 1
store 0
load 0
load 1
+
pop
int 1
return""".strip()
    actual = pt.compileTeal(
        program, version=4, mode=pt.Mode.Application, optimize=optimize_options
    )
    assert actual == expected

    # optimized
    expected = """#pragma version 4
int 0
int 1
app_global_get_ex
+
pop
int 1
return""".strip()
    optimize_options = OptimizeOptions(scratch_slots=True)
    actual = pt.compileTeal(
        program, version=4, mode=pt.Mode.Application, optimize=optimize_options
    )
    assert actual == expected


def test_optimize_dynamic_var():
    myvar = pt.DynamicScratchVar()
    regvar = pt.ScratchVar()
    program = pt.Seq(
        regvar.store(pt.Int(1)),
        myvar.set_index(regvar),
        regvar.store(pt.Int(2)),
        pt.Pop(regvar.load()),
        pt.Approve(),
    )

    optimize_options = OptimizeOptions()

    # unoptimized
    expected = """#pragma version 4
int 1
store 1
int 1
store 0
int 2
store 1
load 1
pop
int 1
return""".strip()
    actual = pt.compileTeal(
        program, version=4, mode=pt.Mode.Application, optimize=optimize_options
    )
    assert actual == expected

    # optimization should not change the code because the candidate slot
    # is used by the dynamic slot variable.
    optimize_options = OptimizeOptions(scratch_slots=True)
    actual = pt.compileTeal(
        program, version=4, mode=pt.Mode.Application, optimize=optimize_options
    )
    assert actual == expected


def test_optimize_default_for_version_etc():
    oo = OptimizeOptions()
    assert oo.optimize_scratch_slots(7) is False
    assert oo.use_frame_pointers(7) is False

    assert oo.optimize_scratch_slots(8) is False
    assert oo.use_frame_pointers(8) is True

    assert oo.optimize_scratch_slots(9) is True
    assert oo.use_frame_pointers(9) is True

    oo = OptimizeOptions(scratch_slots=True)
    assert oo.optimize_scratch_slots(7) is True
    assert oo.optimize_scratch_slots(8) is True
    assert oo.optimize_scratch_slots(9) is True

    oo = OptimizeOptions(scratch_slots=False)
    assert oo.optimize_scratch_slots(7) is False
    assert oo.optimize_scratch_slots(8) is False
    assert oo.optimize_scratch_slots(9) is False

    oo = OptimizeOptions(frame_pointers=False)
    assert oo.use_frame_pointers(7) is False
    assert oo.use_frame_pointers(8) is False
    assert oo.use_frame_pointers(9) is False

    oo = OptimizeOptions(frame_pointers=True)
    with pytest.raises(pt.TealInputError) as tie:
        oo.use_frame_pointers(7)
    assert "Frame pointers aren't available" in str(tie.value)

    assert oo.use_frame_pointers(8) is True
    assert oo.use_frame_pointers(9) is True



================================================
FILE: pyteal/ir/__init__.py
================================================
from pyteal.ir.ops import Op, Mode
from pyteal.ir.tealblock import TealBlock
from pyteal.ir.tealcomponent import TealComponent
from pyteal.ir.tealconditionalblock import TealConditionalBlock
from pyteal.ir.teallabel import TealLabel
from pyteal.ir.tealop import TealOp
from pyteal.ir.tealpragma import TealPragma
from pyteal.ir.tealsimpleblock import TealSimpleBlock

from pyteal.ir.labelref import LabelReference

__all__ = [
    "LabelReference",
    "Mode",
    "Op",
    "TealBlock",
    "TealComponent",
    "TealConditionalBlock",
    "TealLabel",
    "TealOp",
    "TealPragma",
    "TealSimpleBlock",
]



================================================
FILE: pyteal/ir/labelref.py
================================================
class LabelReference:
    def __init__(self, label: str) -> None:
        self.label = label

    def addPrefix(self, prefix: str) -> None:
        self.label = prefix + self.label

    def getLabel(self) -> str:
        return self.label

    def __repr__(self) -> str:
        return repr(self.label)

    def __hash__(self) -> int:
        return hash(self.label)

    def __eq__(self, other) -> bool:
        if not isinstance(other, LabelReference):
            return False
        return self.label == other.label



================================================
FILE: pyteal/ir/ops.py
================================================
from dataclasses import dataclass
from enum import Enum, Flag, auto


class Mode(Flag):
    """Enum of program running modes."""

    Signature = auto()
    Application = auto()


Mode.__module__ = "pyteal"


@dataclass
class OpType:
    value: str
    mode: Mode
    min_version: int


class Op(Enum):
    """Enum of program opcodes."""

    def __str__(self) -> str:
        return self.value.value

    @property
    def mode(self) -> Mode:
        """Get the modes where this op is available."""
        return self.value.mode

    @property
    def min_version(self) -> int:
        """Get the minimum version where this op is available."""
        return self.value.min_version

    # fmt: off
    # meta
    comment             = OpType("//",                  Mode.Signature | Mode.Application,  0)
    # avm
    err                 = OpType("err",                 Mode.Signature | Mode.Application,  2)
    sha256              = OpType("sha256",              Mode.Signature | Mode.Application,  2)
    keccak256           = OpType("keccak256",           Mode.Signature | Mode.Application,  2)
    sha512_256          = OpType("sha512_256",          Mode.Signature | Mode.Application,  2)
    mimc                = OpType("mimc",                Mode.Signature | Mode.Application,  11)
    ed25519verify       = OpType("ed25519verify",       Mode.Signature | Mode.Application,  2)
    add                 = OpType("+",                   Mode.Signature | Mode.Application,  2)
    minus               = OpType("-",                   Mode.Signature | Mode.Application,  2)
    div                 = OpType("/",                   Mode.Signature | Mode.Application,  2)
    mul                 = OpType("*",                   Mode.Signature | Mode.Application,  2)
    lt                  = OpType("<",                   Mode.Signature | Mode.Application,  2)
    gt                  = OpType(">",                   Mode.Signature | Mode.Application,  2)
    le                  = OpType("<=",                  Mode.Signature | Mode.Application,  2)
    ge                  = OpType(">=",                  Mode.Signature | Mode.Application,  2)
    logic_and           = OpType("&&",                  Mode.Signature | Mode.Application,  2)
    logic_or            = OpType("||",                  Mode.Signature | Mode.Application,  2)
    eq                  = OpType("==",                  Mode.Signature | Mode.Application,  2)
    neq                 = OpType("!=",                  Mode.Signature | Mode.Application,  2)
    logic_not           = OpType("!",                   Mode.Signature | Mode.Application,  2)
    len                 = OpType("len",                 Mode.Signature | Mode.Application,  2)
    itob                = OpType("itob",                Mode.Signature | Mode.Application,  2)
    btoi                = OpType("btoi",                Mode.Signature | Mode.Application,  2)
    mod                 = OpType("%",                   Mode.Signature | Mode.Application,  2)
    bitwise_or          = OpType("|",                   Mode.Signature | Mode.Application,  2)
    bitwise_and         = OpType("&",                   Mode.Signature | Mode.Application,  2)
    bitwise_xor         = OpType("^",                   Mode.Signature | Mode.Application,  2)
    bitwise_not         = OpType("~",                   Mode.Signature | Mode.Application,  2)
    mulw                = OpType("mulw",                Mode.Signature | Mode.Application,  2)
    addw                = OpType("addw",                Mode.Signature | Mode.Application,  2)
    intcblock           = OpType("intcblock",           Mode.Signature | Mode.Application,  2)
    intc                = OpType("intc",                Mode.Signature | Mode.Application,  2)
    intc_0              = OpType("intc_0",              Mode.Signature | Mode.Application,  2)
    intc_1              = OpType("intc_1",              Mode.Signature | Mode.Application,  2)
    intc_2              = OpType("intc_2",              Mode.Signature | Mode.Application,  2)
    intc_3              = OpType("intc_3",              Mode.Signature | Mode.Application,  2)
    int                 = OpType("int",                 Mode.Signature | Mode.Application,  2)
    bytecblock          = OpType("bytecblock",          Mode.Signature | Mode.Application,  2)
    bytec               = OpType("bytec",               Mode.Signature | Mode.Application,  2)
    bytec_0             = OpType("bytec_0",             Mode.Signature | Mode.Application,  2)
    bytec_1             = OpType("bytec_1",             Mode.Signature | Mode.Application,  2)
    bytec_2             = OpType("bytec_2",             Mode.Signature | Mode.Application,  2)
    bytec_3             = OpType("bytec_3",             Mode.Signature | Mode.Application,  2)
    byte                = OpType("byte",                Mode.Signature | Mode.Application,  2)
    addr                = OpType("addr",                Mode.Signature | Mode.Application,  2)
    method_signature    = OpType("method",              Mode.Signature | Mode.Application,  2)
    arg                 = OpType("arg",                 Mode.Signature,                     2)
    txn                 = OpType("txn",                 Mode.Signature | Mode.Application,  2)
    global_             = OpType("global",              Mode.Signature | Mode.Application,  2)
    gtxn                = OpType("gtxn",                Mode.Signature | Mode.Application,  2)
    load                = OpType("load",                Mode.Signature | Mode.Application,  2)
    store               = OpType("store",               Mode.Signature | Mode.Application,  2)
    txna                = OpType("txna",                Mode.Signature | Mode.Application,  2)
    gtxna               = OpType("gtxna",               Mode.Signature | Mode.Application,  2)
    bnz                 = OpType("bnz",                 Mode.Signature | Mode.Application,  2)
    bz                  = OpType("bz",                  Mode.Signature | Mode.Application,  2)
    b                   = OpType("b",                   Mode.Signature | Mode.Application,  2)
    return_             = OpType("return",              Mode.Signature | Mode.Application,  2)
    pop                 = OpType("pop",                 Mode.Signature | Mode.Application,  2)
    dup                 = OpType("dup",                 Mode.Signature | Mode.Application,  2)
    dup2                = OpType("dup2",                Mode.Signature | Mode.Application,  2)
    concat              = OpType("concat",              Mode.Signature | Mode.Application,  2)
    substring           = OpType("substring",           Mode.Signature | Mode.Application,  2)
    substring3          = OpType("substring3",          Mode.Signature | Mode.Application,  2)
    balance             = OpType("balance",             Mode.Application,                   2)
    app_opted_in        = OpType("app_opted_in",        Mode.Application,                   2)
    app_local_get       = OpType("app_local_get",       Mode.Application,                   2)
    app_local_get_ex    = OpType("app_local_get_ex",    Mode.Application,                   2)
    app_global_get      = OpType("app_global_get",      Mode.Application,                   2)
    app_global_get_ex   = OpType("app_global_get_ex",   Mode.Application,                   2)
    app_local_put       = OpType("app_local_put",       Mode.Application,                   2)
    app_global_put      = OpType("app_global_put",      Mode.Application,                   2)
    app_local_del       = OpType("app_local_del",       Mode.Application,                   2)
    app_global_del      = OpType("app_global_del",      Mode.Application,                   2)
    asset_holding_get   = OpType("asset_holding_get",   Mode.Application,                   2)
    asset_params_get    = OpType("asset_params_get",    Mode.Application,                   2)
    gtxns               = OpType("gtxns",               Mode.Signature | Mode.Application,  3)
    gtxnsa              = OpType("gtxnsa",              Mode.Signature | Mode.Application,  3)
    assert_             = OpType("assert",              Mode.Signature | Mode.Application,  3)
    dig                 = OpType("dig",                 Mode.Signature | Mode.Application,  3)
    swap                = OpType("swap",                Mode.Signature | Mode.Application,  3)
    select              = OpType("select",              Mode.Signature | Mode.Application,  3)
    getbit              = OpType("getbit",              Mode.Signature | Mode.Application,  3)
    setbit              = OpType("setbit",              Mode.Signature | Mode.Application,  3)
    getbyte             = OpType("getbyte",             Mode.Signature | Mode.Application,  3)
    setbyte             = OpType("setbyte",             Mode.Signature | Mode.Application,  3)
    min_balance         = OpType("min_balance",         Mode.Application,                   3)
    pushbytes           = OpType("pushbytes",           Mode.Signature | Mode.Application,  3)
    pushint             = OpType("pushint",             Mode.Signature | Mode.Application,  3)
    shl                 = OpType("shl",                 Mode.Signature | Mode.Application,  4)
    shr                 = OpType("shr",                 Mode.Signature | Mode.Application,  4)
    sqrt                = OpType("sqrt",                Mode.Signature | Mode.Application,  4)
    bitlen              = OpType("bitlen",              Mode.Signature | Mode.Application,  4)
    exp                 = OpType("exp",                 Mode.Signature | Mode.Application,  4)
    divmodw             = OpType("divmodw",             Mode.Signature | Mode.Application,  4)
    expw                = OpType("expw",                Mode.Signature | Mode.Application,  4)
    b_add               = OpType("b+",                  Mode.Signature | Mode.Application,  4)
    b_minus             = OpType("b-",                  Mode.Signature | Mode.Application,  4)
    b_div               = OpType("b/",                  Mode.Signature | Mode.Application,  4)
    b_mul               = OpType("b*",                  Mode.Signature | Mode.Application,  4)
    b_lt                = OpType("b<",                  Mode.Signature | Mode.Application,  4)
    b_gt                = OpType("b>",                  Mode.Signature | Mode.Application,  4)
    b_le                = OpType("b<=",                 Mode.Signature | Mode.Application,  4)
    b_ge                = OpType("b>=",                 Mode.Signature | Mode.Application,  4)
    b_eq                = OpType("b==",                 Mode.Signature | Mode.Application,  4)
    b_neq               = OpType("b!=",                 Mode.Signature | Mode.Application,  4)
    b_mod               = OpType("b%",                  Mode.Signature | Mode.Application,  4)
    b_or                = OpType("b|",                  Mode.Signature | Mode.Application,  4)
    b_and               = OpType("b&",                  Mode.Signature | Mode.Application,  4)
    b_xor               = OpType("b^",                  Mode.Signature | Mode.Application,  4)
    b_not               = OpType("b~",                  Mode.Signature | Mode.Application,  4)
    bzero               = OpType("bzero",               Mode.Signature | Mode.Application,  4)
    gload               = OpType("gload",               Mode.Application,                   4)
    gloads              = OpType("gloads",              Mode.Application,                   4)
    gaid                = OpType("gaid",                Mode.Application,                   4)
    gaids               = OpType("gaids",               Mode.Application,                   4)
    callsub             = OpType("callsub",             Mode.Signature | Mode.Application,  4)
    retsub              = OpType("retsub",              Mode.Signature | Mode.Application,  4)
    ecdsa_verify        = OpType("ecdsa_verify",        Mode.Signature | Mode.Application,  5)
    ecdsa_pk_decompress = OpType("ecdsa_pk_decompress", Mode.Signature | Mode.Application,  5)
    ecdsa_pk_recover    = OpType("ecdsa_pk_recover",    Mode.Signature | Mode.Application,  5)
    loads               = OpType("loads",               Mode.Signature | Mode.Application,  5)
    stores              = OpType("stores",              Mode.Signature | Mode.Application,  5)
    cover               = OpType("cover",               Mode.Signature | Mode.Application,  5)
    uncover             = OpType("uncover",             Mode.Signature | Mode.Application,  5)
    extract             = OpType("extract",             Mode.Signature | Mode.Application,  5)
    extract3            = OpType("extract3",            Mode.Signature | Mode.Application,  5)
    extract_uint16      = OpType("extract_uint16",      Mode.Signature | Mode.Application,  5)
    extract_uint32      = OpType("extract_uint32",      Mode.Signature | Mode.Application,  5)
    extract_uint64      = OpType("extract_uint64",      Mode.Signature | Mode.Application,  5)
    app_params_get      = OpType("app_params_get",      Mode.Application,                   5)
    log                 = OpType("log",                 Mode.Application,                   5)
    itxn_begin          = OpType("itxn_begin",          Mode.Application,                   5)
    itxn_field          = OpType("itxn_field",          Mode.Application,                   5)
    itxn_submit         = OpType("itxn_submit",         Mode.Application,                   5)
    itxn                = OpType("itxn",                Mode.Application,                   5)
    itxna               = OpType("itxna",               Mode.Application,                   5)
    txnas               = OpType("txnas",               Mode.Signature | Mode.Application,  5)
    gtxnas              = OpType("gtxnas",              Mode.Signature | Mode.Application,  5)
    gtxnsas             = OpType("gtxnsas",             Mode.Signature | Mode.Application,  5)
    args                = OpType("args",                Mode.Signature,                     5)
    bsqrt               = OpType("bsqrt",               Mode.Signature | Mode.Application,  6)
    divw                = OpType("divw",                Mode.Signature | Mode.Application,  6)
    itxn_next           = OpType("itxn_next",           Mode.Application,                   6)
    itxnas              = OpType("itxnas",              Mode.Application,                   6)
    gitxn               = OpType("gitxn",               Mode.Application,                   6)
    gitxna              = OpType("gitxna",              Mode.Application,                   6)
    gitxnas             = OpType("gitxnas",             Mode.Application,                   6)
    gloadss             = OpType("gloadss",             Mode.Application,                   6)
    acct_params_get     = OpType("acct_params_get",     Mode.Application,                   6)
    voter_params_get    = OpType("voter_params_get",    Mode.Application,                  11)
    online_stake        = OpType("online_stake",        Mode.Application,                  11)
    replace2            = OpType("replace2",            Mode.Signature | Mode.Application,  7)
    replace3            = OpType("replace3",            Mode.Signature | Mode.Application,  7)
    base64_decode       = OpType("base64_decode",       Mode.Signature | Mode.Application,  7)
    json_ref            = OpType("json_ref",            Mode.Signature | Mode.Application,  7)
    ed25519verify_bare  = OpType("ed25519verify_bare",  Mode.Signature | Mode.Application,  7)
    sha3_256            = OpType("sha3_256",            Mode.Signature | Mode.Application,  7)
    vrf_verify          = OpType("vrf_verify",          Mode.Signature | Mode.Application,  7)
    block               = OpType("block",               Mode.Signature | Mode.Application,  7)
    box_create          = OpType("box_create",          Mode.Application,                   8)
    box_extract         = OpType("box_extract",         Mode.Application,                   8)
    box_replace         = OpType("box_replace",         Mode.Application,                   8)
    box_del             = OpType("box_del",             Mode.Application,                   8)
    box_len             = OpType("box_len",             Mode.Application,                   8)
    box_get             = OpType("box_get",             Mode.Application,                   8)
    box_put             = OpType("box_put",             Mode.Application,                   8)
    popn                = OpType("popn",                Mode.Signature | Mode.Application,  8)
    dupn                = OpType("dupn",                Mode.Signature | Mode.Application,  8)
    bury                = OpType("bury",                Mode.Signature | Mode.Application,  8)
    frame_dig           = OpType("frame_dig",           Mode.Signature | Mode.Application,  8)
    frame_bury          = OpType("frame_bury",          Mode.Signature | Mode.Application,  8)
    proto               = OpType("proto",               Mode.Signature | Mode.Application,  8)
    box_splice          = OpType("box_splice",          Mode.Application,                  10)
    box_resize          = OpType("box_resize",          Mode.Application,                  10)
    ec_add              = OpType("ec_add",              Mode.Signature | Mode.Application, 10)
    ec_scalar_mul       = OpType("ec_scalar_mul",       Mode.Signature | Mode.Application, 10)
    ec_pairing_check    = OpType("ec_pairing_check",    Mode.Signature | Mode.Application, 10)
    ec_multi_scalar_mul = OpType("ec_multi_scalar_mul", Mode.Signature | Mode.Application, 10)
    ec_subgroup_check   = OpType("ec_subgroup_check",   Mode.Signature | Mode.Application, 10)
    ec_map_to           = OpType("ec_map_to",           Mode.Signature | Mode.Application, 10)
    # fmt: on


Op.__module__ = "pyteal"



================================================
FILE: pyteal/ir/tealblock.py
================================================
from abc import ABC, abstractmethod

from typing import Dict, List, Tuple, Set, Iterator, cast, TYPE_CHECKING

from pyteal.ir.tealop import TealOp, Op
from pyteal.errors import TealCompileError

if TYPE_CHECKING:
    from pyteal.ast import Expr, ScratchSlot
    from pyteal.compiler import CompileOptions
    from pyteal.ir.tealsimpleblock import TealSimpleBlock


class TealBlock(ABC):
    """Represents a basic block of TealComponents in a graph."""

    def __init__(self, ops: List[TealOp], root_expr: "Expr | None" = None) -> None:
        self.ops = ops
        self.incoming: List[TealBlock] = []
        self._sframes_container = root_expr

    @abstractmethod
    def getOutgoing(self) -> List["TealBlock"]:
        """Get this block's children blocks, if any."""
        pass

    @abstractmethod
    def replaceOutgoing(self, oldBlock: "TealBlock", newBlock: "TealBlock") -> None:
        """Replace one of this block's child blocks."""
        pass

    def isTerminal(self) -> bool:
        """Check if this block ends the program."""
        for op in self.ops:
            if op.getOp() in (Op.return_, Op.retsub, Op.err):
                return True
        return len(self.getOutgoing()) == 0

    def validateTree(
        self,
        parent: "TealBlock | None" = None,
        visited: List["TealBlock"] | None = None,
    ) -> None:
        """Check that this block and its children have valid parent pointers.

        Args:
            parent (optional): The parent block to this one, if it has one. Defaults to None.
            visited (optional): Used internally to remember blocks that have been visited. Set to None.
        """
        if visited is None:
            # using a list instead of a set as TealBlock is not hashable and PyTEAL programs should be short anyway
            visited = []

        if parent is not None:
            count = 0
            for block in self.incoming:
                if parent is block:
                    count += 1
            assert count == 1

        if all(self is not b for b in visited):
            # if the block was not already visited
            visited.append(self)
            for block in self.getOutgoing():
                block.validateTree(self, visited)

    def addIncoming(
        self,
        parent: "TealBlock | None" = None,
        visited: List["TealBlock"] | None = None,
    ) -> None:
        """Calculate the parent blocks for this block and its children.

        Args:
            parent (optional): The parent block to this one, if it has one. Defaults to None.
            visited (optional): Used internally to remember blocks that have been visited. Set to None.
        """
        if visited is None:
            # using a list instead of a set as TealBlock is not hashable and PyTEAL programs should be short anyway
            visited = []

        if parent is not None and all(parent is not b for b in self.incoming):
            self.incoming.append(parent)

        if all(self is not b for b in visited):
            # if the block was not already visited
            visited.append(self)
            for b in self.getOutgoing():
                b.addIncoming(self, visited)

    def validateSlots(
        self,
        slotsInUse: Set["ScratchSlot"] | None = None,
        visited: Set[Tuple[int, ...]] | None = None,
    ) -> List[TealCompileError]:
        if visited is None:
            visited = set()

        if slotsInUse is None:
            slotsInUse = set()

        currentSlotsInUse = set(slotsInUse)
        errors = []

        for op in self.ops:
            if op.getOp() == Op.store:
                for slot in op.getSlots():
                    currentSlotsInUse.add(slot)

            if op.getOp() == Op.load:
                for slot in op.getSlots():
                    if slot not in currentSlotsInUse:
                        e = TealCompileError(
                            "Scratch slot load occurs before store", op.expr
                        )
                        errors.append(e)

        if not self.isTerminal():
            sortedSlots = sorted(slot.id for slot in currentSlotsInUse)
            for block in self.getOutgoing():
                visitedKey = (id(block), *sortedSlots)
                if visitedKey in visited:
                    continue
                visited.add(visitedKey)

                for error in block.validateSlots(currentSlotsInUse, visited):
                    if error not in errors:
                        errors.append(error)

        return errors

    @abstractmethod
    def __repr__(self) -> str:
        pass

    @abstractmethod
    def __eq__(self, other: object) -> bool:
        pass

    @classmethod
    def FromOp(
        cls, options: "CompileOptions", op: TealOp, *args: "Expr"
    ) -> Tuple["TealBlock", "TealSimpleBlock"]:
        """Create a path of blocks from a TealOp and its arguments.

        Returns:
            The starting and ending block of the path that encodes the given TealOp and arguments.
        """
        from pyteal.ir.tealsimpleblock import TealSimpleBlock

        opBlock = TealSimpleBlock([op])

        if len(args) == 0:
            return opBlock, opBlock

        start = None
        prevArgEnd = None
        for i, arg in enumerate(args):
            argStart, argEnd = arg.__teal__(options)
            if i == 0:
                start = argStart
            else:
                cast(TealSimpleBlock, prevArgEnd).setNextBlock(argStart)
            prevArgEnd = argEnd

        cast(TealSimpleBlock, prevArgEnd).setNextBlock(opBlock)

        return cast(TealBlock, start), opBlock

    @classmethod
    def Iterate(cls, start: "TealBlock") -> Iterator["TealBlock"]:
        """Perform a breadth-first search of the graph of blocks starting with start."""
        queue = [start]
        visited = list(queue)

        def is_in_visited(block):
            for v in visited:
                if block is v:
                    return True
            return False

        while len(queue) != 0:
            w = queue.pop(0)
            nextBlocks = w.getOutgoing()
            yield w
            for nextBlock in nextBlocks:
                if not is_in_visited(nextBlock):
                    visited.append(nextBlock)
                    queue.append(nextBlock)

    @classmethod
    def NormalizeBlocks(cls, start: "TealBlock") -> "TealBlock":
        """Minimize the number of blocks in the graph of blocks starting with start by combining
        sequential blocks. This operation does not alter the operations of the graph or the
        functionality of its underlying program, however it does mutate the input graph.

        Returns:
            The new starting point of the altered graph. May be the same or differant than start.
        """
        for block in TealBlock.Iterate(start):
            if len(block.incoming) == 1:
                prev = block.incoming[0]
                prevOutgoing = prev.getOutgoing()
                if len(prevOutgoing) == 1 and prevOutgoing[0] is block:
                    # combine blocks
                    block.ops = prev.ops + block.ops
                    block.incoming = prev.incoming
                    for incoming in prev.incoming:
                        incoming.replaceOutgoing(prev, block)
                    if prev is start:
                        start = block

        for block in TealBlock.Iterate(start):
            if len(block.ops) == 0:
                outgoing = block.getOutgoing()
                if len(outgoing) == 1:
                    # if block has 0 ops and 1 outgoing edge, directly connect every incoming block
                    # to the single outgoing block, thereby removing an unnecessary intermediate
                    # jump to this block
                    outgoingBlock = outgoing[0]
                    for i, incomingBlock in enumerate(outgoingBlock.incoming):
                        if block is incomingBlock:
                            # remove block from incoming of outgoing
                            outgoingBlock.incoming.pop(i)
                            break

                    for prev in block.incoming:
                        prev.replaceOutgoing(block, outgoing[0])
                        if id(prev) not in [id(b) for b in outgoingBlock.incoming]:
                            outgoingBlock.incoming.append(prev)

                    if block is start:
                        start = block

        return start

    @classmethod
    def GetReferencedScratchSlots(cls, start: "TealBlock") -> List["ScratchSlot"]:
        """Get all scratch slot references for the graph starting at this TealBlock.

        Returns:
            A list of ScratchSlots where each element represents a reference to that slot by a
            TealOp in the graph. The order of the list is consistent, and there may be duplicate
            ScratchSlots in the list if the same slot is referenced multiple times.
        """
        slots: List[ScratchSlot] = []

        for block in TealBlock.Iterate(start):
            for op in block.ops:
                slots += op.getSlots()

        return slots

    @classmethod
    def MatchScratchSlotReferences(
        cls, actual: List["ScratchSlot"], expected: List["ScratchSlot"]
    ) -> bool:
        """Determine if there is a mapping between the actual and expected lists of ScratchSlots.

        A mapping is defined as follows:
          * The actual and expected lists must have the same length.
          * For every ScratchSlot referenced by either list:

            * If the slot appears in both lists, it must appear the exact same number of times and at
              the exact same indexes in both lists.

            * If the slot appears only in one list, for each of its appearances in that list, there
              must be a ScratchSlot in the other list that appears the exact same number of times
              and at the exact same indexes.

        Returns:
            True if and only if a mapping as described above exists between actual and expected.
        """
        if len(actual) != len(expected):
            return False

        commonSlots = set(actual) & set(expected)
        mapFromActualToExpected: Dict[ScratchSlot, ScratchSlot] = {
            slot: slot for slot in commonSlots
        }

        for actualSlot, expectedSlot in zip(actual, expected):
            if actualSlot not in mapFromActualToExpected:
                if expectedSlot in mapFromActualToExpected.values():
                    # this value was already seen
                    return False
                mapFromActualToExpected[actualSlot] = expectedSlot
                continue

            if mapFromActualToExpected[actualSlot] != expectedSlot:
                return False

        return True


TealBlock.__module__ = "pyteal"



================================================
FILE: pyteal/ir/tealblock_test.py
================================================
from typing import NamedTuple, List

import pyteal as pt

options = pt.CompileOptions()


def test_from_op_no_args():
    op = pt.TealOp(None, pt.Op.int, 1)

    expected = pt.TealSimpleBlock([op])

    actual, _ = pt.TealBlock.FromOp(options, op)

    assert actual == expected


def test_from_op_1_arg():
    op = pt.TealOp(None, pt.Op.pop)
    arg_1 = pt.Bytes("message")

    expected = pt.TealSimpleBlock([pt.TealOp(arg_1, pt.Op.byte, '"message"'), op])

    actual, _ = pt.TealBlock.FromOp(options, op, arg_1)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)
    actual.validateTree()

    assert actual == expected


def test_from_op_2_args():
    op = pt.TealOp(None, pt.Op.app_global_put)
    arg_1 = pt.Bytes("key")
    arg_2 = pt.Int(5)

    expected = pt.TealSimpleBlock(
        [pt.TealOp(arg_1, pt.Op.byte, '"key"'), pt.TealOp(arg_2, pt.Op.int, 5), op]
    )

    actual, _ = pt.TealBlock.FromOp(options, op, arg_1, arg_2)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)
    actual.validateTree()

    assert actual == expected


def test_from_op_3_args():
    op = pt.TealOp(None, pt.Op.app_local_put)
    arg_1 = pt.Int(0)
    arg_2 = pt.Bytes("key")
    arg_3 = pt.Int(1)
    arg_4 = pt.Int(2)
    arg_3_plus_4 = arg_3 + arg_4

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(arg_1, pt.Op.int, 0),
            pt.TealOp(arg_2, pt.Op.byte, '"key"'),
            pt.TealOp(arg_3, pt.Op.int, 1),
            pt.TealOp(arg_4, pt.Op.int, 2),
            pt.TealOp(arg_3_plus_4, pt.Op.add),
            op,
        ]
    )

    actual, _ = pt.TealBlock.FromOp(options, op, arg_1, arg_2, arg_3_plus_4)
    actual.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(actual)
    actual.validateTree()

    assert actual == expected


def test_iterate_single():
    block = pt.TealSimpleBlock([pt.TealOp(None, pt.Op.int, 1)])

    blocks = list(pt.TealBlock.Iterate(block))

    assert blocks == [block]


def test_iterate_sequence():
    block5 = pt.TealSimpleBlock([pt.TealOp(None, pt.Op.int, 5)])
    block4 = pt.TealSimpleBlock([pt.TealOp(None, pt.Op.int, 4)])
    block4.setNextBlock(block5)
    block3 = pt.TealSimpleBlock([pt.TealOp(None, pt.Op.int, 3)])
    block3.setNextBlock(block4)
    block2 = pt.TealSimpleBlock([pt.TealOp(None, pt.Op.int, 2)])
    block2.setNextBlock(block3)
    block1 = pt.TealSimpleBlock([pt.TealOp(None, pt.Op.int, 1)])
    block1.setNextBlock(block2)

    blocks = list(pt.TealBlock.Iterate(block1))

    assert blocks == [block1, block2, block3, block4, block5]


def test_iterate_branch():
    blockTrue = pt.TealSimpleBlock([pt.TealOp(None, pt.Op.byte, '"true"')])
    blockFalse = pt.TealSimpleBlock([pt.TealOp(None, pt.Op.byte, '"false"')])
    block = pt.TealConditionalBlock([pt.TealOp(None, pt.Op.int, 1)])
    block.setTrueBlock(blockTrue)
    block.setFalseBlock(blockFalse)

    blocks = list(pt.TealBlock.Iterate(block))

    assert blocks == [block, blockTrue, blockFalse]


def test_iterate_multiple_branch():
    blockTrueTrue = pt.TealSimpleBlock([pt.TealOp(None, pt.Op.byte, '"true true"')])
    blockTrueFalse = pt.TealSimpleBlock([pt.TealOp(None, pt.Op.byte, '"true false"')])
    blockTrueBranch = pt.TealConditionalBlock([])
    blockTrueBranch.setTrueBlock(blockTrueTrue)
    blockTrueBranch.setFalseBlock(blockTrueFalse)
    blockTrue = pt.TealSimpleBlock([pt.TealOp(None, pt.Op.byte, '"true"')])
    blockTrue.setNextBlock(blockTrueBranch)
    blockFalse = pt.TealSimpleBlock([pt.TealOp(None, pt.Op.byte, '"false"')])
    block = pt.TealConditionalBlock([pt.TealOp(None, pt.Op.int, 1)])
    block.setTrueBlock(blockTrue)
    block.setFalseBlock(blockFalse)

    blocks = list(pt.TealBlock.Iterate(block))

    assert blocks == [
        block,
        blockTrue,
        blockFalse,
        blockTrueBranch,
        blockTrueTrue,
        blockTrueFalse,
    ]


def test_iterate_branch_converge():
    blockEnd = pt.TealSimpleBlock([pt.TealOp(None, pt.Op.return_)])
    blockTrue = pt.TealSimpleBlock([pt.TealOp(None, pt.Op.byte, '"true"')])
    blockTrue.setNextBlock(blockEnd)
    blockFalse = pt.TealSimpleBlock([pt.TealOp(None, pt.Op.byte, '"false"')])
    blockFalse.setNextBlock(blockEnd)
    block = pt.TealConditionalBlock([pt.TealOp(None, pt.Op.int, 1)])
    block.setTrueBlock(blockTrue)
    block.setFalseBlock(blockFalse)

    blocks = list(pt.TealBlock.Iterate(block))

    assert blocks == [block, blockTrue, blockFalse, blockEnd]


def test_normalize_single():
    original = pt.TealSimpleBlock([pt.TealOp(None, pt.Op.int, 1)])

    expected = pt.TealSimpleBlock([pt.TealOp(None, pt.Op.int, 1)])

    original.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(original)
    actual.validateTree()

    assert actual == expected


def test_normalize_sequence():
    block6 = pt.TealSimpleBlock([])
    block5 = pt.TealSimpleBlock([pt.TealOp(None, pt.Op.int, 5)])
    block5.setNextBlock(block6)
    block4 = pt.TealSimpleBlock([pt.TealOp(None, pt.Op.int, 4)])
    block4.setNextBlock(block5)
    block3 = pt.TealSimpleBlock([pt.TealOp(None, pt.Op.int, 3)])
    block3.setNextBlock(block4)
    block2 = pt.TealSimpleBlock([pt.TealOp(None, pt.Op.int, 2)])
    block2.setNextBlock(block3)
    block1 = pt.TealSimpleBlock([pt.TealOp(None, pt.Op.int, 1)])
    block1.setNextBlock(block2)

    expected = pt.TealSimpleBlock(
        [
            pt.TealOp(None, pt.Op.int, 1),
            pt.TealOp(None, pt.Op.int, 2),
            pt.TealOp(None, pt.Op.int, 3),
            pt.TealOp(None, pt.Op.int, 4),
            pt.TealOp(None, pt.Op.int, 5),
        ]
    )

    block1.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(block1)
    actual.validateTree()

    assert actual == expected


def test_normalize_branch():
    blockTrueNext = pt.TealSimpleBlock([pt.TealOp(None, pt.Op.int, 4)])
    blockTrue = pt.TealSimpleBlock([pt.TealOp(None, pt.Op.byte, '"true"')])
    blockTrue.setNextBlock(blockTrueNext)
    blockFalse = pt.TealSimpleBlock([pt.TealOp(None, pt.Op.byte, '"false"')])
    blockBranch = pt.TealConditionalBlock([pt.TealOp(None, pt.Op.int, 1)])
    blockBranch.setTrueBlock(blockTrue)
    blockBranch.setFalseBlock(blockFalse)
    original = pt.TealSimpleBlock([])
    original.setNextBlock(blockBranch)

    expectedTrue = pt.TealSimpleBlock(
        [pt.TealOp(None, pt.Op.byte, '"true"'), pt.TealOp(None, pt.Op.int, 4)]
    )
    expectedFalse = pt.TealSimpleBlock([pt.TealOp(None, pt.Op.byte, '"false"')])
    expected = pt.TealConditionalBlock([pt.TealOp(None, pt.Op.int, 1)])
    expected.setTrueBlock(expectedTrue)
    expected.setFalseBlock(expectedFalse)

    original.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(original)
    actual.validateTree()

    assert actual == expected


def test_normalize_branch_converge():
    blockEnd = pt.TealSimpleBlock([])
    blockTrueNext = pt.TealSimpleBlock([pt.TealOp(None, pt.Op.int, 4)])
    blockTrueNext.setNextBlock(blockEnd)
    blockTrue = pt.TealSimpleBlock([pt.TealOp(None, pt.Op.byte, '"true"')])
    blockTrue.setNextBlock(blockTrueNext)
    blockFalse = pt.TealSimpleBlock([pt.TealOp(None, pt.Op.byte, '"false"')])
    blockFalse.setNextBlock(blockEnd)
    blockBranch = pt.TealConditionalBlock([pt.TealOp(None, pt.Op.int, 1)])
    blockBranch.setTrueBlock(blockTrue)
    blockBranch.setFalseBlock(blockFalse)
    original = pt.TealSimpleBlock([])
    original.setNextBlock(blockBranch)

    expectedEnd = pt.TealSimpleBlock([])
    expectedTrue = pt.TealSimpleBlock(
        [pt.TealOp(None, pt.Op.byte, '"true"'), pt.TealOp(None, pt.Op.int, 4)]
    )
    expectedTrue.setNextBlock(expectedEnd)
    expectedFalse = pt.TealSimpleBlock([pt.TealOp(None, pt.Op.byte, '"false"')])
    expectedFalse.setNextBlock(expectedEnd)
    expected = pt.TealConditionalBlock([pt.TealOp(None, pt.Op.int, 1)])
    expected.setTrueBlock(expectedTrue)
    expected.setFalseBlock(expectedFalse)

    original.addIncoming()
    actual = pt.TealBlock.NormalizeBlocks(original)
    actual.validateTree()

    assert actual == expected


def test_GetReferencedScratchSlots():
    a = pt.ScratchSlot()
    b = pt.ScratchSlot()
    c = pt.ScratchSlot()
    d = pt.ScratchSlot()

    end = pt.TealSimpleBlock([pt.TealOp(None, pt.Op.load, d)])
    trueBranch = pt.TealSimpleBlock([pt.TealOp(None, pt.Op.load, b)])
    trueBranch.setNextBlock(end)
    falseBranch = pt.TealSimpleBlock([pt.TealOp(None, pt.Op.load, c)])
    falseBranch.setNextBlock(end)
    splitBranch = pt.TealConditionalBlock([pt.TealOp(None, pt.Op.load, a)])
    splitBranch.setTrueBlock(trueBranch)
    splitBranch.setFalseBlock(falseBranch)

    slotReferences = pt.TealBlock.GetReferencedScratchSlots(splitBranch)
    assert slotReferences == [a, b, c, d]


def test_MatchScratchSlotReferences():
    class MatchSlotReferenceTest(NamedTuple):
        actual: List[pt.ScratchSlot]
        expected: List[pt.ScratchSlot]
        match: bool

    a = pt.ScratchSlot()
    b = pt.ScratchSlot()
    c = pt.ScratchSlot()
    d = pt.ScratchSlot()

    tests: List[MatchSlotReferenceTest] = [
        MatchSlotReferenceTest(
            actual=[],
            expected=[],
            match=True,
        ),
        MatchSlotReferenceTest(
            actual=[a],
            expected=[],
            match=False,
        ),
        MatchSlotReferenceTest(
            actual=[a],
            expected=[a],
            match=True,
        ),
        MatchSlotReferenceTest(
            actual=[a],
            expected=[b],
            match=True,
        ),
        MatchSlotReferenceTest(
            actual=[a, a],
            expected=[a, a],
            match=True,
        ),
        MatchSlotReferenceTest(
            actual=[a, a],
            expected=[b, b],
            match=True,
        ),
        MatchSlotReferenceTest(
            actual=[a, b],
            expected=[a, b],
            match=True,
        ),
        MatchSlotReferenceTest(
            actual=[a, b],
            expected=[b, c],
            match=False,
        ),
        MatchSlotReferenceTest(
            actual=[a, b],
            expected=[c, d],
            match=True,
        ),
        MatchSlotReferenceTest(
            actual=[a, b, b, a, b],
            expected=[c, d, d, c, d],
            match=True,
        ),
        MatchSlotReferenceTest(
            actual=[a, b, b, a, b],
            expected=[a, d, d, a, d],
            match=True,
        ),
        MatchSlotReferenceTest(
            actual=[a, b, b, a, b],
            expected=[c, a, a, c, a],
            match=False,
        ),
        MatchSlotReferenceTest(
            actual=[a, b, b, a, b],
            expected=[c, d, d, c, c],
            match=False,
        ),
    ]

    for i, test in enumerate(tests):
        assert (
            pt.TealBlock.MatchScratchSlotReferences(test.actual, test.expected)
            == test.match
        ), "Test at index {} failed".format(i)



================================================
FILE: pyteal/ir/tealcomponent.py
================================================
from abc import ABC, abstractmethod
from contextlib import AbstractContextManager
from typing import TYPE_CHECKING, List, cast

from pyteal.stack_frame import NatalStackFrame

if TYPE_CHECKING:
    from pyteal.ast import Expr, ScratchSlot, SubroutineDefinition


class TealComponent(ABC):
    def __init__(self, expr: "Expr | None"):
        self.expr: Expr | None = expr

        # ALL BELOW: for source mapping only
        self._stack_frames: NatalStackFrame | None = None
        if not self.expr:  # expr already has the frame info
            self._stack_frames = NatalStackFrame()

        self._sframes_container: Expr | None = None

    def getSlots(self) -> List["ScratchSlot"]:
        return []

    def assignSlot(self, slot: "ScratchSlot", location: int) -> None:
        pass

    def getSubroutines(self) -> List["SubroutineDefinition"]:
        return []

    def resolveSubroutine(self, subroutine: "SubroutineDefinition", label: str) -> None:
        pass

    def stack_frames(self) -> NatalStackFrame:
        from pyteal.ast import Expr

        root_expr = self._sframes_container or self.expr
        if root_expr:
            if subroot := getattr(root_expr, "_sframes_container", None):
                root_expr = cast(Expr, subroot)
            return root_expr.stack_frames

        return cast(NatalStackFrame, self._stack_frames)

    @abstractmethod
    def assemble(self) -> str:
        pass

    @abstractmethod
    def __repr__(self) -> str:
        pass

    @abstractmethod
    def __hash__(self) -> int:
        pass

    @abstractmethod
    def __eq__(self, other: object) -> bool:
        pass

    class Context:
        checkExprEquality = True

        class ExprEqualityContext(AbstractContextManager):
            def __enter__(self):
                TealComponent.Context.checkExprEquality = False
                return self

            def __exit__(self, *args):
                TealComponent.Context.checkExprEquality = True
                return None

        @classmethod
        def ignoreExprEquality(cls):
            return cls.ExprEqualityContext()

        checkScratchSlotEquality = True

        class ScratchSlotEqualityContext(AbstractContextManager):
            def __enter__(self):
                TealComponent.Context.checkScratchSlotEquality = False

            def __exit__(self, *args):
                TealComponent.Context.checkScratchSlotEquality = True
                return None

        @classmethod
        def ignoreScratchSlotEquality(cls):
            """When comparing TealOps, do not verify the equality of any ScratchSlot arguments.

            This is commonly used in testing to verify the that two control flow graphs contains the
            same operations, but may use different ScratchSlots in them. In this case, you will most
            likely want to also use use the following code after comparing with this option enabled:

                .. code-block:: python

                    TealBlock.MatchScratchSlotReferences(
                        TealBlock.GetReferencedScratchSlots(actual),
                        TealBlock.GetReferencedScratchSlots(expected),
                    )

            This ensures that the ScratchSlot usages between the two control flow graphs is
            equivalent. See :any:`TealBlock.MatchScratchSlotReferences` for more info.
            """
            return cls.ScratchSlotEqualityContext()


TealComponent.__module__ = "pyteal"



================================================
FILE: pyteal/ir/tealcomponent_test.py
================================================
import pyteal as pt


def test_EqualityContext():
    expr1 = pt.Int(1)
    expr2 = pt.Int(1)

    op1 = pt.TealOp(expr1, pt.Op.int, 1)
    op2 = pt.TealOp(expr2, pt.Op.int, 1)

    assert op1 == op1
    assert op2 == op2
    assert op1 != op2
    assert op2 != op1

    with pt.TealComponent.Context.ignoreExprEquality():
        assert op1 == op1
        assert op2 == op2
        assert op1 == op2
        assert op2 == op1



================================================
FILE: pyteal/ir/tealconditionalblock.py
================================================
from typing import List

from pyteal.ir.tealop import TealOp
from pyteal.ir.tealblock import TealBlock


class TealConditionalBlock(TealBlock):
    """Represents a basic block of TealComponents in a graph ending with a branch condition."""

    def __init__(self, ops: List[TealOp], root_expr: "Expr | None" = None) -> None:  # type: ignore
        super().__init__(ops, root_expr=root_expr)
        self.trueBlock: TealBlock | None = None
        self.falseBlock: TealBlock | None = None

    def setTrueBlock(self, block: TealBlock) -> None:
        """Set the block that this one should branch to if its condition is true."""
        self.trueBlock = block

    def setFalseBlock(self, block: TealBlock) -> None:
        """Set the block that this one should branch to if its condition is false."""
        self.falseBlock = block

    def getOutgoing(self) -> List[TealBlock]:
        outgoing = []
        if self.trueBlock is not None:
            outgoing.append(self.trueBlock)
        if self.falseBlock is not None:
            outgoing.append(self.falseBlock)
        return outgoing

    def replaceOutgoing(self, oldBlock: TealBlock, newBlock: TealBlock) -> None:
        if self.trueBlock is oldBlock:
            self.trueBlock = newBlock
        elif self.falseBlock is oldBlock:
            self.falseBlock = newBlock

    def __repr__(self) -> str:
        return "TealConditionalBlock({}, true={}, false={}, conditional={})".format(
            repr(self.ops),
            repr(self.trueBlock),
            repr(self.falseBlock),
            repr(self._sframes_container),
        )

    def __eq__(self, other: object) -> bool:
        if type(other) is not TealConditionalBlock:
            return False
        return (
            self.ops == other.ops
            and self.trueBlock == other.trueBlock
            and self.falseBlock == other.falseBlock
        )


TealConditionalBlock.__module__ = "pyteal"



================================================
FILE: pyteal/ir/tealconditionalblock_test.py
================================================
import pyteal as pt


def test_constructor():
    block1 = pt.TealConditionalBlock([])
    assert block1.ops == []
    assert block1.trueBlock is None
    assert block1.falseBlock is None

    block2 = pt.TealConditionalBlock([pt.TealOp(None, pt.Op.int, 1)])
    assert block2.ops == [pt.TealOp(None, pt.Op.int, 1)]
    assert block2.trueBlock is None
    assert block2.falseBlock is None


def test_true_block():
    block = pt.TealConditionalBlock([])
    block.setTrueBlock(pt.TealSimpleBlock([pt.TealOp(None, pt.Op.substring3)]))
    assert block.trueBlock == pt.TealSimpleBlock([pt.TealOp(None, pt.Op.substring3)])
    assert block.getOutgoing() == [
        pt.TealSimpleBlock([pt.TealOp(None, pt.Op.substring3)])
    ]


def test_false_block():
    block = pt.TealConditionalBlock([])
    block.setFalseBlock(pt.TealSimpleBlock([pt.TealOp(None, pt.Op.substring3)]))
    assert block.falseBlock == pt.TealSimpleBlock([pt.TealOp(None, pt.Op.substring3)])


def test_outgoing():
    emptyBlock = pt.TealConditionalBlock([])
    assert emptyBlock.getOutgoing() == []

    trueBlock = pt.TealConditionalBlock([])
    trueBlock.setTrueBlock(pt.TealSimpleBlock([pt.TealOp(None, pt.Op.byte, '"true"')]))
    assert trueBlock.getOutgoing() == [
        pt.TealSimpleBlock([pt.TealOp(None, pt.Op.byte, '"true"')])
    ]

    falseBlock = pt.TealConditionalBlock([])
    falseBlock.setFalseBlock(
        pt.TealSimpleBlock([pt.TealOp(None, pt.Op.byte, '"false"')])
    )
    assert falseBlock.getOutgoing() == [
        pt.TealSimpleBlock([pt.TealOp(None, pt.Op.byte, '"false"')])
    ]

    bothBlock = pt.TealConditionalBlock([])
    bothBlock.setTrueBlock(pt.TealSimpleBlock([pt.TealOp(None, pt.Op.byte, '"true"')]))
    bothBlock.setFalseBlock(
        pt.TealSimpleBlock([pt.TealOp(None, pt.Op.byte, '"false"')])
    )
    assert bothBlock.getOutgoing() == [
        pt.TealSimpleBlock([pt.TealOp(None, pt.Op.byte, '"true"')]),
        pt.TealSimpleBlock([pt.TealOp(None, pt.Op.byte, '"false"')]),
    ]



================================================
FILE: pyteal/ir/teallabel.py
================================================
from typing import TYPE_CHECKING

from pyteal.ir.tealcomponent import TealComponent
from pyteal.ir.labelref import LabelReference

if TYPE_CHECKING:
    from pyteal.ast import Expr


class TealLabel(TealComponent):
    def __init__(
        self, expr: "Expr | None", label: LabelReference, comment: str | None = None
    ) -> None:
        super().__init__(expr)
        self.label = label
        self.comment = comment

    def getLabelRef(self) -> LabelReference:
        return self.label

    def assemble(self) -> str:
        comment = "\n// {}\n".format(self.comment) if self.comment is not None else ""
        return "{}{}:".format(comment, self.label.getLabel())

    def __repr__(self) -> str:
        return "TealLabel({}, {}, {})".format(
            self.expr, repr(self.label), repr(self.comment)
        )

    def __hash__(self) -> int:
        return hash((self.label, self.comment))

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, TealLabel):
            return False
        if TealComponent.Context.checkExprEquality and self.expr is not other.expr:
            return False
        return self.label == other.label and self.comment == other.comment


TealLabel.__module__ = "pyteal"



================================================
FILE: pyteal/ir/tealop.py
================================================
from typing import Union, List, Optional, TYPE_CHECKING

from pyteal.ir.tealcomponent import TealComponent
from pyteal.ir.labelref import LabelReference
from pyteal.ir.ops import Op
from pyteal.errors import TealInternalError

if TYPE_CHECKING:
    from pyteal.ast import Expr, ScratchSlot, SubroutineDefinition


class TealOp(TealComponent):
    def __init__(
        self,
        expr: Optional["Expr"],
        op: Op,
        *args: Union[int, str, LabelReference, "ScratchSlot", "SubroutineDefinition"]
    ) -> None:
        super().__init__(expr)
        self.op = op
        self.args = list(args)

    def getOp(self) -> Op:
        return self.op

    def getSlots(self) -> List["ScratchSlot"]:
        from pyteal.ast import ScratchSlot

        return [arg for arg in self.args if isinstance(arg, ScratchSlot)]

    def assignSlot(self, slot: "ScratchSlot", location: int) -> None:
        for i, arg in enumerate(self.args):
            if slot == arg:
                self.args[i] = location

    def getSubroutines(self) -> List["SubroutineDefinition"]:
        from pyteal.ast import SubroutineDefinition

        return [arg for arg in self.args if isinstance(arg, SubroutineDefinition)]

    def resolveSubroutine(self, subroutine: "SubroutineDefinition", label: str) -> None:
        for i, arg in enumerate(self.args):
            if subroutine == arg:
                self.args[i] = label

    def assemble(self) -> str:
        from pyteal.ast import ScratchSlot, SubroutineDefinition

        parts = [str(self.op)]
        for arg in self.args:
            if isinstance(arg, ScratchSlot):
                raise TealInternalError("Slot not assigned: {}".format(arg))

            if isinstance(arg, SubroutineDefinition):
                raise TealInternalError("Subroutine not resolved: {}".format(arg))

            if isinstance(arg, int):
                parts.append(str(arg))
            elif isinstance(arg, LabelReference):
                parts.append(arg.getLabel())
            else:
                parts.append(arg)

        return " ".join(parts)

    def __repr__(self) -> str:
        args = [str(self.op)]
        for a in self.args:
            args.append(repr(a))

        return "TealOp({})".format(", ".join(args))

    def __hash__(self) -> int:
        return (self.op, *self.args).__hash__()

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, TealOp):
            return False

        if TealComponent.Context.checkExprEquality and self.expr is not other.expr:
            return False

        if not TealComponent.Context.checkScratchSlotEquality:
            from pyteal import ScratchSlot

            if len(self.args) != len(other.args):
                return False
            for myArg, otherArg in zip(self.args, other.args):
                if type(myArg) is ScratchSlot and type(otherArg) is ScratchSlot:
                    continue
                if myArg != otherArg:
                    return False
        elif self.args != other.args:
            return False

        return self.op == other.op


TealOp.__module__ = "pyteal"



================================================
FILE: pyteal/ir/tealpragma.py
================================================
from pyteal.ir.tealcomponent import TealComponent


class TealPragma(TealComponent):
    _name: str
    _value: str | int

    def __init__(self, version: int | None = None, *, type_track: bool | None = None):
        """Creates an assembler pragma statement.

        Only one of the arguments should be set.

        Args:
            version (optional): Sets the program version.
            type_track (optional): Configures assembler type tracking.
        """
        super().__init__(None)

        if len([x for x in [version, type_track] if x is not None]) != 1:
            raise ValueError("Exactly one of version or type_track must be set")

        if version is not None:
            self._name = "version"
            self._value = version
        elif type_track is not None:
            self._name = "typetrack"
            self._value = "true" if type_track else "false"
        else:
            # Shouldn't happen, just to satisfy type checker
            raise ValueError("Empty pragma statement")

    def assemble(self) -> str:
        return f"#pragma {self._name} {self._value}"

    def __repr__(self) -> str:
        match self._name:
            case "version":
                name = "version"
                value = self._value
            case "typetrack":
                name = "type_track"
                value = self._value == "true"
            case _:
                raise ValueError(f"Unknown pragma name: {self._name}")
        return f"TealPragma({name}={value})"

    def __hash__(self) -> int:
        return hash(repr(self))

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, TealPragma):
            return False
        return self._name == other._name and self._value == other._value


TealPragma.__module__ = "pyteal"



================================================
FILE: pyteal/ir/tealpragma_test.py
================================================
import pytest
import pyteal as pt


def test_version():
    for i in range(10):
        version_pragma = pt.TealPragma(version=i)
        assert version_pragma._name == "version"
        assert version_pragma._value == i
        assert version_pragma.assemble() == f"#pragma version {i}"
        assert repr(version_pragma) == f"TealPragma(version={i})"


def test_type_track():
    for value in (True, False):
        type_track_pragma = pt.TealPragma(type_track=value)
        assert type_track_pragma._name == "typetrack"
        assert type_track_pragma._value == str(value).lower()
        assert type_track_pragma.assemble() == f"#pragma typetrack {str(value).lower()}"
        assert repr(type_track_pragma) == f"TealPragma(type_track={value})"


def test_empty():
    with pytest.raises(ValueError):
        pt.TealPragma()


def test_both():
    with pytest.raises(ValueError):
        pt.TealPragma(version=1, type_track=True)



================================================
FILE: pyteal/ir/tealsimpleblock.py
================================================
from pyteal.ir.tealblock import TealBlock
from pyteal.ir.tealop import TealOp


class TealSimpleBlock(TealBlock):
    """Represents a basic block of TealComponents in a graph that does not contain a branch condition."""

    def __init__(self, ops: list[TealOp]) -> None:
        super().__init__(ops)
        self.nextBlock: TealBlock | None = None
        self.visited = False

    def setNextBlock(self, block: TealBlock) -> None:
        """Set the block that follows this one."""
        self.nextBlock = block

    def getOutgoing(self) -> list[TealBlock]:
        if self.nextBlock is None:
            return []
        return [self.nextBlock]

    def replaceOutgoing(self, oldBlock: TealBlock, newBlock: TealBlock) -> None:
        if self.nextBlock is oldBlock:
            self.nextBlock = newBlock

    def __repr__(self) -> str:
        # check for loop
        if self.visited:
            return "TealSimpleBlock({}, next={})".format(
                repr(self.ops),
                "",
            )
        self.visited = True

        s = "TealSimpleBlock({}, next={})".format(
            repr(self.ops),
            repr(self.nextBlock),
        )

        self.visited = False
        return s

    def __eq__(self, other: object) -> bool:
        # check for loop
        if self.visited:
            return True
        if type(other) is not TealSimpleBlock:
            return False
        self.visited = True
        equal = self.ops == other.ops and self.nextBlock == other.nextBlock
        self.visited = False
        return equal


TealSimpleBlock.__module__ = "pyteal"



================================================
FILE: pyteal/ir/tealsimpleblock_test.py
================================================
import pyteal as pt


def test_constructor():
    block1 = pt.TealSimpleBlock([])
    assert block1.ops == []
    assert block1.nextBlock is None

    block2 = pt.TealSimpleBlock([pt.TealOp(None, pt.Op.int, 1)])
    assert block2.ops == [pt.TealOp(None, pt.Op.int, 1)]
    assert block2.nextBlock is None


def test_next_block():
    block = pt.TealSimpleBlock([])
    block.setNextBlock(pt.TealSimpleBlock([pt.TealOp(None, pt.Op.substring3)]))
    assert block.nextBlock == pt.TealSimpleBlock([pt.TealOp(None, pt.Op.substring3)])


def test_outgoing():
    emptyBlock = pt.TealSimpleBlock([])
    assert emptyBlock.getOutgoing() == []

    block = pt.TealSimpleBlock([])
    block.setNextBlock(pt.TealSimpleBlock([pt.TealOp(None, pt.Op.byte, '"nextBlock"')]))
    assert block.getOutgoing() == [
        pt.TealSimpleBlock([pt.TealOp(None, pt.Op.byte, '"nextBlock"')])
    ]



================================================
FILE: pyteal/pragma/__init__.py
================================================
from pyteal.pragma.pragma import is_valid_compiler_version, pragma

__all__ = [
    "is_valid_compiler_version",
    "pragma",
]



================================================
FILE: pyteal/pragma/pragma.py
================================================
import re
from importlib import metadata
from typing import Any
from semantic_version import Version, NpmSpec

from pyteal.errors import TealPragmaError


def __convert_pep440_compiler_version(compiler_version: str):
    """Convert PEP 440 version identifiers to valid NPM versions.

    For example:
        "1.0.0" -> "1.0.0"
        "1.0.0a1" -> "1.0.0-a1"
        "<0.5.0+local || >=1.0.0a9.post1.dev2" -> "<0.5.0 || >=1.0.0-alpha9.1.2"
    """
    NUMBER = r"(?:x|X|\*|0|[1-9][0-9]*)"
    LOCAL = r"[a-zA-Z0-9.]*"
    TRIM_PREFIX_RE = re.compile(
        r"""
            (?:v)?                                          # Strip optional initial v
            (?P<op><|<=|>=|>|=|\^|~|)                       # Operator, can be empty
            (?P<major>{nb})(?:\.(?P<minor>{nb})(?:\.(?P<patch>{nb}))?)?
            (?:(?P<prerel_type>a|b|rc)(?P<prerel>{nb}))?    # Optional pre-release
            (?:\.post(?P<postrel>{nb}))?                    # Optional post-release
            (?:\.dev(?P<dev>{nb}))?                         # Optional dev release
            (?:\+(?P<local>{lcl}))?                         # Optional local version
        """.format(
            nb=NUMBER,
            lcl=LOCAL,
        ),
        re.VERBOSE,
    )

    def match_replacer(match: re.Match):
        (
            op,
            major,
            minor,
            patch,
            prerel_type,
            prerel,
            postrel,
            dev,
            local,
        ) = match.groups()

        # Base version (major/minor/patch)
        base_version = "{}.{}.{}".format(major or "0", minor or "0", patch or "0")

        # Combine prerel, postrel, and dev
        combined_additions = []
        short_prerel_type_to_long = {
            "a": "alpha",
            "b": "beta",
            "rc": "rc",
        }
        if prerel_type is not None:
            combined_additions.append(short_prerel_type_to_long[prerel_type] + prerel)
        if len(combined_additions) > 0 or postrel is not None or dev is not None:
            combined_additions.append(postrel or "0")
        if len(combined_additions) > 0 or dev is not None:
            combined_additions.append(dev or "0")
        combined_additions_str = ".".join(combined_additions)

        # Build full_version
        full_version = base_version
        if len(combined_additions) > 0:
            full_version += "-" + combined_additions_str
        if local is not None:
            full_version += "+" + local.lower()

        if op is not None:
            return op + full_version
        return full_version

    return re.sub(TRIM_PREFIX_RE, match_replacer, compiler_version)


def is_valid_compiler_version(compiler_version: str):
    """Check if the compiler version is valid.

    Args:
        compiler_version: The compiler version to check.

    Returns:
        True if the compiler version is a valid NPM specification range
        using either the PEP 440 or semantic version format, otherwise False.
    """
    try:
        pep440_converted = __convert_pep440_compiler_version(compiler_version)
        NpmSpec(pep440_converted)
        return True
    except ValueError:
        return False


def pragma(
    *,
    compiler_version: str,
    **kwargs: Any,
) -> None:
    """
    Specify pragmas for the compiler.

    Args:
        compiler_version: Acceptable versions of the compiler. Will fail if the current PyTeal version
            is not contained in the range. Follows the npm `semver range scheme <https://github.com/npm/node-semver#ranges>`_
            for specifying compatible versions.

    For example:

        .. code-block:: python

            # this will immediately fail if the current PyTeal version does not satisfy the
            # version constraint
            pragma(compiler_version="^0.14.0")
    """
    pkg_version = metadata.version("pyteal")
    pyteal_version = Version(__convert_pep440_compiler_version(pkg_version))
    if pyteal_version not in NpmSpec(
        __convert_pep440_compiler_version(compiler_version)
    ):
        raise TealPragmaError(
            "PyTeal version {} is not compatible with compiler version {}".format(
                pkg_version, compiler_version
            )
        )



================================================
FILE: pyteal/pragma/pragma_test.py
================================================
import pytest
from importlib import metadata
from tests.mock_version import (  # noqa: F401
    mock_version,
)

import pyteal as pt
from pyteal.pragma.pragma import __convert_pep440_compiler_version


@pytest.mark.parametrize(
    "compiler_version,expected",
    [
        ("2", "2.0.0"),
        (">=0.12.0a9.post2.dev9", ">=0.12.0-alpha9.2.9"),
        ("<0.5.0 || >=1.0.0a9.post1.dev2", "<0.5.0 || >=1.0.0-alpha9.1.2"),
        ("v0.12.9.post1 - v1.13.0.dev1", "0.12.9-1.0 - 1.13.0-0.1"),
        (
            "1.2.3a4.post5.dev6+AVM7.1",
            "1.2.3-alpha4.5.6+avm7.1",
        ),  # local versions are lowercased to be consistent with pkg_resources
    ],
)
def test_convert_pep440_compiler_version(compiler_version, expected):
    assert __convert_pep440_compiler_version(compiler_version) == expected


@pytest.mark.usefixtures("mock_version")
@pytest.mark.parametrize(
    "version, compiler_version, should_error",
    [
        # valid
        ("0.12.0", "0.12.0", False),
        ("0.12.0", "<=0.12.0", False),
        ("0.12.0", ">=0.12.0", False),
        ("0.13.0", "<0.8.0 || >=0.12.0", False),
        ("0.12.0", "0.12.0-rc1", False),
        ("0.1.0", "<0.2.0", False),
        ("1.2.3", "^1.2.3", False),
        ("1.5.0", "^1.2.3", False),
        ("1.2.3b9", "^1.2.3b4", False),
        ("0.1.0a1", "<0.1.0a2", False),
        ("0.1.0-rc1", "<0.1.0-rc2", False),
        ("0.1.0.dev1", "<0.1.0.dev2", False),
        ("0.1.0a9.dev2", ">0.1.0a8.dev1", False),
        ("v1.1", "<0.5.0 || >=1.0.0a9.post1.dev2", False),
        ("v1.0a9.post2.dev2", "<0.5.0 || >=1.0.0a9.post1.dev2", False),
        ("v1.0a9.post1", "<0.5.0 || >=1.0.0a9.dev10", False),
        ("0.4.0", "<0.5.0 || >=1.0.0a9.dev10", False),
        ("1.2.3a4.post5.dev6+AVM7.1", "=1.2.3a4.post5.dev6+AVM7.1", False),
        (
            "1.0.0+AVM7.1",
            "=1.0.0",
            False,
        ),  # Ignores local version (consistent with PEP 440)
        (
            metadata.version("pyteal"),
            metadata.version("pyteal"),
            False,
        ),
        # invalid
        ("0.13.0", "0.13.1", True),
        ("1.2.3a2", "<0.8.0 || >=0.12.0", True),
        ("0.1.0a1", "<0.2.0", True),
        ("2.0.0", "^1.2.3", True),
        ("0.4.0b10", "<0.5.0 || >=1.0.0a9.dev10", True),
        ("0.4.9a10.dev2.post3", "<0.5.0 || >=1.0.0a9.post1.dev2", True),
    ],
)
def test_pragma_compiler_version(version, compiler_version, should_error):
    if should_error:
        with pytest.raises(pt.TealPragmaError):
            pt.pragma(compiler_version=compiler_version)
    else:
        pt.pragma(compiler_version=compiler_version)


@pytest.mark.parametrize(
    "compiler_version",
    ["not a version", ">=0.1.1,<0.3.0", "1.2.3aq"],  # incorrect spec  # invalid PEP 440
)
def test_pragma_compiler_version_invalid(compiler_version):
    with pytest.raises(ValueError):
        pt.pragma(compiler_version=compiler_version)



================================================
FILE: scripts/generate_init.py
================================================
import argparse
from collections import Counter
import difflib
import os
import sys

from pyteal import __all__ as static_all


# Start of the template to be appended to
pyi_template = """## File generated from scripts/generate_init.py.
## DO NOT EDIT DIRECTLY

"""

# Template for __all__ export list
all_template = """__all__ = [
    {},
]"""

# Flags to denote the beginning/end of the __all__ exports in __init__.py
begin_flag = "# begin __all__"
end_flag = "# end __all__"

# Make it safe to run from anywhere
curr_dir = os.path.dirname(os.path.abspath(__file__))
orig_dir = os.path.join(curr_dir, os.path.join("..", "pyteal"))

# Path to pyi
pyi_file = "__init__.pyi"
orig_file = os.path.join(orig_dir, pyi_file)

# Path to py
py_file = "__init__.py"
init_file = os.path.join(orig_dir, py_file)


def generate_init_pyi() -> str:
    with open(init_file, "r") as f:
        init_contents = f.read()

    start_idx = init_contents.index(begin_flag)
    end_idx = init_contents.index(end_flag)

    counts = Counter(static_all)
    dupes = [x for x, n in counts.items() if n > 1]
    BR = "\n"
    assert (
        not dupes
    ), f"Aborting pyi file generation. The following duplicate imports were detected:{BR}{BR.join(dupes)}"

    all_imports = ",\n    ".join(['"{}"'.format(s) for s in sorted(static_all)])

    return (
        pyi_template
        + init_contents[:start_idx]
        + all_template.format(all_imports)
        + init_contents[end_idx + len(end_flag) :]
    )


def is_different(regen: str) -> bool:
    if not os.path.exists(orig_file):
        return True

    with open(orig_file, "r") as f:
        orig_lines = f.readlines()

    curr_lines = regen.splitlines(keepends=True)

    diff = list(
        difflib.unified_diff(
            orig_lines, curr_lines, fromfile="original", tofile="generated", n=3
        )
    )

    if len(diff) != 0:
        print("".join(diff), end="")
        return True

    return False


def overwrite(regen: str):
    with open(orig_file, "w") as f:
        f.write(regen)


if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument(
        "--check",
        action="store_true",
        help="Only check if the generated file would change",
    )
    args = parser.parse_args()

    regen = generate_init_pyi()

    if args.check:
        if is_different(regen):
            print(
                "The __init__.pyi needs to be regenerated. Please run scripts/generate_init.py"
            )
            sys.exit(1)
        print("No changes in __init__.pyi")
        sys.exit(0)

    overwrite(regen)



================================================
FILE: tests/__init__.py
================================================
[Empty file]


================================================
FILE: tests/abi_roundtrip.py
================================================
from typing import Generic, TypeVar, Optional

import pyteal as pt
from pyteal import abi

from tests.blackbox import Blackbox, BlackboxWrapper, PyTealDryRunExecutor

T = TypeVar("T", bound=abi.BaseType)

DEFAULT_DYNAMIC_ARRAY_LENGTH = 3


class ABIRoundtrip(Generic[T]):
    def __init__(
        self,
        annotation_instance: abi.BaseType,
        length: Optional[int] = None,
    ):
        self.instance: abi.BaseType = annotation_instance
        self.type_spec: abi.TypeSpec = annotation_instance.type_spec()
        self.annotation: type[abi.BaseType] = self.type_spec.annotation_type()

        self.length: Optional[int] = length

    def pytealer(self) -> PyTealDryRunExecutor:
        roundtrip = self.roundtrip_factory()
        return PyTealDryRunExecutor(roundtrip, pt.Mode.Application)

    def roundtrip_factory(self) -> BlackboxWrapper:
        comp = self.mutator_factory()

        ann_out = abi.Tuple3[self.annotation, self.annotation, self.annotation]  # type: ignore[misc,name-defined]

        @Blackbox(input_types=[None])
        @pt.ABIReturnSubroutine
        def round_tripper(x: self.annotation, *, output: ann_out):  # type: ignore[name-defined]
            y = abi.make(self.annotation)
            z = abi.make(self.annotation)
            return pt.Seq(y.set(comp(x)), z.set(comp(y)), output.set(x, y, z))  # type: ignore[attr-defined]

        return round_tripper

    def mutator_factory(self) -> pt.ABIReturnSubroutine:
        if isinstance(self.type_spec, abi.BoolTypeSpec):
            return self.bool_comp_factory()
        if isinstance(self.type_spec, abi.UintTypeSpec):
            return self.numerical_comp_factory()
        if isinstance(self.type_spec, abi.StringTypeSpec):
            return self.string_reverse_factory()
        if isinstance(self.type_spec, abi.TupleTypeSpec):
            return self.tuple_comp_factory()
        if isinstance(self.type_spec, abi.ArrayTypeSpec):
            return self.array_comp_factory()
        if isinstance(self.type_spec, abi.TransactionTypeSpec):
            return self.transaction_comp_factory()

        raise ValueError(f"uh-oh!!! didn't handle type {self.instance}")

    def bool_comp_factory(self) -> pt.ABIReturnSubroutine:
        @pt.ABIReturnSubroutine
        def bool_comp(x: abi.Bool, *, output: abi.Bool):
            return output.set(pt.Not(x.get()))

        return bool_comp

    @classmethod
    def max_int(cls, bit_size):
        return (1 << bit_size) - 1

    def transaction_comp_factory(self) -> pt.ABIReturnSubroutine:
        @pt.ABIReturnSubroutine
        def transaction_comp(x: self.annotation, *, output: abi.Uint64):  # type: ignore[name-defined]
            return output.set(x.get().amount())

        return transaction_comp

    def numerical_comp_factory(self) -> pt.ABIReturnSubroutine:
        @pt.ABIReturnSubroutine
        def numerical_comp(x: self.annotation, *, output: self.annotation):  # type: ignore[name-defined]
            max_uint = pt.Int(self.max_int(self.type_spec.bit_size()))  # type: ignore[attr-defined]
            return output.set(max_uint - x.get())

        return numerical_comp

    def string_reverse_factory(self) -> pt.ABIReturnSubroutine:
        """
        Assume strings are python utf-8 compliant and therefore each byte value is at most 127
        """
        if self.length is None:
            self.length = DEFAULT_DYNAMIC_ARRAY_LENGTH

        char_type_spec = abi.ByteTypeSpec()

        @pt.ABIReturnSubroutine
        def string_reverse(x: self.annotation, *, output: self.annotation):  # type: ignore[name-defined]
            insts = [char_type_spec.new_instance() for _ in range(self.length)]  # type: ignore[arg-type]
            setters = [inst.set(x[i]) for i, inst in enumerate(reversed(insts))]
            return pt.Seq(*(setters + [output.set(insts)]))

        return string_reverse

    def tuple_comp_factory(self) -> pt.ABIReturnSubroutine:  # type: ignore[name-defined]
        value_type_specs: list[abi.TypeSpec] = self.type_spec.value_type_specs()  # type: ignore[attr-defined]

        @pt.ABIReturnSubroutine
        def tuple_complement(x: self.annotation, *, output: self.annotation):  # type: ignore[name-defined]
            insts = [vts.new_instance() for vts in value_type_specs]
            roundtrips: list[ABIRoundtrip[T]] = [
                ABIRoundtrip(inst, length=None) for inst in insts  # type: ignore[arg-type]
            ]
            setters = [inst.set(x[i]) for i, inst in enumerate(insts)]  # type: ignore[attr-defined]
            comp_funcs = [rtrip.mutator_factory() for rtrip in roundtrips]
            compers = [inst.set(comp_funcs[i](inst)) for i, inst in enumerate(insts)]  # type: ignore[attr-defined]
            return pt.Seq(*(setters + compers + [output.set(*insts)]))

        return tuple_complement

    def array_comp_factory(self) -> pt.ABIReturnSubroutine:
        """
        When the length has not been provided for a dynamic array,
        default to DEFAULT_DYNAMIC_ARRAY_LENGTH
        """
        if not self.type_spec.is_length_dynamic():  # type: ignore[attr-defined]
            if self.length is not None:
                assert self.length == self.type_spec.length_static()  # type: ignore[attr-defined]
            else:
                self.length = self.type_spec.length_static()  # type: ignore[attr-defined]
        elif self.length is None:
            self.length = DEFAULT_DYNAMIC_ARRAY_LENGTH

        internal_type_spec = self.type_spec.value_type_spec()  # type: ignore[attr-defined]
        internal_ann_inst = internal_type_spec.new_instance()
        comp_func = ABIRoundtrip(internal_ann_inst, length=None).mutator_factory()

        @pt.ABIReturnSubroutine
        def array_complement(x: self.annotation, *, output: self.annotation):  # type: ignore[name-defined]
            insts = [internal_type_spec.new_instance() for _ in range(self.length)]  # type: ignore[arg-type]
            setters = [inst.set(x[i]) for i, inst in enumerate(insts)]
            compers = [inst.set(comp_func(inst)) for inst in insts]
            return pt.Seq(*(setters + compers + [output.set(insts)]))

        return array_complement



================================================
FILE: tests/blackbox.py
================================================
from collections import defaultdict
from copy import deepcopy
from dataclasses import dataclass, asdict
import json
from typing import Any, Callable, Final, Literal, Sequence, Type, cast

import algosdk.abi as sdk_abi
from algosdk.transaction import OnComplete
from algosdk import v2client

from graviton import blackbox
from graviton.abi_strategy import (
    ABIArgsMod,
    ABICallStrategy,
    ABIStrategy,
    RandomArgLengthCallStrategy,
)
from graviton.blackbox import (
    DryRunInspector,
    DryRunExecutor,
    DryRunTransactionParams as TxParams,
)
from graviton.inspector import DryRunProperty as DRProp
from graviton.models import ExecutionMode, PyTypes
from graviton.sim import InputStrategy, Simulation, SimulationResults

from pyteal.compiler.compiler import OptimizeOptions
from pyteal.ast.subroutine import OutputKwArgInfo

from pyteal import (
    abi,
    Arg,
    Btoi,
    Bytes,
    CallConfig,
    compileTeal,
    Expr,
    Int,
    Itob,
    Len,
    Log,
    MethodConfig,
    Mode,
    Pop,
    Router,
    ScratchVar,
    Seq,
    SubroutineFnWrapper,
    TealType,
    Txn,
)

from pyteal.ast.subroutine import ABIReturnSubroutine

# ---- Types ---- #

Predicates = dict[DRProp, Any]  # same as in graviton


CLEAR_STATE_CALL: Final[str] = "ClearStateCall"
ClearStateCallType = Literal["ClearStateCall"]

# str for methods, None for bare app calls:
CallType = str | None

# CallType for app calls, CLEAR_STATE_CALL for clear state calls:
RouterCallType = CallType | ClearStateCallType  # type: ignore

ABICallConfigs = dict[CallType, MethodConfig]

# key `method_config == None` indicates that the MethodConfig's
# should be picked up from the router
CallPredicates = dict[RouterCallType, Predicates]

# ---- Clients ---- #


def algod_with_assertion():
    algod = _algod_client()
    assert algod.status(), "algod.status() did not produce any results"
    return algod


def _algod_client(
    algod_address="http://localhost:4001", algod_token="a" * 64
) -> v2client.algod.AlgodClient:
    """Instantiate and return Algod client object."""
    return v2client.algod.AlgodClient(algod_token, algod_address)


# ---- Decorator ---- #


class BlackboxWrapper:
    def __init__(
        self,
        subr: SubroutineFnWrapper | ABIReturnSubroutine,
        input_types: list[TealType | None],
    ):
        subr.subroutine._validate(input_types=input_types)
        self.subroutine: SubroutineFnWrapper | ABIReturnSubroutine = subr
        self.input_types: list[TealType | abi.TypeSpec | None] = self._fill(input_types)

    def __call__(self, *args: Expr | ScratchVar, **kwargs) -> Expr | abi.ReturnedValue:
        return self.subroutine(*args, **kwargs)

    def name(self) -> str:
        return self.subroutine.name()

    def _fill(
        self, input_types: list[TealType | None]
    ) -> list[TealType | abi.TypeSpec | None]:
        match self.subroutine:
            case SubroutineFnWrapper() | ABIReturnSubroutine():
                args = self.subroutine.subroutine.arguments()
                abis = self.subroutine.subroutine.abi_args
                return [(x if x else abis[args[i]]) for i, x in enumerate(input_types)]
            case _:
                raise AssertionError(
                    f"Cannot handle subroutine of type {type(self.subroutine)}"
                )


def Blackbox(input_types: list[TealType | None]):
    """
    Decorator for transforming @Subroutine and @ABIReturnSubroutine wrapped functions
    into PyTeal expressions that compile into executable Teal programs.

    input_types: list[TealType] (required)
        List shadowing the input arguments of the decorated subroutine. In particular:
            * the list needs to be the same length as the number of subroutine arguments
            * if the subroutine argument is an ABI type, the shadowing input_type must be None
                as it will be determined at compile time from the subroutine's annotation
            * if the subroutine argument is an Expr or a ScratchVar, the shadowing input_type
                must be a TealType of the same kind as expected in the argument

    Some _Correct_ Examples:

    @Blackbox(input_types=[TealType.bytes, TealType.uint64])
    @Subroutine(TealType.bytes)
    def string_mult(x, y):
        ...

    @Blackbox(input_types=[TealType.bytes, TealType.uint64])
    @Subroutine(TealType.bytes)
    def string_mult(x: Expr, y: Expr):
        ...

    @Blackbox(input_types=[TealType.bytes, TealType.uint64])
    @Subroutine(TealType.bytes)
    def string_mult(x: ScratchVar, y: Expr):
        ...


    @Blackbox(input_types=[None, None])
    @ABIReturnSubroutine
    def string_mult(x: abi.String, y: abi.Uint16):
        ...

    @Blackbox(input_types=[None, TealType.uint64])
    @ABIReturnSubroutine
    def string_mult(x: abi.String, y):
        ...

    @Blackbox([None])
    @Subroutine(TealType.uint64)
    def cubed(n: abi.Uint64):
        ...

    """

    def decorator_blackbox(func: SubroutineFnWrapper | ABIReturnSubroutine):
        return BlackboxWrapper(func, input_types)

    return decorator_blackbox


# ---- API ---- #


def mode_to_execution_mode(mode: Mode) -> blackbox.ExecutionMode:
    if mode == Mode.Application:
        return blackbox.ExecutionMode.Application
    if mode == Mode.Signature:
        return blackbox.ExecutionMode.Signature

    raise ValueError(f"Can't handle {mode=}")


class PyTealDryRunExecutor:
    def __init__(self, subr: BlackboxWrapper, mode: Mode):
        """
        Args:
            subr: a Subroutine or ABIReturnSubroutine which has been decorated with @Blackbox.
                Note: the `input_types` parameters should be supplied to the @Blackbox() decorator
                    cf. the Blackbox class for futher details about acceptable `input_types`

            mode: type of program to produce: logic sig (Mode.Signature) or app (Mode.Application)
        """
        input_types = subr.input_types
        assert input_types is not None, (
            "please provide input_types in your @Subroutine or @ABIReturnSubroutine "
            "annotation. "
            "(this is crucial for generating proper end-to-end testable PyTeal)"
        )

        self.subr, self.mode, self.input_types = subr, mode, input_types
        match subr.subroutine:
            case SubroutineFnWrapper():
                approval = self._handle_SubroutineFnWrapper()
            case ABIReturnSubroutine():
                approval = self._handle_ABIReturnSubroutine()
            case _:
                raise AssertionError(
                    f"Cannot produce Blackbox pyteal for provided subroutine of type {type(subr.subroutine)}"
                )

        self._pyteal_lambda: Callable[..., Expr] = approval

        self.traces: list = []

    def add_trace(self, trace: Any) -> None:
        self.traces.append(trace)

    def is_abi(self) -> bool:
        return isinstance(self.subr.subroutine, ABIReturnSubroutine)

    def abi_method_signature(self) -> None | str:
        if self.is_abi():
            abi_subr = cast(ABIReturnSubroutine, self.subr.subroutine)
            return abi_subr.method_signature()

        # create an artificial method signature
        # based on the `abi_argument_types()` and `abi_return_type()`
        if arg_types := self.abi_argument_types():
            if all(t is None for t in arg_types):
                return None

            ret_type = self.abi_return_type()
            ret = str(ret_type) if ret_type else "void"
            return f"ptdre_foo({','.join(map(str, arg_types))}){ret}"

        return None

    def abi_argument_types(self) -> None | list[sdk_abi.ABIType]:
        if not (self.input_types or self.is_abi()):
            return None

        def handle_arg(arg):
            if isinstance(arg, abi.TypeSpec):
                return abi.algosdk_from_type_spec(arg)
            return None

        return [handle_arg(arg) for arg in self.input_types]

    def abi_return_type(self) -> None | sdk_abi.ABIType:
        if not self.is_abi():
            return None

        out_info = getattr(self.subr.subroutine, "output_kwarg_info")
        if not out_info:
            return None

        return abi.algosdk_from_type_spec(cast(OutputKwArgInfo, out_info).abi_type)

    def program(self) -> Expr:
        """Get ready-to-compile PyTeal program from Subroutines and ABIReturnSubroutines

        Returns:
            a PyTeal expression representing a ready-to-run TEAL program

        Generated TEAL code depends on the self.subr's type, the mode, the input types, and output type
        * logic sigs:
            * input received via `arg i`
            * args are converted (cf. "input conversion" below) and passed to the subroutine
            * subroutine output is not logged (log is not available)
            * in the case of ABIReturnSubroutine: the output is encoded on to the stack an then popped off
            * subroutine output is converted (cf "output conversion" below)
        * apps:
            * input received via `txna ApplicationArgs i`
            * args are converted (cf. "input conversion" below) and passed to the subroutine
            * the output is logged in the following ways:
                * Subroutine: logged after possible conversion (cf. "logging conversion")
                * ABIReturnSubroutine: the encoded output is concatenated to the return method selector and then logged
            * subroutine output is converted (cf "output conversion" below) (Subroutine case only)
        * input conversion:
            * Empty input array:
                do not read any args and call subroutine immediately
            * Expr arg of TealType.bytes and TealType.anytype:
                read arg and pass to subroutine as is
            * Expr arg of TealType.uint64:
                convert arg to int using Btoi() when received
            * pass-by-ref ScratchVar arguments:
                in addition to the above -
                    o store the arg (or converted arg) in a ScratchVar
                    o invoke the subroutine using this ScratchVar instead of the arg (or converted arg)
            * ABI arguments:
                in addition to the above -
                    o store the decoded arg into the ScratchVar of an ABI Type instance
                    o invoke the subroutine using this ABI Type instead of the arg
        * output conversion:
            * Subroutine case:
                * TealType.uint64:
                    provide subroutine's result to the top of the stack when exiting program
                * TealType.bytes:
                    convert subroutine's result to the top of the stack to its length and then exit
                * TealType.none or TealType.anytype:
                    push Int(1337) to the stack as it is either impossible (TealType.none),
                    or unknown at compile time (TealType.anytype) to convert to an Int
            * ABIReturnSubroutine case:
                * when present, the output is encoded as TealType.bytes which can be decoded by the receiver using
                appropriate ABI-libraries
        * logging conversion:
            * Subroutine case:
                * TealType.uint64:
                    convert subroutine's output using Itob() and log the result
                * TealType.bytes:
                    log the subroutine's result
                * TealType.none or TealType.anytype:
                    log Itob(Int(1337)) as it is either impossible (TealType.none),
                    or unknown at compile time (TealType.anytype) how to convert to Bytes
            * ABIReturnSubroutine case:
                * when present, the output is encoded as TealType.bytes and concatenated to the rewturn
                method selector. This can be decoded by the receiver using appropriate ABI-libraries

        For illustrative examples of how to use this method please refer to the integration test file `graviton_test.py` and especially:

        * `blackbox_pyteal_example1()`: Using blackbox_pyteal() for a simple test of both an app and logic sig
        * `blackbox_pyteal_example2()`: Using blackbox_pyteal() to make 400 assertions and generate a CSV report with 400 dryrun rows
        * `blackbox_pyteal_example3()`: declarative Test Driven Development approach through Invariant's
        * `blackbox_pyteal_example4()`: Using PyTealDryRunExecutor to debug an ABIReturnSubroutine with an app, logic sig and csv reports
        """

        return self._pyteal_lambda()

    def _arg_prep_n_call(self, i, p):
        subdef = self.subr.subroutine.subroutine
        arg_names = subdef.arguments()
        name = arg_names[i]
        arg_expr = Txn.application_args[i] if self.mode == Mode.Application else Arg(i)
        if p == TealType.uint64:
            arg_expr = Btoi(arg_expr)

        if name in subdef.by_ref_args:
            arg_var = ScratchVar(p)
            prep = arg_var.store(arg_expr)
        elif name in subdef.abi_args:
            arg_var = p.new_instance()
            prep = arg_var.decode(arg_expr)
        else:
            arg_var = arg_expr
            prep = None
        return prep, arg_var

    def _prepare_n_calls(self):
        preps_n_calls = [
            *(self._arg_prep_n_call(i, p) for i, p in enumerate(self.input_types))
        ]
        preps, calls = zip(*preps_n_calls) if preps_n_calls else ([], [])
        preps = [p for p in preps if p]
        return preps, calls

    def _handle_SubroutineFnWrapper(self):
        subdef = self.subr.subroutine.subroutine

        def subr_caller():
            preps, calls = self._prepare_n_calls()
            invocation = self.subr(*calls)
            if preps:
                return Seq(*(preps + [invocation]))
            return invocation

        def make_return(e):
            if e.type_of() == TealType.uint64:
                return e
            if e.type_of() == TealType.bytes:
                return Len(e)
            if e.type_of() == TealType.anytype:
                x = ScratchVar(TealType.anytype)
                return Seq(x.store(e), Int(1337))
            # TealType.none:
            return Seq(e, Int(1337))

        def make_log(e):
            if e.type_of() == TealType.uint64:
                return Log(Itob(e))
            if e.type_of() == TealType.bytes:
                return Log(e)
            return Log(Bytes("nada"))

        if self.mode == Mode.Signature:

            def approval():
                return make_return(subr_caller())

        else:

            def approval():
                if subdef.return_type == TealType.none:
                    result = ScratchVar(TealType.uint64)
                    part1 = [subr_caller(), result.store(Int(1337))]
                else:
                    result = ScratchVar(subdef.return_type)
                    part1 = [result.store(subr_caller())]

                part2 = [make_log(result.load()), make_return(result.load())]
                return Seq(*(part1 + part2))

        return approval

    def _handle_ABIReturnSubroutine(self):
        output = None
        if self.subr.subroutine.output_kwarg_info:
            output = self.subr.subroutine.output_kwarg_info.abi_type.new_instance()

        def approval():
            preps, calls = self._prepare_n_calls()

            # when @ABIReturnSubroutine is void:
            #   invocation is an Expr of TealType.none
            # otherwise:
            #   it is a ComputedValue
            invocation = self.subr(*calls)
            if output:
                invocation = output.set(invocation)
                if self.mode == Mode.Signature:
                    results = [invocation, Pop(output.encode()), Int(1)]
                else:
                    results = [invocation, abi.MethodReturn(output), Int(1)]
            else:
                results = [invocation, Int(1)]

            return Seq(*(preps + results))

        return approval

    def compile(self, version: int, assemble_constants: bool = False) -> str:
        return compileTeal(
            self.program(),
            self.mode,
            version=version,
            assembleConstants=assemble_constants,
        )

    def executor(self, compiler_version: int = 6) -> DryRunExecutor:
        return DryRunExecutor(
            algod=algod_with_assertion(),
            mode=mode_to_execution_mode(self.mode),
            teal=self.compile(compiler_version),
            abi_method_signature=self.abi_method_signature(),
            omit_method_selector=True,
        )

    def dryrun_sequence(
        self,
        inputs: list[Sequence[PyTypes]],
        *,
        compiler_version=6,
        txn_params: TxParams | None = None,
        verbose: bool = False,
    ) -> list[DryRunInspector]:
        return cast(
            list,
            self.executor(compiler_version).run_sequence(
                inputs, txn_params=txn_params, verbose=verbose
            ),
        )

    def dryrun_one(
        self,
        args: Sequence[bytes | str | int],
        *,
        compiler_version=6,
        txn_params: TxParams | None = None,
        verbose: bool = False,
    ) -> DryRunInspector:
        return self.executor(compiler_version).run_one(
            args, txn_params=txn_params, verbose=verbose
        )


def as_on_complete(oc_str: str) -> OnComplete:
    match oc_str:
        case "no_op":
            return OnComplete.NoOpOC
        case "opt_in":
            return OnComplete.OptInOC
        case "close_out":
            return OnComplete.CloseOutOC
        case "clear_state":
            return OnComplete.ClearStateOC
        case "update_application":
            return OnComplete.UpdateApplicationOC
        case "delete_application":
            return OnComplete.DeleteApplicationOC

    raise ValueError(f"unrecognized {oc_str=}")


def negate_cc(cc: CallConfig) -> CallConfig:
    return CallConfig(3 - cc)


@dataclass(frozen=True)
class RouterSimulationResults:
    stats: dict[str, Any]
    results: dict
    approval_simulator: Simulation | None
    clear_simulator: Simulation | None


class RouterSimulation:
    """
    Lifecycle of a RouterSimulation

    1. Creation (__init__ method):
        * router: Router (no version or other options specified)
        * predicates: CallPredicates - the Router ought satisfy. Type has shape:
            * method --> <property -> predicate ...> ...
        * model_router: Router (optional) - in the case when the predicates provided
            are of type PredicateKind.IdenticalPair, this parameter needs to be
            provided for comparison.
            NOTE: model_router may in fact be the same as router, and in this case
            it is expected that something else such as version or optimization option
            would differ between model_router and router during the simulation
        * algod (optional) - if missing, just get one

    Artifacts from Step 1 are stored in self.results: _SimConfig

    2. Simulation (simulate_and_assert method): - using self.results artifacts Step 1, also takes params:
        * approval_arg_strat_type: Type[ABICallStrategy]
            - strategy type to use for approval program's arg generation
        * clear_arg_strat_type_or_inputs: Type[ABICallStrategy] | Iterable[Sequence[PyTypes]] | None
            - strategy type to use for clear program's arg generation
        * approval_abi_args_mod: ABIArgsMod (default None)
            - used to specify any arg mutation
        # TODO: currently there aren't any clear_abi_args_mod, but we might need these for testing non-trivial clear programs
        * version: int - for compiling self.router
        * method_configs: ABICallConfigs - these drive all the test cases
        * assemble_constants: bool (optional) - for compiling self.router
        * optimize: OptimizeOptions (optional) - for compiling self.router
        * num_dryruns: int (default 1)
            - the number of input runs to generate per method X config combination
        * txn_params: TxParams (optional)
            - other TxParams to append in addition to the (is_app_create, OnComplete) information
        * model_version: int - for compiling self.model_router
        * model_assemble_constants: bool (optional) - for compiling self.model_router
        * model_optimize: OptimizeOptions (optional) - for compiling self.model_router
        * msg: string (optional) - message to report when an assertion is violated
        * omit_approval_call: bool (default False) - allow purely testing the clear program
        * omit_clear_call: bool (default False) - allow purely testing the approval program
        NOTE: one of omit_approval_call or omit_clear_call must remain False
        * executor_validation (default True) - when False, skip the DryRunExecutor's validation
        * skip_validation (default False) - when False, skip the Router's validation
    """

    def __init__(
        self,
        router: Router,
        predicates: CallPredicates,
        *,
        model_router: Router | None = None,
        algod: v2client.algod.AlgodClient | None = None,
    ):
        self.router: Router = self._validate_router(router)

        self.predicates: CallPredicates = self._validate_predicates(predicates)

        self.model_router: Router | None = None
        if model_router:
            self.model_router = self._validate_router(model_router, kind="Model")

        self.algod: v2client.algod.AlgodClient = algod or algod_with_assertion()

        self.results: dict[
            str | None, dict[tuple[bool, OnComplete], SimulationResults]
        ] = {}

    # ---- Validation ---- #

    @classmethod
    def _validate_router(cls, router: Router, kind: str = "Base") -> Router:
        assert isinstance(
            router, Router
        ), f"Wrong type for {kind} Router: {type(router)}"
        cls._validate_method_configs(router.method_configs)

        return router

    @classmethod
    def _validate_method_configs(cls, method_configs):
        assert isinstance(
            method_configs, dict
        ), f"method_configs '{method_configs}' has type {type(method_configs)} but only 'dict' and 'NoneType' are allowed."

        assert (
            method_configs
        ), "make sure to give at least one key/value pair in method_configs"

        for call, meth_config in method_configs.items():
            assert isinstance(  # type: ignore
                call, CallType
            ), f"method_configs dict key '{call}' has type {type(call)} but only str and NoneType are allowed."
            cls._validate_single_method_config(call, meth_config)

    @classmethod
    def _validate_single_method_config(cls, call, meth_config):
        assert isinstance(
            meth_config, MethodConfig
        ), f"method_configs['{call}'] = has type {type(meth_config)} but only MethodConfig is allowed."
        assert (
            not meth_config.is_never()
        ), f"method_configs['{call}'] specifies NEVER to be called; for driving the test, each configured method should ACTUALLY be tested."
        assert (
            meth_config.clear_state is CallConfig.NEVER
        ), "unexpected value for method_config's clear_state"

    @classmethod
    def _validate_predicates(cls, predicates):
        assert isinstance(predicates, dict), (
            f"Wrong type for predicates: {type(predicates)}. Please provide: "
            f"dict[str | None, dict[graviton.DryRunProporty, Any]."
        )

        assert (
            len(predicates) > 0
        ), "Please provide at least one method to call and assert against."

        for method, preds in predicates.items():
            assert isinstance(method, (str, type(None), type(ClearStateCallType))), (
                f"Predicates method '{method}' has type {type(method)} but only "
                "'str' and 'NoneType' and Literal['ClearStateCall'] (== ClearStateCall)"
                " are allowed."
            )
            if isinstance(method, type(ClearStateCallType)):
                assert method == ClearStateCallType, (
                    f"Predicates method '{method}' is not allowed. "
                    "Only Literal['ClearStateCall'] (== ClearStateCall) "
                    "is allowed for a Literal."
                )
            assert (
                preds
            ), f"Every method must provide at least one predicate for assertion but method '{method}' is missing predicates."
            assert isinstance(
                preds, dict
            ), f"Method '{method}' is expected to have dict[graviton.DryRunProperty, Any] for its predicates value but the type is {type(preds)}."
            for prop in preds:
                assert isinstance(
                    prop, DRProp
                ), f"Method '{method}' is expected to have dict[graviton.DryRunProperty, Any] for its predicates value but predicates['{method}'] has key '{prop}' of {type(prop)}."

        return predicates

    def _validate_simulation(
        self,
        approval_args_strat_type,
        clear_args_strat_type,
        approval_abi_args_mod,
        num_dryruns,
        txn_params,
        model_version,
        method_configs,
        contract,
        model_contract,
        omit_clear_call,
    ):
        assert isinstance(approval_args_strat_type, type) and issubclass(
            approval_args_strat_type, ABIStrategy
        ), f"approval_args_strat_type should _BE_ a subtype of ABIStrategy but we have {approval_args_strat_type} (its type is {type(approval_args_strat_type)})."
        if not omit_clear_call:
            assert isinstance(clear_args_strat_type, type) and issubclass(
                clear_args_strat_type, ABIStrategy
            ), f"clear_args_strat_type should _BE_ a subtype of ABIStrategy but we have {clear_args_strat_type} (its type is {type(clear_args_strat_type)})."

        assert isinstance(
            approval_abi_args_mod, (ABIArgsMod, type(None))
        ), f"approval_abi_args_mod '{approval_abi_args_mod}' has type {type(approval_abi_args_mod)} but only 'ABIArgsMod' and 'NoneType' are allowed."

        self._validate_method_configs(method_configs)

        self._validate_meths_in_contract(method_configs, contract)

        if model_contract:
            self._validate_meths_in_contract(
                method_configs, model_contract, router_prefix="model"
            )

        assert (
            isinstance(num_dryruns, int) and num_dryruns >= 1
        ), f"num_dryruns must be a positive int but is {num_dryruns}."

        assert isinstance(
            txn_params, (TxParams, type(None))
        ), f"txn_params must have type DryRunTransactionParams or NoneType but has type {type(txn_params)}."

        if not self.model_router:
            assert (
                model_version is None
            ), f"model_version '{model_version}' was provided which is nonsensical because model_router was never provided for."

    def _validate_meths_in_contract(
        self, method_configs, contract, router_prefix="base"
    ):
        for meth in method_configs:
            if meth is None:
                continue
            try:
                contract.get_method_by_name(meth)
            except KeyError:
                raise ValueError(
                    f"method_configs has a method '{meth}' missing from {router_prefix}-Router's contract."
                )

    def simulate_and_assert(
        self,
        approval_args_strat_type: Type[ABIStrategy],
        clear_args_strat_type_or_inputs: (
            Type[ABIStrategy] | list[Sequence[PyTypes]] | None
        ),
        approval_abi_args_mod: ABIArgsMod | None,
        version: int,
        method_configs: ABICallConfigs,
        *,
        assemble_constants: bool = False,
        optimize: OptimizeOptions | None = None,
        num_dryruns: int = 1,
        txn_params: TxParams | None = None,
        model_version: int | None = None,
        model_assemble_constants: bool = False,
        model_optimize: OptimizeOptions | None = None,
        msg: str = "",
        omit_approval_call: bool = False,
        omit_clear_call: bool = False,
        executor_validation: bool = True,
        skip_validation: bool = False,
    ) -> RouterSimulationResults:
        assert not (
            omit_approval_call and omit_clear_call
        ), "Aborting and failing as all tests are being omitted"

        # --- setup local functions including reporter and stats. Also declare closure vars --- #

        # for purposes of clarity, declare all the variables for closures before each function:
        approve_sim: Simulation | None  # required for return RouterResults

        # msg4simulate:

        # msg - cf. parameters
        approval_strat: ABICallStrategy | None
        meth_name: str | None  # simulate_approval's closure as well
        call_cfg: CallConfig | None
        is_app_create: bool
        stats: dict[str, int | str] = defaultdict(int)

        def msg4simulate() -> str:
            return f"""user provide message={msg}
call_strat={type(approval_strat)}
{meth_name=}
{oc=}
{call_cfg=}
{is_app_create=}
{len(self.predicates[meth_name])=}
{stats["method_combo_count"]=}
{stats["dryrun_count"]=}
{stats["assertions_count"]=}
"""

        # update_stats:
        # num_dryruns - cf. parameters
        # stats - cf. above
        def update_stats(meth, num_preds):
            stats[str(meth)] += num_dryruns
            stats["method_combo_count"] += 1
            stats["dryrun_count"] += num_dryruns
            stats["assertions_count"] += num_dryruns * num_preds

        # simulate_approval:
        # txn_params - cf. parameters
        oc: OnComplete
        # approval_strat - cf. above

        def simulate_approval(on_create):
            tp: TxParams = deepcopy(txn_params)
            tp.update_fields(TxParams.for_app(is_app_create=on_create, on_complete=oc))
            sim_results = approve_sim.run_and_assert(
                approval_strat, txn_params=tp, msg=msg4simulate()
            )
            assert sim_results.succeeded
            if meth_name not in self.results:
                self.results[meth_name] = {}
            self.results[meth_name][(on_create, oc)] = sim_results
            update_stats(meth_name, len(self.predicates[meth_name]))

        # --- Compile Programs --- #
        approval_teal, clear_teal, contract = self.router.compile_program(
            version=version, assemble_constants=assemble_constants, optimize=optimize
        )

        model_approval_teal: str | None = None
        model_clear_teal: str | None = None
        model_contract: sdk_abi.Contract | None = None
        if self.model_router:
            (
                model_approval_teal,
                model_clear_teal,
                model_contract,
            ) = self.model_router.compile_program(
                version=cast(int, model_version),
                assemble_constants=model_assemble_constants,
                optimize=model_optimize,
            )

        if not skip_validation:
            self._validate_simulation(
                approval_args_strat_type,
                clear_args_strat_type_or_inputs,
                approval_abi_args_mod,
                num_dryruns,
                txn_params,
                model_version,
                method_configs,
                contract,
                model_contract,
                omit_clear_call,
            )

        if not txn_params:
            txn_params = TxParams()

        stats["name"] = self.router.name

        # ---- APPROVAL PROGRAM SIMULATION ---- #
        if not omit_approval_call:
            approval_strat = ABICallStrategy(
                json.dumps(contract.dictify()),
                approval_args_strat_type,
                num_dryruns=num_dryruns,
                abi_args_mod=approval_abi_args_mod,
            )
            double_check_at_least_one_method = False
            for meth_name, meth_cfg in method_configs.items():
                sig = approval_strat.method_signature(meth_name)
                approve_sim = Simulation(
                    self.algod,
                    ExecutionMode.Application,
                    approval_teal,
                    self.predicates[meth_name],
                    abi_method_signature=sig,
                    identities_teal=model_approval_teal,
                    validation=executor_validation,
                )

                for oc_str, call_cfg in asdict(meth_cfg).items():
                    oc = as_on_complete(oc_str)

                    # weird walrus is_app_create := ... to fill closure of msg4simulate()
                    if cast(CallConfig, call_cfg) & CallConfig.CALL:
                        double_check_at_least_one_method = True
                        simulate_approval(is_app_create := False)

                    if cast(CallConfig, call_cfg) & CallConfig.CREATE:
                        double_check_at_least_one_method = True
                        simulate_approval(is_app_create := True)
            assert double_check_at_least_one_method, "no method was simulated"

        # ---- CLEAR PROGRAM SIMULATION ---- #
        approval_strat = None
        call_cfg = None
        approve_sim = None
        clear_strat_or_inputs: (
            InputStrategy  # CallStrategy | Iterable[Sequence[PyTypes]]
        )
        clear_sim: Simulation | None = None
        if not omit_clear_call:
            assert clear_args_strat_type_or_inputs  # therefore Type[ABIStrategy] | list[Sequence[PyTypes]]
            if isinstance(clear_args_strat_type_or_inputs, list):
                clear_strat_or_inputs = cast(
                    list[Sequence[PyTypes]], clear_args_strat_type_or_inputs
                )
                # for the closure of local update_stats():
                num_dryruns = len(clear_strat_or_inputs)
            else:
                clear_strat_or_inputs = RandomArgLengthCallStrategy(
                    cast(Type[ABIStrategy], clear_args_strat_type_or_inputs),
                    max_args=2,
                    num_dryruns=num_dryruns,
                    min_args=0,
                    type_for_args=sdk_abi.ABIType.from_string("byte[8]"),
                )

            meth_name = CLEAR_STATE_CALL
            is_app_create = False
            oc = OnComplete.ClearStateOC
            clear_sim = Simulation(
                self.algod,
                ExecutionMode.Application,
                clear_teal,
                self.predicates[meth_name],
                identities_teal=model_clear_teal,
                validation=executor_validation,
            )

            sim_results = clear_sim.run_and_assert(
                clear_strat_or_inputs, msg=msg4simulate()
            )
            assert sim_results.succeeded
            if meth_name not in self.results:
                self.results[meth_name] = {}
            self.results[meth_name][(is_app_create, oc)] = sim_results
            update_stats(meth_name, len(self.predicates[meth_name]))

        # ---- Summary Statistics ---- #
        return RouterSimulationResults(
            stats=stats,
            results=self.results,
            approval_simulator=approve_sim,
            clear_simulator=clear_sim,
        )



================================================
FILE: tests/compile_asserts.py
================================================
from pathlib import Path
from difflib import unified_diff

from pyteal.compiler import compileTeal
from pyteal.ir import Mode

PATH = Path.cwd() / "tests" / "unit"
FIXTURES = PATH / "teal"
GENERATED = PATH / "generated"


def compile_and_save(approval, version: int, test_name: str) -> tuple[Path, str, str]:
    compiled = compileTeal(approval(), mode=Mode.Application, version=version)
    name = approval.__name__
    tealdir = GENERATED / test_name
    tealdir.mkdir(parents=True, exist_ok=True)
    with open(tealdir / (name + ".teal"), "w") as f:
        f.write(compiled)
    print(
        f"""Successfuly tested approval program <<{name}>> having
compiled it into {len(compiled)} characters. See the results in:
{tealdir}
"""
    )
    return tealdir, name, compiled


def assert_teal_as_expected(path2actual: Path, path2expected: Path):
    with open(path2actual, "r") as f:
        actual_lines = f.readlines()

    with open(path2expected, "r") as f:
        expected_lines = f.readlines()

    diff = list(
        unified_diff(
            expected_lines,
            actual_lines,
            fromfile=str(path2expected),
            tofile=str(path2actual),
            n=3,
        )
    )

    assert (
        len(diff) == 0
    ), f"Difference between expected and actual TEAL code:\n\n{''.join(diff)}"


def assert_new_v_old(approve_func, version: int, test_name: str):
    tealdir, name, compiled = compile_and_save(approve_func, version, test_name)

    print(
        f"""Compilation resulted in TEAL program of length {len(compiled)}.
To view output SEE <{name}.teal> in ({tealdir})
--------------"""
    )

    path2actual = tealdir / (name + ".teal")
    path2expected = FIXTURES / test_name / (name + ".teal")
    assert_teal_as_expected(path2actual, path2expected)



================================================
FILE: tests/mock_version.py
================================================
import pytest
from importlib import metadata


@pytest.fixture
def mock_version(version: str, monkeypatch: pytest.MonkeyPatch):
    def mocked_version(name: str):
        if (
            name == "pyteal"
            and version is not None  # don't mock if no version is specified
        ):
            return version
        else:
            return metadata.version(name)

    monkeypatch.setattr(metadata, "version", mocked_version)



================================================
FILE: tests/integration/__init__.py
================================================
[Empty file]


================================================
FILE: tests/integration/abi_roundtrip_test.py
================================================
from inspect import isclass
from pathlib import Path
import pytest
from typing import Literal

import algosdk.abi

from graviton.abi_strategy import RandomABIStrategy

from pyteal import abi

from tests.abi_roundtrip import ABIRoundtrip
from tests.compile_asserts import assert_teal_as_expected

GAI_ISSUE_2050 = "https://github.com/algorand/go-algorand-internal/issues/2050"
BAD_TEALS = {
    "()": GAI_ISSUE_2050,
}


GAI_ISSUE_2068 = "https://github.com/algorand/go-algorand-internal/issues/2068"
BAD_TYPES = {
    # Reference Types
    "account": GAI_ISSUE_2068,
    "asset": GAI_ISSUE_2068,
    "application": GAI_ISSUE_2068,
    # Transaction Types
    "txn": GAI_ISSUE_2068,
    "pay": GAI_ISSUE_2068,
    "keyreg": GAI_ISSUE_2068,
    "acfg": GAI_ISSUE_2068,
    "afrz": GAI_ISSUE_2068,
    "axfer": GAI_ISSUE_2068,
    "appl": GAI_ISSUE_2068,
}


class NamedTupleInherit(abi.NamedTuple):
    a: abi.Field[abi.Bool]
    b: abi.Field[abi.Address]
    c: abi.Field[abi.Tuple2[abi.Uint64, abi.Bool]]
    d: abi.Field[abi.StaticArray[abi.Byte, Literal[10]]]
    e: abi.Field[abi.StaticArray[abi.Bool, Literal[4]]]
    f: abi.Field[abi.Uint64]


PATH = Path.cwd() / "tests" / "integration"
FIXTURES = PATH / "teal"
GENERATED = PATH / "generated"
ABI_TYPES = [
    abi.Address,
    abi.Bool,
    abi.Byte,
    (abi.String, 0),
    (abi.String, 1),
    (abi.String, 13),
    abi.Uint8,
    abi.Uint16,
    abi.Uint32,
    abi.Uint64,
    abi.Account,
    abi.Asset,
    abi.Application,
    abi.Transaction,
    abi.PaymentTransaction,
    abi.KeyRegisterTransaction,
    abi.AssetConfigTransaction,
    abi.AssetFreezeTransaction,
    abi.AssetTransferTransaction,
    abi.ApplicationCallTransaction,
    abi.Tuple0,
    abi.Tuple1[abi.Bool],
    abi.Tuple1[abi.Byte],
    abi.Tuple1[abi.Uint8],
    abi.Tuple1[abi.Uint16],
    abi.Tuple1[abi.Uint32],
    abi.Tuple1[abi.Uint64],
    abi.Tuple2[abi.Bool, abi.Byte],
    abi.Tuple2[abi.DynamicBytes, abi.StaticBytes[Literal[3]]],
    abi.Tuple3[abi.Bool, abi.Uint64, abi.Uint32],
    abi.Tuple3[abi.Byte, abi.Bool, abi.Uint64],
    abi.Tuple3[abi.Uint8, abi.Byte, abi.Bool],
    abi.Tuple3[abi.Uint16, abi.Uint8, abi.Byte],
    abi.Tuple3[abi.Uint32, abi.Uint16, abi.Uint8],
    abi.Tuple3[abi.Uint64, abi.Uint32, abi.Uint16],
    abi.Tuple4[abi.Bool, abi.Byte, abi.Address, abi.String],
    abi.Tuple5[abi.Bool, abi.Byte, abi.Address, abi.String, abi.Uint64],
    abi.StaticArray[abi.Bool, Literal[1]],
    abi.StaticArray[abi.Bool, Literal[42]],
    abi.StaticArray[abi.Uint64, Literal[1]],
    abi.StaticArray[abi.Uint64, Literal[42]],
    abi.StaticBytes[Literal[16]],
    (abi.DynamicArray[abi.Bool], 0),
    (abi.DynamicArray[abi.Bool], 1),
    (abi.DynamicArray[abi.Bool], 42),
    (abi.DynamicArray[abi.Uint64], 0),
    (abi.DynamicArray[abi.Uint64], 1),
    (abi.DynamicArray[abi.Uint64], 42),
    (abi.DynamicArray[abi.Address], 10),
    (abi.DynamicBytes, 36),
    (abi.DynamicArray[abi.StaticArray[abi.Bool, Literal[3]]], 11),
    abi.StaticArray[abi.Tuple1[abi.Bool], Literal[10]],
    (
        abi.DynamicArray[
            abi.Tuple4[
                abi.StaticArray[abi.Byte, Literal[4]],
                abi.Tuple2[abi.Bool, abi.Bool],
                abi.Uint64,
                abi.Address,
            ]
        ],
        7,
    ),
    (
        abi.DynamicArray[
            abi.Tuple5[
                abi.Bool,
                abi.Byte,
                abi.Address,
                abi.String,
                abi.Tuple4[
                    abi.Address,
                    abi.StaticArray[
                        abi.Tuple5[
                            abi.Uint32,
                            abi.DynamicArray[abi.String],
                            abi.StaticArray[abi.Bool, Literal[2]],
                            abi.Tuple1[abi.Byte],
                            abi.Uint8,
                        ],
                        Literal[2],
                    ],
                    abi.String,
                    abi.DynamicArray[abi.Bool],
                ],
            ]
        ],
        2,
    ),
    abi.Tuple1[
        abi.Tuple3[
            abi.Uint64,
            abi.DynamicBytes,
            abi.StaticArray[abi.Uint64, Literal[1]],
        ],
    ],
    NamedTupleInherit,
]


def roundtrip_setup(abi_type):
    dynamic_length = None
    if isinstance(abi_type, tuple):
        abi_type, dynamic_length = abi_type

    abi_type_str = str(abi.type_spec_from_annotation(abi_type))
    roundtrip_or_none = None
    if abi_type_str not in BAD_TYPES:
        roundtrip_or_none = ABIRoundtrip(
            abi.make(abi_type), length=dynamic_length
        ).pytealer()

    return abi_type, abi_type_str, dynamic_length, roundtrip_or_none


def test_abi_types_comprehensive():
    top_level_names = set()
    for at in ABI_TYPES:
        at = at[0] if isinstance(at, tuple) else at
        tli: str

        tli = (
            str(abi.NamedTuple)
            if isclass(at) and issubclass(at, abi.NamedTuple)
            else str(at)
        )
        tli = tli.split("[")[0] if tli.startswith("pyteal") else tli.split("'")[1]

        top_level_names.add(tli)

    def get_subclasses(cls):
        for subclass in cls.__subclasses__():
            yield from get_subclasses(subclass)
            yield subclass

    all_abi_names = {
        str(at).split("'")[1]
        for at in (
            cls
            for cls in abi.__dict__.values()
            if isinstance(cls, type)
            and issubclass(cls, abi.BaseType)
            and not cls.__abstractmethods__
            and cls is not abi.Tuple
        )
    }

    missing_cases = all_abi_names - top_level_names
    assert not missing_cases, f"missing round trip tests for {missing_cases}"


@pytest.mark.parametrize("abi_type", ABI_TYPES)
def test_pure_compilation(abi_type):
    print(f"Pure Compilation Test for {abi_type=}")
    abi_type, type_str, dynamic_length, roundtripper = roundtrip_setup(abi_type)

    if type_str in BAD_TYPES:
        print(
            f"Skipping encoding roundtrip test of '{abi_type}' because of {BAD_TYPES[type_str]}"
        )
        return

    sdk_abi_type = abi.algosdk_from_annotation(abi_type)

    abi_arg_types = roundtripper.abi_argument_types()
    abi_ret_type = roundtripper.abi_return_type()
    assert [sdk_abi_type] == abi_arg_types
    assert algosdk.abi.TupleType([sdk_abi_type] * 3) == abi_ret_type

    def compile_and_compare(version: int):
        teal = roundtripper.compile(version)

        filename = (
            f"app_roundtrip_{sdk_abi_type}"
            + ("" if dynamic_length is None else f"_{dynamic_length}")
            + f"_v{version}.teal"
        )
        tealdir = GENERATED / "roundtrip"
        tealdir.mkdir(parents=True, exist_ok=True)

        save_to = tealdir / filename
        with open(save_to, "w") as f:
            f.write(teal)

        assert_teal_as_expected(save_to, FIXTURES / "roundtrip" / filename)

    compile_and_compare(6)
    compile_and_compare(8)


@pytest.mark.parametrize("abi_type", ABI_TYPES)
def test_roundtrip(abi_type):
    print(f"Round Trip Test for {abi_type=}")

    _, type_str, dynamic_length, roundtripper = roundtrip_setup(abi_type)

    if type_str in BAD_TYPES:
        print(
            f"Skipping encoding roundtrip test of '{abi_type}' because of {BAD_TYPES[type_str]}"
        )
        return

    sdk_abi_types = roundtripper.abi_argument_types()
    sdk_ret_type = roundtripper.abi_return_type()

    sdk_abi_str = str(sdk_abi_types[0])
    if sdk_abi_str in BAD_TEALS:
        print(
            f"Skipping encoding roundtrip test of '{sdk_abi_str}' because of {BAD_TEALS[sdk_abi_str]}"
        )
        return

    abi_strat = RandomABIStrategy(sdk_abi_types[0], dynamic_length=dynamic_length)
    rand_abi_instance = abi_strat.get()
    args = (rand_abi_instance,)

    def dryrun_roundtrip(version: int):
        inspector = roundtripper.dryrun_one(args, compiler_version=version)

        cost = inspector.cost()
        passed = inspector.passed()
        original, mut, mut_mut = inspector.last_log()

        print(
            f"""
version={version}
{abi_type=}
{sdk_abi_str=}
{dynamic_length=}
{sdk_abi_types=}
{sdk_ret_type=}
{rand_abi_instance=}
{cost=}
{original=}
{mut=}
{mut_mut=}
"""
        )

        last_steps = 2

        assert passed == (cost <= 700), inspector.report(
            args, f"passed={passed} contradicted cost={cost}", last_steps=last_steps
        )
        assert rand_abi_instance == original, inspector.report(
            args, "rand_abi_instance v. original", last_steps=last_steps
        )
        assert original == mut_mut, inspector.report(
            args, "orginal v. mut_mut", last_steps=last_steps
        )

        expected_mut = abi_strat.mutate_for_roundtrip(rand_abi_instance)
        assert expected_mut == mut, inspector.report(
            args, "expected_mut v. mut", last_steps=last_steps
        )

    dryrun_roundtrip(6)
    dryrun_roundtrip(8)



================================================
FILE: tests/integration/abi_router_test.py
================================================
import json
import re
from collections import defaultdict
from dataclasses import asdict
from pathlib import Path

import pytest
from graviton.abi_strategy import (
    ABIArgsMod,
    RandomABIStrategy,
    RandomABIStrategyHalfSized,
)
from graviton.blackbox import DryRunEncoder
from graviton.invariant import DryRunProperty as DRProp
from graviton.invariant import PredicateKind

import pyteal as pt
from pyteal.compiler.compiler_test import router_app_tester
from tests.blackbox import (
    CLEAR_STATE_CALL,
    ABICallConfigs,
    Predicates,
    RouterCallType,
    RouterSimulation,
    negate_cc,
)

NUM_ROUTER_DRYRUNS = 7
FIXTURES = Path.cwd() / "tests" / "teal" / "router"


ALL_ROUTER_CASES, ROUTER_SOURCES = router_app_tester()

ROUTER_CASES, NONTRIV_CLEAR_ROUTER_CASES = ALL_ROUTER_CASES[:-2], ALL_ROUTER_CASES[-2:]

TYPICAL_IAC_OC = pt.MethodConfig(no_op=pt.CallConfig.CALL)

# TEST DRIVERS LEGEND - combines method_configs + predicates
# * @0 - method: RouterCallType
#   method == None indicates bare app call
#   method == CLEAR_STATE_CALL indicates clear state app call
#
# * @1 - method_config: MethodConfig
#   defines how to call the method
#
# * @2 - predicates: Predicates ~ dict[DRProp, Any]
#   these are being asserted after being processed into Invariant's
#
# NOTE: the "yacc" routers will simply ignore the case with method `None`
# as they do not have any bare-app-calls
QUESTIONABLE_DRIVER: list[tuple[RouterCallType, pt.MethodConfig, Predicates]] = [
    (
        "add",
        TYPICAL_IAC_OC,
        {DRProp.passed: True, DRProp.lastLog: lambda args: args[1] + args[2]},
    ),
    (
        "sub",
        TYPICAL_IAC_OC,
        {
            DRProp.passed: lambda args: args[1] >= args[2],
            DRProp.lastLog: (
                lambda args, actual: (
                    True if args[1] < args[2] else actual == args[1] - args[2]
                )
            ),
        },
    ),
    (
        "mul",
        TYPICAL_IAC_OC,
        {DRProp.passed: True, DRProp.lastLog: lambda args: args[1] * args[2]},
    ),
    (
        "div",
        TYPICAL_IAC_OC,
        {DRProp.passed: True, DRProp.lastLog: lambda args: args[1] // args[2]},
    ),
    (
        "mod",
        TYPICAL_IAC_OC,
        {DRProp.passed: True, DRProp.lastLog: lambda args: args[1] % args[2]},
    ),
    (
        "all_laid_to_args",
        TYPICAL_IAC_OC,
        {DRProp.passed: True, DRProp.lastLog: lambda args: sum(args[1:])},
    ),
    (
        "empty_return_subroutine",
        pt.MethodConfig(
            no_op=pt.CallConfig.CALL,
            opt_in=pt.CallConfig.ALL,
        ),
        {
            DRProp.passed: True,
            DRProp.lastLog: DryRunEncoder.hex(
                "appear in both approval and clear state"
            ),
        },
    ),
    (
        "log_1",
        pt.MethodConfig(
            no_op=pt.CallConfig.CALL,
            opt_in=pt.CallConfig.CALL,
            # clear_state=pt.CallConfig.CALL,
        ),
        {DRProp.passed: True, DRProp.lastLog: 1},
    ),
    (
        "log_creation",
        pt.MethodConfig(no_op=pt.CallConfig.CREATE),
        {DRProp.passed: True, DRProp.lastLog: "logging creation"},
    ),
    (
        None,
        pt.MethodConfig(
            opt_in=pt.CallConfig.CALL,
        ),
        {
            DRProp.passed: True,
            DRProp.lastLog: lambda _, actual: actual
            in (None, DryRunEncoder.hex("optin call")),
        },
    ),
    (
        CLEAR_STATE_CALL,
        pt.MethodConfig(),  # ignored in this case
        {
            DRProp.passed: True,
            DRProp.cost: 2,
        },
    ),
]

YACC_DRIVER = [case for case in QUESTIONABLE_DRIVER if case[0]]

DRIVERS = {
    "questionable": QUESTIONABLE_DRIVER,
    "yacc": YACC_DRIVER,
    "nontriv_clear": QUESTIONABLE_DRIVER,
}


def split_driver2predicates_methconfigs(driver) -> tuple[Predicates, ABICallConfigs]:
    predicates = {}
    methconfigs = {}
    for meth, meth_config, predicate in driver:
        predicates[meth] = predicate
        if meth != CLEAR_STATE_CALL:
            methconfigs[meth] = meth_config

    return predicates, methconfigs


def assert_full_method_coverage(router, methconfigs):
    assert len(methconfigs) == len(rmc := router.method_configs)
    for meth_sig, meth_config in rmc.items():
        k = meth_sig
        if k:
            k = meth_sig.split("(")[0]
        assert k in methconfigs, f"{k=} (derived from {meth_sig=} not in methconfigs"
        assert meth_config == methconfigs[k]


@pytest.mark.parametrize("case, version, router", ROUTER_CASES)
def test_abi_router_positive(case, version, router):
    """
    Test the _positive_ version of a case. In other words, ensure that for each
    router encountered and its driver, iterate through the driver as follows:
        * consider each method or bare call
        * consider each (OnComplete, CallConfig) combination
        * assert that all predicates hold for this call
    """
    driver = DRIVERS[case]
    predicates, methconfigs = split_driver2predicates_methconfigs(driver)

    assert_full_method_coverage(router, methconfigs)

    rsim = RouterSimulation(router, predicates)

    def msg():
        return f"""test_abi_router_positive()
{case=}
{version=}
{router.name=}"""

    results = rsim.simulate_and_assert(
        approval_args_strat_type=RandomABIStrategyHalfSized,
        clear_args_strat_type_or_inputs=RandomABIStrategy,
        approval_abi_args_mod=None,
        version=version,
        method_configs=methconfigs,
        num_dryruns=NUM_ROUTER_DRYRUNS,
        msg=msg(),
    )
    # won't even get here if there was an error, but some extra sanity checks:
    assert (sim_results := results.results) and all(
        sim.succeeded for meth in sim_results.values() for sim in meth.values()
    )

    print("\nstats:", json.dumps(stats := results.stats, indent=2))
    assert stats and all(stats.values())

    # TODO: add these assertions after the flakiness of issue #199 is fixed for good
    # These fail because of differing scratch slot assignments:
    # pregen_approval, pregen_clear = ROUTER_SOURCES[(case, version)]
    # assert pregen_clear == results.clear_simulator.simulate_dre.program
    # assert pregen_approval == results.approval_simulator.simulate_dre.program


# cf. https://death.andgravity.com/f-re for an explanation of verbose regex'es
EXPECTED_ERR_PATTERN = r"""
    err\ opcode                                 # pyteal generated err's ok
|   assert\ failed\ pc=                         # pyteal generated assert's ok
|   invalid\ ApplicationArgs\ index             # failing because an app arg wasn't provided
|   extraction\ end\ 16\ is\ beyond\ length     # failing because couldn't extract when omitted final arg or jammed in tuple
"""


APPROVAL_NEGATIVE_PREDS = {
    DRProp.rejected: True,
    DRProp.error: True,
    DRProp.errorMessage: lambda _, actual: (
        bool(re.search(EXPECTED_ERR_PATTERN, actual, re.VERBOSE))
    ),
}

CLEAR_NEGATIVE_INVARIANTS_MUST_APPROVE = [
    inv for m, _, inv in QUESTIONABLE_DRIVER if m == CLEAR_STATE_CALL
][0]


def scenario_assert_stats(scenario, results, totals):
    part_a = f"""
SCENARIO: {scenario} 
"""
    if results:
        part_b = json.dumps(stats := results.stats, indent=2)
        assert stats and all(stats.values())
        for k, v in stats.items():
            if isinstance(v, int):
                totals[k] += v
    else:
        part_b = "SKIPPED"
    print(f"{part_a}stats:", part_b)


@pytest.mark.parametrize("case, version, router", ROUTER_CASES)
def test_abi_router_negative(case, version, router):
    totals = defaultdict(int)

    contract = router.contract_construct()

    driver = DRIVERS[case]
    pos_predicates, pos_mconfigs = split_driver2predicates_methconfigs(driver)

    # assert FULL coverage (before modifying the dict):
    assert_full_method_coverage(router, pos_mconfigs)

    if None not in pos_mconfigs:
        pos_mconfigs[None] = pt.MethodConfig()
        pos_predicates[None] = APPROVAL_NEGATIVE_PREDS

    pure_meth_mconfigs = {
        meth: methconfig
        for meth, methconfig in pos_mconfigs.items()
        if meth is not None
    }

    neg_predicates = {
        meth: (
            APPROVAL_NEGATIVE_PREDS
            if meth != CLEAR_STATE_CALL
            else CLEAR_NEGATIVE_INVARIANTS_MUST_APPROVE
        )
        for meth in pos_predicates
    }

    rsim = RouterSimulation(router, neg_predicates)

    def msg():
        return f"""test_abi_router_negative()
{scenario=}
{case=}
{version=}
{router.name=}"""

    scenario = "I. explore all UNEXPECTED (is_app_create, on_complete) combos"

    # NOTE: We're NOT including clear_state calls for the approval program
    # as they would never be applied.
    # Also, we're ONLY including clear_state for the clear program.
    neg_mconfigs = {
        meth: pt.MethodConfig(
            **{k: negate_cc(v) for k, v in asdict(mc).items() if k != "clear_state"}
        )
        for meth, mc in pos_mconfigs.items()
    }

    results = rsim.simulate_and_assert(
        approval_args_strat_type=RandomABIStrategyHalfSized,
        clear_args_strat_type_or_inputs=RandomABIStrategy,
        approval_abi_args_mod=None,
        version=version,
        method_configs=neg_mconfigs,
        num_dryruns=NUM_ROUTER_DRYRUNS,
        executor_validation=False,
        msg=msg(),
    )
    # won't even get here if there was an error, but some extra sanity checks:
    assert (sim_results := results.results) and all(
        sim.succeeded for meth in sim_results.values() for sim in meth.values()
    )
    scenario_assert_stats(scenario, results, totals)

    # II. the case of bare-app-calls
    scenario = "II. adding an argument to a bare app call"
    if None in pos_mconfigs and not pos_mconfigs[None].is_never():
        bare_only_methconfigs = {None: pos_mconfigs[None]}
        results = rsim.simulate_and_assert(
            approval_args_strat_type=RandomABIStrategyHalfSized,
            clear_args_strat_type_or_inputs=None,
            approval_abi_args_mod=ABIArgsMod.parameter_append,
            version=version,
            method_configs=bare_only_methconfigs,
            omit_clear_call=True,
            num_dryruns=NUM_ROUTER_DRYRUNS,
            executor_validation=False,
            msg=msg(),
        )
        assert (sim_results := results.results) and all(
            sim.succeeded for meth in sim_results.values() for sim in meth.values()
        )
        scenario_assert_stats(scenario, results, totals)
    else:
        scenario_assert_stats(scenario, None, totals)

    # For the rest, we may assume method calls (i.e. non bare-app calls)
    # III. explore changing method selector arg[0] by edit distance 1

    # NOTE: We don't test the case of adding an argument to method calls
    # because the SDK's will guard against this case.
    # However, we should re-think this assumption.
    # Cf. https://github.com/algorand/go-algorand-internal/issues/2772
    # Cf. https://github.com/algorand/algorand-sdk-testing/issues/190

    scenario = "III(a). inserting an extra random byte into method selector"
    results = rsim.simulate_and_assert(
        approval_args_strat_type=RandomABIStrategyHalfSized,
        clear_args_strat_type_or_inputs=None,
        approval_abi_args_mod=ABIArgsMod.selector_byte_insert,
        version=version,
        method_configs=pure_meth_mconfigs,
        omit_clear_call=True,
        num_dryruns=NUM_ROUTER_DRYRUNS,
        executor_validation=False,
        msg=msg(),
    )
    assert (sim_results := results.results) and all(
        sim.succeeded for meth in sim_results.values() for sim in meth.values()
    )
    scenario_assert_stats(scenario, results, totals)

    scenario = "III(b). removing a random byte from method selector"
    results = rsim.simulate_and_assert(
        approval_args_strat_type=RandomABIStrategyHalfSized,
        clear_args_strat_type_or_inputs=None,
        approval_abi_args_mod=ABIArgsMod.selector_byte_delete,
        version=version,
        method_configs=pure_meth_mconfigs,
        omit_clear_call=True,
        num_dryruns=NUM_ROUTER_DRYRUNS,
        executor_validation=False,
        msg=msg(),
    )
    assert (sim_results := results.results) and all(
        sim.succeeded for meth in sim_results.values() for sim in meth.values()
    )
    scenario_assert_stats(scenario, results, totals)

    scenario = "III(c). replacing a random byte in method selector"
    results = rsim.simulate_and_assert(
        approval_args_strat_type=RandomABIStrategyHalfSized,
        clear_args_strat_type_or_inputs=None,
        approval_abi_args_mod=ABIArgsMod.selector_byte_replace,
        version=version,
        method_configs=pure_meth_mconfigs,
        omit_clear_call=True,
        num_dryruns=NUM_ROUTER_DRYRUNS,
        executor_validation=False,
        msg=msg(),
    )
    assert (sim_results := results.results) and all(
        sim.succeeded for meth in sim_results.values() for sim in meth.values()
    )
    scenario_assert_stats(scenario, results, totals)

    # IV. explore changing the number of args over the 'good' call_types
    # NOTE: We don't test the case of adding an argument to method calls
    # We also remove methods with 0 arguments, as these degenerate to the
    # already tested bare-app call case.
    scenario = "IV. removing the final argument"
    atleast_one_param_mconfigs = {
        meth: mconfig
        for meth, mconfig in pure_meth_mconfigs.items()
        if len(contract.get_method_by_name(meth).args) > 0
    }
    results = rsim.simulate_and_assert(
        approval_args_strat_type=RandomABIStrategyHalfSized,
        clear_args_strat_type_or_inputs=None,
        approval_abi_args_mod=ABIArgsMod.parameter_delete,
        version=version,
        method_configs=atleast_one_param_mconfigs,
        omit_clear_call=True,
        num_dryruns=NUM_ROUTER_DRYRUNS,
        executor_validation=False,
        msg=msg(),
    )
    assert (sim_results := results.results) and all(
        sim.succeeded for meth in sim_results.values() for sim in meth.values()
    )
    scenario_assert_stats(scenario, results, totals)

    print("SUMMARY STATS: ", json.dumps(totals, indent=2))


IDENTITY_PREDICATES = {
    DRProp.lastLog: PredicateKind.IdenticalPair,
    DRProp.status: PredicateKind.IdenticalPair,
    DRProp.error: PredicateKind.IdenticalPair,
}


def test_nontriv_clear():
    totals = defaultdict(int)

    questionable = [
        r for name, ver, r in ALL_ROUTER_CASES if name == "questionable" and ver == 6
    ][0]
    nontriv_clear = [
        r for name, ver, r in ALL_ROUTER_CASES if name == "nontriv_clear" and ver == 6
    ][0]

    _, mconfigs = split_driver2predicates_methconfigs(DRIVERS["nontriv_clear"])
    predicates = {meth: IDENTITY_PREDICATES for meth in mconfigs}

    rsim_nt_vs_q = RouterSimulation(
        nontriv_clear, predicates, model_router=questionable
    )

    # Sanity check the approval programs (_POSITIVE_ cases only):
    msg = "APPROVAL nontriv@v6 vs. questionable@v8"
    version = 6
    results = rsim_nt_vs_q.simulate_and_assert(
        approval_args_strat_type=RandomABIStrategyHalfSized,
        clear_args_strat_type_or_inputs=None,
        approval_abi_args_mod=None,
        version=version,
        method_configs=mconfigs,
        num_dryruns=NUM_ROUTER_DRYRUNS,
        omit_clear_call=True,
        model_version=8,
        msg=msg,
    )
    assert (sim_results := results.results) and all(
        sim.succeeded for meth in sim_results.values() for sim in meth.values()
    )
    scenario_assert_stats(msg, results, totals)

    msg = "APPROVAL nontriv@v8 vs. questionable@v8"
    version = 8
    results = rsim_nt_vs_q.simulate_and_assert(
        approval_args_strat_type=RandomABIStrategyHalfSized,
        clear_args_strat_type_or_inputs=None,
        approval_abi_args_mod=None,
        version=version,
        method_configs=mconfigs,
        num_dryruns=NUM_ROUTER_DRYRUNS,
        omit_clear_call=True,
        model_version=8,
        msg=msg,
    )
    assert (sim_results := results.results) and all(
        sim.succeeded for meth in sim_results.values() for sim in meth.values()
    )
    scenario_assert_stats(msg, results, totals)

    print("PARTIAL SUMMARY STATS: ", json.dumps(totals, indent=2))

    # Finally, a bespoke test for the non-trivial clear program:
    bespoke = {
        DRProp.passed: {
            (): True,
            (b"random bytes",): True,
            (b"CLEANUP",): True,
            (b"CLEANUP", b"random bytes"): True,
            (b"CLEANUP", b"ABORTING"): False,
            (b"CLEANUP", b"ABORTING", b"random bytes"): False,
        }
    }
    inputs = list(bespoke[DRProp.passed].keys())
    clear_preds = {CLEAR_STATE_CALL: bespoke}

    msg = "CLEAR nontriv@v6"
    version = 6
    clear_rsim = RouterSimulation(nontriv_clear, clear_preds)
    results = clear_rsim.simulate_and_assert(
        approval_args_strat_type=None,
        clear_args_strat_type_or_inputs=inputs,
        approval_abi_args_mod=None,
        version=version,
        method_configs=None,
        msg=msg,
        omit_approval_call=True,
        skip_validation=True,
    )
    assert (sim_results := results.results) and all(
        sim.succeeded for meth in sim_results.values() for sim in meth.values()
    )
    scenario_assert_stats(msg, results, totals)

    msg = "CLEAR nontriv@v8"
    version = 8
    clear_rsim = RouterSimulation(nontriv_clear, clear_preds)
    results = clear_rsim.simulate_and_assert(
        approval_args_strat_type=None,
        clear_args_strat_type_or_inputs=inputs,
        approval_abi_args_mod=None,
        version=version,
        method_configs=None,
        msg=msg,
        omit_approval_call=True,
        skip_validation=True,
    )
    assert (sim_results := results.results) and all(
        sim.succeeded for meth in sim_results.values() for sim in meth.values()
    )
    scenario_assert_stats(msg, results, totals)



================================================
FILE: tests/integration/algod_test.py
================================================
from unittest import mock

import pytest

from pyteal.errors import AlgodClientError
from pyteal.util import algod_with_assertion


def test_algod_with_assertion_copacetic():
    """
    In C.I. integration tests we expect the happy path for the Algod client
    """
    client = algod_with_assertion()

    assert client

    reclient = algod_with_assertion(client)
    assert client is reclient


def test_algod_errors():
    from algosdk.v2client.algod import AlgodClient

    from pyteal import util

    with mock.patch.object(util, "_algod_client", side_effect=Exception("1337")):
        with pytest.raises(AlgodClientError) as ace:
            algod_with_assertion()
        assert "1337" in str(ace)

        with pytest.raises(AlgodClientError) as ace:
            algod_with_assertion(msg="okey dokey")
        assert "1337" in str(ace)
        assert "okey dokey" in str(ace)

    with mock.patch.object(AlgodClient, "status", side_effect=Exception("42")):
        with pytest.raises(AlgodClientError) as ace:
            algod_with_assertion()
        assert "42" in str(ace)

        with pytest.raises(AlgodClientError) as ace:
            algod_with_assertion(msg="yoyo ma")
        assert "42" in str(ace)
        assert "yoyo ma" in str(ace)

    with mock.patch.object(AlgodClient, "status", lambda _: None):
        with pytest.raises(AlgodClientError) as ace:
            algod_with_assertion()
        assert "did not produce any results" in str(ace)

        with pytest.raises(AlgodClientError) as ace:
            algod_with_assertion(msg="mellow yellow")
        assert "did not produce any results" in str(ace)
        assert "mellow yellow" in str(ace)

    with pytest.raises(AlgodClientError) as ace:
        algod_with_assertion("foo")  # type: ignore
    assert "has no attribute 'status'" in str(ace)

    with pytest.raises(AlgodClientError) as ace:
        algod_with_assertion("foo", msg="blarney")  # type: ignore
    assert "has no attribute 'status'" in str(ace)
    assert "blarney" in str(ace)

    client = algod_with_assertion()
    assert client

    with mock.patch.object(client, "status", side_effect=Exception("42")):
        with pytest.raises(AlgodClientError) as ace:
            algod_with_assertion(client)
        assert "42" in str(ace)

        with pytest.raises(AlgodClientError) as ace:
            algod_with_assertion(client, msg="hokus pokus")
        assert "42" in str(ace)
        assert "hokus pokus" in str(ace)



================================================
FILE: tests/integration/ecdsa_test.py
================================================
from pyteal import (
    Bytes,
    EcdsaCurve,
    EcdsaDecompress,
    EcdsaRecover,
    EcdsaVerify,
    Int,
    And,
    Subroutine,
    Sha512_256,
    Mode,
    TealType,
)

from tests.blackbox import (
    Blackbox,
    PyTealDryRunExecutor,
)


def test_verify():
    @Blackbox(input_types=[])
    @Subroutine(TealType.uint64)
    def verify():
        return EcdsaVerify(
            EcdsaCurve.Secp256k1,
            Sha512_256(Bytes("testdata")),
            Bytes(
                "base16",
                "33602297203d2753372cea7794ffe1756a278cbc4907b15a0dd132c9fb82555e",
            ),
            Bytes(
                "base16",
                "20f112126cf3e2eac6e8d4f97a403d21bab07b8dbb77154511bb7b07c0173195",
            ),
            (
                Bytes(
                    "base16",
                    "d6143a58c90c06b594e4414cb788659c2805e0056b1dfceea32c03f59efec517",
                ),
                Bytes(
                    "base16",
                    "00bd2400c479efe5ea556f37e1dc11ccb20f1e642dbfe00ca346fffeae508298",
                ),
            ),
        )

    args = []
    app_result = PyTealDryRunExecutor(verify, Mode.Application).dryrun_one(
        args, compiler_version=5
    )

    assert app_result.stack_top() == 1, app_result.report(
        args, "stack_top() is not equal to 1, indicating ecdsa verification failed."
    )

    @Blackbox(input_types=[])
    @Subroutine(TealType.uint64)
    def verify_fail():
        return EcdsaVerify(
            EcdsaCurve.Secp256k1,
            Sha512_256(Bytes("testdata")),
            Bytes(
                "base16",
                "13602297203d2753372cea7794ffe1756a278cbc4907b15a0dd132c9fb82555e",
            ),
            Bytes(
                "base16",
                "20f112126cf3e2eac6e8d4f97a403d21bab07b8dbb77154511bb7b07c0173195",
            ),
            (
                Bytes(
                    "base16",
                    "d6143a58c90c06b594e4414cb788659c2805e0056b1dfceea32c03f59efec517",
                ),
                Bytes(
                    "base16",
                    "00bd2400c479efe5ea556f37e1dc11ccb20f1e642dbfe00ca346fffeae508298",
                ),
            ),
        )

    args = []
    app_result = PyTealDryRunExecutor(verify_fail, Mode.Application).dryrun_one(
        args, compiler_version=5
    )

    assert app_result.stack_top() == 0, app_result.report(
        args,
        "stack_top() is not equal to 0, indicating ecdsa verification succeeded when a failure was expected.",
    )


def test_decompress():
    @Blackbox(input_types=[])
    @Subroutine(TealType.uint64)
    def decompress():
        return EcdsaDecompress(
            EcdsaCurve.Secp256k1,
            Bytes(
                "base16",
                "03bd83d54f6a799d05b496653b64bc933e17a898cda4793fe662d50645ecc977d1",
            ),
        ).outputReducer(
            lambda x, y: And(
                x
                == Bytes(
                    "base16",
                    "bd83d54f6a799d05b496653b64bc933e17a898cda4793fe662d50645ecc977d1",
                ),
                y
                == Bytes(
                    "base16",
                    "d4f3063a1ffca4139ea921b5696a6597640289175afece3bc38217a29d6270f9",
                ),
            )
        )

    args = []
    app_result = PyTealDryRunExecutor(decompress, Mode.Application).dryrun_one(
        args, compiler_version=5
    )

    assert app_result.stack_top() == 1, app_result.report(
        args, "stack_top() is not equal to 1, indicating ecdsa verification failed."
    )


def test_recover():
    @Blackbox(input_types=[])
    @Subroutine(TealType.uint64)
    def recover():
        return EcdsaRecover(
            EcdsaCurve.Secp256k1,
            Sha512_256(Bytes("testdata")),
            Int(1),
            Bytes(
                "base16",
                "cabed943e1403fb93b388174c59a52c759b321855f2d7c4fcc23c99a8a6dce79",
            ),
            Bytes(
                "base16",
                "56192820dde344c32f81450db05e51c6a6f45a2a2db229f657d2c040baf31537",
            ),
        ).outputReducer(
            lambda x, y: And(
                x
                == Bytes(
                    "base16",
                    "71539e0c7a6902a3f5413d6e28a455b2a14316fcf0f6b21193343b3b9d455053",
                ),
                y
                == Bytes(
                    "base16",
                    "fa49ccd95795c7c9a447fdeee83a2193472507a4e41a47e0d50eeeb547b74c51",
                ),
            )
        )

    args = []
    app_result = PyTealDryRunExecutor(recover, Mode.Application).dryrun_one(
        args, compiler_version=5
    )

    assert app_result.stack_top() == 1, app_result.report(
        args, "stack_top() is not equal to 1, indicating ecdsa verification failed."
    )



================================================
FILE: tests/integration/graviton_abi_test.py
================================================
import random
import pytest

from graviton.inspector import DryRunInspector

import pyteal as pt
from pyteal.ast.subroutine import ABIReturnSubroutine

from tests.blackbox import (
    Blackbox,
    PyTealDryRunExecutor,
)


# ---- Integers and Complex Integral Numbers (aka Gaussian Integers) ---- #


"""
WARNING: The following ABI types Int65 and Complex130 are ONLY for the purpose of testing/demo'ing
ABISubroutine and graviton ABI capabilities and are NOT the recommended approach for
implementing integers and complex integers.
A better approach would likely leverage `Uint64` (if any ABI type at all) and make use of 2's complement arithmetic.

Cf. https://github.com/algorand/pyteal/issues/184
"""

Int65 = pt.abi.Tuple2[pt.abi.Bool, pt.abi.Uint64]
Complex130 = pt.abi.Tuple2[Int65, Int65]


@Blackbox(input_types=[None, None])
@pt.ABIReturnSubroutine
def int65_minus_cond(x: Int65, y: Int65, *, output: Int65):
    """
    WARNING: not an ideal implementation. See explanation in first WARNING above.
    """
    x0 = pt.abi.Bool()
    x1 = pt.abi.Uint64()
    y0 = pt.abi.Bool()
    y1 = pt.abi.Uint64()
    z0 = pt.abi.Bool()
    z1 = pt.abi.Uint64()
    return pt.Seq(
        x0.set(x[0]),
        x1.set(x[1]),
        y0.set(y[0]),
        y1.set(y[1]),
        pt.Cond(
            # Case I. x, y positive
            [
                pt.And(x0.get(), y0.get()),
                pt.Seq(
                    z0.set(x1.get() >= y1.get()),
                    z1.set(
                        pt.If(x1.get() <= y1.get())
                        .Then(y1.get() - x1.get())
                        .Else(x1.get() - y1.get())
                    ),
                ),
            ],
            # Case II. x positive, y negative
            [
                pt.And(x0.get(), pt.Not(y0.get())),
                pt.Seq(z0.set(True), z1.set(x1.get() + y1.get())),
            ],
            # Case III. x negative, y positive
            [
                pt.And(pt.Not(x0.get()), y0.get()),
                pt.Seq(z0.set(False), z1.set(x1.get() + y1.get())),
            ],
            # Case IV. x, y negative
            [
                pt.Int(1),
                pt.Seq(
                    z0.set(x1.get() <= y1.get()),
                    z1.set(
                        pt.If(x1.get() <= y1.get())
                        .Then(y1.get() - x1.get())
                        .Else(x1.get() - y1.get())
                    ),
                ),
            ],
        ),
        output.set(z0, z1),
    )


@Blackbox(input_types=[None, None])
@pt.ABIReturnSubroutine
def int65_sub(x: Int65, y: Int65, *, output: Int65):
    """
    WARNING: not an ideal implementation. See explanation in first WARNING above.
    """
    x0 = pt.abi.Bool()
    x1 = pt.abi.Uint64()
    y0 = pt.abi.Bool()
    y1 = pt.abi.Uint64()
    z0 = pt.abi.Bool()
    z1 = pt.abi.Uint64()
    return pt.Seq(
        x0.set(x[0]),
        x1.set(x[1]),
        y0.set(y[0]),
        y1.set(y[1]),
        pt.If(x0.get() == y0.get())
        .Then(  # Case I. x, y same signature
            pt.Seq(
                z0.set(pt.Not(x0.get()) ^ (x1.get() >= y1.get())),
                z1.set(
                    pt.If(x1.get() <= y1.get())
                    .Then(y1.get() - x1.get())
                    .Else(x1.get() - y1.get())
                ),
            )
        )
        .Else(  # Case II. x, y opposite signatures
            pt.Seq(
                z0.set(x0.get()),
                z1.set(x1.get() + y1.get()),
            ),
        ),
        output.set(z0, z1),
    )


@Blackbox(input_types=[None, None])
@pt.ABIReturnSubroutine
def int65_mult(x: Int65, y: Int65, *, output: Int65):
    """
    WARNING: not an ideal implementation. See explanation in first WARNING above.
    """

    # TODO: can we get something like the following one-liner working?
    # return output.set(pt.Not(x[0].get() ^ y[0].get()), x[1].get() * y[1].get())
    def get(x):
        return x.use(lambda ni: ni.get())

    return pt.Seq(
        (z0 := pt.abi.Bool()).set(pt.Not(get(x[0]) ^ get(y[0]))),
        (z1 := pt.abi.Uint64()).set(get(x[1]) * get(y[1])),
        output.set(z0, z1),
    )


@Blackbox(input_types=[None])
@ABIReturnSubroutine
def int65_negate(x: Int65, *, output: Int65):
    """
    WARNING: not an ideal implementation. See explanation in first WARNING above.
    """
    # TODO: can I haz a one-liner pls????
    x0 = pt.abi.Bool()
    x1 = pt.abi.Uint64()
    z0 = pt.abi.Bool()
    z1 = pt.abi.Uint64()
    return pt.Seq(
        x0.set(x[0]),
        x1.set(x[1]),
        z0.set(pt.Not(x0.get())),
        z1.set(x1.get()),
        output.set(z0, z1),
    )


@Blackbox(input_types=[None, None])
@ABIReturnSubroutine
def int65_add(x: Int65, y: Int65, *, output: Int65):
    """
    WARNING: not an ideal implementation. See explanation in first WARNING above.
    """
    return pt.Seq(y.set(int65_negate(y)), output.set(int65_sub(x, y)))


@Blackbox(input_types=[None, None])
@ABIReturnSubroutine
def complex130_add(x: Complex130, y: Complex130, *, output: Complex130):
    """
    WARNING: not an ideal implementation. See explanation in first WARNING above.
    """
    x0 = pt.abi.make(Int65)
    x1 = pt.abi.make(Int65)
    y0 = pt.abi.make(Int65)
    y1 = pt.abi.make(Int65)
    z0 = pt.abi.make(Int65)
    z1 = pt.abi.make(Int65)
    return pt.Seq(
        x0.set(x[0]),
        x1.set(x[1]),
        y0.set(y[0]),
        y1.set(y[1]),
        z0.set(int65_add(x0, y0)),
        z1.set(int65_add(x1, y1)),
        output.set(z0, z1),
    )


@Blackbox(input_types=[None, None])
@ABIReturnSubroutine
def complex130_mult(x: Complex130, y: Complex130, *, output: Complex130):
    """
    WARNING: not an ideal implementation. See explanation in first WARNING above.
    """
    x0 = pt.abi.make(Int65)
    x1 = pt.abi.make(Int65)
    y0 = pt.abi.make(Int65)
    y1 = pt.abi.make(Int65)
    t1 = pt.abi.make(Int65)
    t2 = pt.abi.make(Int65)
    t3 = pt.abi.make(Int65)
    t4 = pt.abi.make(Int65)
    z0 = pt.abi.make(Int65)
    z1 = pt.abi.make(Int65)
    return pt.Seq(
        x0.set(x[0]),
        x1.set(x[1]),
        y0.set(y[0]),
        y1.set(y[1]),
        # TODO: why can't I chain ABI calls?
        # z0.set(int65_sub(int65_mult(x0, y0), int65_mult(x1, y1))),
        # z1.set(int65_add(int65_mult(x0, y1), int65_mult(x1, y0))),
        t1.set(int65_mult(x0, y0)),
        t2.set(int65_mult(x1, y1)),
        t3.set(int65_mult(x0, y1)),
        t4.set(int65_mult(x1, y0)),
        z0.set(int65_sub(t1, t2)),
        z1.set(int65_add(t3, t4)),
        output.set(z0, z1),
    )


@Blackbox(input_types=[None])
@ABIReturnSubroutine
def complex130_real(x: Complex130, *, output: Int65):
    """
    WARNING: not an ideal implementation. See explanation in first WARNING above.
    """
    return output.set(x[0])


@Blackbox(input_types=[None])
@ABIReturnSubroutine
def complex130_imag(x: Complex130, *, output: Int65):
    """
    WARNING: not an ideal implementation. See explanation in first WARNING above.
    """
    return output.set(x[1])


@Blackbox(input_types=[None])
@ABIReturnSubroutine
def complex130_conjugate(x: Complex130, *, output: Complex130):
    """
    WARNING: not an ideal implementation. See explanation in first WARNING above.
    """
    z0 = pt.abi.make(Int65)
    z1 = pt.abi.make(Int65)
    return pt.Seq(
        z0.set(complex130_real(x)),
        z1.set(complex130_imag(x)),
        z1.set(int65_negate(z1)),
        output.set(z0, z1),
    )


@Blackbox(input_types=[None])
@ABIReturnSubroutine
def complex130_norm_squared(x: Complex130, *, output: Int65):
    """
    WARNING: not an ideal implementation. See explanation in first WARNING above.
    """
    t = pt.abi.make(Complex130)
    return pt.Seq(
        t.set(complex130_conjugate(x)),
        t.set(complex130_mult(t, x)),
        output.set(complex130_real(t)),
    )


# ---- additional stand-alone ABIReturnSubroutine's ---- #


@Blackbox(input_types=[None])
@ABIReturnSubroutine
def conditional_factorial(_factor: pt.abi.Uint64, *, output: pt.abi.Uint64) -> pt.Expr:
    i = pt.ScratchVar(pt.TealType.uint64)

    return pt.Seq(
        output.set(1),
        pt.If(_factor.get() <= pt.Int(1))
        .Then(pt.Return())
        .Else(
            pt.For(
                i.store(_factor.get()),
                i.load() > pt.Int(1),
                i.store(i.load() - pt.Int(1)),
            ).Do(output.set(output.get() * i.load())),
        ),
    )


# ---- integration test functions ---- #


@pytest.mark.parametrize("version", [6, 8])
def test_integer65(version: int):
    bbpt_subtract_slick = PyTealDryRunExecutor(int65_sub, pt.Mode.Application)

    bbpt_subtract_cond = PyTealDryRunExecutor(int65_minus_cond, pt.Mode.Application)

    bbpt_mult = PyTealDryRunExecutor(int65_mult, pt.Mode.Application)

    bbpt_negate = PyTealDryRunExecutor(int65_negate, pt.Mode.Application)

    bbpt_add = PyTealDryRunExecutor(int65_add, pt.Mode.Application)

    def pynum_to_int65tuple(n):
        return (n >= 0, abs(n))

    def pytuple_to_num(t):
        s, x = t
        return x if s else -x

    N = 100
    random.seed(42)

    choices = range(-9_999, 10_000)
    unary_inputs = [(pynum_to_int65tuple(x),) for x in random.sample(choices, N)]

    binary_inputs = [
        (pynum_to_int65tuple(x), pynum_to_int65tuple(y))
        for x, y in zip(random.sample(choices, N), random.sample(choices, N))
    ]

    def binary_dryrun(p: PyTealDryRunExecutor) -> list[DryRunInspector]:
        return p.dryrun_sequence(binary_inputs, compiler_version=version)  # type: ignore

    # Binary:
    inspectors_subtract_slick = binary_dryrun(bbpt_subtract_slick)

    inspectors_subtract_cond = binary_dryrun(bbpt_subtract_cond)

    inspectors_mult = binary_dryrun(bbpt_mult)

    inspectors_add = binary_dryrun(bbpt_add)

    # Unary:
    inspectors_negate = bbpt_negate.dryrun_sequence(
        unary_inputs, compiler_version=version  # type: ignore
    )

    for i in range(N):
        binary_args = binary_inputs[i]
        x, y = tuple(map(pytuple_to_num, binary_args))

        unary_args = unary_inputs[i]
        u = pytuple_to_num(unary_args[0])

        inspector_subtract_slick = inspectors_subtract_slick[i]
        inspector_subtract_cond = inspectors_subtract_cond[i]
        inspector_mult = inspectors_mult[i]
        inspector_add = inspectors_add[i]

        inspector_negate = inspectors_negate[i]

        assert x - y == pytuple_to_num(
            inspector_subtract_slick.last_log()
        ), inspector_subtract_slick.report(
            binary_args, f"failed for {binary_args}", row=i
        )

        assert x - y == pytuple_to_num(
            inspector_subtract_cond.last_log()
        ), inspector_subtract_cond.report(
            binary_args, f"failed for {binary_args}", row=i
        )

        assert x * y == pytuple_to_num(
            inspector_mult.last_log()
        ), inspector_mult.report(binary_args, f"failed for {binary_args}", row=i)

        assert x + y == pytuple_to_num(inspector_add.last_log()), inspector_add.report(
            binary_args, f"failed for {binary_args}", row=i
        )

        assert -u == pytuple_to_num(
            inspector_negate.last_log()
        ), inspector_negate.report(unary_args, f"failed for {unary_args}", row=i)


@pytest.mark.parametrize("version", [6, 8])
def test_complex130(version: int):
    # Binary:

    bbpt_cplx_add = PyTealDryRunExecutor(complex130_add, pt.Mode.Application)

    bbpt_cplx_mult = PyTealDryRunExecutor(complex130_mult, pt.Mode.Application)

    # Unary:

    bbpt_complex_real = PyTealDryRunExecutor(complex130_real, pt.Mode.Application)

    bbpt_complex_imag = PyTealDryRunExecutor(complex130_imag, pt.Mode.Application)

    bbpt_complex_conjugate = PyTealDryRunExecutor(
        complex130_conjugate, pt.Mode.Application
    )

    bbpt_complex_norm_squared = PyTealDryRunExecutor(
        complex130_norm_squared, pt.Mode.Application
    )

    def pyint_to_tuple(n):
        return (n >= 0, abs(n))

    def pycomplex_to_tuple(z):
        return (pyint_to_tuple(int(z.real)), pyint_to_tuple(int(z.imag)))

    def pytuple_to_int(t):
        s, x = t
        return x if s else -x

    def pytuple_to_complex(tt):
        tx, ty = tt
        return complex(pytuple_to_int(tx), pytuple_to_int(ty))

    N = 100
    # just for fun - no random seed - but this shouldn't be flakey

    choices = range(-999_999, 1_000_000)

    unary_inputs = [
        (pycomplex_to_tuple(complex(x, y)),)
        for x, y in zip(random.sample(choices, N), random.sample(choices, N))
    ]

    binary_inputs = [
        (pycomplex_to_tuple(complex(x, y)), pycomplex_to_tuple(complex(z, w)))
        for x, y, z, w in zip(
            random.sample(choices, N),
            random.sample(choices, N),
            random.sample(choices, N),
            random.sample(choices, N),
        )
    ]

    # Binary:
    def binary_dryrun(p: PyTealDryRunExecutor) -> list[DryRunInspector]:
        return p.dryrun_sequence(binary_inputs, compiler_version=version)  # type: ignore

    # Unary:
    def unary_dryrun(p: PyTealDryRunExecutor) -> list[DryRunInspector]:
        return p.dryrun_sequence(unary_inputs, compiler_version=version)  # type: ignore

    inspectors_cplx_add = binary_dryrun(bbpt_cplx_add)

    inspectors_cplx_mult = binary_dryrun(bbpt_cplx_mult)

    inspectors_cplx_real = unary_dryrun(bbpt_complex_real)

    inspectors_cplx_imag = unary_dryrun(bbpt_complex_imag)

    inspectors_cplx_conjugate = unary_dryrun(bbpt_complex_conjugate)

    inspectors_cplx_norm_squared = unary_dryrun(bbpt_complex_norm_squared)

    for i in range(N):
        binary_args = binary_inputs[i]
        x, y = tuple(map(pytuple_to_complex, binary_args))

        unary_args = unary_inputs[i]
        u = pytuple_to_complex(unary_args[0])

        # Binary:

        inspector_cplx_add = inspectors_cplx_add[i]

        inspector_cplx_mult = inspectors_cplx_mult[i]

        # Unary:

        inspector_cplx_real = inspectors_cplx_real[i]

        inspector_cplx_imag = inspectors_cplx_imag[i]

        inspector_cplx_conjugate = inspectors_cplx_conjugate[i]

        inspector_cplx_norm_squared = inspectors_cplx_norm_squared[i]

        assert x + y == pytuple_to_complex(
            inspector_cplx_add.last_log()
        ), inspector_cplx_add.report(binary_args, f"failed for {binary_args}", row=i)

        assert x * y == pytuple_to_complex(
            inspector_cplx_mult.last_log()
        ), inspector_cplx_mult.report(binary_args, f"failed for {binary_args}", row=i)

        assert u.real == pytuple_to_int(
            inspector_cplx_real.last_log()
        ), inspector_cplx_real.report(unary_args, f"failed for {unary_args}", row=i)

        assert u.imag == pytuple_to_int(
            inspector_cplx_imag.last_log()
        ), inspector_cplx_imag.report(unary_args, f"failed for {unary_args}", row=i)

        assert u.conjugate() == pytuple_to_complex(
            inspector_cplx_conjugate.last_log()
        ), inspector_cplx_conjugate.report(
            unary_args, f"failed for {unary_args}", row=i
        )

        assert u * u.conjugate() == pytuple_to_int(
            inspector_cplx_norm_squared.last_log()
        ), inspector_cplx_norm_squared.report(
            unary_args, f"failed for {unary_args}", row=i
        )


def py_factorial(n):
    return 1 if n <= 1 else n * py_factorial(n - 1)


@pytest.mark.parametrize("version", [6, 8])
def test_conditional_factorial(version: int):
    ptdre = PyTealDryRunExecutor(conditional_factorial, pt.Mode.Application)
    inputs = [(n,) for n in range(20)]

    inspectors = ptdre.dryrun_sequence(inputs, compiler_version=version)  # type: ignore
    for i, args in enumerate(inputs):
        inspector = inspectors[i]
        n = args[0]
        assert inspector.passed(), inspector.report(args, row=i + 1)

        expected = py_factorial(n)
        assert expected == inspector.last_log(), inspector.report(args, row=i + 1)

    n = 21
    args = (n,)
    inspector = ptdre.dryrun_one(args)
    assert inspector.rejected(), inspector.report(
        args, f"FAILED: should have rejected for {n=}", row=n + 1
    )
    assert inspector.error(), inspector.report(
        args, f"FAILED: should error for {n=}", row=n + 1
    )



================================================
FILE: tests/integration/graviton_test.py
================================================
from itertools import product
from pathlib import Path
from typing import Any, Dict

import pytest

import pyteal as pt

from tests.compile_asserts import assert_teal_as_expected
from tests.blackbox import (
    Blackbox,
    BlackboxWrapper,
    algod_with_assertion,
    mode_to_execution_mode,
    PyTealDryRunExecutor,
)

from graviton.blackbox import DryRunEncoder as Encoder, DryRunExecutor
from graviton.inspector import DryRunProperty as DRProp, DryRunInspector
from graviton.invariant import Invariant, PredicateKind, mode_has_property

PATH = Path.cwd() / "tests" / "integration"
FIXTURES = PATH / "teal"
GENERATED = PATH / "generated"

# TODO: remove these skips after the following issue has been fixed https://github.com/algorand/pyteal/issues/199
STABLE_SLOT_GENERATION = False
SKIP_SCRATCH_ASSERTIONS = not STABLE_SLOT_GENERATION

# ---- Helper ---- #


def wrap_compile_and_save(
    subr,
    mode,
    version,
    assemble_constants,
    test_name,
    case_name,
):
    is_app = mode == pt.Mode.Application

    teal = PyTealDryRunExecutor(subr, mode).compile(version, assemble_constants)
    tealfile = f'{"app" if is_app else "lsig"}_{case_name}_v{version}.teal'

    tealdir = GENERATED / test_name
    tealdir.mkdir(parents=True, exist_ok=True)
    tealpath = tealdir / tealfile
    with open(tealpath, "w") as f:
        f.write(teal)

    print(
        f"""Subroutine {case_name}@{mode} generated TEAL.
saved to {tealpath}:
-------
{teal}
-------"""
    )

    return teal, is_app, tealfile


# ---- Subroutines for Blackbox Testing ---- #


@Blackbox(input_types=[])
@pt.Subroutine(pt.TealType.uint64)
def exp():
    return pt.Int(2) ** pt.Int(10)


@Blackbox(input_types=[pt.TealType.uint64])
@pt.Subroutine(pt.TealType.none)
def square_byref(x: pt.ScratchVar):
    return x.store(x.load() * x.load())


@Blackbox(input_types=[pt.TealType.uint64])
@pt.Subroutine(pt.TealType.uint64)
def square(x):
    return x ** pt.Int(2)


@Blackbox(input_types=[pt.TealType.anytype, pt.TealType.anytype])
@pt.Subroutine(pt.TealType.none)
def swap(x: pt.ScratchVar, y: pt.ScratchVar):
    z = pt.ScratchVar(pt.TealType.anytype)
    return pt.Seq(
        z.store(x.load()),
        x.store(y.load()),
        y.store(z.load()),
    )


@Blackbox(input_types=[pt.TealType.bytes, pt.TealType.uint64])
@pt.Subroutine(pt.TealType.bytes)
def string_mult(s: pt.ScratchVar, n):
    i = pt.ScratchVar(pt.TealType.uint64)
    tmp = pt.ScratchVar(pt.TealType.bytes)
    start = pt.Seq(i.store(pt.Int(1)), tmp.store(s.load()), s.store(pt.Bytes("")))
    step = i.store(i.load() + pt.Int(1))
    return pt.Seq(
        pt.For(start, i.load() <= n, step).Do(s.store(pt.Concat(s.load(), tmp.load()))),
        s.load(),
    )


@Blackbox(input_types=[pt.TealType.uint64])
@pt.Subroutine(pt.TealType.uint64)
def oldfac(n):
    return pt.If(n < pt.Int(2)).Then(pt.Int(1)).Else(n * oldfac(n - pt.Int(1)))


@Blackbox(input_types=[pt.TealType.uint64])
@pt.Subroutine(pt.TealType.uint64)
def slow_fibonacci(n):
    return (
        pt.If(n <= pt.Int(1))
        .Then(n)
        .Else(slow_fibonacci(n - pt.Int(2)) + slow_fibonacci(n - pt.Int(1)))
    )


def fac_with_overflow(n):
    if n < 2:
        return 1
    if n > 20:
        return 2432902008176640000
    return n * fac_with_overflow(n - 1)


def fib(n):
    a, b = 0, 1
    for _ in range(n):
        a, b = b, a + b
    return a


# ---- Blackbox pure unit tests (Skipping for now due to flakiness) ---- #


@pytest.mark.skipif(not STABLE_SLOT_GENERATION, reason="cf. #199")
@pytest.mark.parametrize(
    "subr, mode",
    product(
        [exp, square_byref, square, swap, string_mult, oldfac, slow_fibonacci],
        [pt.Mode.Application, pt.Mode.Signature],
    ),
)
def test_stable_teal_generation(subr, mode):
    """
    TODO: here's an example of issue #199 at play - need to run a dynamic version of `git bisect`
    to figure out what is driving this
    """
    case_name = subr.name()
    print(f"stable TEAL generation test for {case_name} in mode {mode}")

    # HANG NOTE: I prefer not to modify this test, for it is skipped now on thread-unsafe behavior,
    # and I would suggest revisiting later after we have satisfied solution for #199.
    _, _, tealfile = wrap_compile_and_save(subr, mode, 6, True, "stability", case_name)
    path2actual = GENERATED / "stability" / tealfile
    path2expected = FIXTURES / "stability" / tealfile
    assert_teal_as_expected(path2actual, path2expected)


APP_SCENARIOS = {
    exp: {
        "inputs": [()],
        # since only a single input, just assert a constant in each case
        "assertions": {
            DRProp.cost: lambda _, actual: actual in {11, 12},
            # int assertions on log outputs need encoding to varuint-hex:
            DRProp.lastLog: Encoder.hex(2**10),
            # dicts have a special meaning as assertions. So in the case of "finalScratch"
            # which is supposed to _ALSO_ output a dict, we need to use a lambda as a work-around
            DRProp.finalScratch: lambda _: {0: 1024},
            DRProp.stackTop: 1024,
            DRProp.maxStackHeight: 2,
            DRProp.status: "PASS",
            DRProp.passed: True,
            DRProp.rejected: False,
            DRProp.errorMessage: None,
        },
    },
    square_byref: {
        "inputs": [(i,) for i in range(100)],
        "assertions": {
            DRProp.cost: lambda _, actual: 20 < actual < 24,
            DRProp.lastLog: Encoder.hex(1337),
            # due to dry-run artifact of not reporting 0-valued scratchvars,
            # we have a special case for n=0:
            DRProp.finalScratch: lambda args, actual: (
                {1, 1337, (args[0] ** 2 if args[0] else 1)}
            ).issubset(set(actual.values())),
            DRProp.stackTop: 1337,
            DRProp.maxStackHeight: lambda _, actual: actual in [3, 4],
            DRProp.status: "PASS",
            DRProp.passed: True,
            DRProp.rejected: False,
            DRProp.errorMessage: None,
        },
    },
    square: {
        "inputs": [(i,) for i in range(100)],
        "assertions": {
            DRProp.cost: 14,
            DRProp.lastLog: {
                # since execution REJECTS for 0, expect last log for this case to be None
                (i,): Encoder.hex(i * i)
                for i in range(100)
            },
            DRProp.finalScratch: lambda args: (
                {0: args[0] ** 2, 1: args[0]} if args[0] else {}
            ),
            DRProp.stackTop: lambda args: args[0] ** 2,
            DRProp.maxStackHeight: lambda _, actual: actual in range(2, 5),
            DRProp.status: lambda i: "PASS" if i[0] > 0 else "REJECT",
            DRProp.passed: lambda i: i[0] > 0,
            DRProp.rejected: lambda i: i[0] == 0,
            DRProp.errorMessage: None,
        },
    },
    swap: {
        "inputs": [(1, 2), (1, "two"), ("one", 2), ("one", "two")],
        "assertions": {
            DRProp.cost: lambda _, actual: actual in [27, 30],
            DRProp.lastLog: Encoder.hex(1337),
            DRProp.finalScratch: lambda args: {
                0: 1337,
                1: Encoder.hex0x(args[1]),
                2: Encoder.hex0x(args[0]),
                3: 1,
                4: 2,
                5: Encoder.hex0x(args[0]),
            },
            DRProp.stackTop: 1337,
            DRProp.maxStackHeight: lambda _, actual: actual in [2, 4],
            DRProp.status: "PASS",
            DRProp.passed: True,
            DRProp.rejected: False,
            DRProp.errorMessage: None,
        },
    },
    string_mult: {
        "inputs": [("xyzw", i) for i in range(100)],
        "assertions": {
            DRProp.lastLog: (lambda args: Encoder.hex(args[0] * args[1])),
            # due to dryrun 0-scratchvar artifact, special case for i == 0:
            DRProp.finalScratch: lambda args: (
                {
                    0: Encoder.hex0x(args[0] * args[1]),
                    1: Encoder.hex0x(args[0] * args[1]),
                    2: 1,
                    3: args[1],
                    4: args[1] + 1,
                    5: Encoder.hex0x(args[0]),
                }
                if args[1]
                else {
                    2: 1,
                    4: args[1] + 1,
                    5: Encoder.hex0x(args[0]),
                }
            ),
            DRProp.stackTop: lambda args: len(args[0] * args[1]),
            DRProp.status: lambda args: ("PASS" if 0 < args[1] < 45 else "REJECT"),
            DRProp.passed: lambda args: 0 < args[1] < 45,
            DRProp.rejected: lambda args: 0 >= args[1] or args[1] >= 45,
            DRProp.errorMessage: None,
        },
    },
    oldfac: {
        "inputs": [(i,) for i in range(25)],
        "assertions": {
            DRProp.lastLog: lambda args: (
                Encoder.hex(fac_with_overflow(args[0])) if args[0] < 21 else None
            ),
            DRProp.finalScratch: lambda args: (
                {1: args[0], 0: fac_with_overflow(args[0])}
                if 0 < args[0] < 21
                else (
                    {1: min(21, args[0])}
                    if args[0]
                    else {0: fac_with_overflow(args[0])}
                )
            ),
            DRProp.stackTop: lambda args: fac_with_overflow(args[0]),
            DRProp.status: lambda args: "PASS" if args[0] < 21 else "REJECT",
            DRProp.passed: lambda args: args[0] < 21,
            DRProp.rejected: lambda args: args[0] >= 21,
            DRProp.errorMessage: lambda args, actual: (
                actual is None if args[0] < 21 else "overflowed" in actual
            ),
        },
    },
    slow_fibonacci: {
        "inputs": [(i,) for i in range(17)],
        "assertions": {
            DRProp.lastLog: lambda args, actual: (
                Encoder.hex(fib(args[0])) == actual if 0 <= args[0] < 17 else True
            ),
            DRProp.finalScratch: lambda args, actual: (
                actual == {1: args[0], 0: fib(args[0])}
                if 0 < args[0] < 17
                else (True if args[0] >= 17 else actual == {})
            ),
            # we declare to "not care" about the top of the stack for n >= 17
            DRProp.stackTop: lambda args, actual: (
                actual == fib(args[0]) if args[0] < 17 else True
            ),
            DRProp.status: lambda args: "PASS" if 0 < args[0] < 8 else "REJECT",
            DRProp.passed: lambda args: 0 < args[0] < 8,
            DRProp.rejected: lambda args: 0 >= args[0] or args[0] >= 8,
            DRProp.errorMessage: lambda args, actual: (
                actual is None
                if args[0] < 17
                else "dynamic cost budget exceeded" in actual
            ),
        },
    },
}

# NOTE: logic sig dry runs are missing some information when compared with app dry runs.
# Therefore, certain assertions don't make sense for logic sigs explaining why some of the below are commented out:
LOGICSIG_SCENARIOS = {
    exp: {
        "inputs": [()],
        "assertions": {
            # DRProp.cost: 11,
            # DRProp.lastLog: Encoder.hex(2 ** 10),
            DRProp.finalScratch: lambda _: {},
            DRProp.stackTop: 1024,
            DRProp.maxStackHeight: 2,
            DRProp.status: "PASS",
            DRProp.passed: True,
            DRProp.rejected: False,
            DRProp.errorMessage: None,
        },
    },
    square_byref: {
        "inputs": [(i,) for i in range(100)],
        "assertions": {
            # due to dry-run artifact of not reporting 0-valued scratchvars,
            # we have a special case for n=0:
            DRProp.finalScratch: lambda args, actual: (
                {1, 1337, (args[0] ** 2 if args[0] else 1)}
            ).issubset(set(actual.values())),
            DRProp.stackTop: 1337,
            DRProp.maxStackHeight: lambda _, actual: actual in [3, 4],
            DRProp.status: "PASS",
            DRProp.passed: True,
            DRProp.rejected: False,
            DRProp.errorMessage: None,
        },
    },
    square: {
        "inputs": [(i,) for i in range(100)],
        "assertions": {
            DRProp.finalScratch: lambda args: (
                {0: args[0] ** 2, 1: args[0]} if args[0] else {}
            ),
            DRProp.stackTop: lambda args: args[0] ** 2,
            DRProp.maxStackHeight: lambda _, actual: actual in range(2, 5),
            DRProp.status: lambda i: "PASS" if i[0] > 0 else "REJECT",
            DRProp.passed: lambda i: i[0] > 0,
            DRProp.rejected: lambda i: i[0] == 0,
            DRProp.errorMessage: None,
        },
    },
    swap: {
        "inputs": [(1, 2), (1, "two"), ("one", 2), ("one", "two")],
        "assertions": {
            DRProp.finalScratch: lambda args: {
                0: 1337,
                1: Encoder.hex0x(args[1]),
                2: Encoder.hex0x(args[0]),
                3: 1,
                4: 2,
                5: Encoder.hex0x(args[0]),
            },
            DRProp.stackTop: 1337,
            DRProp.maxStackHeight: lambda _, actual: actual in [2, 4],
            DRProp.status: "PASS",
            DRProp.passed: True,
            DRProp.rejected: False,
            DRProp.errorMessage: None,
        },
    },
    string_mult: {
        "inputs": [("xyzw", i) for i in range(100)],
        "assertions": {
            # due to dryrun 0-scratchvar artifact, special case for i == 0:
            DRProp.finalScratch: lambda args: (
                {
                    0: Encoder.hex0x(args[0] * args[1]),
                    1: Encoder.hex0x(args[0] * args[1]),
                    2: 1,
                    3: args[1],
                    4: args[1] + 1,
                    5: Encoder.hex0x(args[0]),
                }
                if args[1]
                else {
                    2: 1,
                    4: args[1] + 1,
                    5: Encoder.hex0x(args[0]),
                }
            ),
            DRProp.stackTop: lambda args: len(args[0] * args[1]),
            DRProp.status: lambda args: "PASS" if args[1] else "REJECT",
            DRProp.passed: lambda args: bool(args[1]),
            DRProp.rejected: lambda args: not bool(args[1]),
            DRProp.errorMessage: None,
        },
    },
    oldfac: {
        "inputs": [(i,) for i in range(25)],
        "assertions": {
            DRProp.finalScratch: lambda args: (
                {1: args[0], 0: fac_with_overflow(args[0])}
                if 0 < args[0] < 21
                else (
                    {1: min(21, args[0])}
                    if args[0]
                    else {0: fac_with_overflow(args[0])}
                )
            ),
            DRProp.stackTop: lambda args: fac_with_overflow(args[0]),
            DRProp.status: lambda args: "PASS" if args[0] < 21 else "REJECT",
            DRProp.passed: lambda args: args[0] < 21,
            DRProp.rejected: lambda args: args[0] >= 21,
            DRProp.errorMessage: lambda args, actual: (
                actual is None if args[0] < 21 else "overflowed" in actual
            ),
        },
    },
    slow_fibonacci: {
        "inputs": [(i,) for i in range(17)],
        "assertions": {
            DRProp.finalScratch: lambda args, actual: (
                actual == {1: args[0], 0: fib(args[0])}
                if 0 < args[0] < 17
                else (True if args[0] >= 17 else actual == {})
            ),
            # we declare to "not care" about the top of the stack for n >= 15
            DRProp.stackTop: lambda args, actual: (
                actual == fib(args[0]) if args[0] < 15 else True
            ),
            DRProp.status: lambda args: "PASS" if 0 < args[0] < 15 else "REJECT",
            DRProp.passed: lambda args: 0 < args[0] < 15,
            DRProp.rejected: lambda args: not (0 < args[0] < 15),
            DRProp.errorMessage: lambda args, actual: (
                actual is None
                if args[0] < 15
                else "dynamic cost budget exceeded" in actual
            ),
        },
    },
}

APP_IDENTICAL_PREDICATES = {
    DRProp.lastLog: PredicateKind.IdenticalPair,
    DRProp.status: PredicateKind.IdenticalPair,
    DRProp.error: PredicateKind.IdenticalPair,
}
LSIG_IDENTICAL_PREDICATES = {
    DRProp.status: PredicateKind.IdenticalPair,
    DRProp.error: PredicateKind.IdenticalPair,
}


def blackbox_test_runner(
    subr: pt.SubroutineFnWrapper,
    mode: pt.Mode,
    scenario: Dict[str, Any],
    version: int,
    assemble_constants: bool = True,
) -> list[DryRunInspector]:
    case_name = subr.name()
    print(f"blackbox test of {case_name} with mode {mode}")
    exec_mode = mode_to_execution_mode(mode)

    # 0. Validations
    assert isinstance(subr, BlackboxWrapper), f"unexpected subr type {type(subr)}"
    assert isinstance(mode, pt.Mode)

    # 1. Compile to TEAL
    teal, _, tealfile = wrap_compile_and_save(
        subr, mode, version, assemble_constants, "blackbox", case_name
    )

    # Fail fast in case algod is not configured:
    algod = algod_with_assertion()

    # 2. validate dry run scenarios:
    inputs = scenario["inputs"]
    predicates = scenario["assertions"]
    assert inputs and isinstance(inputs, list)
    assert predicates, "Must configure >= 1 predicate"
    assert isinstance(predicates, dict)

    # 3. execute dry run sequence:
    inspectors = DryRunExecutor(algod, exec_mode, teal).run_sequence(inputs)

    # 4. Statistical report:
    csvpath = GENERATED / "blackbox" / f"{tealfile}_v{version}.csv"
    with open(csvpath, "w") as f:
        f.write(DryRunInspector.csv_report(inputs, inspectors))

    print(f"Saved Dry Run CSV report to {csvpath}")

    # 5. Sequential assertions (if provided any)
    for i, (dr_prop, predicate) in enumerate(predicates.items()):
        if SKIP_SCRATCH_ASSERTIONS and dr_prop == DRProp.finalScratch:
            print("skipping scratch assertions because unstable slots produced")
            continue

        assert mode_has_property(exec_mode, dr_prop)

        invariant = Invariant(predicate, name=f"{case_name}[{i}]@{mode}-{dr_prop}")
        print(f"{i + 1}. Assertion for {case_name}-{mode}: {dr_prop} <<{predicate}>>")
        invariant.validates(dr_prop, inspectors)

    return inspectors


# ---- Graviton / Blackbox tests ---- #


@pytest.mark.parametrize("subr, scenario", APP_SCENARIOS.items())
def test_blackbox_subroutines_as_apps(
    subr: pt.SubroutineFnWrapper,
    scenario: Dict[str, Any],
):
    inspectors6 = blackbox_test_runner(subr, pt.Mode.Application, scenario, 6)
    inspectors8 = blackbox_test_runner(subr, pt.Mode.Application, scenario, 8)

    Invariant.full_validation(
        APP_IDENTICAL_PREDICATES,
        inspectors=inspectors6,
        identities=inspectors8,
        msg=f"{subr.name()=}",
    )


@pytest.mark.parametrize("subr, scenario", LOGICSIG_SCENARIOS.items())
def test_blackbox_subroutines_as_logic_sigs(
    subr: pt.SubroutineFnWrapper,
    scenario: Dict[str, Any],
):
    inspectors6 = blackbox_test_runner(subr, pt.Mode.Signature, scenario, 6)
    inspectors8 = blackbox_test_runner(subr, pt.Mode.Signature, scenario, 8)
    Invariant.full_validation(
        LSIG_IDENTICAL_PREDICATES,
        inspectors=inspectors6,
        identities=inspectors8,
        msg=f"{subr.name()=}",
    )


def blackbox_pyteal_example1():
    # Example 1: Using blackbox_pyteal for a simple test of both an app and logic sig:
    from graviton.blackbox import DryRunEncoder

    from pyteal import Int, Mode, Subroutine, TealType
    from tests.blackbox import Blackbox

    @Blackbox(input_types=[TealType.uint64])
    @Subroutine(TealType.uint64)
    def square(x):
        return x ** Int(2)

    # provide args for evaluation (will compute x^2)
    x = 9
    args = [x]

    def evaluate_and_check(version: int):
        # evaluate the programs
        app_result = PyTealDryRunExecutor(square, Mode.Application).dryrun_one(
            args, compiler_version=version
        )
        lsig_result = PyTealDryRunExecutor(square, Mode.Signature).dryrun_one(
            args, compiler_version=version
        )

        # check to see that x^2 is at the top of the stack as expected
        assert app_result.stack_top() == x**2, app_result.report(
            args, "stack_top() gave unexpected results for app"
        )
        assert lsig_result.stack_top() == x**2, lsig_result.report(
            args, "stack_top() gave unexpected results for lsig"
        )

        # check to see that itob of x^2 has been logged (only for the app case)
        assert app_result.last_log() == DryRunEncoder.hex(x**2), app_result.report(
            args, "last_log() gave unexpected results from app"
        )

        return app_result, lsig_result

    app6, lsig6 = evaluate_and_check(6)
    app8, lsig8 = evaluate_and_check(8)
    Invariant.full_validation(
        APP_IDENTICAL_PREDICATES,
        inspectors=[app6],
        identities=[app8],
        msg="Mode.Application example 1",
    )
    Invariant.full_validation(
        LSIG_IDENTICAL_PREDICATES,
        inspectors=[lsig6],
        identities=[lsig8],
        msg="Mode.Signature example 1",
    )


def blackbox_pyteal_example2():
    # Example 2: Using blackbox_pyteal to make 400 assertions and generate a CSV report with 400 dryrun rows
    from itertools import product
    import math
    from pathlib import Path
    import random

    from graviton.blackbox import DryRunInspector

    from pyteal import (
        For,
        If,
        Int,
        Mod,
        Mode,
        ScratchVar,
        Seq,
        Subroutine,
        TealType,
    )

    from tests.blackbox import Blackbox

    # GCD via the Euclidean Algorithm (iterative version):
    @Blackbox(input_types=[TealType.uint64, TealType.uint64])
    @Subroutine(TealType.uint64)
    def euclid(x, y):
        a = ScratchVar(TealType.uint64)
        b = ScratchVar(TealType.uint64)
        tmp = ScratchVar(TealType.uint64)
        start = If(x < y, Seq(a.store(y), b.store(x)), Seq(a.store(x), b.store(y)))
        cond = b.load() > Int(0)
        step = Seq(
            tmp.store(b.load()), b.store(Mod(a.load(), b.load())), a.store(tmp.load())
        )
        return Seq(For(start, cond, step).Do(Seq()), a.load())

    # generate a report with 400 = 20*20 dry run rows:
    N = 20
    inputs = list(
        product(
            tuple(random.randint(0, 1000) for _ in range(N)),
            tuple(random.randint(0, 1000) for _ in range(N)),
        )
    )

    def test_and_report(version: int):
        # assert that each result is that same as what Python's math.gcd() computes
        inspectors = PyTealDryRunExecutor(euclid, Mode.Application).dryrun_sequence(
            inputs, compiler_version=version
        )
        for i, result in enumerate(inspectors):
            args = inputs[i]
            assert result.stack_top() == math.gcd(*args), result.report(
                args, f"failed for {args}"
            )

        # save the CSV to ...current working directory.../euclid_v{version}.csv
        euclid_csv = DryRunInspector.csv_report(inputs, inspectors)
        with open(Path.cwd() / f"euclid_v{version}.csv", "w") as f:
            f.write(euclid_csv)

        return inspectors

    inspectors6 = test_and_report(6)
    inspectors8 = test_and_report(8)
    Invariant.full_validation(
        APP_IDENTICAL_PREDICATES,
        inspectors=inspectors6,
        identities=inspectors8,
        msg="example 2",
    )


def blackbox_pyteal_example3():
    # Example 3: declarative Test Driven Development approach through Invariant's
    from itertools import product
    import math
    import random

    from graviton.blackbox import DryRunEncoder
    from graviton.inspector import DryRunProperty as DRProp
    from graviton.invariant import Invariant

    from pyteal import If, Int, Mod, Mode, Subroutine, TealType

    from tests.blackbox import Blackbox

    # avoid flaky tests just in case I was wrong about the stack height invariant...
    random.seed(42)

    # helper that will be used for scratch-slots invariant:
    def is_subdict(x, y):
        return all(k in y and x[k] == y[k] for k in x)

    predicates = {
        # the program's log should be the hex encoding of Python's math.gcd:
        DRProp.lastLog: lambda args: (
            DryRunEncoder.hex(math.gcd(*args)) if math.gcd(*args) else None
        ),
        # the program's scratch should contain math.gcd() at slot 0:
        DRProp.finalScratch: lambda args, actual: is_subdict(
            {0: math.gcd(*args)}, actual
        ),
        # the top of the stack should be math.gcd():
        DRProp.stackTop: lambda args: math.gcd(*args),
        # Making the rather weak assertion that the max stack height is between 2 and 3*log2(max(args)):
        DRProp.maxStackHeight: (
            lambda args, actual: 2
            <= actual
            <= 3 * math.ceil(math.log2(max(args + (1,))))
        ),
        # the program PASS'es exactly for non-0 math.gcd (3 variants):
        DRProp.status: lambda args: "PASS" if math.gcd(*args) else "REJECT",
        DRProp.passed: lambda args: bool(math.gcd(*args)),
        DRProp.rejected: lambda args: not bool(math.gcd(*args)),
        # the program never errors:
        DRProp.errorMessage: None,
    }

    # Define a scenario 400 random pairs (x,y) as inputs:
    N = 20
    inputs = list(
        product(
            tuple(random.randint(0, 1000) for _ in range(N)),
            tuple(random.randint(0, 1000) for _ in range(N)),
        )
    )

    # GCD via the Euclidean Algorithm (recursive version):
    @Blackbox(input_types=[TealType.uint64, TealType.uint64])
    @Subroutine(TealType.uint64)
    def euclid(x, y):
        return (
            If(x < y)
            .Then(euclid(y, x))
            .Else(If(y == Int(0)).Then(x).Else(euclid(y, Mod(x, y))))
        )

    # Execute on the input sequence to get a dry-run inspectors:
    inspectors6 = PyTealDryRunExecutor(euclid, Mode.Application).dryrun_sequence(
        inputs, compiler_version=6
    )

    # Assert that each invariant holds on the sequences of inputs and dry-runs:
    for property, predicate in predicates.items():
        Invariant(predicate).validates(property, inspectors6)

    # Execute on the input sequence to get a dry-run inspectors:
    inspectors8 = PyTealDryRunExecutor(euclid, Mode.Application).dryrun_sequence(
        inputs, compiler_version=8
    )

    # Assert that each invariant holds on the sequences of inputs and dry-runs:
    for property, predicate in predicates.items():
        Invariant(predicate).validates(property, inspectors8)

    Invariant.full_validation(
        APP_IDENTICAL_PREDICATES,
        inspectors=inspectors6,
        identities=inspectors8,
        msg="Mode.Application example 3",
    )

    # Assert that each invariant holds on the sequences of inputs and dry-runs:
    for property, predicate in predicates.items():
        Invariant(predicate).validates(property, inspectors8)

    Invariant.full_validation(
        APP_IDENTICAL_PREDICATES,
        inspectors=inspectors6,
        identities=inspectors8,
        msg="Mode.Application example 3",
    )


def blackbox_pyteal_example4():
    # Example 4: Using PyTealDryRunExecutor to debug an ABIReturnSubroutine with an app, logic sig and csv report
    from pathlib import Path
    import random

    from graviton.blackbox import DryRunInspector

    from pyteal import (
        abi,
        ABIReturnSubroutine,
        Expr,
        For,
        Int,
        Mode,
        ScratchVar,
        Seq,
        TealType,
    )

    from tests.blackbox import Blackbox, PyTealDryRunExecutor

    # Sum a dynamic uint64 array
    @Blackbox(input_types=[None])
    @ABIReturnSubroutine
    def abi_sum(toSum: abi.DynamicArray[abi.Uint64], *, output: abi.Uint64) -> Expr:
        i = ScratchVar(TealType.uint64)
        valueAtIndex = abi.Uint64()
        return Seq(
            output.set(0),
            For(
                i.store(Int(0)),
                i.load() < toSum.length(),
                i.store(i.load() + Int(1)),
            ).Do(
                Seq(
                    toSum[i.load()].store_into(valueAtIndex),
                    output.set(output.get() + valueAtIndex.get()),
                )
            ),
        )

    # instantiate PyTealDryRunExecutor objects for the app and lsig:
    app_pytealer = PyTealDryRunExecutor(abi_sum, Mode.Application)
    lsig_pytealer = PyTealDryRunExecutor(abi_sum, Mode.Signature)

    # generate reports with the same random inputs (fix the randomness with a seed):
    random.seed(42)

    N = 50  # the number of dry runs for each experiment
    choices = range(10_000)
    inputs = []
    for n in range(N):
        inputs.append(tuple([random.sample(choices, n)]))

    def test_and_report_for_app_and_lsig(_version: int):
        app_inspectors = app_pytealer.dryrun_sequence(inputs, compiler_version=_version)
        lsig_inspectors = lsig_pytealer.dryrun_sequence(
            inputs, compiler_version=_version
        )
        for i in range(N):
            args = inputs[i]

            app_inspector = app_inspectors[i]
            lsig_inspector = lsig_inspectors[i]

            def message(insp):
                return insp.report(args, f"failed for {args}", row=i)

            # the app should pass exactly when it's cost was within the 700 budget:
            assert app_inspector.passed() == (app_inspector.cost() <= 700), message(
                app_inspector
            )
            # the lsig always passes (never goes over budget):
            assert lsig_inspector.passed(), message(lsig_inspector)

            expected = sum(args[0])
            actual4app = app_inspector.last_log()
            assert expected == actual4app, message(app_inspector)

            if i > 0:
                assert expected in app_inspector.final_scratch().values(), message(
                    app_inspector
                )
                assert expected in lsig_inspector.final_scratch().values(), message(
                    lsig_inspector
                )

        def report(kind):
            assert kind in ("app", "lsig")
            insps = app_inspectors if kind == "app" else lsig_inspectors
            csv_report = DryRunInspector.csv_report(inputs, insps)
            with open(Path.cwd() / f"abi_sum_{kind}_v{_version}.csv", "w") as f:
                f.write(csv_report)

        report("app")
        report("lsig")

        return app_inspectors, lsig_inspectors

    app_inspectors6, lsig_inspectors6 = test_and_report_for_app_and_lsig(6)
    app_inspectors8, lsig_inspectors8 = test_and_report_for_app_and_lsig(8)
    Invariant.full_validation(
        APP_IDENTICAL_PREDICATES,
        inspectors=app_inspectors6,
        identities=app_inspectors8,
        msg=f"Mode.Application example 4 {abi_sum.name()=}",
    )
    Invariant.full_validation(
        LSIG_IDENTICAL_PREDICATES,
        inspectors=lsig_inspectors6,
        identities=lsig_inspectors8,
        msg=f"Mode.Signature example 4 {abi_sum.name()=}",
    )


def blackbox_pyteal_example5():
    from graviton.blackbox import DryRunEncoder

    from pyteal import abi, Subroutine, TealType, Int, Mode
    from tests.blackbox import Blackbox

    @Blackbox([None])
    @Subroutine(TealType.uint64)
    def cubed(n: abi.Uint64):
        return n.get() ** Int(3)

    app_pytealer = PyTealDryRunExecutor(cubed, Mode.Application)
    lsig_pytealer = PyTealDryRunExecutor(cubed, Mode.Signature)

    inputs = [(i,) for i in range(1, 11)]

    def test_app_and_lsig(_version: int):
        app_inspect = app_pytealer.dryrun_sequence(inputs, compiler_version=_version)
        lsig_inspect = lsig_pytealer.dryrun_sequence(inputs, compiler_version=_version)

        for index, inspect in enumerate(app_inspect):
            input_var = inputs[index][0]
            assert inspect.stack_top() == input_var**3, inspect.report(
                args=inputs[index], msg="stack_top() gave unexpected results from app"
            )
            assert inspect.last_log() == DryRunEncoder.hex(
                input_var**3
            ), inspect.report(
                args=inputs[index], msg="last_log() gave unexpected results from app"
            )

        for index, inspect in enumerate(lsig_inspect):
            input_var = inputs[index][0]
            assert inspect.stack_top() == input_var**3, inspect.report(
                args=inputs[index], msg="stack_top() gave unexpected results from app"
            )
        return app_inspect, lsig_inspect

    app_inspectors6, lsig_inspectors6 = test_app_and_lsig(6)
    app_inspectors8, lsig_inspectors8 = test_app_and_lsig(8)
    Invariant.full_validation(
        APP_IDENTICAL_PREDICATES,
        inspectors=app_inspectors6,
        identities=app_inspectors8,
        msg="Mode.Application example 5",
    )
    Invariant.full_validation(
        LSIG_IDENTICAL_PREDICATES,
        inspectors=lsig_inspectors6,
        identities=lsig_inspectors8,
        msg="Mode.Signature example 5",
    )


def blackbox_pyteal_while_continue_test():
    from tests.blackbox import Blackbox
    from pyteal import (
        Continue,
        Int,
        Mode,
        Return,
        ScratchVar,
        Seq,
        Subroutine,
        TealType,
        While,
    )

    @Blackbox(input_types=[TealType.uint64])
    @Subroutine(TealType.uint64)
    def while_continue_accumulation(n):
        i = ScratchVar(TealType.uint64)
        return Seq(
            i.store(Int(0)),
            While(i.load() < n).Do(
                Seq(
                    i.store(i.load() + Int(1)),
                    Continue(),
                )
            ),
            Return(i.load()),
        )

    executor = PyTealDryRunExecutor(while_continue_accumulation, Mode.Signature)

    for x in range(30):
        args = [x]
        lsig_result = executor.dryrun_one(args)
        if x == 0:
            assert not lsig_result.passed()
        else:
            assert lsig_result.passed()

        assert lsig_result.stack_top() == x, lsig_result.report(
            args, "stack_top() gave unexpected results for lsig"
        )

        lsig_result = executor.dryrun_one(args, compiler_version=8)
        if x == 0:
            assert not lsig_result.passed()
        else:
            assert lsig_result.passed()

        assert lsig_result.stack_top() == x, lsig_result.report(
            args, "stack_top() gave unexpected results for lsig"
        )


def blackbox_pyteal_named_tupleness_test():
    from typing import Literal as L
    from tests.blackbox import Blackbox
    from pyteal import (
        Seq,
        abi,
        Subroutine,
        TealType,
        Return,
        And,
        Mode,
    )

    class NamedTupleExample(abi.NamedTuple):
        a: abi.Field[abi.Bool]
        b: abi.Field[abi.Address]
        c: abi.Field[abi.Tuple2[abi.Uint64, abi.Bool]]
        d: abi.Field[abi.StaticArray[abi.Byte, L[10]]]
        e: abi.Field[abi.StaticArray[abi.Bool, L[4]]]
        f: abi.Field[abi.Uint64]

    @Blackbox(input_types=[None] * 6)
    @Subroutine(TealType.uint64)
    def named_tuple_field_access(
        a_0: abi.Bool,
        a_1: abi.Address,
        a_2: abi.Tuple2[abi.Uint64, abi.Bool],
        a_3: abi.StaticArray[abi.Byte, L[10]],
        a_4: abi.StaticArray[abi.Bool, L[4]],
        a_5: abi.Uint64,
    ):
        return Seq(
            (v_tuple := NamedTupleExample()).set(a_0, a_1, a_2, a_3, a_4, a_5),
            (v_a := abi.Bool()).set(v_tuple.a),
            (v_b := abi.Address()).set(v_tuple.b),
            (v_c := abi.make(abi.Tuple2[abi.Uint64, abi.Bool])).set(v_tuple.c),
            (v_d := abi.make(abi.StaticArray[abi.Byte, L[10]])).set(v_tuple.d),
            (v_e := abi.make(abi.StaticArray[abi.Bool, L[4]])).set(v_tuple.e),
            (v_f := abi.Uint64()).set(v_tuple.f),
            Return(
                And(
                    a_0.get() == v_a.get(),
                    a_1.get() == v_b.get(),
                    a_2.encode() == v_c.encode(),
                    a_3.encode() == v_d.encode(),
                    a_4.encode() == v_e.encode(),
                    a_5.get() == v_f.get(),
                )
            ),
        )

    lsig_pytealer = PyTealDryRunExecutor(named_tuple_field_access, Mode.Signature)
    args = (False, b"1" * 32, (0, False), b"0" * 10, [True] * 4, 0)

    inspector6 = lsig_pytealer.dryrun_one(args, compiler_version=6)

    assert inspector6.stack_top() == 1
    assert inspector6.passed()

    inspector8 = lsig_pytealer.dryrun_one(args, compiler_version=8)
    assert inspector8.passed()
    assert inspector8.stack_top() == 1

    Invariant.full_validation(
        LSIG_IDENTICAL_PREDICATES,
        inspectors=[inspector6],
        identities=[inspector8],
        msg="Mode.Signature NamedTuple example",
    )

    inspector = lsig_pytealer.dryrun_one(args, compiler_version=8)
    assert inspector.passed()
    assert inspector.stack_top() == 1

    Invariant.full_validation(
        LSIG_IDENTICAL_PREDICATES,
        inspectors=[inspector6],
        identities=[inspector8],
        msg="Mode.Signature NamedTuple example",
    )


@pytest.mark.parametrize(
    "example",
    [
        blackbox_pyteal_example1,
        blackbox_pyteal_example2,
        blackbox_pyteal_example3,
        blackbox_pyteal_example4,
        blackbox_pyteal_example5,
        blackbox_pyteal_while_continue_test,
        blackbox_pyteal_named_tupleness_test,
    ],
)
def test_blackbox_pyteal_examples(example):
    example()



================================================
FILE: tests/integration/opup_test.py
================================================
import graviton.models
import pytest
import math

from typing import cast
import pyteal as pt
from tests.blackbox import (
    Blackbox,
    BlackboxWrapper,
    PyTealDryRunExecutor,
)
from graviton.blackbox import (
    DryRunExecutor,
    DryRunInspector,
    DryRunTransactionParams as TxParams,
)

from algosdk.v2client.models import Account
import algosdk


def _dryrun(
    bw: BlackboxWrapper,
    sp: algosdk.transaction.SuggestedParams,
    accounts: list[Account | str],
) -> DryRunInspector:
    return PyTealDryRunExecutor(bw, pt.Mode.Application).dryrun_one(
        [],
        compiler_version=pt.compiler.MAX_PROGRAM_VERSION,
        txn_params=TxParams.for_app(
            sender=graviton.models.ZERO_ADDRESS,
            sp=sp,
            index=DryRunExecutor.EXISTING_APP_CALL,
            on_complete=algosdk.transaction.OnComplete.NoOpOC,
            dryrun_accounts=accounts,
        ),
    )


_application_opcode_budget = 700


@pytest.mark.parametrize("source", pt.OpUpFeeSource)
@pytest.mark.parametrize("inner_txn_count", range(1, 5))
@pytest.mark.parametrize("with_funding", [True, False])
@pytest.mark.serial  # Serial due to reused account + application state
def test_opup_maximize_budget(
    source: pt.OpUpFeeSource, inner_txn_count: int, with_funding: bool
):
    innerTxnFeeMicroAlgos = inner_txn_count * algosdk.constants.min_txn_fee

    @Blackbox(input_types=[])
    @pt.Subroutine(pt.TealType.uint64)
    def maximize_budget():
        return pt.Seq(
            pt.OpUp(mode=pt.OpUpMode.OnCall).maximize_budget(
                pt.Int(innerTxnFeeMicroAlgos), source
            ),
            pt.Global.opcode_budget(),
        )

    if with_funding:
        accounts: list[Account | str] = (
            [
                Account(
                    address=algosdk.logic.get_application_address(
                        DryRunExecutor.EXISTING_APP_CALL
                    ),
                    status="Offline",
                    amount=innerTxnFeeMicroAlgos,
                    amount_without_pending_rewards=innerTxnFeeMicroAlgos,
                )
            ]
            if source == pt.OpUpFeeSource.AppAccount
            else []
        )

        sp = DryRunExecutor.SUGGESTED_PARAMS
        sp.fee = (
            innerTxnFeeMicroAlgos + algosdk.constants.min_txn_fee
            if source == pt.OpUpFeeSource.GroupCredit
            else sp.fee
        )

        result = _dryrun(maximize_budget, sp, accounts)

        assert result.passed()
        assert result.budget_added() == _application_opcode_budget * inner_txn_count
    else:
        # Withholding account and/or transaction fee funding fails the
        # transaction.
        sp = DryRunExecutor.SUGGESTED_PARAMS
        sp.flat_fee = True
        sp.fee = algosdk.constants.min_txn_fee
        result = _dryrun(maximize_budget, DryRunExecutor.SUGGESTED_PARAMS, [])
        assert not result.passed()


@pytest.mark.parametrize("source", [f for f in pt.OpUpFeeSource])
@pytest.mark.parametrize("budget_added", range(1_000, 20_000, 2_500))
@pytest.mark.parametrize("with_funding", [True, False])
@pytest.mark.serial  # Serial due to reused account + application state
def test_opup_ensure_budget(
    source: pt.OpUpFeeSource, budget_added: int, with_funding: bool
):
    inner_txn_count = math.ceil(budget_added / _application_opcode_budget)
    innerTxnFeeMicroAlgos = (
        inner_txn_count * algosdk.constants.min_txn_fee + algosdk.constants.min_txn_fee
    )
    dryrun_starting_budget = 70_000  # https://github.com/algorand/go-algorand/blob/3a5e5847bebc21bfcae1f5fe056a78067b16c781/daemon/algod/api/server/v2/dryrun.go#L408

    @Blackbox(input_types=[])
    @pt.Subroutine(pt.TealType.uint64)
    def ensure_budget():
        return pt.Seq(
            pt.OpUp(mode=pt.OpUpMode.OnCall).ensure_budget(
                pt.Int(dryrun_starting_budget + budget_added), source
            ),
            pt.Global.opcode_budget(),
        )

    if with_funding:
        accounts: list[Account | str] = (
            [
                Account(
                    address=algosdk.logic.get_application_address(
                        DryRunExecutor.EXISTING_APP_CALL
                    ),
                    status="Offline",
                    amount=innerTxnFeeMicroAlgos,
                    amount_without_pending_rewards=innerTxnFeeMicroAlgos,
                )
            ]
            if source == pt.OpUpFeeSource.AppAccount
            else []
        )

        sp = DryRunExecutor.SUGGESTED_PARAMS
        sp.fee = (
            innerTxnFeeMicroAlgos + algosdk.constants.min_txn_fee
            if source == pt.OpUpFeeSource.GroupCredit
            else sp.fee
        )

        result = _dryrun(ensure_budget, sp, accounts)

        assert result.passed(), result.report()
        # Since ensure_budget guarantees _at least_ the required budget, the
        # assertions confirm minimum expected budget added without significantly
        # overshooting the mark.
        actual = cast(int, result.budget_added())
        threshold = _application_opcode_budget * inner_txn_count
        assert threshold <= actual <= threshold + _application_opcode_budget
    else:
        # Withholding account and/or transaction fee funding fails the
        # transaction.
        sp = DryRunExecutor.SUGGESTED_PARAMS
        sp.flat_fee = True
        sp.fee = algosdk.constants.min_txn_fee
        result = _dryrun(ensure_budget, DryRunExecutor.SUGGESTED_PARAMS, [])
        assert not result.passed()



================================================
FILE: tests/integration/pure_logicsig_test.py
================================================
from itertools import product
from os import environ
from pathlib import Path
import pytest

from pyteal import compileTeal, Mode

import examples.signature.factorizer_game as factorizer

from tests.blackbox import algod_with_assertion
from graviton.blackbox import (
    DryRunExecutor,
    ExecutionMode,
    DryRunTransactionParams as TxParams,
)
from graviton.inspector import DryRunInspector as Inspector, DryRunProperty as DRProp
from graviton.invariant import Invariant

REPORTS_DIR = Path.cwd() / "tests" / "integration" / "reports"
ALGOD = algod_with_assertion()

DEFAULT = {
    "A": 3,
    "P": 5,  # 13
    "Q": 7,  # 13
    "M": 5,  # 10
    "N": 5,  # 10
}


def get_param_bounds():
    """
    Allow setting the bounds either from the environment via something like:

    % A=3 P=13 Q=13 M=10 N=10 pytest tests/integration/pure_logicsig_test.py::test_many_factorizer_games

    OR - when any of the above is missing, replace with the default version
    """
    vars = []
    for var in ("A", "P", "Q", "M", "N"):
        val = environ.get(var)
        if val is None:
            val = DEFAULT[var]
        vars.append(int(val))
    return vars


def get_factorizer_param_sequence():
    A, P, Q, M, N = get_param_bounds()
    return [(a, p, q, M, N) for a in range(A) for p in range(P) for q in range(Q)]


def inputs_for_coefficients(a, p, q, M, N):
    # TODO: this should really be focused around the roots p and q
    return product(range(M), range(N))


def factorizer_game_check(a: int, p: int, q: int, M: int, N: int):
    ae = None
    if a <= 0 or p < 0 or q <= p:
        with pytest.raises(AssertionError) as ae:
            factorizer.logicsig(a, p, q),

    if ae:
        return

    compiled = compileTeal(
        factorizer.logicsig(a, p, q),
        version=6,
        mode=Mode.Signature,
        assembleConstants=True,
    )
    executor = DryRunExecutor(ALGOD, ExecutionMode.Signature, compiled)

    inputs = list(inputs_for_coefficients(a, p, q, M, N))
    N = len(inputs)

    def poly(x):
        return abs(a * x**2 - a * (p + q) * x + a * p * q)

    def naive_prize(x, y):
        return 1_000_000 * max(10 - (sum(map(poly, (x, y))) + 1) // 2, 0)

    def payment_amount(x, y):
        return 0 if x == y else naive_prize(x, y)

    amts = list(map(lambda args: payment_amount(*args), inputs))

    inspectors, txns = [], []
    for args, amt in zip(inputs, amts):
        txn = {"amt": amt}
        txns.append(txn)
        inspectors.append(
            executor.run_one(args, txn_params=TxParams(**txn)),
        )

    print(
        f"generating a report for (a,p,q) = {a, p, q} with {M, N} dry-run calls and spreadsheet rows"
    )
    filebase = f"factorizer_game_{a}_{p}_{q}"

    reports_dir = REPORTS_DIR / "pure_logicsig"
    reports_dir.mkdir(parents=True, exist_ok=True)
    csvpath = reports_dir / f"{filebase}.csv"
    with open(csvpath, "w") as f:
        f.write(Inspector.csv_report(inputs, inspectors, txns=txns))

    print(
        f"validating passing_invariant for (a,p,q) = {a, p, q} over {N} dry-run calls"
    )
    passing_invariant = Invariant(
        lambda args: bool(payment_amount(*args)),
        name=f"passing invariant for coeffs {a, p, q}",
    )
    passing_invariant.validates(DRProp.passed, inspectors)

    print(
        f"validate procedurally that payment amount as expected for (a,p,q) = {a, p, q} over {M, N} dry-rundry-run calls"
    )

    for args, inspector in zip(inputs, inspectors):
        x, y = args
        eprize = naive_prize(x, y)
        final_scratches = inspector.final_scratch().values()
        assert eprize == 0 or eprize in final_scratches, inspector.report(
            args,
            f"(a, p, q, x, y) = {a, p, q, x, y}. final scratch slots expected to contain {eprize} v. actual={final_scratches}",
        )


@pytest.mark.parametrize("a, p, q, M, N", get_factorizer_param_sequence())
def test_many_factorizer_games(a: int, p: int, q: int, M: int, N: int):
    factorizer_game_check(a, p, q, M, N)



================================================
FILE: tests/integration/sourcemap_monkey_integ_test.py
================================================
from importlib import import_module
from itertools import product
from pathlib import Path

import pytest

from feature_gates import FeatureGates

"""
Tests run with a fixture that enables the sourcemap
via feature gate.
"""


STABLE_SLOT_GENERATION = (
    False  # The second router is flaky due to issue 199, so skipping for now
)
FIXTURES = Path.cwd() / "tests" / "integration" / "teal" / "annotated"

ROUTERS = [
    ("examples.application.abi.algobank", "router"),
    ("pyteal.compiler.compiler_test", "FIRST_ROUTER"),
]

if not STABLE_SLOT_GENERATION:
    del ROUTERS[1]


@pytest.fixture
def sourcemap_enabled():
    previous = FeatureGates.sourcemap_enabled()
    FeatureGates.set_sourcemap_enabled(True)
    yield
    FeatureGates.set_sourcemap_enabled(previous)


@pytest.mark.skipif(not STABLE_SLOT_GENERATION, reason="cf. #199")
@pytest.mark.serial
@pytest.mark.parametrize("path, obj", ROUTERS)
@pytest.mark.parametrize("annotate_teal_headers", [True, False])
@pytest.mark.parametrize("annotate_teal_concise", [True, False])
def test_sourcemap_annotate(
    sourcemap_enabled, path, obj, annotate_teal_headers, annotate_teal_concise
):
    from pyteal import OptimizeOptions

    router = getattr(import_module(path), obj)

    a_fname, c_fname = "A.teal", "C.teal"
    compile_bundle = router.compile(
        version=6,
        optimize=OptimizeOptions(scratch_slots=True),
        assemble_constants=False,
        with_sourcemaps=True,
        approval_filename=a_fname,
        clear_filename=c_fname,
        pcs_in_sourcemap=True,
        annotate_teal=True,
        annotate_teal_headers=annotate_teal_headers,
        annotate_teal_concise=annotate_teal_concise,
    )

    CL = 50  # COMPILATION LINE right before this
    CFILE = "tests/integration/sourcemap_monkey_integ_test.py"  # this file
    COMPILE = "router.compile(version=6, optimize=OptimizeOptions(scratch_slots=True), assemble_constants=False, with_sourcemaps=True, approval_filename=a_fname, clear_filename=c_fname, pcs_in_sourcemap=True, annotate_teal=True, annotate_teal_headers=annotate_teal_headers, annotate_teal_concise=annotate_teal_concise)"
    BCAs = "BareCallActions(no_op=OnCompleteAction(action=Approve(), call_config=CallConfig.CREATE), opt_in=OnCompleteAction(action=Approve(), call_config=CallConfig.ALL), close_out=OnCompleteAction(action=transfer_balance_to_lost, call_config=CallConfig.CALL), update_application=OnCompleteAction(action=assert_sender_is_creator, call_config=CallConfig.CALL), delete_application=OnCompleteAction(action=assert_sender_is_creator, call_config=CallConfig.CALL))"
    INNERTXN = "InnerTxnBuilder.SetFields({TxnField.type_enum: TxnType.Payment, TxnField.receiver: recipient.address(), TxnField.amount: amount.get(), TxnField.fee: Int(0)})"

    with_headers_int = int(annotate_teal_headers)
    concise_int = int(annotate_teal_concise)
    with open(
        FIXTURES / f"{router.name}_h{with_headers_int}_c{concise_int}.tealf"
    ) as f:
        tealf = f.read()

    # less confident that this annotated teal will remain identical in 310, but for now it's working:
    EXPECTED_ANNOTATED_TEAL_311 = tealf.format(
        CFILE=CFILE,
        CL=CL,
        COMPILE=COMPILE,
        BCAs=BCAs,
        INNERTXN=INNERTXN,
    ).strip()

    annotated_approval, annotated_clear = (
        compile_bundle.approval_sourcemap.annotated_teal,
        compile_bundle.clear_sourcemap.annotated_teal,
    )
    assert annotated_approval
    assert annotated_clear

    the_same = EXPECTED_ANNOTATED_TEAL_311 == annotated_approval
    print(f"{annotated_approval.splitlines()=}")
    assert the_same, first_diff(EXPECTED_ANNOTATED_TEAL_311, annotated_approval)

    raw_approval_lines, raw_clear_lines = (
        compile_bundle.approval_teal.splitlines(),
        compile_bundle.clear_teal.splitlines(),
    )

    ann_approval_lines, ann_clear_lines = (
        annotated_approval.splitlines(),
        annotated_clear.splitlines(),
    )

    assert len(raw_approval_lines) + with_headers_int == len(ann_approval_lines)
    assert len(raw_clear_lines) + with_headers_int == len(ann_clear_lines)

    for i, raw_line in enumerate(raw_approval_lines):
        assert ann_approval_lines[i + with_headers_int].startswith(raw_line)

    for i, raw_line in enumerate(raw_clear_lines):
        assert ann_clear_lines[i + with_headers_int].startswith(raw_line)


def first_diff(expected, actual):
    alines = actual.splitlines()
    elines = expected.splitlines()
    for i, e in enumerate(elines):
        if i >= len(alines):
            return f"""LINE[{i + 1}] missing from actual:
{e}"""
        if e != (a := alines[i]):
            return f"""LINE[{i + 1}]
{e}
VS.
{a}
"""
    if len(alines) > len(elines):
        return f"""LINE[{len(elines) + 1}] missing from expected:
{alines[len(elines)]}"""

    return ""


def assert_lines_start_with(prefixes, lines):
    assert len(prefixes) == len(lines)
    for prefix, line in zip(prefixes, lines):
        assert line.startswith(prefix)


@pytest.mark.skipif(not STABLE_SLOT_GENERATION, reason="cf. #199")
@pytest.mark.serial
def test_no_regressions_via_fixtures_algobank(sourcemap_enabled):
    import pyteal as pt

    module_path, obj = ROUTERS[0]
    algobank_router = getattr(import_module(module_path), obj)
    assert algobank_router.name == "AlgoBank"

    first_approval, first_clear, _ = algobank_router.compile_program(
        version=6, optimize=pt.OptimizeOptions(scratch_slots=True)
    )

    algobank_path = Path.cwd() / "examples" / "application" / "abi"

    with open(algobank_path / "algobank_approval.teal") as f:
        expected_approval = f.read()

    with open(algobank_path / "algobank_clear_state.teal") as f:
        expected_clear = f.read()

    assert expected_approval == first_approval
    assert expected_clear == first_clear

    bundle = algobank_router.compile(
        version=6,
        optimize=pt.OptimizeOptions(scratch_slots=True),
    )
    assert expected_approval == bundle.approval_teal
    assert expected_clear == bundle.clear_teal

    assert first_approval == bundle.approval_teal
    assert first_clear == bundle.clear_teal

    assert bundle.approval_sourcemap is None
    assert bundle.clear_sourcemap is None

    expected_approval_prefixes = expected_approval.splitlines()
    expected_clear_prefixes = expected_clear.splitlines()

    first_approval_prefixes = first_approval.splitlines()
    first_clear_prefixes = first_clear.splitlines()

    def assert_didnt_regress(pcs, headers, concise):
        bundle = algobank_router.compile(
            version=6,
            optimize=pt.OptimizeOptions(scratch_slots=True),
            with_sourcemaps=True,
            pcs_in_sourcemap=pcs,
            annotate_teal=True,
            annotate_teal_headers=headers,
            annotate_teal_concise=concise,
        )
        assert expected_approval == bundle.approval_teal
        assert expected_clear == bundle.clear_teal

        current_approval_lines = bundle.approval_sourcemap.annotated_teal.splitlines()
        current_clear_lines = bundle.clear_sourcemap.annotated_teal.splitlines()

        if headers:
            del current_approval_lines[0]
            del current_clear_lines[0]

        assert_lines_start_with(expected_approval_prefixes, current_approval_lines)
        assert_lines_start_with(expected_clear_prefixes, current_clear_lines)
        assert_lines_start_with(first_approval_prefixes, current_approval_lines)
        assert_lines_start_with(first_clear_prefixes, current_clear_lines)

    for pcs, headers, concise in product([True, False], repeat=3):
        assert_didnt_regress(pcs, headers, concise)


RPS = Path.cwd() / "tests" / "teal"


@pytest.mark.serial
def test_no_regressions_via_fixtures_rps(sourcemap_enabled):
    import pyteal as pt
    from tests.teal.rps import approval_program

    actual_approval = pt.compileTeal(approval_program(), pt.Mode.Application, version=6)

    with open(RPS / "rps.teal") as f:
        expected_approval = f.read()

    assert expected_approval == actual_approval

    compilation = pt.Compilation(approval_program(), pt.Mode.Application, version=6)

    bundle = compilation.compile()

    assert expected_approval == bundle.teal

    assert bundle.sourcemap is None

    approval_prefixes = expected_approval.splitlines()

    def assert_didnt_regress(pcs, headers, concise):
        bundle = compilation.compile(
            with_sourcemap=True,
            pcs_in_sourcemap=pcs,
            annotate_teal=True,
            annotate_teal_headers=headers,
            annotate_teal_concise=concise,
        )
        assert expected_approval == bundle.teal

        actual_approval_lines = bundle.sourcemap.annotated_teal.splitlines()

        if headers:
            del actual_approval_lines[0]

        assert_lines_start_with(approval_prefixes, actual_approval_lines)

    for pcs, headers, concise in product([True, False], repeat=3):
        assert_didnt_regress(pcs, headers, concise)



================================================
FILE: tests/integration/teal/annotated/AlgoBank_h0_c0.tealf
================================================
#pragma version 6                      //  (0)    {CFILE}  {CL}   {COMPILE}
txn NumAppArgs                         //  (20)   examples/application/abi/algobank.py              19   {BCAs}
int 0                                  //  (22)
==                                     //  (23)
bnz main_l8                            //  (24)
txna ApplicationArgs 0                 //  (27)                                                     41   def deposit(payment: abi.PaymentTransaction, sender: abi.Account) -> Expr:
method "deposit(pay,account)void"      //  (30)
==                                     //  (36)
bnz main_l7                            //  (37)
txna ApplicationArgs 0                 //  (40)                                                     65   def getBalance(user: abi.Account, *, output: abi.Uint64) -> Expr:
method "getBalance(account)uint64"     //  (43)
==                                     //  (49)
bnz main_l6                            //  (50)
txna ApplicationArgs 0                 //  (53)                                                     78   def withdraw(amount: abi.Uint64, recipient: abi.Account) -> Expr:
method "withdraw(uint64,account)void"  //  (56)
==                                     //  (62)
bnz main_l5                            //  (63)
err                                    //  (66)   {CFILE}  {CL}   {COMPILE}
main_l5:                               //         examples/application/abi/algobank.py              78   def withdraw(amount: abi.Uint64, recipient: abi.Account) -> Expr:
txn OnCompletion                       //  (67)
int NoOp                               //  (69)
==                                     //  (70)
txn ApplicationID                      //  (71)
int 0                                  //  (73)
!=                                     //  (74)
&&                                     //  (75)
assert                                 //  (76)
txna ApplicationArgs 1                 //  (77)
btoi                                   //  (80)
store 5                                //  (81)
txna ApplicationArgs 2                 //  (83)
int 0                                  //  (86)
getbyte                                //  (87)
store 6                                //  (88)
load 5                                 //  (90)
load 6                                 //  (92)
callsub withdraw_3                     //  (94)
int 1                                  //  (97)
return                                 //  (98)
main_l6:                               //                                                           65   def getBalance(user: abi.Account, *, output: abi.Uint64) -> Expr:
txn OnCompletion                       //  (99)
int NoOp                               //  (101)
==                                     //  (102)
txn ApplicationID                      //  (103)
int 0                                  //  (105)
!=                                     //  (106)
&&                                     //  (107)
assert                                 //  (108)
txna ApplicationArgs 1                 //  (109)
int 0                                  //  (112)
getbyte                                //  (113)
callsub getBalance_2                   //  (114)
store 4                                //  (117)
byte 0x151f7c75                        //  (119)
load 4                                 //  (125)
itob                                   //  (127)
concat                                 //  (128)
log                                    //  (129)
int 1                                  //  (130)
return                                 //  (131)
main_l7:                               //                                                           41   def deposit(payment: abi.PaymentTransaction, sender: abi.Account) -> Expr:
txn OnCompletion                       //  (132)
int NoOp                               //  (134)
==                                     //  (135)
txn ApplicationID                      //  (136)
int 0                                  //  (138)
!=                                     //  (139)
&&                                     //  (140)
txn OnCompletion                       //  (141)
int OptIn                              //  (143)
==                                     //  (144)
txn ApplicationID                      //  (145)
int 0                                  //  (147)
!=                                     //  (148)
&&                                     //  (149)
||                                     //  (150)
assert                                 //  (151)
txna ApplicationArgs 1                 //  (152)
int 0                                  //  (155)
getbyte                                //  (156)
store 1                                //  (157)
txn GroupIndex                         //  (159)
int 1                                  //  (161)
-                                      //  (162)
store 0                                //  (163)
load 0                                 //  (165)  {CFILE}  {CL}   {COMPILE}
gtxns TypeEnum                         //  (167)  examples/application/abi/algobank.py              41   def deposit(payment: abi.PaymentTransaction, sender: abi.Account) -> Expr:
int pay                                //  (169)
==                                     //  (170)
assert                                 //  (171)
load 0                                 //  (172)
load 1                                 //  (174)
callsub deposit_1                      //  (176)
int 1                                  //  (179)
return                                 //  (180)
main_l8:                               //                                                           21   OnCompleteAction(action=Approve(), call_config=CallConfig.CREATE)
txn OnCompletion                       //  (181)
int NoOp                               //  (183)
==                                     //  (184)
bnz main_l18                           //  (185)
txn OnCompletion                       //  (188)                                                    23   OnCompleteAction(action=Approve(), call_config=CallConfig.ALL)
int OptIn                              //  (190)
==                                     //  (191)
bnz main_l17                           //  (192)
txn OnCompletion                       //  (195)                                                    25   OnCompleteAction(action=transfer_balance_to_lost, call_config=CallConfig.CALL)
int CloseOut                           //  (197)
==                                     //  (199)
bnz main_l16                           //  (200)
txn OnCompletion                       //  (203)                                                    29   OnCompleteAction(action=assert_sender_is_creator, call_config=CallConfig.CALL)
int UpdateApplication                  //  (205)
==                                     //  (207)
bnz main_l15                           //  (208)
txn OnCompletion                       //  (211)                                                    32   OnCompleteAction(action=assert_sender_is_creator, call_config=CallConfig.CALL)
int DeleteApplication                  //  (213)
==                                     //  (215)
bnz main_l14                           //  (216)
err                                    //  (219)                                                    19   {BCAs}
main_l14:                              //                                                           32   OnCompleteAction(action=assert_sender_is_creator, call_config=CallConfig.CALL)
txn ApplicationID                      //  (220)
int 0                                  //  (222)
!=                                     //  (223)
assert                                 //  (224)
callsub assertsenderiscreator_0        //  (225)
int 1                                  //  (228)
return                                 //  (229)
main_l15:                              //                                                           29   OnCompleteAction(action=assert_sender_is_creator, call_config=CallConfig.CALL)
txn ApplicationID                      //  (230)
int 0                                  //  (232)
!=                                     //  (233)
assert                                 //  (234)
callsub assertsenderiscreator_0        //  (235)
int 1                                  //  (238)
return                                 //  (239)
main_l16:                              //                                                           25   OnCompleteAction(action=transfer_balance_to_lost, call_config=CallConfig.CALL)
txn ApplicationID                      //  (240)
int 0                                  //  (242)
!=                                     //  (243)
assert                                 //  (244)
byte "lost"                            //  (245)                                                    13   Bytes('lost')
byte "lost"                            //  (246)                                                    14   Bytes('lost')
app_global_get                         //  (247)                                                         App.globalGet(Bytes('lost'))
txn Sender                             //  (248)                                                         Txn.sender()
byte "balance"                         //  (250)                                                         Bytes('balance')
app_local_get                          //  (251)                                                         App.localGet(Txn.sender(), Bytes('balance'))
+                                      //  (252)                                                         App.globalGet(Bytes('lost')) + App.localGet(Txn.sender(), Bytes('balance'))
app_global_put                         //  (253)                                                    12   App.globalPut(Bytes('lost'), App.globalGet(Bytes('lost')) + App.localGet(Txn.sender(), Bytes('balance')))
int 1                                  //  (254)                                                    25   OnCompleteAction(action=transfer_balance_to_lost, call_config=CallConfig.CALL)
return                                 //  (255)
main_l17:                              //                                                           23   OnCompleteAction(action=Approve(), call_config=CallConfig.ALL)
int 1                                  //  (256)                                                         Approve()
return                                 //  (257)
main_l18:                              //                                                           21   OnCompleteAction(action=Approve(), call_config=CallConfig.CREATE)
txn ApplicationID                      //  (258)
int 0                                  //  (260)
==                                     //  (261)
assert                                 //  (262)
int 1                                  //  (263)                                                         Approve()
return                                 //  (264)
                                       //                                                           7    def assert_sender_is_creator() -> Expr:
// assert_sender_is_creator            //
assertsenderiscreator_0:               //
txn Sender                             //  (265)                                                    8    Txn.sender()
global CreatorAddress                  //  (267)                                                         Global.creator_address()
==                                     //  (269)                                                         Txn.sender() == Global.creator_address()
assert                                 //  (270)                                                         Assert(Txn.sender() == Global.creator_address())
retsub                                 //  (271)                                                    7    def assert_sender_is_creator() -> Expr:
                                       //                                                           41   def deposit(payment: abi.PaymentTransaction, sender: abi.Account) -> Expr:
// deposit                             //
deposit_1:                             //
store 3                                //  (272)
store 2                                //  (274)
load 2                                 //  (276)                                                    54   payment.get()
gtxns Sender                           //  (278)                                                         payment.get().sender()
load 3                                 //  (280)                                                         sender.address()
txnas Accounts                         //  (282)
==                                     //  (284)                                                         payment.get().sender() == sender.address()
assert                                 //  (285)                                                         Assert(payment.get().sender() == sender.address())
load 2                                 //  (286)                                                    55   payment.get()
gtxns Receiver                         //  (288)                                                         payment.get().receiver()
global CurrentApplicationAddress       //  (290)                                                         Global.current_application_address()
==                                     //  (292)                                                         payment.get().receiver() == Global.current_application_address()
assert                                 //  (293)                                                         Assert(payment.get().receiver() == Global.current_application_address())
load 3                                 //  (294)                                                    57   sender.address()
txnas Accounts                         //  (296)
byte "balance"                         //  (298)                                                    58   Bytes('balance')
load 3                                 //  (299)                                                    59   sender.address()
txnas Accounts                         //  (301)
byte "balance"                         //  (303)                                                         Bytes('balance')
app_local_get                          //  (304)                                                         App.localGet(sender.address(), Bytes('balance'))
load 2                                 //  (305)                                                         payment.get()
gtxns Amount                           //  (307)                                                         payment.get().amount()
+                                      //  (309)                                                         App.localGet(sender.address(), Bytes('balance')) + payment.get().amount()
app_local_put                          //  (310)                                                    56   App.localPut(sender.address(), Bytes('balance'), App.localGet(sender.address(), Bytes('balance')) + payment.get().amount())
retsub                                 //  (311)                                                    41   def deposit(payment: abi.PaymentTransaction, sender: abi.Account) -> Expr:
                                       //                                                           65   def getBalance(user: abi.Account, *, output: abi.Uint64) -> Expr:
// getBalance                          //
getBalance_2:                          //
txnas Accounts                         //  (312)                                                    74   user.address()
byte "balance"                         //  (314)                                                         Bytes('balance')
app_local_get                          //  (315)                                                         App.localGet(user.address(), Bytes('balance'))
retsub                                 //  (316)                                                    65   def getBalance(user: abi.Account, *, output: abi.Uint64) -> Expr:
                                       //                                                           78   def withdraw(amount: abi.Uint64, recipient: abi.Account) -> Expr:
// withdraw                            //
withdraw_3:                            //
store 8                                //  (317)
store 7                                //  (319)
txn Sender                             //  (321)                                                    98   Txn.sender()
byte "balance"                         //  (323)                                                    99   Bytes('balance')
txn Sender                             //  (324)                                                    100  Txn.sender()
byte "balance"                         //  (326)                                                         Bytes('balance')
app_local_get                          //  (327)                                                         App.localGet(Txn.sender(), Bytes('balance'))
load 7                                 //  (328)                                                         amount.get()
-                                      //  (330)                                                         App.localGet(Txn.sender(), Bytes('balance')) - amount.get()
app_local_put                          //  (331)                                                    97   App.localPut(Txn.sender(), Bytes('balance'), App.localGet(Txn.sender(), Bytes('balance')) - amount.get())
itxn_begin                             //  (332)                                                    102  InnerTxnBuilder.Begin()
int pay                                //  (333)                                                    103  {INNERTXN}
itxn_field TypeEnum                    //  (334)
load 8                                 //  (336)                                                    106  recipient.address()
txnas Accounts                         //  (338)
itxn_field Receiver                    //  (340)                                                    103  {INNERTXN}
load 7                                 //  (342)                                                    107  amount.get()
itxn_field Amount                      //  (344)                                                    103  {INNERTXN}
int 0                                  //  (346)                                                    108  Int(0)
itxn_field Fee                         //  (347)                                                    103  {INNERTXN}
itxn_submit                            //  (349)                                                    111  InnerTxnBuilder.Submit()
retsub                                 //  (350)                                                    78   def withdraw(amount: abi.Uint64, recipient: abi.Account) -> Expr:


================================================
FILE: tests/integration/teal/annotated/AlgoBank_h0_c1.tealf
================================================
#pragma version 6                      //  (0)    {COMPILE}
txn NumAppArgs                         //  (20)   {BCAs}
int 0                                  //  (22)
==                                     //  (23)
bnz main_l8                            //  (24)
txna ApplicationArgs 0                 //  (27)   def deposit(payment: abi.PaymentTransaction, sender: abi.Account) -> Expr:
method "deposit(pay,account)void"      //  (30)
==                                     //  (36)
bnz main_l7                            //  (37)
txna ApplicationArgs 0                 //  (40)   def getBalance(user: abi.Account, *, output: abi.Uint64) -> Expr:
method "getBalance(account)uint64"     //  (43)
==                                     //  (49)
bnz main_l6                            //  (50)
txna ApplicationArgs 0                 //  (53)   def withdraw(amount: abi.Uint64, recipient: abi.Account) -> Expr:
method "withdraw(uint64,account)void"  //  (56)
==                                     //  (62)
bnz main_l5                            //  (63)
err                                    //  (66)   {COMPILE}
main_l5:                               //         def withdraw(amount: abi.Uint64, recipient: abi.Account) -> Expr:
txn OnCompletion                       //  (67)
int NoOp                               //  (69)
==                                     //  (70)
txn ApplicationID                      //  (71)
int 0                                  //  (73)
!=                                     //  (74)
&&                                     //  (75)
assert                                 //  (76)
txna ApplicationArgs 1                 //  (77)
btoi                                   //  (80)
store 5                                //  (81)
txna ApplicationArgs 2                 //  (83)
int 0                                  //  (86)
getbyte                                //  (87)
store 6                                //  (88)
load 5                                 //  (90)
load 6                                 //  (92)
callsub withdraw_3                     //  (94)
int 1                                  //  (97)
return                                 //  (98)
main_l6:                               //         def getBalance(user: abi.Account, *, output: abi.Uint64) -> Expr:
txn OnCompletion                       //  (99)
int NoOp                               //  (101)
==                                     //  (102)
txn ApplicationID                      //  (103)
int 0                                  //  (105)
!=                                     //  (106)
&&                                     //  (107)
assert                                 //  (108)
txna ApplicationArgs 1                 //  (109)
int 0                                  //  (112)
getbyte                                //  (113)
callsub getBalance_2                   //  (114)
store 4                                //  (117)
byte 0x151f7c75                        //  (119)
load 4                                 //  (125)
itob                                   //  (127)
concat                                 //  (128)
log                                    //  (129)
int 1                                  //  (130)
return                                 //  (131)
main_l7:                               //         def deposit(payment: abi.PaymentTransaction, sender: abi.Account) -> Expr:
txn OnCompletion                       //  (132)
int NoOp                               //  (134)
==                                     //  (135)
txn ApplicationID                      //  (136)
int 0                                  //  (138)
!=                                     //  (139)
&&                                     //  (140)
txn OnCompletion                       //  (141)
int OptIn                              //  (143)
==                                     //  (144)
txn ApplicationID                      //  (145)
int 0                                  //  (147)
!=                                     //  (148)
&&                                     //  (149)
||                                     //  (150)
assert                                 //  (151)
txna ApplicationArgs 1                 //  (152)
int 0                                  //  (155)
getbyte                                //  (156)
store 1                                //  (157)
txn GroupIndex                         //  (159)
int 1                                  //  (161)
-                                      //  (162)
store 0                                //  (163)
load 0                                 //  (165)  {COMPILE}
gtxns TypeEnum                         //  (167)  def deposit(payment: abi.PaymentTransaction, sender: abi.Account) -> Expr:
int pay                                //  (169)
==                                     //  (170)
assert                                 //  (171)
load 0                                 //  (172)
load 1                                 //  (174)
callsub deposit_1                      //  (176)
int 1                                  //  (179)
return                                 //  (180)
main_l8:                               //         OnCompleteAction(action=Approve(), call_config=CallConfig.CREATE)
txn OnCompletion                       //  (181)
int NoOp                               //  (183)
==                                     //  (184)
bnz main_l18                           //  (185)
txn OnCompletion                       //  (188)  OnCompleteAction(action=Approve(), call_config=CallConfig.ALL)
int OptIn                              //  (190)
==                                     //  (191)
bnz main_l17                           //  (192)
txn OnCompletion                       //  (195)  OnCompleteAction(action=transfer_balance_to_lost, call_config=CallConfig.CALL)
int CloseOut                           //  (197)
==                                     //  (199)
bnz main_l16                           //  (200)
txn OnCompletion                       //  (203)  OnCompleteAction(action=assert_sender_is_creator, call_config=CallConfig.CALL)
int UpdateApplication                  //  (205)
==                                     //  (207)
bnz main_l15                           //  (208)
txn OnCompletion                       //  (211)  OnCompleteAction(action=assert_sender_is_creator, call_config=CallConfig.CALL)
int DeleteApplication                  //  (213)
==                                     //  (215)
bnz main_l14                           //  (216)
err                                    //  (219)  {BCAs}
main_l14:                              //         OnCompleteAction(action=assert_sender_is_creator, call_config=CallConfig.CALL)
txn ApplicationID                      //  (220)
int 0                                  //  (222)
!=                                     //  (223)
assert                                 //  (224)
callsub assertsenderiscreator_0        //  (225)
int 1                                  //  (228)
return                                 //  (229)
main_l15:                              //         OnCompleteAction(action=assert_sender_is_creator, call_config=CallConfig.CALL)
txn ApplicationID                      //  (230)
int 0                                  //  (232)
!=                                     //  (233)
assert                                 //  (234)
callsub assertsenderiscreator_0        //  (235)
int 1                                  //  (238)
return                                 //  (239)
main_l16:                              //         OnCompleteAction(action=transfer_balance_to_lost, call_config=CallConfig.CALL)
txn ApplicationID                      //  (240)
int 0                                  //  (242)
!=                                     //  (243)
assert                                 //  (244)
byte "lost"                            //  (245)  Bytes('lost')
byte "lost"                            //  (246)  Bytes('lost')
app_global_get                         //  (247)  App.globalGet(Bytes('lost'))
txn Sender                             //  (248)  Txn.sender()
byte "balance"                         //  (250)  Bytes('balance')
app_local_get                          //  (251)  App.localGet(Txn.sender(), Bytes('balance'))
+                                      //  (252)  App.globalGet(Bytes('lost')) + App.localGet(Txn.sender(), Bytes('balance'))
app_global_put                         //  (253)  App.globalPut(Bytes('lost'), App.globalGet(Bytes('lost')) + App.localGet(Txn.sender(), Bytes('balance')))
int 1                                  //  (254)  OnCompleteAction(action=transfer_balance_to_lost, call_config=CallConfig.CALL)
return                                 //  (255)
main_l17:                              //         OnCompleteAction(action=Approve(), call_config=CallConfig.ALL)
int 1                                  //  (256)  Approve()
return                                 //  (257)
main_l18:                              //         OnCompleteAction(action=Approve(), call_config=CallConfig.CREATE)
txn ApplicationID                      //  (258)
int 0                                  //  (260)
==                                     //  (261)
assert                                 //  (262)
int 1                                  //  (263)  Approve()
return                                 //  (264)
                                       //         def assert_sender_is_creator() -> Expr:
// assert_sender_is_creator            //
assertsenderiscreator_0:               //
txn Sender                             //  (265)  Txn.sender()
global CreatorAddress                  //  (267)  Global.creator_address()
==                                     //  (269)  Txn.sender() == Global.creator_address()
assert                                 //  (270)  Assert(Txn.sender() == Global.creator_address())
retsub                                 //  (271)  def assert_sender_is_creator() -> Expr:
                                       //         def deposit(payment: abi.PaymentTransaction, sender: abi.Account) -> Expr:
// deposit                             //
deposit_1:                             //
store 3                                //  (272)
store 2                                //  (274)
load 2                                 //  (276)  payment.get()
gtxns Sender                           //  (278)  payment.get().sender()
load 3                                 //  (280)  sender.address()
txnas Accounts                         //  (282)
==                                     //  (284)  payment.get().sender() == sender.address()
assert                                 //  (285)  Assert(payment.get().sender() == sender.address())
load 2                                 //  (286)  payment.get()
gtxns Receiver                         //  (288)  payment.get().receiver()
global CurrentApplicationAddress       //  (290)  Global.current_application_address()
==                                     //  (292)  payment.get().receiver() == Global.current_application_address()
assert                                 //  (293)  Assert(payment.get().receiver() == Global.current_application_address())
load 3                                 //  (294)  sender.address()
txnas Accounts                         //  (296)
byte "balance"                         //  (298)  Bytes('balance')
load 3                                 //  (299)  sender.address()
txnas Accounts                         //  (301)
byte "balance"                         //  (303)  Bytes('balance')
app_local_get                          //  (304)  App.localGet(sender.address(), Bytes('balance'))
load 2                                 //  (305)  payment.get()
gtxns Amount                           //  (307)  payment.get().amount()
+                                      //  (309)  App.localGet(sender.address(), Bytes('balance')) + payment.get().amount()
app_local_put                          //  (310)  App.localPut(sender.address(), Bytes('balance'), App.localGet(sender.address(), Bytes('balance')) + payment.get().amount())
retsub                                 //  (311)  def deposit(payment: abi.PaymentTransaction, sender: abi.Account) -> Expr:
                                       //         def getBalance(user: abi.Account, *, output: abi.Uint64) -> Expr:
// getBalance                          //
getBalance_2:                          //
txnas Accounts                         //  (312)  user.address()
byte "balance"                         //  (314)  Bytes('balance')
app_local_get                          //  (315)  App.localGet(user.address(), Bytes('balance'))
retsub                                 //  (316)  def getBalance(user: abi.Account, *, output: abi.Uint64) -> Expr:
                                       //         def withdraw(amount: abi.Uint64, recipient: abi.Account) -> Expr:
// withdraw                            //
withdraw_3:                            //
store 8                                //  (317)
store 7                                //  (319)
txn Sender                             //  (321)  Txn.sender()
byte "balance"                         //  (323)  Bytes('balance')
txn Sender                             //  (324)  Txn.sender()
byte "balance"                         //  (326)  Bytes('balance')
app_local_get                          //  (327)  App.localGet(Txn.sender(), Bytes('balance'))
load 7                                 //  (328)  amount.get()
-                                      //  (330)  App.localGet(Txn.sender(), Bytes('balance')) - amount.get()
app_local_put                          //  (331)  App.localPut(Txn.sender(), Bytes('balance'), App.localGet(Txn.sender(), Bytes('balance')) - amount.get())
itxn_begin                             //  (332)  InnerTxnBuilder.Begin()
int pay                                //  (333)  {INNERTXN}
itxn_field TypeEnum                    //  (334)
load 8                                 //  (336)  recipient.address()
txnas Accounts                         //  (338)
itxn_field Receiver                    //  (340)  {INNERTXN}
load 7                                 //  (342)  amount.get()
itxn_field Amount                      //  (344)  {INNERTXN}
int 0                                  //  (346)  Int(0)
itxn_field Fee                         //  (347)  {INNERTXN}
itxn_submit                            //  (349)  InnerTxnBuilder.Submit()
retsub                                 //  (350)  def withdraw(amount: abi.Uint64, recipient: abi.Account) -> Expr:


================================================
FILE: tests/integration/teal/annotated/AlgoBank_h1_c0.tealf
================================================
// GENERATED TEAL                      //    PC     PYTEAL PATH                                       LINE    PYTEAL
#pragma version 6                      //    (0)    {CFILE}  {CL}      {COMPILE}
txn NumAppArgs                         //    (20)   examples/application/abi/algobank.py              19      {BCAs}
int 0                                  //    (22)
==                                     //    (23)
bnz main_l8                            //    (24)
txna ApplicationArgs 0                 //    (27)                                                     41      def deposit(payment: abi.PaymentTransaction, sender: abi.Account) -> Expr:
method "deposit(pay,account)void"      //    (30)
==                                     //    (36)
bnz main_l7                            //    (37)
txna ApplicationArgs 0                 //    (40)                                                     65      def getBalance(user: abi.Account, *, output: abi.Uint64) -> Expr:
method "getBalance(account)uint64"     //    (43)
==                                     //    (49)
bnz main_l6                            //    (50)
txna ApplicationArgs 0                 //    (53)                                                     78      def withdraw(amount: abi.Uint64, recipient: abi.Account) -> Expr:
method "withdraw(uint64,account)void"  //    (56)
==                                     //    (62)
bnz main_l5                            //    (63)
err                                    //    (66)   {CFILE}  {CL}      {COMPILE}
main_l5:                               //           examples/application/abi/algobank.py              78      def withdraw(amount: abi.Uint64, recipient: abi.Account) -> Expr:
txn OnCompletion                       //    (67)
int NoOp                               //    (69)
==                                     //    (70)
txn ApplicationID                      //    (71)
int 0                                  //    (73)
!=                                     //    (74)
&&                                     //    (75)
assert                                 //    (76)
txna ApplicationArgs 1                 //    (77)
btoi                                   //    (80)
store 5                                //    (81)
txna ApplicationArgs 2                 //    (83)
int 0                                  //    (86)
getbyte                                //    (87)
store 6                                //    (88)
load 5                                 //    (90)
load 6                                 //    (92)
callsub withdraw_3                     //    (94)
int 1                                  //    (97)
return                                 //    (98)
main_l6:                               //                                                             65      def getBalance(user: abi.Account, *, output: abi.Uint64) -> Expr:
txn OnCompletion                       //    (99)
int NoOp                               //    (101)
==                                     //    (102)
txn ApplicationID                      //    (103)
int 0                                  //    (105)
!=                                     //    (106)
&&                                     //    (107)
assert                                 //    (108)
txna ApplicationArgs 1                 //    (109)
int 0                                  //    (112)
getbyte                                //    (113)
callsub getBalance_2                   //    (114)
store 4                                //    (117)
byte 0x151f7c75                        //    (119)
load 4                                 //    (125)
itob                                   //    (127)
concat                                 //    (128)
log                                    //    (129)
int 1                                  //    (130)
return                                 //    (131)
main_l7:                               //                                                             41      def deposit(payment: abi.PaymentTransaction, sender: abi.Account) -> Expr:
txn OnCompletion                       //    (132)
int NoOp                               //    (134)
==                                     //    (135)
txn ApplicationID                      //    (136)
int 0                                  //    (138)
!=                                     //    (139)
&&                                     //    (140)
txn OnCompletion                       //    (141)
int OptIn                              //    (143)
==                                     //    (144)
txn ApplicationID                      //    (145)
int 0                                  //    (147)
!=                                     //    (148)
&&                                     //    (149)
||                                     //    (150)
assert                                 //    (151)
txna ApplicationArgs 1                 //    (152)
int 0                                  //    (155)
getbyte                                //    (156)
store 1                                //    (157)
txn GroupIndex                         //    (159)
int 1                                  //    (161)
-                                      //    (162)
store 0                                //    (163)
load 0                                 //    (165)  {CFILE}  {CL}      {COMPILE}
gtxns TypeEnum                         //    (167)  examples/application/abi/algobank.py              41      def deposit(payment: abi.PaymentTransaction, sender: abi.Account) -> Expr:
int pay                                //    (169)
==                                     //    (170)
assert                                 //    (171)
load 0                                 //    (172)
load 1                                 //    (174)
callsub deposit_1                      //    (176)
int 1                                  //    (179)
return                                 //    (180)
main_l8:                               //                                                             21      OnCompleteAction(action=Approve(), call_config=CallConfig.CREATE)
txn OnCompletion                       //    (181)
int NoOp                               //    (183)
==                                     //    (184)
bnz main_l18                           //    (185)
txn OnCompletion                       //    (188)                                                    23      OnCompleteAction(action=Approve(), call_config=CallConfig.ALL)
int OptIn                              //    (190)
==                                     //    (191)
bnz main_l17                           //    (192)
txn OnCompletion                       //    (195)                                                    25      OnCompleteAction(action=transfer_balance_to_lost, call_config=CallConfig.CALL)
int CloseOut                           //    (197)
==                                     //    (199)
bnz main_l16                           //    (200)
txn OnCompletion                       //    (203)                                                    29      OnCompleteAction(action=assert_sender_is_creator, call_config=CallConfig.CALL)
int UpdateApplication                  //    (205)
==                                     //    (207)
bnz main_l15                           //    (208)
txn OnCompletion                       //    (211)                                                    32      OnCompleteAction(action=assert_sender_is_creator, call_config=CallConfig.CALL)
int DeleteApplication                  //    (213)
==                                     //    (215)
bnz main_l14                           //    (216)
err                                    //    (219)                                                    19      {BCAs}
main_l14:                              //                                                             32      OnCompleteAction(action=assert_sender_is_creator, call_config=CallConfig.CALL)
txn ApplicationID                      //    (220)
int 0                                  //    (222)
!=                                     //    (223)
assert                                 //    (224)
callsub assertsenderiscreator_0        //    (225)
int 1                                  //    (228)
return                                 //    (229)
main_l15:                              //                                                             29      OnCompleteAction(action=assert_sender_is_creator, call_config=CallConfig.CALL)
txn ApplicationID                      //    (230)
int 0                                  //    (232)
!=                                     //    (233)
assert                                 //    (234)
callsub assertsenderiscreator_0        //    (235)
int 1                                  //    (238)
return                                 //    (239)
main_l16:                              //                                                             25      OnCompleteAction(action=transfer_balance_to_lost, call_config=CallConfig.CALL)
txn ApplicationID                      //    (240)
int 0                                  //    (242)
!=                                     //    (243)
assert                                 //    (244)
byte "lost"                            //    (245)                                                    13      Bytes('lost')
byte "lost"                            //    (246)                                                    14      Bytes('lost')
app_global_get                         //    (247)                                                            App.globalGet(Bytes('lost'))
txn Sender                             //    (248)                                                            Txn.sender()
byte "balance"                         //    (250)                                                            Bytes('balance')
app_local_get                          //    (251)                                                            App.localGet(Txn.sender(), Bytes('balance'))
+                                      //    (252)                                                            App.globalGet(Bytes('lost')) + App.localGet(Txn.sender(), Bytes('balance'))
app_global_put                         //    (253)                                                    12      App.globalPut(Bytes('lost'), App.globalGet(Bytes('lost')) + App.localGet(Txn.sender(), Bytes('balance')))
int 1                                  //    (254)                                                    25      OnCompleteAction(action=transfer_balance_to_lost, call_config=CallConfig.CALL)
return                                 //    (255)
main_l17:                              //                                                             23      OnCompleteAction(action=Approve(), call_config=CallConfig.ALL)
int 1                                  //    (256)                                                            Approve()
return                                 //    (257)
main_l18:                              //                                                             21      OnCompleteAction(action=Approve(), call_config=CallConfig.CREATE)
txn ApplicationID                      //    (258)
int 0                                  //    (260)
==                                     //    (261)
assert                                 //    (262)
int 1                                  //    (263)                                                            Approve()
return                                 //    (264)
                                       //                                                             7       def assert_sender_is_creator() -> Expr:
// assert_sender_is_creator            //
assertsenderiscreator_0:               //
txn Sender                             //    (265)                                                    8       Txn.sender()
global CreatorAddress                  //    (267)                                                            Global.creator_address()
==                                     //    (269)                                                            Txn.sender() == Global.creator_address()
assert                                 //    (270)                                                            Assert(Txn.sender() == Global.creator_address())
retsub                                 //    (271)                                                    7       def assert_sender_is_creator() -> Expr:
                                       //                                                             41      def deposit(payment: abi.PaymentTransaction, sender: abi.Account) -> Expr:
// deposit                             //
deposit_1:                             //
store 3                                //    (272)
store 2                                //    (274)
load 2                                 //    (276)                                                    54      payment.get()
gtxns Sender                           //    (278)                                                            payment.get().sender()
load 3                                 //    (280)                                                            sender.address()
txnas Accounts                         //    (282)
==                                     //    (284)                                                            payment.get().sender() == sender.address()
assert                                 //    (285)                                                            Assert(payment.get().sender() == sender.address())
load 2                                 //    (286)                                                    55      payment.get()
gtxns Receiver                         //    (288)                                                            payment.get().receiver()
global CurrentApplicationAddress       //    (290)                                                            Global.current_application_address()
==                                     //    (292)                                                            payment.get().receiver() == Global.current_application_address()
assert                                 //    (293)                                                            Assert(payment.get().receiver() == Global.current_application_address())
load 3                                 //    (294)                                                    57      sender.address()
txnas Accounts                         //    (296)
byte "balance"                         //    (298)                                                    58      Bytes('balance')
load 3                                 //    (299)                                                    59      sender.address()
txnas Accounts                         //    (301)
byte "balance"                         //    (303)                                                            Bytes('balance')
app_local_get                          //    (304)                                                            App.localGet(sender.address(), Bytes('balance'))
load 2                                 //    (305)                                                            payment.get()
gtxns Amount                           //    (307)                                                            payment.get().amount()
+                                      //    (309)                                                            App.localGet(sender.address(), Bytes('balance')) + payment.get().amount()
app_local_put                          //    (310)                                                    56      App.localPut(sender.address(), Bytes('balance'), App.localGet(sender.address(), Bytes('balance')) + payment.get().amount())
retsub                                 //    (311)                                                    41      def deposit(payment: abi.PaymentTransaction, sender: abi.Account) -> Expr:
                                       //                                                             65      def getBalance(user: abi.Account, *, output: abi.Uint64) -> Expr:
// getBalance                          //
getBalance_2:                          //
txnas Accounts                         //    (312)                                                    74      user.address()
byte "balance"                         //    (314)                                                            Bytes('balance')
app_local_get                          //    (315)                                                            App.localGet(user.address(), Bytes('balance'))
retsub                                 //    (316)                                                    65      def getBalance(user: abi.Account, *, output: abi.Uint64) -> Expr:
                                       //                                                             78      def withdraw(amount: abi.Uint64, recipient: abi.Account) -> Expr:
// withdraw                            //
withdraw_3:                            //
store 8                                //    (317)
store 7                                //    (319)
txn Sender                             //    (321)                                                    98      Txn.sender()
byte "balance"                         //    (323)                                                    99      Bytes('balance')
txn Sender                             //    (324)                                                    100     Txn.sender()
byte "balance"                         //    (326)                                                            Bytes('balance')
app_local_get                          //    (327)                                                            App.localGet(Txn.sender(), Bytes('balance'))
load 7                                 //    (328)                                                            amount.get()
-                                      //    (330)                                                            App.localGet(Txn.sender(), Bytes('balance')) - amount.get()
app_local_put                          //    (331)                                                    97      App.localPut(Txn.sender(), Bytes('balance'), App.localGet(Txn.sender(), Bytes('balance')) - amount.get())
itxn_begin                             //    (332)                                                    102     InnerTxnBuilder.Begin()
int pay                                //    (333)                                                    103     {INNERTXN}
itxn_field TypeEnum                    //    (334)
load 8                                 //    (336)                                                    106     recipient.address()
txnas Accounts                         //    (338)
itxn_field Receiver                    //    (340)                                                    103     {INNERTXN}
load 7                                 //    (342)                                                    107     amount.get()
itxn_field Amount                      //    (344)                                                    103     {INNERTXN}
int 0                                  //    (346)                                                    108     Int(0)
itxn_field Fee                         //    (347)                                                    103     {INNERTXN}
itxn_submit                            //    (349)                                                    111     InnerTxnBuilder.Submit()
retsub                                 //    (350)                                                    78      def withdraw(amount: abi.Uint64, recipient: abi.Account) -> Expr:


================================================
FILE: tests/integration/teal/annotated/AlgoBank_h1_c1.tealf
================================================
// GENERATED TEAL                      //    PC     PYTEAL
#pragma version 6                      //    (0)    {COMPILE}
txn NumAppArgs                         //    (20)   {BCAs}
int 0                                  //    (22)
==                                     //    (23)
bnz main_l8                            //    (24)
txna ApplicationArgs 0                 //    (27)   def deposit(payment: abi.PaymentTransaction, sender: abi.Account) -> Expr:
method "deposit(pay,account)void"      //    (30)
==                                     //    (36)
bnz main_l7                            //    (37)
txna ApplicationArgs 0                 //    (40)   def getBalance(user: abi.Account, *, output: abi.Uint64) -> Expr:
method "getBalance(account)uint64"     //    (43)
==                                     //    (49)
bnz main_l6                            //    (50)
txna ApplicationArgs 0                 //    (53)   def withdraw(amount: abi.Uint64, recipient: abi.Account) -> Expr:
method "withdraw(uint64,account)void"  //    (56)
==                                     //    (62)
bnz main_l5                            //    (63)
err                                    //    (66)   {COMPILE}
main_l5:                               //           def withdraw(amount: abi.Uint64, recipient: abi.Account) -> Expr:
txn OnCompletion                       //    (67)
int NoOp                               //    (69)
==                                     //    (70)
txn ApplicationID                      //    (71)
int 0                                  //    (73)
!=                                     //    (74)
&&                                     //    (75)
assert                                 //    (76)
txna ApplicationArgs 1                 //    (77)
btoi                                   //    (80)
store 5                                //    (81)
txna ApplicationArgs 2                 //    (83)
int 0                                  //    (86)
getbyte                                //    (87)
store 6                                //    (88)
load 5                                 //    (90)
load 6                                 //    (92)
callsub withdraw_3                     //    (94)
int 1                                  //    (97)
return                                 //    (98)
main_l6:                               //           def getBalance(user: abi.Account, *, output: abi.Uint64) -> Expr:
txn OnCompletion                       //    (99)
int NoOp                               //    (101)
==                                     //    (102)
txn ApplicationID                      //    (103)
int 0                                  //    (105)
!=                                     //    (106)
&&                                     //    (107)
assert                                 //    (108)
txna ApplicationArgs 1                 //    (109)
int 0                                  //    (112)
getbyte                                //    (113)
callsub getBalance_2                   //    (114)
store 4                                //    (117)
byte 0x151f7c75                        //    (119)
load 4                                 //    (125)
itob                                   //    (127)
concat                                 //    (128)
log                                    //    (129)
int 1                                  //    (130)
return                                 //    (131)
main_l7:                               //           def deposit(payment: abi.PaymentTransaction, sender: abi.Account) -> Expr:
txn OnCompletion                       //    (132)
int NoOp                               //    (134)
==                                     //    (135)
txn ApplicationID                      //    (136)
int 0                                  //    (138)
!=                                     //    (139)
&&                                     //    (140)
txn OnCompletion                       //    (141)
int OptIn                              //    (143)
==                                     //    (144)
txn ApplicationID                      //    (145)
int 0                                  //    (147)
!=                                     //    (148)
&&                                     //    (149)
||                                     //    (150)
assert                                 //    (151)
txna ApplicationArgs 1                 //    (152)
int 0                                  //    (155)
getbyte                                //    (156)
store 1                                //    (157)
txn GroupIndex                         //    (159)
int 1                                  //    (161)
-                                      //    (162)
store 0                                //    (163)
load 0                                 //    (165)  {COMPILE}
gtxns TypeEnum                         //    (167)  def deposit(payment: abi.PaymentTransaction, sender: abi.Account) -> Expr:
int pay                                //    (169)
==                                     //    (170)
assert                                 //    (171)
load 0                                 //    (172)
load 1                                 //    (174)
callsub deposit_1                      //    (176)
int 1                                  //    (179)
return                                 //    (180)
main_l8:                               //           OnCompleteAction(action=Approve(), call_config=CallConfig.CREATE)
txn OnCompletion                       //    (181)
int NoOp                               //    (183)
==                                     //    (184)
bnz main_l18                           //    (185)
txn OnCompletion                       //    (188)  OnCompleteAction(action=Approve(), call_config=CallConfig.ALL)
int OptIn                              //    (190)
==                                     //    (191)
bnz main_l17                           //    (192)
txn OnCompletion                       //    (195)  OnCompleteAction(action=transfer_balance_to_lost, call_config=CallConfig.CALL)
int CloseOut                           //    (197)
==                                     //    (199)
bnz main_l16                           //    (200)
txn OnCompletion                       //    (203)  OnCompleteAction(action=assert_sender_is_creator, call_config=CallConfig.CALL)
int UpdateApplication                  //    (205)
==                                     //    (207)
bnz main_l15                           //    (208)
txn OnCompletion                       //    (211)  OnCompleteAction(action=assert_sender_is_creator, call_config=CallConfig.CALL)
int DeleteApplication                  //    (213)
==                                     //    (215)
bnz main_l14                           //    (216)
err                                    //    (219)  {BCAs}
main_l14:                              //           OnCompleteAction(action=assert_sender_is_creator, call_config=CallConfig.CALL)
txn ApplicationID                      //    (220)
int 0                                  //    (222)
!=                                     //    (223)
assert                                 //    (224)
callsub assertsenderiscreator_0        //    (225)
int 1                                  //    (228)
return                                 //    (229)
main_l15:                              //           OnCompleteAction(action=assert_sender_is_creator, call_config=CallConfig.CALL)
txn ApplicationID                      //    (230)
int 0                                  //    (232)
!=                                     //    (233)
assert                                 //    (234)
callsub assertsenderiscreator_0        //    (235)
int 1                                  //    (238)
return                                 //    (239)
main_l16:                              //           OnCompleteAction(action=transfer_balance_to_lost, call_config=CallConfig.CALL)
txn ApplicationID                      //    (240)
int 0                                  //    (242)
!=                                     //    (243)
assert                                 //    (244)
byte "lost"                            //    (245)  Bytes('lost')
byte "lost"                            //    (246)  Bytes('lost')
app_global_get                         //    (247)  App.globalGet(Bytes('lost'))
txn Sender                             //    (248)  Txn.sender()
byte "balance"                         //    (250)  Bytes('balance')
app_local_get                          //    (251)  App.localGet(Txn.sender(), Bytes('balance'))
+                                      //    (252)  App.globalGet(Bytes('lost')) + App.localGet(Txn.sender(), Bytes('balance'))
app_global_put                         //    (253)  App.globalPut(Bytes('lost'), App.globalGet(Bytes('lost')) + App.localGet(Txn.sender(), Bytes('balance')))
int 1                                  //    (254)  OnCompleteAction(action=transfer_balance_to_lost, call_config=CallConfig.CALL)
return                                 //    (255)
main_l17:                              //           OnCompleteAction(action=Approve(), call_config=CallConfig.ALL)
int 1                                  //    (256)  Approve()
return                                 //    (257)
main_l18:                              //           OnCompleteAction(action=Approve(), call_config=CallConfig.CREATE)
txn ApplicationID                      //    (258)
int 0                                  //    (260)
==                                     //    (261)
assert                                 //    (262)
int 1                                  //    (263)  Approve()
return                                 //    (264)
                                       //           def assert_sender_is_creator() -> Expr:
// assert_sender_is_creator            //
assertsenderiscreator_0:               //
txn Sender                             //    (265)  Txn.sender()
global CreatorAddress                  //    (267)  Global.creator_address()
==                                     //    (269)  Txn.sender() == Global.creator_address()
assert                                 //    (270)  Assert(Txn.sender() == Global.creator_address())
retsub                                 //    (271)  def assert_sender_is_creator() -> Expr:
                                       //           def deposit(payment: abi.PaymentTransaction, sender: abi.Account) -> Expr:
// deposit                             //
deposit_1:                             //
store 3                                //    (272)
store 2                                //    (274)
load 2                                 //    (276)  payment.get()
gtxns Sender                           //    (278)  payment.get().sender()
load 3                                 //    (280)  sender.address()
txnas Accounts                         //    (282)
==                                     //    (284)  payment.get().sender() == sender.address()
assert                                 //    (285)  Assert(payment.get().sender() == sender.address())
load 2                                 //    (286)  payment.get()
gtxns Receiver                         //    (288)  payment.get().receiver()
global CurrentApplicationAddress       //    (290)  Global.current_application_address()
==                                     //    (292)  payment.get().receiver() == Global.current_application_address()
assert                                 //    (293)  Assert(payment.get().receiver() == Global.current_application_address())
load 3                                 //    (294)  sender.address()
txnas Accounts                         //    (296)
byte "balance"                         //    (298)  Bytes('balance')
load 3                                 //    (299)  sender.address()
txnas Accounts                         //    (301)
byte "balance"                         //    (303)  Bytes('balance')
app_local_get                          //    (304)  App.localGet(sender.address(), Bytes('balance'))
load 2                                 //    (305)  payment.get()
gtxns Amount                           //    (307)  payment.get().amount()
+                                      //    (309)  App.localGet(sender.address(), Bytes('balance')) + payment.get().amount()
app_local_put                          //    (310)  App.localPut(sender.address(), Bytes('balance'), App.localGet(sender.address(), Bytes('balance')) + payment.get().amount())
retsub                                 //    (311)  def deposit(payment: abi.PaymentTransaction, sender: abi.Account) -> Expr:
                                       //           def getBalance(user: abi.Account, *, output: abi.Uint64) -> Expr:
// getBalance                          //
getBalance_2:                          //
txnas Accounts                         //    (312)  user.address()
byte "balance"                         //    (314)  Bytes('balance')
app_local_get                          //    (315)  App.localGet(user.address(), Bytes('balance'))
retsub                                 //    (316)  def getBalance(user: abi.Account, *, output: abi.Uint64) -> Expr:
                                       //           def withdraw(amount: abi.Uint64, recipient: abi.Account) -> Expr:
// withdraw                            //
withdraw_3:                            //
store 8                                //    (317)
store 7                                //    (319)
txn Sender                             //    (321)  Txn.sender()
byte "balance"                         //    (323)  Bytes('balance')
txn Sender                             //    (324)  Txn.sender()
byte "balance"                         //    (326)  Bytes('balance')
app_local_get                          //    (327)  App.localGet(Txn.sender(), Bytes('balance'))
load 7                                 //    (328)  amount.get()
-                                      //    (330)  App.localGet(Txn.sender(), Bytes('balance')) - amount.get()
app_local_put                          //    (331)  App.localPut(Txn.sender(), Bytes('balance'), App.localGet(Txn.sender(), Bytes('balance')) - amount.get())
itxn_begin                             //    (332)  InnerTxnBuilder.Begin()
int pay                                //    (333)  {INNERTXN}
itxn_field TypeEnum                    //    (334)
load 8                                 //    (336)  recipient.address()
txnas Accounts                         //    (338)
itxn_field Receiver                    //    (340)  {INNERTXN}
load 7                                 //    (342)  amount.get()
itxn_field Amount                      //    (344)  {INNERTXN}
int 0                                  //    (346)  Int(0)
itxn_field Fee                         //    (347)  {INNERTXN}
itxn_submit                            //    (349)  InnerTxnBuilder.Submit()
retsub                                 //    (350)  def withdraw(amount: abi.Uint64, recipient: abi.Account) -> Expr:


================================================
FILE: tests/integration/teal/roundtrip/app_roundtrip_((uint64,byte[],uint64[1]))_v6.teal
================================================
#pragma version 6
txna ApplicationArgs 0
store 1
load 1
callsub roundtripper_1
store 0
byte 0x151f7c75
load 0
concat
log
int 1
return

// tuple_complement
tuplecomplement_0:
store 6
load 6
load 6
int 0
extract_uint16
dig 1
len
substring3
store 8
load 8
callsub tuplecomplement_2
store 8
load 8
store 34
load 34
store 33
int 2
store 32
load 32
itob
extract 6 0
load 33
concat
store 7
load 7
retsub

// round_tripper
roundtripper_1:
store 2
load 2
callsub tuplecomplement_0
store 4
load 4
callsub tuplecomplement_0
store 5
load 2
store 38
load 38
store 37
int 6
store 35
load 35
load 38
len
+
store 36
load 36
int 65536
<
assert
load 35
itob
extract 6 0
load 4
store 38
load 37
load 38
concat
store 37
load 36
store 35
load 35
load 38
len
+
store 36
load 36
int 65536
<
assert
load 35
itob
extract 6 0
concat
load 5
store 38
load 37
load 38
concat
store 37
load 36
store 35
load 35
itob
extract 6 0
concat
load 37
concat
store 3
load 3
retsub

// tuple_complement
tuplecomplement_2:
store 9
load 9
int 0
extract_uint64
store 11
load 9
load 9
int 8
extract_uint16
dig 1
len
substring3
store 12
load 9
extract 10 8
store 13
load 11
callsub numericalcomp_3
store 11
load 12
callsub arraycomplement_5
store 12
load 13
callsub arraycomplement_7
store 13
load 11
itob
load 12
store 31
load 31
store 30
int 18
store 29
load 29
itob
extract 6 0
concat
load 13
concat
load 30
concat
store 10
load 10
retsub

// numerical_comp
numericalcomp_3:
store 14
int 18446744073709551615
load 14
-
store 15
load 15
retsub

// numerical_comp
numericalcomp_4:
store 21
int 255
load 21
-
store 22
load 22
int 256
<
assert
load 22
retsub

// array_complement
arraycomplement_5:
store 16
load 16
int 1
int 0
*
int 2
+
getbyte
store 18
load 16
int 1
int 1
*
int 2
+
getbyte
store 19
load 16
int 1
int 2
*
int 2
+
getbyte
store 20
load 18
callsub numericalcomp_4
store 18
load 19
callsub numericalcomp_4
store 19
load 20
callsub numericalcomp_4
store 20
int 3
store 23
load 23
itob
extract 6 0
byte 0x00
int 0
load 18
setbyte
byte 0x00
int 0
load 19
setbyte
concat
byte 0x00
int 0
load 20
setbyte
concat
concat
store 17
load 17
retsub

// numerical_comp
numericalcomp_6:
store 27
int 18446744073709551615
load 27
-
store 28
load 28
retsub

// array_complement
arraycomplement_7:
store 24
load 24
int 8
int 0
*
extract_uint64
store 26
load 26
callsub numericalcomp_6
store 26
load 26
itob
store 25
load 25
retsub


================================================
FILE: tests/integration/teal/roundtrip/app_roundtrip_((uint64,byte[],uint64[1]))_v8.teal
================================================
#pragma version 8
txna ApplicationArgs 0
store 1
load 1
callsub roundtripper_1
store 0
byte 0x151f7c75
load 0
concat
log
int 1
return

// tuple_complement
tuplecomplement_0:
proto 1 1
byte ""
dup
int 0
dup
byte ""
dup
frame_dig -1
frame_dig -1
int 0
extract_uint16
dig 1
len
substring3
frame_bury 1
frame_dig 1
callsub tuplecomplement_2
frame_bury 1
frame_dig 1
frame_bury 5
frame_dig 5
frame_bury 4
int 2
frame_bury 2
frame_dig 2
itob
extract 6 0
frame_dig 4
concat
frame_bury 0
retsub

// round_tripper
roundtripper_1:
proto 1 1
byte ""
dupn 2
int 0
dup
byte ""
dup
frame_dig -1
callsub tuplecomplement_0
frame_bury 1
frame_dig 1
callsub tuplecomplement_0
frame_bury 2
frame_dig -1
frame_bury 6
frame_dig 6
frame_bury 5
int 6
frame_bury 3
frame_dig 3
frame_dig 6
len
+
frame_bury 4
frame_dig 4
int 65536
<
assert
frame_dig 3
itob
extract 6 0
frame_dig 1
frame_bury 6
frame_dig 5
frame_dig 6
concat
frame_bury 5
frame_dig 4
frame_bury 3
frame_dig 3
frame_dig 6
len
+
frame_bury 4
frame_dig 4
int 65536
<
assert
frame_dig 3
itob
extract 6 0
concat
frame_dig 2
frame_bury 6
frame_dig 5
frame_dig 6
concat
frame_bury 5
frame_dig 4
frame_bury 3
frame_dig 3
itob
extract 6 0
concat
frame_dig 5
concat
frame_bury 0
retsub

// tuple_complement
tuplecomplement_2:
proto 1 1
byte ""
int 0
byte ""
dup
int 0
dupn 3
byte ""
dup
frame_dig -1
int 0
extract_uint64
frame_bury 1
frame_dig -1
frame_dig -1
int 8
extract_uint16
dig 1
len
substring3
frame_bury 2
frame_dig -1
extract 10 8
frame_bury 3
frame_dig 1
callsub numericalcomp_3
frame_bury 1
frame_dig 2
callsub arraycomplement_5
frame_bury 2
frame_dig 3
callsub arraycomplement_7
frame_bury 3
frame_dig 1
itob
frame_dig 2
frame_bury 9
frame_dig 9
frame_bury 8
int 18
frame_bury 6
frame_dig 6
itob
extract 6 0
concat
frame_dig 3
concat
frame_dig 8
concat
frame_bury 0
retsub

// numerical_comp
numericalcomp_3:
proto 1 1
int 0
int 18446744073709551615
frame_dig -1
-
frame_bury 0
retsub

// numerical_comp
numericalcomp_4:
proto 1 1
int 0
int 255
frame_dig -1
-
frame_bury 0
frame_dig 0
int 256
<
assert
retsub

// array_complement
arraycomplement_5:
proto 1 1
byte ""
int 0
dupn 7
byte ""
dup
int 0
frame_dig -1
int 1
int 0
*
int 2
+
getbyte
frame_bury 1
frame_dig -1
int 1
int 1
*
int 2
+
getbyte
frame_bury 2
frame_dig -1
int 1
int 2
*
int 2
+
getbyte
frame_bury 3
frame_dig 1
callsub numericalcomp_4
frame_bury 1
frame_dig 2
callsub numericalcomp_4
frame_bury 2
frame_dig 3
callsub numericalcomp_4
frame_bury 3
int 3
frame_bury 11
frame_dig 11
itob
extract 6 0
byte 0x00
int 0
frame_dig 1
setbyte
byte 0x00
int 0
frame_dig 2
setbyte
concat
byte 0x00
int 0
frame_dig 3
setbyte
concat
concat
frame_bury 0
retsub

// numerical_comp
numericalcomp_6:
proto 1 1
int 0
int 18446744073709551615
frame_dig -1
-
frame_bury 0
retsub

// array_complement
arraycomplement_7:
proto 1 1
byte ""
int 0
dupn 2
byte ""
dup
frame_dig -1
int 8
int 0
*
extract_uint64
frame_bury 1
frame_dig 1
callsub numericalcomp_6
frame_bury 1
frame_dig 1
itob
frame_bury 0
retsub


================================================
FILE: tests/integration/teal/roundtrip/app_roundtrip_()_v6.teal
================================================
#pragma version 6
txna ApplicationArgs 0
store 1
load 1
callsub roundtripper_1
store 0
byte 0x151f7c75
load 0
concat
log
int 1
return

// tuple_complement
tuplecomplement_0:
store 6
byte ""
store 7
load 7
retsub

// round_tripper
roundtripper_1:
store 2
load 2
callsub tuplecomplement_0
store 4
load 4
callsub tuplecomplement_0
store 5
load 2
load 4
concat
load 5
concat
store 3
load 3
retsub


================================================
FILE: tests/integration/teal/roundtrip/app_roundtrip_()_v8.teal
================================================
#pragma version 8
txna ApplicationArgs 0
store 1
load 1
callsub roundtripper_1
store 0
byte 0x151f7c75
load 0
concat
log
int 1
return

// tuple_complement
tuplecomplement_0:
proto 1 1
byte ""
int 0
dup
byte ""
dup
byte ""
frame_bury 0
retsub

// round_tripper
roundtripper_1:
proto 1 1
byte ""
dupn 2
int 0
dup
byte ""
dup
frame_dig -1
callsub tuplecomplement_0
frame_bury 1
frame_dig 1
callsub tuplecomplement_0
frame_bury 2
frame_dig -1
frame_dig 1
concat
frame_dig 2
concat
frame_bury 0
retsub


================================================
FILE: tests/integration/teal/roundtrip/app_roundtrip_(bool)[10]_v6.teal
================================================
#pragma version 6
txna ApplicationArgs 0
store 1
load 1
callsub roundtripper_2
store 0
byte 0x151f7c75
load 0
concat
log
int 1
return

// tuple_complement
tuplecomplement_0:
store 18
load 18
int 0
getbit
store 20
load 20
callsub boolcomp_3
store 20
byte 0x00
int 0
load 20
setbit
store 19
load 19
retsub

// array_complement
arraycomplement_1:
store 6
load 6
int 1
int 0
*
int 1
extract3
store 8
load 6
int 1
int 1
*
int 1
extract3
store 9
load 6
int 1
int 2
*
int 1
extract3
store 10
load 6
int 1
int 3
*
int 1
extract3
store 11
load 6
int 1
int 4
*
int 1
extract3
store 12
load 6
int 1
int 5
*
int 1
extract3
store 13
load 6
int 1
int 6
*
int 1
extract3
store 14
load 6
int 1
int 7
*
int 1
extract3
store 15
load 6
int 1
int 8
*
int 1
extract3
store 16
load 6
int 1
int 9
*
int 1
extract3
store 17
load 8
callsub tuplecomplement_0
store 8
load 9
callsub tuplecomplement_0
store 9
load 10
callsub tuplecomplement_0
store 10
load 11
callsub tuplecomplement_0
store 11
load 12
callsub tuplecomplement_0
store 12
load 13
callsub tuplecomplement_0
store 13
load 14
callsub tuplecomplement_0
store 14
load 15
callsub tuplecomplement_0
store 15
load 16
callsub tuplecomplement_0
store 16
load 17
callsub tuplecomplement_0
store 17
load 8
load 9
concat
load 10
concat
load 11
concat
load 12
concat
load 13
concat
load 14
concat
load 15
concat
load 16
concat
load 17
concat
store 7
load 7
retsub

// round_tripper
roundtripper_2:
store 2
load 2
callsub arraycomplement_1
store 4
load 4
callsub arraycomplement_1
store 5
load 2
load 4
concat
load 5
concat
store 3
load 3
retsub

// bool_comp
boolcomp_3:
store 21
load 21
!
!
!
store 22
load 22
retsub


================================================
FILE: tests/integration/teal/roundtrip/app_roundtrip_(bool)[10]_v8.teal
================================================
#pragma version 8
txna ApplicationArgs 0
store 1
load 1
callsub roundtripper_2
store 0
byte 0x151f7c75
load 0
concat
log
int 1
return

// tuple_complement
tuplecomplement_0:
proto 1 1
byte ""
int 0
dupn 2
byte ""
dup
frame_dig -1
int 0
getbit
frame_bury 1
frame_dig 1
callsub boolcomp_3
frame_bury 1
byte 0x00
int 0
frame_dig 1
setbit
frame_bury 0
retsub

// array_complement
arraycomplement_1:
proto 1 1
byte ""
dupn 10
int 0
dup
byte ""
dup
frame_dig -1
int 1
int 0
*
int 1
extract3
frame_bury 1
frame_dig -1
int 1
int 1
*
int 1
extract3
frame_bury 2
frame_dig -1
int 1
int 2
*
int 1
extract3
frame_bury 3
frame_dig -1
int 1
int 3
*
int 1
extract3
frame_bury 4
frame_dig -1
int 1
int 4
*
int 1
extract3
frame_bury 5
frame_dig -1
int 1
int 5
*
int 1
extract3
frame_bury 6
frame_dig -1
int 1
int 6
*
int 1
extract3
frame_bury 7
frame_dig -1
int 1
int 7
*
int 1
extract3
frame_bury 8
frame_dig -1
int 1
int 8
*
int 1
extract3
frame_bury 9
frame_dig -1
int 1
int 9
*
int 1
extract3
frame_bury 10
frame_dig 1
callsub tuplecomplement_0
frame_bury 1
frame_dig 2
callsub tuplecomplement_0
frame_bury 2
frame_dig 3
callsub tuplecomplement_0
frame_bury 3
frame_dig 4
callsub tuplecomplement_0
frame_bury 4
frame_dig 5
callsub tuplecomplement_0
frame_bury 5
frame_dig 6
callsub tuplecomplement_0
frame_bury 6
frame_dig 7
callsub tuplecomplement_0
frame_bury 7
frame_dig 8
callsub tuplecomplement_0
frame_bury 8
frame_dig 9
callsub tuplecomplement_0
frame_bury 9
frame_dig 10
callsub tuplecomplement_0
frame_bury 10
frame_dig 1
frame_dig 2
concat
frame_dig 3
concat
frame_dig 4
concat
frame_dig 5
concat
frame_dig 6
concat
frame_dig 7
concat
frame_dig 8
concat
frame_dig 9
concat
frame_dig 10
concat
frame_bury 0
retsub

// round_tripper
roundtripper_2:
proto 1 1
byte ""
dupn 2
int 0
dup
byte ""
dup
frame_dig -1
callsub arraycomplement_1
frame_bury 1
frame_dig 1
callsub arraycomplement_1
frame_bury 2
frame_dig -1
frame_dig 1
concat
frame_dig 2
concat
frame_bury 0
retsub

// bool_comp
boolcomp_3:
proto 1 1
int 0
frame_dig -1
!
!
!
frame_bury 0
retsub


================================================
FILE: tests/integration/teal/roundtrip/app_roundtrip_(bool)_v6.teal
================================================
#pragma version 6
txna ApplicationArgs 0
store 1
load 1
callsub roundtripper_1
store 0
byte 0x151f7c75
load 0
concat
log
int 1
return

// tuple_complement
tuplecomplement_0:
store 6
load 6
int 0
getbit
store 8
load 8
callsub boolcomp_2
store 8
byte 0x00
int 0
load 8
setbit
store 7
load 7
retsub

// round_tripper
roundtripper_1:
store 2
load 2
callsub tuplecomplement_0
store 4
load 4
callsub tuplecomplement_0
store 5
load 2
load 4
concat
load 5
concat
store 3
load 3
retsub

// bool_comp
boolcomp_2:
store 9
load 9
!
!
!
store 10
load 10
retsub


================================================
FILE: tests/integration/teal/roundtrip/app_roundtrip_(bool)_v8.teal
================================================
#pragma version 8
txna ApplicationArgs 0
store 1
load 1
callsub roundtripper_1
store 0
byte 0x151f7c75
load 0
concat
log
int 1
return

// tuple_complement
tuplecomplement_0:
proto 1 1
byte ""
int 0
dupn 2
byte ""
dup
frame_dig -1
int 0
getbit
frame_bury 1
frame_dig 1
callsub boolcomp_2
frame_bury 1
byte 0x00
int 0
frame_dig 1
setbit
frame_bury 0
retsub

// round_tripper
roundtripper_1:
proto 1 1
byte ""
dupn 2
int 0
dup
byte ""
dup
frame_dig -1
callsub tuplecomplement_0
frame_bury 1
frame_dig 1
callsub tuplecomplement_0
frame_bury 2
frame_dig -1
frame_dig 1
concat
frame_dig 2
concat
frame_bury 0
retsub

// bool_comp
boolcomp_2:
proto 1 1
int 0
frame_dig -1
!
!
!
frame_bury 0
retsub


================================================
FILE: tests/integration/teal/roundtrip/app_roundtrip_(bool,address,(uint64,bool),byte[10],bool[4],uint64)_v6.teal
================================================
#pragma version 6
txna ApplicationArgs 0
store 1
load 1
callsub roundtripper_1
store 0
byte 0x151f7c75
load 0
concat
log
int 1
return

// tuple_complement
tuplecomplement_0:
store 6
load 6
int 0
getbit
store 8
load 6
extract 1 32
store 9
load 6
extract 33 9
store 10
load 6
extract 42 10
store 11
load 6
extract 52 1
store 12
load 6
int 53
extract_uint64
store 13
load 8
callsub boolcomp_2
store 8
load 9
callsub arraycomplement_4
store 9
load 10
callsub tuplecomplement_5
store 10
load 11
callsub arraycomplement_7
store 11
load 12
callsub arraycomplement_9
store 12
load 13
callsub numericalcomp_10
store 13
byte 0x00
int 0
load 8
setbit
load 9
concat
load 10
concat
load 11
concat
load 12
concat
load 13
itob
concat
store 7
load 7
retsub

// round_tripper
roundtripper_1:
store 2
load 2
callsub tuplecomplement_0
store 4
load 4
callsub tuplecomplement_0
store 5
load 2
load 4
concat
load 5
concat
store 3
load 3
retsub

// bool_comp
boolcomp_2:
store 14
load 14
!
!
!
store 15
load 15
retsub

// numerical_comp
numericalcomp_3:
store 50
int 255
load 50
-
store 51
load 51
int 256
<
assert
load 51
retsub

// array_complement
arraycomplement_4:
store 16
load 16
int 1
int 0
*
getbyte
store 18
load 16
int 1
int 1
*
getbyte
store 19
load 16
int 1
int 2
*
getbyte
store 20
load 16
int 1
int 3
*
getbyte
store 21
load 16
int 1
int 4
*
getbyte
store 22
load 16
int 1
int 5
*
getbyte
store 23
load 16
int 1
int 6
*
getbyte
store 24
load 16
int 1
int 7
*
getbyte
store 25
load 16
int 1
int 8
*
getbyte
store 26
load 16
int 1
int 9
*
getbyte
store 27
load 16
int 1
int 10
*
getbyte
store 28
load 16
int 1
int 11
*
getbyte
store 29
load 16
int 1
int 12
*
getbyte
store 30
load 16
int 1
int 13
*
getbyte
store 31
load 16
int 1
int 14
*
getbyte
store 32
load 16
int 1
int 15
*
getbyte
store 33
load 16
int 1
int 16
*
getbyte
store 34
load 16
int 1
int 17
*
getbyte
store 35
load 16
int 1
int 18
*
getbyte
store 36
load 16
int 1
int 19
*
getbyte
store 37
load 16
int 1
int 20
*
getbyte
store 38
load 16
int 1
int 21
*
getbyte
store 39
load 16
int 1
int 22
*
getbyte
store 40
load 16
int 1
int 23
*
getbyte
store 41
load 16
int 1
int 24
*
getbyte
store 42
load 16
int 1
int 25
*
getbyte
store 43
load 16
int 1
int 26
*
getbyte
store 44
load 16
int 1
int 27
*
getbyte
store 45
load 16
int 1
int 28
*
getbyte
store 46
load 16
int 1
int 29
*
getbyte
store 47
load 16
int 1
int 30
*
getbyte
store 48
load 16
int 1
int 31
*
getbyte
store 49
load 18
callsub numericalcomp_3
store 18
load 19
callsub numericalcomp_3
store 19
load 20
callsub numericalcomp_3
store 20
load 21
callsub numericalcomp_3
store 21
load 22
callsub numericalcomp_3
store 22
load 23
callsub numericalcomp_3
store 23
load 24
callsub numericalcomp_3
store 24
load 25
callsub numericalcomp_3
store 25
load 26
callsub numericalcomp_3
store 26
load 27
callsub numericalcomp_3
store 27
load 28
callsub numericalcomp_3
store 28
load 29
callsub numericalcomp_3
store 29
load 30
callsub numericalcomp_3
store 30
load 31
callsub numericalcomp_3
store 31
load 32
callsub numericalcomp_3
store 32
load 33
callsub numericalcomp_3
store 33
load 34
callsub numericalcomp_3
store 34
load 35
callsub numericalcomp_3
store 35
load 36
callsub numericalcomp_3
store 36
load 37
callsub numericalcomp_3
store 37
load 38
callsub numericalcomp_3
store 38
load 39
callsub numericalcomp_3
store 39
load 40
callsub numericalcomp_3
store 40
load 41
callsub numericalcomp_3
store 41
load 42
callsub numericalcomp_3
store 42
load 43
callsub numericalcomp_3
store 43
load 44
callsub numericalcomp_3
store 44
load 45
callsub numericalcomp_3
store 45
load 46
callsub numericalcomp_3
store 46
load 47
callsub numericalcomp_3
store 47
load 48
callsub numericalcomp_3
store 48
load 49
callsub numericalcomp_3
store 49
byte 0x00
int 0
load 18
setbyte
byte 0x00
int 0
load 19
setbyte
concat
byte 0x00
int 0
load 20
setbyte
concat
byte 0x00
int 0
load 21
setbyte
concat
byte 0x00
int 0
load 22
setbyte
concat
byte 0x00
int 0
load 23
setbyte
concat
byte 0x00
int 0
load 24
setbyte
concat
byte 0x00
int 0
load 25
setbyte
concat
byte 0x00
int 0
load 26
setbyte
concat
byte 0x00
int 0
load 27
setbyte
concat
byte 0x00
int 0
load 28
setbyte
concat
byte 0x00
int 0
load 29
setbyte
concat
byte 0x00
int 0
load 30
setbyte
concat
byte 0x00
int 0
load 31
setbyte
concat
byte 0x00
int 0
load 32
setbyte
concat
byte 0x00
int 0
load 33
setbyte
concat
byte 0x00
int 0
load 34
setbyte
concat
byte 0x00
int 0
load 35
setbyte
concat
byte 0x00
int 0
load 36
setbyte
concat
byte 0x00
int 0
load 37
setbyte
concat
byte 0x00
int 0
load 38
setbyte
concat
byte 0x00
int 0
load 39
setbyte
concat
byte 0x00
int 0
load 40
setbyte
concat
byte 0x00
int 0
load 41
setbyte
concat
byte 0x00
int 0
load 42
setbyte
concat
byte 0x00
int 0
load 43
setbyte
concat
byte 0x00
int 0
load 44
setbyte
concat
byte 0x00
int 0
load 45
setbyte
concat
byte 0x00
int 0
load 46
setbyte
concat
byte 0x00
int 0
load 47
setbyte
concat
byte 0x00
int 0
load 48
setbyte
concat
byte 0x00
int 0
load 49
setbyte
concat
store 17
load 17
retsub

// tuple_complement
tuplecomplement_5:
store 52
load 52
int 0
extract_uint64
store 54
load 52
int 64
getbit
store 55
load 54
callsub numericalcomp_11
store 54
load 55
callsub boolcomp_12
store 55
load 54
itob
byte 0x00
int 0
load 55
setbit
concat
store 53
load 53
retsub

// numerical_comp
numericalcomp_6:
store 72
int 255
load 72
-
store 73
load 73
int 256
<
assert
load 73
retsub

// array_complement
arraycomplement_7:
store 60
load 60
int 1
int 0
*
getbyte
store 62
load 60
int 1
int 1
*
getbyte
store 63
load 60
int 1
int 2
*
getbyte
store 64
load 60
int 1
int 3
*
getbyte
store 65
load 60
int 1
int 4
*
getbyte
store 66
load 60
int 1
int 5
*
getbyte
store 67
load 60
int 1
int 6
*
getbyte
store 68
load 60
int 1
int 7
*
getbyte
store 69
load 60
int 1
int 8
*
getbyte
store 70
load 60
int 1
int 9
*
getbyte
store 71
load 62
callsub numericalcomp_6
store 62
load 63
callsub numericalcomp_6
store 63
load 64
callsub numericalcomp_6
store 64
load 65
callsub numericalcomp_6
store 65
load 66
callsub numericalcomp_6
store 66
load 67
callsub numericalcomp_6
store 67
load 68
callsub numericalcomp_6
store 68
load 69
callsub numericalcomp_6
store 69
load 70
callsub numericalcomp_6
store 70
load 71
callsub numericalcomp_6
store 71
byte 0x00
int 0
load 62
setbyte
byte 0x00
int 0
load 63
setbyte
concat
byte 0x00
int 0
load 64
setbyte
concat
byte 0x00
int 0
load 65
setbyte
concat
byte 0x00
int 0
load 66
setbyte
concat
byte 0x00
int 0
load 67
setbyte
concat
byte 0x00
int 0
load 68
setbyte
concat
byte 0x00
int 0
load 69
setbyte
concat
byte 0x00
int 0
load 70
setbyte
concat
byte 0x00
int 0
load 71
setbyte
concat
store 61
load 61
retsub

// bool_comp
boolcomp_8:
store 80
load 80
!
!
!
store 81
load 81
retsub

// array_complement
arraycomplement_9:
store 74
load 74
int 0
getbit
store 76
load 74
int 1
getbit
store 77
load 74
int 2
getbit
store 78
load 74
int 3
getbit
store 79
load 76
callsub boolcomp_8
store 76
load 77
callsub boolcomp_8
store 77
load 78
callsub boolcomp_8
store 78
load 79
callsub boolcomp_8
store 79
byte 0x00
int 0
load 76
setbit
int 1
load 77
setbit
int 2
load 78
setbit
int 3
load 79
setbit
store 75
load 75
retsub

// numerical_comp
numericalcomp_10:
store 82
int 18446744073709551615
load 82
-
store 83
load 83
retsub

// numerical_comp
numericalcomp_11:
store 56
int 18446744073709551615
load 56
-
store 57
load 57
retsub

// bool_comp
boolcomp_12:
store 58
load 58
!
!
!
store 59
load 59
retsub


================================================
FILE: tests/integration/teal/roundtrip/app_roundtrip_(bool,address,(uint64,bool),byte[10],bool[4],uint64)_v8.teal
================================================
#pragma version 8
txna ApplicationArgs 0
store 1
load 1
callsub roundtripper_1
store 0
byte 0x151f7c75
load 0
concat
log
int 1
return

// tuple_complement
tuplecomplement_0:
proto 1 1
byte ""
int 0
byte ""
dupn 3
int 0
dupn 5
byte ""
dup
frame_dig -1
int 0
getbit
frame_bury 1
frame_dig -1
extract 1 32
frame_bury 2
frame_dig -1
extract 33 9
frame_bury 3
frame_dig -1
extract 42 10
frame_bury 4
frame_dig -1
extract 52 1
frame_bury 5
frame_dig -1
int 53
extract_uint64
frame_bury 6
frame_dig 1
callsub boolcomp_2
frame_bury 1
frame_dig 2
callsub arraycomplement_4
frame_bury 2
frame_dig 3
callsub tuplecomplement_5
frame_bury 3
frame_dig 4
callsub arraycomplement_7
frame_bury 4
frame_dig 5
callsub arraycomplement_9
frame_bury 5
frame_dig 6
callsub numericalcomp_10
frame_bury 6
byte 0x00
int 0
frame_dig 1
setbit
frame_dig 2
concat
frame_dig 3
concat
frame_dig 4
concat
frame_dig 5
concat
frame_dig 6
itob
concat
frame_bury 0
retsub

// round_tripper
roundtripper_1:
proto 1 1
byte ""
dupn 4
int 0
dup
byte ""
dup
frame_dig -1
callsub tuplecomplement_0
frame_bury 2
frame_dig 2
callsub tuplecomplement_0
frame_bury 4
frame_dig -1
frame_dig 2
concat
frame_dig 4
concat
frame_bury 0
retsub

// bool_comp
boolcomp_2:
proto 1 1
int 0
frame_dig -1
!
!
!
frame_bury 0
retsub

// numerical_comp
numericalcomp_3:
proto 1 1
int 0
int 255
frame_dig -1
-
frame_bury 0
frame_dig 0
int 256
<
assert
retsub

// array_complement
arraycomplement_4:
proto 1 1
byte ""
int 0
dupn 33
byte ""
dup
frame_dig -1
int 1
int 0
*
getbyte
frame_bury 1
frame_dig -1
int 1
int 1
*
getbyte
frame_bury 2
frame_dig -1
int 1
int 2
*
getbyte
frame_bury 3
frame_dig -1
int 1
int 3
*
getbyte
frame_bury 4
frame_dig -1
int 1
int 4
*
getbyte
frame_bury 5
frame_dig -1
int 1
int 5
*
getbyte
frame_bury 6
frame_dig -1
int 1
int 6
*
getbyte
frame_bury 7
frame_dig -1
int 1
int 7
*
getbyte
frame_bury 8
frame_dig -1
int 1
int 8
*
getbyte
frame_bury 9
frame_dig -1
int 1
int 9
*
getbyte
frame_bury 10
frame_dig -1
int 1
int 10
*
getbyte
frame_bury 11
frame_dig -1
int 1
int 11
*
getbyte
frame_bury 12
frame_dig -1
int 1
int 12
*
getbyte
frame_bury 13
frame_dig -1
int 1
int 13
*
getbyte
frame_bury 14
frame_dig -1
int 1
int 14
*
getbyte
frame_bury 15
frame_dig -1
int 1
int 15
*
getbyte
frame_bury 16
frame_dig -1
int 1
int 16
*
getbyte
frame_bury 17
frame_dig -1
int 1
int 17
*
getbyte
frame_bury 18
frame_dig -1
int 1
int 18
*
getbyte
frame_bury 19
frame_dig -1
int 1
int 19
*
getbyte
frame_bury 20
frame_dig -1
int 1
int 20
*
getbyte
frame_bury 21
frame_dig -1
int 1
int 21
*
getbyte
frame_bury 22
frame_dig -1
int 1
int 22
*
getbyte
frame_bury 23
frame_dig -1
int 1
int 23
*
getbyte
frame_bury 24
frame_dig -1
int 1
int 24
*
getbyte
frame_bury 25
frame_dig -1
int 1
int 25
*
getbyte
frame_bury 26
frame_dig -1
int 1
int 26
*
getbyte
frame_bury 27
frame_dig -1
int 1
int 27
*
getbyte
frame_bury 28
frame_dig -1
int 1
int 28
*
getbyte
frame_bury 29
frame_dig -1
int 1
int 29
*
getbyte
frame_bury 30
frame_dig -1
int 1
int 30
*
getbyte
frame_bury 31
frame_dig -1
int 1
int 31
*
getbyte
frame_bury 32
frame_dig 1
callsub numericalcomp_3
frame_bury 1
frame_dig 2
callsub numericalcomp_3
frame_bury 2
frame_dig 3
callsub numericalcomp_3
frame_bury 3
frame_dig 4
callsub numericalcomp_3
frame_bury 4
frame_dig 5
callsub numericalcomp_3
frame_bury 5
frame_dig 6
callsub numericalcomp_3
frame_bury 6
frame_dig 7
callsub numericalcomp_3
frame_bury 7
frame_dig 8
callsub numericalcomp_3
frame_bury 8
frame_dig 9
callsub numericalcomp_3
frame_bury 9
frame_dig 10
callsub numericalcomp_3
frame_bury 10
frame_dig 11
callsub numericalcomp_3
frame_bury 11
frame_dig 12
callsub numericalcomp_3
frame_bury 12
frame_dig 13
callsub numericalcomp_3
frame_bury 13
frame_dig 14
callsub numericalcomp_3
frame_bury 14
frame_dig 15
callsub numericalcomp_3
frame_bury 15
frame_dig 16
callsub numericalcomp_3
frame_bury 16
frame_dig 17
callsub numericalcomp_3
frame_bury 17
frame_dig 18
callsub numericalcomp_3
frame_bury 18
frame_dig 19
callsub numericalcomp_3
frame_bury 19
frame_dig 20
callsub numericalcomp_3
frame_bury 20
frame_dig 21
callsub numericalcomp_3
frame_bury 21
frame_dig 22
callsub numericalcomp_3
frame_bury 22
frame_dig 23
callsub numericalcomp_3
frame_bury 23
frame_dig 24
callsub numericalcomp_3
frame_bury 24
frame_dig 25
callsub numericalcomp_3
frame_bury 25
frame_dig 26
callsub numericalcomp_3
frame_bury 26
frame_dig 27
callsub numericalcomp_3
frame_bury 27
frame_dig 28
callsub numericalcomp_3
frame_bury 28
frame_dig 29
callsub numericalcomp_3
frame_bury 29
frame_dig 30
callsub numericalcomp_3
frame_bury 30
frame_dig 31
callsub numericalcomp_3
frame_bury 31
frame_dig 32
callsub numericalcomp_3
frame_bury 32
byte 0x00
int 0
frame_dig 1
setbyte
byte 0x00
int 0
frame_dig 2
setbyte
concat
byte 0x00
int 0
frame_dig 3
setbyte
concat
byte 0x00
int 0
frame_dig 4
setbyte
concat
byte 0x00
int 0
frame_dig 5
setbyte
concat
byte 0x00
int 0
frame_dig 6
setbyte
concat
byte 0x00
int 0
frame_dig 7
setbyte
concat
byte 0x00
int 0
frame_dig 8
setbyte
concat
byte 0x00
int 0
frame_dig 9
setbyte
concat
byte 0x00
int 0
frame_dig 10
setbyte
concat
byte 0x00
int 0
frame_dig 11
setbyte
concat
byte 0x00
int 0
frame_dig 12
setbyte
concat
byte 0x00
int 0
frame_dig 13
setbyte
concat
byte 0x00
int 0
frame_dig 14
setbyte
concat
byte 0x00
int 0
frame_dig 15
setbyte
concat
byte 0x00
int 0
frame_dig 16
setbyte
concat
byte 0x00
int 0
frame_dig 17
setbyte
concat
byte 0x00
int 0
frame_dig 18
setbyte
concat
byte 0x00
int 0
frame_dig 19
setbyte
concat
byte 0x00
int 0
frame_dig 20
setbyte
concat
byte 0x00
int 0
frame_dig 21
setbyte
concat
byte 0x00
int 0
frame_dig 22
setbyte
concat
byte 0x00
int 0
frame_dig 23
setbyte
concat
byte 0x00
int 0
frame_dig 24
setbyte
concat
byte 0x00
int 0
frame_dig 25
setbyte
concat
byte 0x00
int 0
frame_dig 26
setbyte
concat
byte 0x00
int 0
frame_dig 27
setbyte
concat
byte 0x00
int 0
frame_dig 28
setbyte
concat
byte 0x00
int 0
frame_dig 29
setbyte
concat
byte 0x00
int 0
frame_dig 30
setbyte
concat
byte 0x00
int 0
frame_dig 31
setbyte
concat
byte 0x00
int 0
frame_dig 32
setbyte
concat
frame_bury 0
retsub

// tuple_complement
tuplecomplement_5:
proto 1 1
byte ""
int 0
dupn 3
byte ""
dup
frame_dig -1
int 0
extract_uint64
frame_bury 1
frame_dig -1
int 64
getbit
frame_bury 2
frame_dig 1
callsub numericalcomp_11
frame_bury 1
frame_dig 2
callsub boolcomp_12
frame_bury 2
frame_dig 1
itob
byte 0x00
int 0
frame_dig 2
setbit
concat
frame_bury 0
retsub

// numerical_comp
numericalcomp_6:
proto 1 1
int 0
int 255
frame_dig -1
-
frame_bury 0
frame_dig 0
int 256
<
assert
retsub

// array_complement
arraycomplement_7:
proto 1 1
byte ""
int 0
dupn 11
byte ""
dup
frame_dig -1
int 1
int 0
*
getbyte
frame_bury 1
frame_dig -1
int 1
int 1
*
getbyte
frame_bury 2
frame_dig -1
int 1
int 2
*
getbyte
frame_bury 3
frame_dig -1
int 1
int 3
*
getbyte
frame_bury 4
frame_dig -1
int 1
int 4
*
getbyte
frame_bury 5
frame_dig -1
int 1
int 5
*
getbyte
frame_bury 6
frame_dig -1
int 1
int 6
*
getbyte
frame_bury 7
frame_dig -1
int 1
int 7
*
getbyte
frame_bury 8
frame_dig -1
int 1
int 8
*
getbyte
frame_bury 9
frame_dig -1
int 1
int 9
*
getbyte
frame_bury 10
frame_dig 1
callsub numericalcomp_6
frame_bury 1
frame_dig 2
callsub numericalcomp_6
frame_bury 2
frame_dig 3
callsub numericalcomp_6
frame_bury 3
frame_dig 4
callsub numericalcomp_6
frame_bury 4
frame_dig 5
callsub numericalcomp_6
frame_bury 5
frame_dig 6
callsub numericalcomp_6
frame_bury 6
frame_dig 7
callsub numericalcomp_6
frame_bury 7
frame_dig 8
callsub numericalcomp_6
frame_bury 8
frame_dig 9
callsub numericalcomp_6
frame_bury 9
frame_dig 10
callsub numericalcomp_6
frame_bury 10
byte 0x00
int 0
frame_dig 1
setbyte
byte 0x00
int 0
frame_dig 2
setbyte
concat
byte 0x00
int 0
frame_dig 3
setbyte
concat
byte 0x00
int 0
frame_dig 4
setbyte
concat
byte 0x00
int 0
frame_dig 5
setbyte
concat
byte 0x00
int 0
frame_dig 6
setbyte
concat
byte 0x00
int 0
frame_dig 7
setbyte
concat
byte 0x00
int 0
frame_dig 8
setbyte
concat
byte 0x00
int 0
frame_dig 9
setbyte
concat
byte 0x00
int 0
frame_dig 10
setbyte
concat
frame_bury 0
retsub

// bool_comp
boolcomp_8:
proto 1 1
int 0
frame_dig -1
!
!
!
frame_bury 0
retsub

// array_complement
arraycomplement_9:
proto 1 1
byte ""
int 0
dupn 5
byte ""
dup
frame_dig -1
int 0
getbit
frame_bury 1
frame_dig -1
int 1
getbit
frame_bury 2
frame_dig -1
int 2
getbit
frame_bury 3
frame_dig -1
int 3
getbit
frame_bury 4
frame_dig 1
callsub boolcomp_8
frame_bury 1
frame_dig 2
callsub boolcomp_8
frame_bury 2
frame_dig 3
callsub boolcomp_8
frame_bury 3
frame_dig 4
callsub boolcomp_8
frame_bury 4
byte 0x00
int 0
frame_dig 1
setbit
int 1
frame_dig 2
setbit
int 2
frame_dig 3
setbit
int 3
frame_dig 4
setbit
frame_bury 0
retsub

// numerical_comp
numericalcomp_10:
proto 1 1
int 0
int 18446744073709551615
frame_dig -1
-
frame_bury 0
retsub

// numerical_comp
numericalcomp_11:
proto 1 1
int 0
int 18446744073709551615
frame_dig -1
-
frame_bury 0
retsub

// bool_comp
boolcomp_12:
proto 1 1
int 0
frame_dig -1
!
!
!
frame_bury 0
retsub


================================================
FILE: tests/integration/teal/roundtrip/app_roundtrip_(bool,byte)_v6.teal
================================================
#pragma version 6
txna ApplicationArgs 0
store 1
load 1
callsub roundtripper_1
store 0
byte 0x151f7c75
load 0
concat
log
int 1
return

// tuple_complement
tuplecomplement_0:
store 6
load 6
int 0
getbit
store 8
load 6
int 1
getbyte
store 9
load 8
callsub boolcomp_2
store 8
load 9
callsub numericalcomp_3
store 9
byte 0x00
int 0
load 8
setbit
byte 0x00
int 0
load 9
setbyte
concat
store 7
load 7
retsub

// round_tripper
roundtripper_1:
store 2
load 2
callsub tuplecomplement_0
store 4
load 4
callsub tuplecomplement_0
store 5
load 2
load 4
concat
load 5
concat
store 3
load 3
retsub

// bool_comp
boolcomp_2:
store 10
load 10
!
!
!
store 11
load 11
retsub

// numerical_comp
numericalcomp_3:
store 12
int 255
load 12
-
store 13
load 13
int 256
<
assert
load 13
retsub


================================================
FILE: tests/integration/teal/roundtrip/app_roundtrip_(bool,byte)_v8.teal
================================================
#pragma version 8
txna ApplicationArgs 0
store 1
load 1
callsub roundtripper_1
store 0
byte 0x151f7c75
load 0
concat
log
int 1
return

// tuple_complement
tuplecomplement_0:
proto 1 1
byte ""
int 0
dupn 3
byte ""
dup
frame_dig -1
int 0
getbit
frame_bury 1
frame_dig -1
int 1
getbyte
frame_bury 2
frame_dig 1
callsub boolcomp_2
frame_bury 1
frame_dig 2
callsub numericalcomp_3
frame_bury 2
byte 0x00
int 0
frame_dig 1
setbit
byte 0x00
int 0
frame_dig 2
setbyte
concat
frame_bury 0
retsub

// round_tripper
roundtripper_1:
proto 1 1
byte ""
dupn 2
int 0
dup
byte ""
dup
frame_dig -1
callsub tuplecomplement_0
frame_bury 1
frame_dig 1
callsub tuplecomplement_0
frame_bury 2
frame_dig -1
frame_dig 1
concat
frame_dig 2
concat
frame_bury 0
retsub

// bool_comp
boolcomp_2:
proto 1 1
int 0
frame_dig -1
!
!
!
frame_bury 0
retsub

// numerical_comp
numericalcomp_3:
proto 1 1
int 0
int 255
frame_dig -1
-
frame_bury 0
frame_dig 0
int 256
<
assert
retsub


================================================
FILE: tests/integration/teal/roundtrip/app_roundtrip_(bool,byte,address,string)_v6.teal
================================================
#pragma version 6
txna ApplicationArgs 0
store 1
load 1
callsub roundtripper_1
store 0
byte 0x151f7c75
load 0
concat
log
int 1
return

// tuple_complement
tuplecomplement_0:
store 6
load 6
int 0
getbit
store 8
load 6
int 1
getbyte
store 9
load 6
extract 2 32
store 10
load 6
load 6
int 34
extract_uint16
dig 1
len
substring3
store 11
load 8
callsub boolcomp_2
store 8
load 9
callsub numericalcomp_3
store 9
load 10
callsub arraycomplement_5
store 10
load 11
callsub stringreverse_6
store 11
byte 0x00
int 0
load 8
setbit
byte 0x00
int 0
load 9
setbyte
concat
load 10
concat
load 11
store 60
load 60
store 59
int 36
store 58
load 58
itob
extract 6 0
concat
load 59
concat
store 7
load 7
retsub

// round_tripper
roundtripper_1:
store 2
load 2
callsub tuplecomplement_0
store 4
load 4
callsub tuplecomplement_0
store 5
load 2
store 64
load 64
store 63
int 6
store 61
load 61
load 64
len
+
store 62
load 62
int 65536
<
assert
load 61
itob
extract 6 0
load 4
store 64
load 63
load 64
concat
store 63
load 62
store 61
load 61
load 64
len
+
store 62
load 62
int 65536
<
assert
load 61
itob
extract 6 0
concat
load 5
store 64
load 63
load 64
concat
store 63
load 62
store 61
load 61
itob
extract 6 0
concat
load 63
concat
store 3
load 3
retsub

// bool_comp
boolcomp_2:
store 12
load 12
!
!
!
store 13
load 13
retsub

// numerical_comp
numericalcomp_3:
store 14
int 255
load 14
-
store 15
load 15
int 256
<
assert
load 15
retsub

// numerical_comp
numericalcomp_4:
store 50
int 255
load 50
-
store 51
load 51
int 256
<
assert
load 51
retsub

// array_complement
arraycomplement_5:
store 16
load 16
int 1
int 0
*
getbyte
store 18
load 16
int 1
int 1
*
getbyte
store 19
load 16
int 1
int 2
*
getbyte
store 20
load 16
int 1
int 3
*
getbyte
store 21
load 16
int 1
int 4
*
getbyte
store 22
load 16
int 1
int 5
*
getbyte
store 23
load 16
int 1
int 6
*
getbyte
store 24
load 16
int 1
int 7
*
getbyte
store 25
load 16
int 1
int 8
*
getbyte
store 26
load 16
int 1
int 9
*
getbyte
store 27
load 16
int 1
int 10
*
getbyte
store 28
load 16
int 1
int 11
*
getbyte
store 29
load 16
int 1
int 12
*
getbyte
store 30
load 16
int 1
int 13
*
getbyte
store 31
load 16
int 1
int 14
*
getbyte
store 32
load 16
int 1
int 15
*
getbyte
store 33
load 16
int 1
int 16
*
getbyte
store 34
load 16
int 1
int 17
*
getbyte
store 35
load 16
int 1
int 18
*
getbyte
store 36
load 16
int 1
int 19
*
getbyte
store 37
load 16
int 1
int 20
*
getbyte
store 38
load 16
int 1
int 21
*
getbyte
store 39
load 16
int 1
int 22
*
getbyte
store 40
load 16
int 1
int 23
*
getbyte
store 41
load 16
int 1
int 24
*
getbyte
store 42
load 16
int 1
int 25
*
getbyte
store 43
load 16
int 1
int 26
*
getbyte
store 44
load 16
int 1
int 27
*
getbyte
store 45
load 16
int 1
int 28
*
getbyte
store 46
load 16
int 1
int 29
*
getbyte
store 47
load 16
int 1
int 30
*
getbyte
store 48
load 16
int 1
int 31
*
getbyte
store 49
load 18
callsub numericalcomp_4
store 18
load 19
callsub numericalcomp_4
store 19
load 20
callsub numericalcomp_4
store 20
load 21
callsub numericalcomp_4
store 21
load 22
callsub numericalcomp_4
store 22
load 23
callsub numericalcomp_4
store 23
load 24
callsub numericalcomp_4
store 24
load 25
callsub numericalcomp_4
store 25
load 26
callsub numericalcomp_4
store 26
load 27
callsub numericalcomp_4
store 27
load 28
callsub numericalcomp_4
store 28
load 29
callsub numericalcomp_4
store 29
load 30
callsub numericalcomp_4
store 30
load 31
callsub numericalcomp_4
store 31
load 32
callsub numericalcomp_4
store 32
load 33
callsub numericalcomp_4
store 33
load 34
callsub numericalcomp_4
store 34
load 35
callsub numericalcomp_4
store 35
load 36
callsub numericalcomp_4
store 36
load 37
callsub numericalcomp_4
store 37
load 38
callsub numericalcomp_4
store 38
load 39
callsub numericalcomp_4
store 39
load 40
callsub numericalcomp_4
store 40
load 41
callsub numericalcomp_4
store 41
load 42
callsub numericalcomp_4
store 42
load 43
callsub numericalcomp_4
store 43
load 44
callsub numericalcomp_4
store 44
load 45
callsub numericalcomp_4
store 45
load 46
callsub numericalcomp_4
store 46
load 47
callsub numericalcomp_4
store 47
load 48
callsub numericalcomp_4
store 48
load 49
callsub numericalcomp_4
store 49
byte 0x00
int 0
load 18
setbyte
byte 0x00
int 0
load 19
setbyte
concat
byte 0x00
int 0
load 20
setbyte
concat
byte 0x00
int 0
load 21
setbyte
concat
byte 0x00
int 0
load 22
setbyte
concat
byte 0x00
int 0
load 23
setbyte
concat
byte 0x00
int 0
load 24
setbyte
concat
byte 0x00
int 0
load 25
setbyte
concat
byte 0x00
int 0
load 26
setbyte
concat
byte 0x00
int 0
load 27
setbyte
concat
byte 0x00
int 0
load 28
setbyte
concat
byte 0x00
int 0
load 29
setbyte
concat
byte 0x00
int 0
load 30
setbyte
concat
byte 0x00
int 0
load 31
setbyte
concat
byte 0x00
int 0
load 32
setbyte
concat
byte 0x00
int 0
load 33
setbyte
concat
byte 0x00
int 0
load 34
setbyte
concat
byte 0x00
int 0
load 35
setbyte
concat
byte 0x00
int 0
load 36
setbyte
concat
byte 0x00
int 0
load 37
setbyte
concat
byte 0x00
int 0
load 38
setbyte
concat
byte 0x00
int 0
load 39
setbyte
concat
byte 0x00
int 0
load 40
setbyte
concat
byte 0x00
int 0
load 41
setbyte
concat
byte 0x00
int 0
load 42
setbyte
concat
byte 0x00
int 0
load 43
setbyte
concat
byte 0x00
int 0
load 44
setbyte
concat
byte 0x00
int 0
load 45
setbyte
concat
byte 0x00
int 0
load 46
setbyte
concat
byte 0x00
int 0
load 47
setbyte
concat
byte 0x00
int 0
load 48
setbyte
concat
byte 0x00
int 0
load 49
setbyte
concat
store 17
load 17
retsub

// string_reverse
stringreverse_6:
store 52
load 52
int 1
int 0
*
int 2
+
getbyte
store 56
load 52
int 1
int 1
*
int 2
+
getbyte
store 55
load 52
int 1
int 2
*
int 2
+
getbyte
store 54
int 3
store 57
load 57
itob
extract 6 0
byte 0x00
int 0
load 54
setbyte
byte 0x00
int 0
load 55
setbyte
concat
byte 0x00
int 0
load 56
setbyte
concat
concat
store 53
load 53
retsub


================================================
FILE: tests/integration/teal/roundtrip/app_roundtrip_(bool,byte,address,string)_v8.teal
================================================
#pragma version 8
txna ApplicationArgs 0
store 1
load 1
callsub roundtripper_1
store 0
byte 0x151f7c75
load 0
concat
log
int 1
return

// tuple_complement
tuplecomplement_0:
proto 1 1
byte ""
int 0
dup
byte ""
dup
int 0
dupn 2
byte ""
dup
frame_dig -1
int 0
getbit
frame_bury 1
frame_dig -1
int 1
getbyte
frame_bury 2
frame_dig -1
extract 2 32
frame_bury 3
frame_dig -1
frame_dig -1
int 34
extract_uint16
dig 1
len
substring3
frame_bury 4
frame_dig 1
callsub boolcomp_2
frame_bury 1
frame_dig 2
callsub numericalcomp_3
frame_bury 2
frame_dig 3
callsub arraycomplement_5
frame_bury 3
frame_dig 4
callsub stringreverse_6
frame_bury 4
byte 0x00
int 0
frame_dig 1
setbit
byte 0x00
int 0
frame_dig 2
setbyte
concat
frame_dig 3
concat
frame_dig 4
frame_bury 9
frame_dig 9
frame_bury 8
int 36
frame_bury 6
frame_dig 6
itob
extract 6 0
concat
frame_dig 8
concat
frame_bury 0
retsub

// round_tripper
roundtripper_1:
proto 1 1
byte ""
dupn 2
int 0
dup
byte ""
dup
frame_dig -1
callsub tuplecomplement_0
frame_bury 1
frame_dig 1
callsub tuplecomplement_0
frame_bury 2
frame_dig -1
frame_bury 6
frame_dig 6
frame_bury 5
int 6
frame_bury 3
frame_dig 3
frame_dig 6
len
+
frame_bury 4
frame_dig 4
int 65536
<
assert
frame_dig 3
itob
extract 6 0
frame_dig 1
frame_bury 6
frame_dig 5
frame_dig 6
concat
frame_bury 5
frame_dig 4
frame_bury 3
frame_dig 3
frame_dig 6
len
+
frame_bury 4
frame_dig 4
int 65536
<
assert
frame_dig 3
itob
extract 6 0
concat
frame_dig 2
frame_bury 6
frame_dig 5
frame_dig 6
concat
frame_bury 5
frame_dig 4
frame_bury 3
frame_dig 3
itob
extract 6 0
concat
frame_dig 5
concat
frame_bury 0
retsub

// bool_comp
boolcomp_2:
proto 1 1
int 0
frame_dig -1
!
!
!
frame_bury 0
retsub

// numerical_comp
numericalcomp_3:
proto 1 1
int 0
int 255
frame_dig -1
-
frame_bury 0
frame_dig 0
int 256
<
assert
retsub

// numerical_comp
numericalcomp_4:
proto 1 1
int 0
int 255
frame_dig -1
-
frame_bury 0
frame_dig 0
int 256
<
assert
retsub

// array_complement
arraycomplement_5:
proto 1 1
byte ""
int 0
dupn 33
byte ""
dup
frame_dig -1
int 1
int 0
*
getbyte
frame_bury 1
frame_dig -1
int 1
int 1
*
getbyte
frame_bury 2
frame_dig -1
int 1
int 2
*
getbyte
frame_bury 3
frame_dig -1
int 1
int 3
*
getbyte
frame_bury 4
frame_dig -1
int 1
int 4
*
getbyte
frame_bury 5
frame_dig -1
int 1
int 5
*
getbyte
frame_bury 6
frame_dig -1
int 1
int 6
*
getbyte
frame_bury 7
frame_dig -1
int 1
int 7
*
getbyte
frame_bury 8
frame_dig -1
int 1
int 8
*
getbyte
frame_bury 9
frame_dig -1
int 1
int 9
*
getbyte
frame_bury 10
frame_dig -1
int 1
int 10
*
getbyte
frame_bury 11
frame_dig -1
int 1
int 11
*
getbyte
frame_bury 12
frame_dig -1
int 1
int 12
*
getbyte
frame_bury 13
frame_dig -1
int 1
int 13
*
getbyte
frame_bury 14
frame_dig -1
int 1
int 14
*
getbyte
frame_bury 15
frame_dig -1
int 1
int 15
*
getbyte
frame_bury 16
frame_dig -1
int 1
int 16
*
getbyte
frame_bury 17
frame_dig -1
int 1
int 17
*
getbyte
frame_bury 18
frame_dig -1
int 1
int 18
*
getbyte
frame_bury 19
frame_dig -1
int 1
int 19
*
getbyte
frame_bury 20
frame_dig -1
int 1
int 20
*
getbyte
frame_bury 21
frame_dig -1
int 1
int 21
*
getbyte
frame_bury 22
frame_dig -1
int 1
int 22
*
getbyte
frame_bury 23
frame_dig -1
int 1
int 23
*
getbyte
frame_bury 24
frame_dig -1
int 1
int 24
*
getbyte
frame_bury 25
frame_dig -1
int 1
int 25
*
getbyte
frame_bury 26
frame_dig -1
int 1
int 26
*
getbyte
frame_bury 27
frame_dig -1
int 1
int 27
*
getbyte
frame_bury 28
frame_dig -1
int 1
int 28
*
getbyte
frame_bury 29
frame_dig -1
int 1
int 29
*
getbyte
frame_bury 30
frame_dig -1
int 1
int 30
*
getbyte
frame_bury 31
frame_dig -1
int 1
int 31
*
getbyte
frame_bury 32
frame_dig 1
callsub numericalcomp_4
frame_bury 1
frame_dig 2
callsub numericalcomp_4
frame_bury 2
frame_dig 3
callsub numericalcomp_4
frame_bury 3
frame_dig 4
callsub numericalcomp_4
frame_bury 4
frame_dig 5
callsub numericalcomp_4
frame_bury 5
frame_dig 6
callsub numericalcomp_4
frame_bury 6
frame_dig 7
callsub numericalcomp_4
frame_bury 7
frame_dig 8
callsub numericalcomp_4
frame_bury 8
frame_dig 9
callsub numericalcomp_4
frame_bury 9
frame_dig 10
callsub numericalcomp_4
frame_bury 10
frame_dig 11
callsub numericalcomp_4
frame_bury 11
frame_dig 12
callsub numericalcomp_4
frame_bury 12
frame_dig 13
callsub numericalcomp_4
frame_bury 13
frame_dig 14
callsub numericalcomp_4
frame_bury 14
frame_dig 15
callsub numericalcomp_4
frame_bury 15
frame_dig 16
callsub numericalcomp_4
frame_bury 16
frame_dig 17
callsub numericalcomp_4
frame_bury 17
frame_dig 18
callsub numericalcomp_4
frame_bury 18
frame_dig 19
callsub numericalcomp_4
frame_bury 19
frame_dig 20
callsub numericalcomp_4
frame_bury 20
frame_dig 21
callsub numericalcomp_4
frame_bury 21
frame_dig 22
callsub numericalcomp_4
frame_bury 22
frame_dig 23
callsub numericalcomp_4
frame_bury 23
frame_dig 24
callsub numericalcomp_4
frame_bury 24
frame_dig 25
callsub numericalcomp_4
frame_bury 25
frame_dig 26
callsub numericalcomp_4
frame_bury 26
frame_dig 27
callsub numericalcomp_4
frame_bury 27
frame_dig 28
callsub numericalcomp_4
frame_bury 28
frame_dig 29
callsub numericalcomp_4
frame_bury 29
frame_dig 30
callsub numericalcomp_4
frame_bury 30
frame_dig 31
callsub numericalcomp_4
frame_bury 31
frame_dig 32
callsub numericalcomp_4
frame_bury 32
byte 0x00
int 0
frame_dig 1
setbyte
byte 0x00
int 0
frame_dig 2
setbyte
concat
byte 0x00
int 0
frame_dig 3
setbyte
concat
byte 0x00
int 0
frame_dig 4
setbyte
concat
byte 0x00
int 0
frame_dig 5
setbyte
concat
byte 0x00
int 0
frame_dig 6
setbyte
concat
byte 0x00
int 0
frame_dig 7
setbyte
concat
byte 0x00
int 0
frame_dig 8
setbyte
concat
byte 0x00
int 0
frame_dig 9
setbyte
concat
byte 0x00
int 0
frame_dig 10
setbyte
concat
byte 0x00
int 0
frame_dig 11
setbyte
concat
byte 0x00
int 0
frame_dig 12
setbyte
concat
byte 0x00
int 0
frame_dig 13
setbyte
concat
byte 0x00
int 0
frame_dig 14
setbyte
concat
byte 0x00
int 0
frame_dig 15
setbyte
concat
byte 0x00
int 0
frame_dig 16
setbyte
concat
byte 0x00
int 0
frame_dig 17
setbyte
concat
byte 0x00
int 0
frame_dig 18
setbyte
concat
byte 0x00
int 0
frame_dig 19
setbyte
concat
byte 0x00
int 0
frame_dig 20
setbyte
concat
byte 0x00
int 0
frame_dig 21
setbyte
concat
byte 0x00
int 0
frame_dig 22
setbyte
concat
byte 0x00
int 0
frame_dig 23
setbyte
concat
byte 0x00
int 0
frame_dig 24
setbyte
concat
byte 0x00
int 0
frame_dig 25
setbyte
concat
byte 0x00
int 0
frame_dig 26
setbyte
concat
byte 0x00
int 0
frame_dig 27
setbyte
concat
byte 0x00
int 0
frame_dig 28
setbyte
concat
byte 0x00
int 0
frame_dig 29
setbyte
concat
byte 0x00
int 0
frame_dig 30
setbyte
concat
byte 0x00
int 0
frame_dig 31
setbyte
concat
byte 0x00
int 0
frame_dig 32
setbyte
concat
frame_bury 0
retsub

// string_reverse
stringreverse_6:
proto 1 1
byte ""
int 0
dupn 7
byte ""
dup
int 0
frame_dig -1
int 1
int 0
*
int 2
+
getbyte
frame_bury 3
frame_dig -1
int 1
int 1
*
int 2
+
getbyte
frame_bury 2
frame_dig -1
int 1
int 2
*
int 2
+
getbyte
frame_bury 1
int 3
frame_bury 11
frame_dig 11
itob
extract 6 0
byte 0x00
int 0
frame_dig 1
setbyte
byte 0x00
int 0
frame_dig 2
setbyte
concat
byte 0x00
int 0
frame_dig 3
setbyte
concat
concat
frame_bury 0
retsub


================================================
FILE: tests/integration/teal/roundtrip/app_roundtrip_(bool,byte,address,string,(address,(uint32,string[],bool[2],(byte),uint8)[2],string,bool[]))[]_2_v6.teal
================================================
#pragma version 6
txna ApplicationArgs 0
store 1
load 1
callsub roundtripper_2
store 0
byte 0x151f7c75
load 0
concat
log
int 1
return

// tuple_complement
tuplecomplement_0:
store 12
load 12
int 0
getbit
store 14
load 12
int 1
getbyte
store 15
load 12
extract 2 32
store 16
load 12
load 12
int 34
extract_uint16
load 12
int 36
extract_uint16
substring3
store 17
load 12
load 12
int 36
extract_uint16
dig 1
len
substring3
store 18
load 14
callsub boolcomp_3
store 14
load 15
callsub numericalcomp_4
store 15
load 16
callsub arraycomplement_6
store 16
load 17
callsub stringreverse_7
store 17
load 18
callsub tuplecomplement_8
store 18
byte 0x00
int 0
load 14
setbit
byte 0x00
int 0
load 15
setbyte
concat
load 16
concat
load 17
store 180
load 180
store 179
int 38
store 177
load 177
load 180
len
+
store 178
load 178
int 65536
<
assert
load 177
itob
extract 6 0
concat
load 18
store 180
load 179
load 180
concat
store 179
load 178
store 177
load 177
itob
extract 6 0
concat
load 179
concat
store 13
load 13
retsub

// array_complement
arraycomplement_1:
store 6
load 6
load 6
int 2
int 0
*
int 2
+
extract_uint16
int 2
+
int 0
int 1
+
load 6
int 0
extract_uint16
store 10
load 10
==
bnz arraycomplement_1_l5
load 6
int 2
int 0
*
int 2
+
int 2
+
extract_uint16
int 2
+
arraycomplement_1_l2:
substring3
store 8
load 6
load 6
int 2
int 1
*
int 2
+
extract_uint16
int 2
+
int 1
int 1
+
load 6
int 0
extract_uint16
store 11
load 11
==
bnz arraycomplement_1_l4
load 6
int 2
int 1
*
int 2
+
int 2
+
extract_uint16
int 2
+
b arraycomplement_1_l6
arraycomplement_1_l4:
load 6
len
b arraycomplement_1_l6
arraycomplement_1_l5:
load 6
len
b arraycomplement_1_l2
arraycomplement_1_l6:
substring3
store 9
load 8
callsub tuplecomplement_0
store 8
load 9
callsub tuplecomplement_0
store 9
int 2
store 185
load 185
itob
extract 6 0
load 8
store 184
load 184
store 183
int 4
store 181
load 181
load 184
len
+
store 182
load 182
int 65536
<
assert
load 181
itob
extract 6 0
load 9
store 184
load 183
load 184
concat
store 183
load 182
store 181
load 181
itob
extract 6 0
concat
load 183
concat
concat
store 7
load 7
retsub

// round_tripper
roundtripper_2:
store 2
load 2
callsub arraycomplement_1
store 4
load 4
callsub arraycomplement_1
store 5
load 2
store 189
load 189
store 188
int 6
store 186
load 186
load 189
len
+
store 187
load 187
int 65536
<
assert
load 186
itob
extract 6 0
load 4
store 189
load 188
load 189
concat
store 188
load 187
store 186
load 186
load 189
len
+
store 187
load 187
int 65536
<
assert
load 186
itob
extract 6 0
concat
load 5
store 189
load 188
load 189
concat
store 188
load 187
store 186
load 186
itob
extract 6 0
concat
load 188
concat
store 3
load 3
retsub

// bool_comp
boolcomp_3:
store 19
load 19
!
!
!
store 20
load 20
retsub

// numerical_comp
numericalcomp_4:
store 21
int 255
load 21
-
store 22
load 22
int 256
<
assert
load 22
retsub

// numerical_comp
numericalcomp_5:
store 57
int 255
load 57
-
store 58
load 58
int 256
<
assert
load 58
retsub

// array_complement
arraycomplement_6:
store 23
load 23
int 1
int 0
*
getbyte
store 25
load 23
int 1
int 1
*
getbyte
store 26
load 23
int 1
int 2
*
getbyte
store 27
load 23
int 1
int 3
*
getbyte
store 28
load 23
int 1
int 4
*
getbyte
store 29
load 23
int 1
int 5
*
getbyte
store 30
load 23
int 1
int 6
*
getbyte
store 31
load 23
int 1
int 7
*
getbyte
store 32
load 23
int 1
int 8
*
getbyte
store 33
load 23
int 1
int 9
*
getbyte
store 34
load 23
int 1
int 10
*
getbyte
store 35
load 23
int 1
int 11
*
getbyte
store 36
load 23
int 1
int 12
*
getbyte
store 37
load 23
int 1
int 13
*
getbyte
store 38
load 23
int 1
int 14
*
getbyte
store 39
load 23
int 1
int 15
*
getbyte
store 40
load 23
int 1
int 16
*
getbyte
store 41
load 23
int 1
int 17
*
getbyte
store 42
load 23
int 1
int 18
*
getbyte
store 43
load 23
int 1
int 19
*
getbyte
store 44
load 23
int 1
int 20
*
getbyte
store 45
load 23
int 1
int 21
*
getbyte
store 46
load 23
int 1
int 22
*
getbyte
store 47
load 23
int 1
int 23
*
getbyte
store 48
load 23
int 1
int 24
*
getbyte
store 49
load 23
int 1
int 25
*
getbyte
store 50
load 23
int 1
int 26
*
getbyte
store 51
load 23
int 1
int 27
*
getbyte
store 52
load 23
int 1
int 28
*
getbyte
store 53
load 23
int 1
int 29
*
getbyte
store 54
load 23
int 1
int 30
*
getbyte
store 55
load 23
int 1
int 31
*
getbyte
store 56
load 25
callsub numericalcomp_5
store 25
load 26
callsub numericalcomp_5
store 26
load 27
callsub numericalcomp_5
store 27
load 28
callsub numericalcomp_5
store 28
load 29
callsub numericalcomp_5
store 29
load 30
callsub numericalcomp_5
store 30
load 31
callsub numericalcomp_5
store 31
load 32
callsub numericalcomp_5
store 32
load 33
callsub numericalcomp_5
store 33
load 34
callsub numericalcomp_5
store 34
load 35
callsub numericalcomp_5
store 35
load 36
callsub numericalcomp_5
store 36
load 37
callsub numericalcomp_5
store 37
load 38
callsub numericalcomp_5
store 38
load 39
callsub numericalcomp_5
store 39
load 40
callsub numericalcomp_5
store 40
load 41
callsub numericalcomp_5
store 41
load 42
callsub numericalcomp_5
store 42
load 43
callsub numericalcomp_5
store 43
load 44
callsub numericalcomp_5
store 44
load 45
callsub numericalcomp_5
store 45
load 46
callsub numericalcomp_5
store 46
load 47
callsub numericalcomp_5
store 47
load 48
callsub numericalcomp_5
store 48
load 49
callsub numericalcomp_5
store 49
load 50
callsub numericalcomp_5
store 50
load 51
callsub numericalcomp_5
store 51
load 52
callsub numericalcomp_5
store 52
load 53
callsub numericalcomp_5
store 53
load 54
callsub numericalcomp_5
store 54
load 55
callsub numericalcomp_5
store 55
load 56
callsub numericalcomp_5
store 56
byte 0x00
int 0
load 25
setbyte
byte 0x00
int 0
load 26
setbyte
concat
byte 0x00
int 0
load 27
setbyte
concat
byte 0x00
int 0
load 28
setbyte
concat
byte 0x00
int 0
load 29
setbyte
concat
byte 0x00
int 0
load 30
setbyte
concat
byte 0x00
int 0
load 31
setbyte
concat
byte 0x00
int 0
load 32
setbyte
concat
byte 0x00
int 0
load 33
setbyte
concat
byte 0x00
int 0
load 34
setbyte
concat
byte 0x00
int 0
load 35
setbyte
concat
byte 0x00
int 0
load 36
setbyte
concat
byte 0x00
int 0
load 37
setbyte
concat
byte 0x00
int 0
load 38
setbyte
concat
byte 0x00
int 0
load 39
setbyte
concat
byte 0x00
int 0
load 40
setbyte
concat
byte 0x00
int 0
load 41
setbyte
concat
byte 0x00
int 0
load 42
setbyte
concat
byte 0x00
int 0
load 43
setbyte
concat
byte 0x00
int 0
load 44
setbyte
concat
byte 0x00
int 0
load 45
setbyte
concat
byte 0x00
int 0
load 46
setbyte
concat
byte 0x00
int 0
load 47
setbyte
concat
byte 0x00
int 0
load 48
setbyte
concat
byte 0x00
int 0
load 49
setbyte
concat
byte 0x00
int 0
load 50
setbyte
concat
byte 0x00
int 0
load 51
setbyte
concat
byte 0x00
int 0
load 52
setbyte
concat
byte 0x00
int 0
load 53
setbyte
concat
byte 0x00
int 0
load 54
setbyte
concat
byte 0x00
int 0
load 55
setbyte
concat
byte 0x00
int 0
load 56
setbyte
concat
store 24
load 24
retsub

// string_reverse
stringreverse_7:
store 59
load 59
int 1
int 0
*
int 2
+
getbyte
store 63
load 59
int 1
int 1
*
int 2
+
getbyte
store 62
load 59
int 1
int 2
*
int 2
+
getbyte
store 61
int 3
store 64
load 64
itob
extract 6 0
byte 0x00
int 0
load 61
setbyte
byte 0x00
int 0
load 62
setbyte
concat
byte 0x00
int 0
load 63
setbyte
concat
concat
store 60
load 60
retsub

// tuple_complement
tuplecomplement_8:
store 65
load 65
extract 0 32
store 67
load 65
load 65
int 32
extract_uint16
load 65
int 34
extract_uint16
substring3
store 68
load 65
load 65
int 34
extract_uint16
load 65
int 36
extract_uint16
substring3
store 69
load 65
load 65
int 36
extract_uint16
dig 1
len
substring3
store 70
load 67
callsub arraycomplement_10
store 67
load 68
callsub arraycomplement_12
store 68
load 69
callsub stringreverse_13
store 69
load 70
callsub arraycomplement_15
store 70
load 67
load 68
store 176
load 176
store 175
int 38
store 173
load 173
load 176
len
+
store 174
load 174
int 65536
<
assert
load 173
itob
extract 6 0
concat
load 69
store 176
load 175
load 176
concat
store 175
load 174
store 173
load 173
load 176
len
+
store 174
load 174
int 65536
<
assert
load 173
itob
extract 6 0
concat
load 70
store 176
load 175
load 176
concat
store 175
load 174
store 173
load 173
itob
extract 6 0
concat
load 175
concat
store 66
load 66
retsub

// numerical_comp
numericalcomp_9:
store 105
int 255
load 105
-
store 106
load 106
int 256
<
assert
load 106
retsub

// array_complement
arraycomplement_10:
store 71
load 71
int 1
int 0
*
getbyte
store 73
load 71
int 1
int 1
*
getbyte
store 74
load 71
int 1
int 2
*
getbyte
store 75
load 71
int 1
int 3
*
getbyte
store 76
load 71
int 1
int 4
*
getbyte
store 77
load 71
int 1
int 5
*
getbyte
store 78
load 71
int 1
int 6
*
getbyte
store 79
load 71
int 1
int 7
*
getbyte
store 80
load 71
int 1
int 8
*
getbyte
store 81
load 71
int 1
int 9
*
getbyte
store 82
load 71
int 1
int 10
*
getbyte
store 83
load 71
int 1
int 11
*
getbyte
store 84
load 71
int 1
int 12
*
getbyte
store 85
load 71
int 1
int 13
*
getbyte
store 86
load 71
int 1
int 14
*
getbyte
store 87
load 71
int 1
int 15
*
getbyte
store 88
load 71
int 1
int 16
*
getbyte
store 89
load 71
int 1
int 17
*
getbyte
store 90
load 71
int 1
int 18
*
getbyte
store 91
load 71
int 1
int 19
*
getbyte
store 92
load 71
int 1
int 20
*
getbyte
store 93
load 71
int 1
int 21
*
getbyte
store 94
load 71
int 1
int 22
*
getbyte
store 95
load 71
int 1
int 23
*
getbyte
store 96
load 71
int 1
int 24
*
getbyte
store 97
load 71
int 1
int 25
*
getbyte
store 98
load 71
int 1
int 26
*
getbyte
store 99
load 71
int 1
int 27
*
getbyte
store 100
load 71
int 1
int 28
*
getbyte
store 101
load 71
int 1
int 29
*
getbyte
store 102
load 71
int 1
int 30
*
getbyte
store 103
load 71
int 1
int 31
*
getbyte
store 104
load 73
callsub numericalcomp_9
store 73
load 74
callsub numericalcomp_9
store 74
load 75
callsub numericalcomp_9
store 75
load 76
callsub numericalcomp_9
store 76
load 77
callsub numericalcomp_9
store 77
load 78
callsub numericalcomp_9
store 78
load 79
callsub numericalcomp_9
store 79
load 80
callsub numericalcomp_9
store 80
load 81
callsub numericalcomp_9
store 81
load 82
callsub numericalcomp_9
store 82
load 83
callsub numericalcomp_9
store 83
load 84
callsub numericalcomp_9
store 84
load 85
callsub numericalcomp_9
store 85
load 86
callsub numericalcomp_9
store 86
load 87
callsub numericalcomp_9
store 87
load 88
callsub numericalcomp_9
store 88
load 89
callsub numericalcomp_9
store 89
load 90
callsub numericalcomp_9
store 90
load 91
callsub numericalcomp_9
store 91
load 92
callsub numericalcomp_9
store 92
load 93
callsub numericalcomp_9
store 93
load 94
callsub numericalcomp_9
store 94
load 95
callsub numericalcomp_9
store 95
load 96
callsub numericalcomp_9
store 96
load 97
callsub numericalcomp_9
store 97
load 98
callsub numericalcomp_9
store 98
load 99
callsub numericalcomp_9
store 99
load 100
callsub numericalcomp_9
store 100
load 101
callsub numericalcomp_9
store 101
load 102
callsub numericalcomp_9
store 102
load 103
callsub numericalcomp_9
store 103
load 104
callsub numericalcomp_9
store 104
byte 0x00
int 0
load 73
setbyte
byte 0x00
int 0
load 74
setbyte
concat
byte 0x00
int 0
load 75
setbyte
concat
byte 0x00
int 0
load 76
setbyte
concat
byte 0x00
int 0
load 77
setbyte
concat
byte 0x00
int 0
load 78
setbyte
concat
byte 0x00
int 0
load 79
setbyte
concat
byte 0x00
int 0
load 80
setbyte
concat
byte 0x00
int 0
load 81
setbyte
concat
byte 0x00
int 0
load 82
setbyte
concat
byte 0x00
int 0
load 83
setbyte
concat
byte 0x00
int 0
load 84
setbyte
concat
byte 0x00
int 0
load 85
setbyte
concat
byte 0x00
int 0
load 86
setbyte
concat
byte 0x00
int 0
load 87
setbyte
concat
byte 0x00
int 0
load 88
setbyte
concat
byte 0x00
int 0
load 89
setbyte
concat
byte 0x00
int 0
load 90
setbyte
concat
byte 0x00
int 0
load 91
setbyte
concat
byte 0x00
int 0
load 92
setbyte
concat
byte 0x00
int 0
load 93
setbyte
concat
byte 0x00
int 0
load 94
setbyte
concat
byte 0x00
int 0
load 95
setbyte
concat
byte 0x00
int 0
load 96
setbyte
concat
byte 0x00
int 0
load 97
setbyte
concat
byte 0x00
int 0
load 98
setbyte
concat
byte 0x00
int 0
load 99
setbyte
concat
byte 0x00
int 0
load 100
setbyte
concat
byte 0x00
int 0
load 101
setbyte
concat
byte 0x00
int 0
load 102
setbyte
concat
byte 0x00
int 0
load 103
setbyte
concat
byte 0x00
int 0
load 104
setbyte
concat
store 72
load 72
retsub

// tuple_complement
tuplecomplement_11:
store 111
load 111
int 0
extract_uint32
store 113
load 111
load 111
int 4
extract_uint16
dig 1
len
substring3
store 114
load 111
extract 6 1
store 115
load 111
extract 7 1
store 116
load 111
int 8
getbyte
store 117
load 113
callsub numericalcomp_16
store 113
load 114
callsub arraycomplement_18
store 114
load 115
callsub arraycomplement_20
store 115
load 116
callsub tuplecomplement_21
store 116
load 117
callsub numericalcomp_22
store 117
load 113
itob
extract 4 0
load 114
store 154
load 154
store 153
int 9
store 152
load 152
itob
extract 6 0
concat
load 115
concat
load 116
concat
byte 0x00
int 0
load 117
setbyte
concat
load 153
concat
store 112
load 112
retsub

// array_complement
arraycomplement_12:
store 107
load 107
load 107
int 2
int 0
*
extract_uint16
int 0
int 1
+
int 2
==
bnz arraycomplement_12_l5
load 107
int 2
int 0
*
int 2
+
extract_uint16
arraycomplement_12_l2:
substring3
store 109
load 107
load 107
int 2
int 1
*
extract_uint16
int 1
int 1
+
int 2
==
bnz arraycomplement_12_l4
load 107
int 2
int 1
*
int 2
+
extract_uint16
b arraycomplement_12_l6
arraycomplement_12_l4:
load 107
len
b arraycomplement_12_l6
arraycomplement_12_l5:
load 107
len
b arraycomplement_12_l2
arraycomplement_12_l6:
substring3
store 110
load 109
callsub tuplecomplement_11
store 109
load 110
callsub tuplecomplement_11
store 110
load 109
store 158
load 158
store 157
int 4
store 155
load 155
load 158
len
+
store 156
load 156
int 65536
<
assert
load 155
itob
extract 6 0
load 110
store 158
load 157
load 158
concat
store 157
load 156
store 155
load 155
itob
extract 6 0
concat
load 157
concat
store 108
load 108
retsub

// string_reverse
stringreverse_13:
store 159
load 159
int 1
int 0
*
int 2
+
getbyte
store 163
load 159
int 1
int 1
*
int 2
+
getbyte
store 162
load 159
int 1
int 2
*
int 2
+
getbyte
store 161
int 3
store 164
load 164
itob
extract 6 0
byte 0x00
int 0
load 161
setbyte
byte 0x00
int 0
load 162
setbyte
concat
byte 0x00
int 0
load 163
setbyte
concat
concat
store 160
load 160
retsub

// bool_comp
boolcomp_14:
store 170
load 170
!
!
!
store 171
load 171
retsub

// array_complement
arraycomplement_15:
store 165
load 165
int 0
int 16
+
getbit
store 167
load 165
int 1
int 16
+
getbit
store 168
load 165
int 2
int 16
+
getbit
store 169
load 167
callsub boolcomp_14
store 167
load 168
callsub boolcomp_14
store 168
load 169
callsub boolcomp_14
store 169
int 3
store 172
load 172
itob
extract 6 0
byte 0x00
int 0
load 167
setbit
int 1
load 168
setbit
int 2
load 169
setbit
concat
store 166
load 166
retsub

// numerical_comp
numericalcomp_16:
store 118
int 4294967295
load 118
-
store 119
load 119
int 4294967296
<
assert
load 119
retsub

// string_reverse
stringreverse_17:
store 128
load 128
int 1
int 0
*
int 2
+
getbyte
store 132
load 128
int 1
int 1
*
int 2
+
getbyte
store 131
load 128
int 1
int 2
*
int 2
+
getbyte
store 130
int 3
store 133
load 133
itob
extract 6 0
byte 0x00
int 0
load 130
setbyte
byte 0x00
int 0
load 131
setbyte
concat
byte 0x00
int 0
load 132
setbyte
concat
concat
store 129
load 129
retsub

// array_complement
arraycomplement_18:
store 120
load 120
load 120
int 2
int 0
*
int 2
+
extract_uint16
int 2
+
int 0
int 1
+
load 120
int 0
extract_uint16
store 125
load 125
==
bnz arraycomplement_18_l8
load 120
int 2
int 0
*
int 2
+
int 2
+
extract_uint16
int 2
+
arraycomplement_18_l2:
substring3
store 122
load 120
load 120
int 2
int 1
*
int 2
+
extract_uint16
int 2
+
int 1
int 1
+
load 120
int 0
extract_uint16
store 126
load 126
==
bnz arraycomplement_18_l7
load 120
int 2
int 1
*
int 2
+
int 2
+
extract_uint16
int 2
+
arraycomplement_18_l4:
substring3
store 123
load 120
load 120
int 2
int 2
*
int 2
+
extract_uint16
int 2
+
int 2
int 1
+
load 120
int 0
extract_uint16
store 127
load 127
==
bnz arraycomplement_18_l6
load 120
int 2
int 2
*
int 2
+
int 2
+
extract_uint16
int 2
+
b arraycomplement_18_l9
arraycomplement_18_l6:
load 120
len
b arraycomplement_18_l9
arraycomplement_18_l7:
load 120
len
b arraycomplement_18_l4
arraycomplement_18_l8:
load 120
len
b arraycomplement_18_l2
arraycomplement_18_l9:
substring3
store 124
load 122
callsub stringreverse_17
store 122
load 123
callsub stringreverse_17
store 123
load 124
callsub stringreverse_17
store 124
int 3
store 138
load 138
itob
extract 6 0
load 122
store 137
load 137
store 136
int 6
store 134
load 134
load 137
len
+
store 135
load 135
int 65536
<
assert
load 134
itob
extract 6 0
load 123
store 137
load 136
load 137
concat
store 136
load 135
store 134
load 134
load 137
len
+
store 135
load 135
int 65536
<
assert
load 134
itob
extract 6 0
concat
load 124
store 137
load 136
load 137
concat
store 136
load 135
store 134
load 134
itob
extract 6 0
concat
load 136
concat
concat
store 121
load 121
retsub

// bool_comp
boolcomp_19:
store 143
load 143
!
!
!
store 144
load 144
retsub

// array_complement
arraycomplement_20:
store 139
load 139
int 0
getbit
store 141
load 139
int 1
getbit
store 142
load 141
callsub boolcomp_19
store 141
load 142
callsub boolcomp_19
store 142
byte 0x00
int 0
load 141
setbit
int 1
load 142
setbit
store 140
load 140
retsub

// tuple_complement
tuplecomplement_21:
store 145
load 145
int 0
getbyte
store 147
load 147
callsub numericalcomp_23
store 147
byte 0x00
int 0
load 147
setbyte
store 146
load 146
retsub

// numerical_comp
numericalcomp_22:
store 150
int 255
load 150
-
store 151
load 151
int 256
<
assert
load 151
retsub

// numerical_comp
numericalcomp_23:
store 148
int 255
load 148
-
store 149
load 149
int 256
<
assert
load 149
retsub


================================================
FILE: tests/integration/teal/roundtrip/app_roundtrip_(bool,byte,address,string,(address,(uint32,string[],bool[2],(byte),uint8)[2],string,bool[]))[]_2_v8.teal
================================================
#pragma version 8
txna ApplicationArgs 0
store 1
load 1
callsub roundtripper_2
store 0
byte 0x151f7c75
load 0
concat
log
int 1
return

// tuple_complement
tuplecomplement_0:
proto 1 1
byte ""
int 0
dup
byte ""
dupn 2
int 0
dupn 2
byte ""
dup
frame_dig -1
int 0
getbit
frame_bury 1
frame_dig -1
int 1
getbyte
frame_bury 2
frame_dig -1
extract 2 32
frame_bury 3
frame_dig -1
frame_dig -1
int 34
extract_uint16
frame_dig -1
int 36
extract_uint16
substring3
frame_bury 4
frame_dig -1
frame_dig -1
int 36
extract_uint16
dig 1
len
substring3
frame_bury 5
frame_dig 1
callsub boolcomp_3
frame_bury 1
frame_dig 2
callsub numericalcomp_4
frame_bury 2
frame_dig 3
callsub arraycomplement_6
frame_bury 3
frame_dig 4
callsub stringreverse_7
frame_bury 4
frame_dig 5
callsub tuplecomplement_8
frame_bury 5
byte 0x00
int 0
frame_dig 1
setbit
byte 0x00
int 0
frame_dig 2
setbyte
concat
frame_dig 3
concat
frame_dig 4
frame_bury 10
frame_dig 10
frame_bury 9
int 38
frame_bury 7
frame_dig 7
frame_dig 10
len
+
frame_bury 8
frame_dig 8
int 65536
<
assert
frame_dig 7
itob
extract 6 0
concat
frame_dig 5
frame_bury 10
frame_dig 9
frame_dig 10
concat
frame_bury 9
frame_dig 8
frame_bury 7
frame_dig 7
itob
extract 6 0
concat
frame_dig 9
concat
frame_bury 0
retsub

// array_complement
arraycomplement_1:
proto 1 1
byte ""
dupn 2
int 0
dupn 3
byte ""
dup
int 0
frame_dig -1
frame_dig -1
int 2
int 0
*
int 2
+
extract_uint16
int 2
+
int 0
int 1
+
frame_dig -1
int 0
extract_uint16
frame_bury 3
frame_dig 3
==
bnz arraycomplement_1_l5
frame_dig -1
int 2
int 0
*
int 2
+
int 2
+
extract_uint16
int 2
+
arraycomplement_1_l2:
substring3
frame_bury 1
frame_dig -1
frame_dig -1
int 2
int 1
*
int 2
+
extract_uint16
int 2
+
int 1
int 1
+
frame_dig -1
int 0
extract_uint16
frame_bury 4
frame_dig 4
==
bnz arraycomplement_1_l4
frame_dig -1
int 2
int 1
*
int 2
+
int 2
+
extract_uint16
int 2
+
b arraycomplement_1_l6
arraycomplement_1_l4:
frame_dig -1
len
b arraycomplement_1_l6
arraycomplement_1_l5:
frame_dig -1
len
b arraycomplement_1_l2
arraycomplement_1_l6:
substring3
frame_bury 2
frame_dig 1
callsub tuplecomplement_0
frame_bury 1
frame_dig 2
callsub tuplecomplement_0
frame_bury 2
int 2
frame_bury 9
frame_dig 9
itob
extract 6 0
frame_dig 1
frame_bury 8
frame_dig 8
frame_bury 7
int 4
frame_bury 5
frame_dig 5
frame_dig 8
len
+
frame_bury 6
frame_dig 6
int 65536
<
assert
frame_dig 5
itob
extract 6 0
frame_dig 2
frame_bury 8
frame_dig 7
frame_dig 8
concat
frame_bury 7
frame_dig 6
frame_bury 5
frame_dig 5
itob
extract 6 0
concat
frame_dig 7
concat
concat
frame_bury 0
retsub

// round_tripper
roundtripper_2:
proto 1 1
byte ""
dupn 2
int 0
dup
byte ""
dup
frame_dig -1
callsub arraycomplement_1
frame_bury 1
frame_dig 1
callsub arraycomplement_1
frame_bury 2
frame_dig -1
frame_bury 6
frame_dig 6
frame_bury 5
int 6
frame_bury 3
frame_dig 3
frame_dig 6
len
+
frame_bury 4
frame_dig 4
int 65536
<
assert
frame_dig 3
itob
extract 6 0
frame_dig 1
frame_bury 6
frame_dig 5
frame_dig 6
concat
frame_bury 5
frame_dig 4
frame_bury 3
frame_dig 3
frame_dig 6
len
+
frame_bury 4
frame_dig 4
int 65536
<
assert
frame_dig 3
itob
extract 6 0
concat
frame_dig 2
frame_bury 6
frame_dig 5
frame_dig 6
concat
frame_bury 5
frame_dig 4
frame_bury 3
frame_dig 3
itob
extract 6 0
concat
frame_dig 5
concat
frame_bury 0
retsub

// bool_comp
boolcomp_3:
proto 1 1
int 0
frame_dig -1
!
!
!
frame_bury 0
retsub

// numerical_comp
numericalcomp_4:
proto 1 1
int 0
int 255
frame_dig -1
-
frame_bury 0
frame_dig 0
int 256
<
assert
retsub

// numerical_comp
numericalcomp_5:
proto 1 1
int 0
int 255
frame_dig -1
-
frame_bury 0
frame_dig 0
int 256
<
assert
retsub

// array_complement
arraycomplement_6:
proto 1 1
byte ""
int 0
dupn 33
byte ""
dup
frame_dig -1
int 1
int 0
*
getbyte
frame_bury 1
frame_dig -1
int 1
int 1
*
getbyte
frame_bury 2
frame_dig -1
int 1
int 2
*
getbyte
frame_bury 3
frame_dig -1
int 1
int 3
*
getbyte
frame_bury 4
frame_dig -1
int 1
int 4
*
getbyte
frame_bury 5
frame_dig -1
int 1
int 5
*
getbyte
frame_bury 6
frame_dig -1
int 1
int 6
*
getbyte
frame_bury 7
frame_dig -1
int 1
int 7
*
getbyte
frame_bury 8
frame_dig -1
int 1
int 8
*
getbyte
frame_bury 9
frame_dig -1
int 1
int 9
*
getbyte
frame_bury 10
frame_dig -1
int 1
int 10
*
getbyte
frame_bury 11
frame_dig -1
int 1
int 11
*
getbyte
frame_bury 12
frame_dig -1
int 1
int 12
*
getbyte
frame_bury 13
frame_dig -1
int 1
int 13
*
getbyte
frame_bury 14
frame_dig -1
int 1
int 14
*
getbyte
frame_bury 15
frame_dig -1
int 1
int 15
*
getbyte
frame_bury 16
frame_dig -1
int 1
int 16
*
getbyte
frame_bury 17
frame_dig -1
int 1
int 17
*
getbyte
frame_bury 18
frame_dig -1
int 1
int 18
*
getbyte
frame_bury 19
frame_dig -1
int 1
int 19
*
getbyte
frame_bury 20
frame_dig -1
int 1
int 20
*
getbyte
frame_bury 21
frame_dig -1
int 1
int 21
*
getbyte
frame_bury 22
frame_dig -1
int 1
int 22
*
getbyte
frame_bury 23
frame_dig -1
int 1
int 23
*
getbyte
frame_bury 24
frame_dig -1
int 1
int 24
*
getbyte
frame_bury 25
frame_dig -1
int 1
int 25
*
getbyte
frame_bury 26
frame_dig -1
int 1
int 26
*
getbyte
frame_bury 27
frame_dig -1
int 1
int 27
*
getbyte
frame_bury 28
frame_dig -1
int 1
int 28
*
getbyte
frame_bury 29
frame_dig -1
int 1
int 29
*
getbyte
frame_bury 30
frame_dig -1
int 1
int 30
*
getbyte
frame_bury 31
frame_dig -1
int 1
int 31
*
getbyte
frame_bury 32
frame_dig 1
callsub numericalcomp_5
frame_bury 1
frame_dig 2
callsub numericalcomp_5
frame_bury 2
frame_dig 3
callsub numericalcomp_5
frame_bury 3
frame_dig 4
callsub numericalcomp_5
frame_bury 4
frame_dig 5
callsub numericalcomp_5
frame_bury 5
frame_dig 6
callsub numericalcomp_5
frame_bury 6
frame_dig 7
callsub numericalcomp_5
frame_bury 7
frame_dig 8
callsub numericalcomp_5
frame_bury 8
frame_dig 9
callsub numericalcomp_5
frame_bury 9
frame_dig 10
callsub numericalcomp_5
frame_bury 10
frame_dig 11
callsub numericalcomp_5
frame_bury 11
frame_dig 12
callsub numericalcomp_5
frame_bury 12
frame_dig 13
callsub numericalcomp_5
frame_bury 13
frame_dig 14
callsub numericalcomp_5
frame_bury 14
frame_dig 15
callsub numericalcomp_5
frame_bury 15
frame_dig 16
callsub numericalcomp_5
frame_bury 16
frame_dig 17
callsub numericalcomp_5
frame_bury 17
frame_dig 18
callsub numericalcomp_5
frame_bury 18
frame_dig 19
callsub numericalcomp_5
frame_bury 19
frame_dig 20
callsub numericalcomp_5
frame_bury 20
frame_dig 21
callsub numericalcomp_5
frame_bury 21
frame_dig 22
callsub numericalcomp_5
frame_bury 22
frame_dig 23
callsub numericalcomp_5
frame_bury 23
frame_dig 24
callsub numericalcomp_5
frame_bury 24
frame_dig 25
callsub numericalcomp_5
frame_bury 25
frame_dig 26
callsub numericalcomp_5
frame_bury 26
frame_dig 27
callsub numericalcomp_5
frame_bury 27
frame_dig 28
callsub numericalcomp_5
frame_bury 28
frame_dig 29
callsub numericalcomp_5
frame_bury 29
frame_dig 30
callsub numericalcomp_5
frame_bury 30
frame_dig 31
callsub numericalcomp_5
frame_bury 31
frame_dig 32
callsub numericalcomp_5
frame_bury 32
byte 0x00
int 0
frame_dig 1
setbyte
byte 0x00
int 0
frame_dig 2
setbyte
concat
byte 0x00
int 0
frame_dig 3
setbyte
concat
byte 0x00
int 0
frame_dig 4
setbyte
concat
byte 0x00
int 0
frame_dig 5
setbyte
concat
byte 0x00
int 0
frame_dig 6
setbyte
concat
byte 0x00
int 0
frame_dig 7
setbyte
concat
byte 0x00
int 0
frame_dig 8
setbyte
concat
byte 0x00
int 0
frame_dig 9
setbyte
concat
byte 0x00
int 0
frame_dig 10
setbyte
concat
byte 0x00
int 0
frame_dig 11
setbyte
concat
byte 0x00
int 0
frame_dig 12
setbyte
concat
byte 0x00
int 0
frame_dig 13
setbyte
concat
byte 0x00
int 0
frame_dig 14
setbyte
concat
byte 0x00
int 0
frame_dig 15
setbyte
concat
byte 0x00
int 0
frame_dig 16
setbyte
concat
byte 0x00
int 0
frame_dig 17
setbyte
concat
byte 0x00
int 0
frame_dig 18
setbyte
concat
byte 0x00
int 0
frame_dig 19
setbyte
concat
byte 0x00
int 0
frame_dig 20
setbyte
concat
byte 0x00
int 0
frame_dig 21
setbyte
concat
byte 0x00
int 0
frame_dig 22
setbyte
concat
byte 0x00
int 0
frame_dig 23
setbyte
concat
byte 0x00
int 0
frame_dig 24
setbyte
concat
byte 0x00
int 0
frame_dig 25
setbyte
concat
byte 0x00
int 0
frame_dig 26
setbyte
concat
byte 0x00
int 0
frame_dig 27
setbyte
concat
byte 0x00
int 0
frame_dig 28
setbyte
concat
byte 0x00
int 0
frame_dig 29
setbyte
concat
byte 0x00
int 0
frame_dig 30
setbyte
concat
byte 0x00
int 0
frame_dig 31
setbyte
concat
byte 0x00
int 0
frame_dig 32
setbyte
concat
frame_bury 0
retsub

// string_reverse
stringreverse_7:
proto 1 1
byte ""
int 0
dupn 7
byte ""
dup
int 0
frame_dig -1
int 1
int 0
*
int 2
+
getbyte
frame_bury 3
frame_dig -1
int 1
int 1
*
int 2
+
getbyte
frame_bury 2
frame_dig -1
int 1
int 2
*
int 2
+
getbyte
frame_bury 1
int 3
frame_bury 11
frame_dig 11
itob
extract 6 0
byte 0x00
int 0
frame_dig 1
setbyte
byte 0x00
int 0
frame_dig 2
setbyte
concat
byte 0x00
int 0
frame_dig 3
setbyte
concat
concat
frame_bury 0
retsub

// tuple_complement
tuplecomplement_8:
proto 1 1
byte ""
dupn 4
int 0
byte ""
int 0
dupn 2
byte ""
dup
frame_dig -1
extract 0 32
frame_bury 1
frame_dig -1
frame_dig -1
int 32
extract_uint16
frame_dig -1
int 34
extract_uint16
substring3
frame_bury 2
frame_dig -1
frame_dig -1
int 34
extract_uint16
frame_dig -1
int 36
extract_uint16
substring3
frame_bury 3
frame_dig -1
frame_dig -1
int 36
extract_uint16
dig 1
len
substring3
frame_bury 4
frame_dig 1
callsub arraycomplement_10
frame_bury 1
frame_dig 2
callsub arraycomplement_12
frame_bury 2
frame_dig 3
callsub stringreverse_13
frame_bury 3
frame_dig 4
callsub arraycomplement_15
frame_bury 4
frame_dig 1
frame_dig 2
frame_bury 11
frame_dig 11
frame_bury 10
int 38
frame_bury 8
frame_dig 8
frame_dig 11
len
+
frame_bury 9
frame_dig 9
int 65536
<
assert
frame_dig 8
itob
extract 6 0
concat
frame_dig 3
frame_bury 11
frame_dig 10
frame_dig 11
concat
frame_bury 10
frame_dig 9
frame_bury 8
frame_dig 8
frame_dig 11
len
+
frame_bury 9
frame_dig 9
int 65536
<
assert
frame_dig 8
itob
extract 6 0
concat
frame_dig 4
frame_bury 11
frame_dig 10
frame_dig 11
concat
frame_bury 10
frame_dig 9
frame_bury 8
frame_dig 8
itob
extract 6 0
concat
frame_dig 10
concat
frame_bury 0
retsub

// numerical_comp
numericalcomp_9:
proto 1 1
int 0
int 255
frame_dig -1
-
frame_bury 0
frame_dig 0
int 256
<
assert
retsub

// array_complement
arraycomplement_10:
proto 1 1
byte ""
int 0
dupn 33
byte ""
dup
frame_dig -1
int 1
int 0
*
getbyte
frame_bury 1
frame_dig -1
int 1
int 1
*
getbyte
frame_bury 2
frame_dig -1
int 1
int 2
*
getbyte
frame_bury 3
frame_dig -1
int 1
int 3
*
getbyte
frame_bury 4
frame_dig -1
int 1
int 4
*
getbyte
frame_bury 5
frame_dig -1
int 1
int 5
*
getbyte
frame_bury 6
frame_dig -1
int 1
int 6
*
getbyte
frame_bury 7
frame_dig -1
int 1
int 7
*
getbyte
frame_bury 8
frame_dig -1
int 1
int 8
*
getbyte
frame_bury 9
frame_dig -1
int 1
int 9
*
getbyte
frame_bury 10
frame_dig -1
int 1
int 10
*
getbyte
frame_bury 11
frame_dig -1
int 1
int 11
*
getbyte
frame_bury 12
frame_dig -1
int 1
int 12
*
getbyte
frame_bury 13
frame_dig -1
int 1
int 13
*
getbyte
frame_bury 14
frame_dig -1
int 1
int 14
*
getbyte
frame_bury 15
frame_dig -1
int 1
int 15
*
getbyte
frame_bury 16
frame_dig -1
int 1
int 16
*
getbyte
frame_bury 17
frame_dig -1
int 1
int 17
*
getbyte
frame_bury 18
frame_dig -1
int 1
int 18
*
getbyte
frame_bury 19
frame_dig -1
int 1
int 19
*
getbyte
frame_bury 20
frame_dig -1
int 1
int 20
*
getbyte
frame_bury 21
frame_dig -1
int 1
int 21
*
getbyte
frame_bury 22
frame_dig -1
int 1
int 22
*
getbyte
frame_bury 23
frame_dig -1
int 1
int 23
*
getbyte
frame_bury 24
frame_dig -1
int 1
int 24
*
getbyte
frame_bury 25
frame_dig -1
int 1
int 25
*
getbyte
frame_bury 26
frame_dig -1
int 1
int 26
*
getbyte
frame_bury 27
frame_dig -1
int 1
int 27
*
getbyte
frame_bury 28
frame_dig -1
int 1
int 28
*
getbyte
frame_bury 29
frame_dig -1
int 1
int 29
*
getbyte
frame_bury 30
frame_dig -1
int 1
int 30
*
getbyte
frame_bury 31
frame_dig -1
int 1
int 31
*
getbyte
frame_bury 32
frame_dig 1
callsub numericalcomp_9
frame_bury 1
frame_dig 2
callsub numericalcomp_9
frame_bury 2
frame_dig 3
callsub numericalcomp_9
frame_bury 3
frame_dig 4
callsub numericalcomp_9
frame_bury 4
frame_dig 5
callsub numericalcomp_9
frame_bury 5
frame_dig 6
callsub numericalcomp_9
frame_bury 6
frame_dig 7
callsub numericalcomp_9
frame_bury 7
frame_dig 8
callsub numericalcomp_9
frame_bury 8
frame_dig 9
callsub numericalcomp_9
frame_bury 9
frame_dig 10
callsub numericalcomp_9
frame_bury 10
frame_dig 11
callsub numericalcomp_9
frame_bury 11
frame_dig 12
callsub numericalcomp_9
frame_bury 12
frame_dig 13
callsub numericalcomp_9
frame_bury 13
frame_dig 14
callsub numericalcomp_9
frame_bury 14
frame_dig 15
callsub numericalcomp_9
frame_bury 15
frame_dig 16
callsub numericalcomp_9
frame_bury 16
frame_dig 17
callsub numericalcomp_9
frame_bury 17
frame_dig 18
callsub numericalcomp_9
frame_bury 18
frame_dig 19
callsub numericalcomp_9
frame_bury 19
frame_dig 20
callsub numericalcomp_9
frame_bury 20
frame_dig 21
callsub numericalcomp_9
frame_bury 21
frame_dig 22
callsub numericalcomp_9
frame_bury 22
frame_dig 23
callsub numericalcomp_9
frame_bury 23
frame_dig 24
callsub numericalcomp_9
frame_bury 24
frame_dig 25
callsub numericalcomp_9
frame_bury 25
frame_dig 26
callsub numericalcomp_9
frame_bury 26
frame_dig 27
callsub numericalcomp_9
frame_bury 27
frame_dig 28
callsub numericalcomp_9
frame_bury 28
frame_dig 29
callsub numericalcomp_9
frame_bury 29
frame_dig 30
callsub numericalcomp_9
frame_bury 30
frame_dig 31
callsub numericalcomp_9
frame_bury 31
frame_dig 32
callsub numericalcomp_9
frame_bury 32
byte 0x00
int 0
frame_dig 1
setbyte
byte 0x00
int 0
frame_dig 2
setbyte
concat
byte 0x00
int 0
frame_dig 3
setbyte
concat
byte 0x00
int 0
frame_dig 4
setbyte
concat
byte 0x00
int 0
frame_dig 5
setbyte
concat
byte 0x00
int 0
frame_dig 6
setbyte
concat
byte 0x00
int 0
frame_dig 7
setbyte
concat
byte 0x00
int 0
frame_dig 8
setbyte
concat
byte 0x00
int 0
frame_dig 9
setbyte
concat
byte 0x00
int 0
frame_dig 10
setbyte
concat
byte 0x00
int 0
frame_dig 11
setbyte
concat
byte 0x00
int 0
frame_dig 12
setbyte
concat
byte 0x00
int 0
frame_dig 13
setbyte
concat
byte 0x00
int 0
frame_dig 14
setbyte
concat
byte 0x00
int 0
frame_dig 15
setbyte
concat
byte 0x00
int 0
frame_dig 16
setbyte
concat
byte 0x00
int 0
frame_dig 17
setbyte
concat
byte 0x00
int 0
frame_dig 18
setbyte
concat
byte 0x00
int 0
frame_dig 19
setbyte
concat
byte 0x00
int 0
frame_dig 20
setbyte
concat
byte 0x00
int 0
frame_dig 21
setbyte
concat
byte 0x00
int 0
frame_dig 22
setbyte
concat
byte 0x00
int 0
frame_dig 23
setbyte
concat
byte 0x00
int 0
frame_dig 24
setbyte
concat
byte 0x00
int 0
frame_dig 25
setbyte
concat
byte 0x00
int 0
frame_dig 26
setbyte
concat
byte 0x00
int 0
frame_dig 27
setbyte
concat
byte 0x00
int 0
frame_dig 28
setbyte
concat
byte 0x00
int 0
frame_dig 29
setbyte
concat
byte 0x00
int 0
frame_dig 30
setbyte
concat
byte 0x00
int 0
frame_dig 31
setbyte
concat
byte 0x00
int 0
frame_dig 32
setbyte
concat
frame_bury 0
retsub

// tuple_complement
tuplecomplement_11:
proto 1 1
byte ""
int 0
byte ""
dupn 2
int 0
byte ""
int 0
dupn 2
byte ""
dup
frame_dig -1
int 0
extract_uint32
frame_bury 1
frame_dig -1
frame_dig -1
int 4
extract_uint16
dig 1
len
substring3
frame_bury 2
frame_dig -1
extract 6 1
frame_bury 3
frame_dig -1
extract 7 1
frame_bury 4
frame_dig -1
int 8
getbyte
frame_bury 5
frame_dig 1
callsub numericalcomp_16
frame_bury 1
frame_dig 2
callsub arraycomplement_18
frame_bury 2
frame_dig 3
callsub arraycomplement_20
frame_bury 3
frame_dig 4
callsub tuplecomplement_21
frame_bury 4
frame_dig 5
callsub numericalcomp_22
frame_bury 5
frame_dig 1
itob
extract 4 0
frame_dig 2
frame_bury 11
frame_dig 11
frame_bury 10
int 9
frame_bury 8
frame_dig 8
itob
extract 6 0
concat
frame_dig 3
concat
frame_dig 4
concat
byte 0x00
int 0
frame_dig 5
setbyte
concat
frame_dig 10
concat
frame_bury 0
retsub

// array_complement
arraycomplement_12:
proto 1 1
byte ""
dupn 2
int 0
dup
byte ""
dup
frame_dig -1
frame_dig -1
int 2
int 0
*
extract_uint16
int 0
int 1
+
int 2
==
bnz arraycomplement_12_l5
frame_dig -1
int 2
int 0
*
int 2
+
extract_uint16
arraycomplement_12_l2:
substring3
frame_bury 1
frame_dig -1
frame_dig -1
int 2
int 1
*
extract_uint16
int 1
int 1
+
int 2
==
bnz arraycomplement_12_l4
frame_dig -1
int 2
int 1
*
int 2
+
extract_uint16
b arraycomplement_12_l6
arraycomplement_12_l4:
frame_dig -1
len
b arraycomplement_12_l6
arraycomplement_12_l5:
frame_dig -1
len
b arraycomplement_12_l2
arraycomplement_12_l6:
substring3
frame_bury 2
frame_dig 1
callsub tuplecomplement_11
frame_bury 1
frame_dig 2
callsub tuplecomplement_11
frame_bury 2
frame_dig 1
frame_bury 6
frame_dig 6
frame_bury 5
int 4
frame_bury 3
frame_dig 3
frame_dig 6
len
+
frame_bury 4
frame_dig 4
int 65536
<
assert
frame_dig 3
itob
extract 6 0
frame_dig 2
frame_bury 6
frame_dig 5
frame_dig 6
concat
frame_bury 5
frame_dig 4
frame_bury 3
frame_dig 3
itob
extract 6 0
concat
frame_dig 5
concat
frame_bury 0
retsub

// string_reverse
stringreverse_13:
proto 1 1
byte ""
int 0
dupn 7
byte ""
dup
int 0
frame_dig -1
int 1
int 0
*
int 2
+
getbyte
frame_bury 3
frame_dig -1
int 1
int 1
*
int 2
+
getbyte
frame_bury 2
frame_dig -1
int 1
int 2
*
int 2
+
getbyte
frame_bury 1
int 3
frame_bury 11
frame_dig 11
itob
extract 6 0
byte 0x00
int 0
frame_dig 1
setbyte
byte 0x00
int 0
frame_dig 2
setbyte
concat
byte 0x00
int 0
frame_dig 3
setbyte
concat
concat
frame_bury 0
retsub

// bool_comp
boolcomp_14:
proto 1 1
int 0
frame_dig -1
!
!
!
frame_bury 0
retsub

// array_complement
arraycomplement_15:
proto 1 1
byte ""
int 0
dupn 4
byte ""
dup
int 0
frame_dig -1
int 0
int 16
+
getbit
frame_bury 1
frame_dig -1
int 1
int 16
+
getbit
frame_bury 2
frame_dig -1
int 2
int 16
+
getbit
frame_bury 3
frame_dig 1
callsub boolcomp_14
frame_bury 1
frame_dig 2
callsub boolcomp_14
frame_bury 2
frame_dig 3
callsub boolcomp_14
frame_bury 3
int 3
frame_bury 8
frame_dig 8
itob
extract 6 0
byte 0x00
int 0
frame_dig 1
setbit
int 1
frame_dig 2
setbit
int 2
frame_dig 3
setbit
concat
frame_bury 0
retsub

// numerical_comp
numericalcomp_16:
proto 1 1
int 0
int 4294967295
frame_dig -1
-
frame_bury 0
frame_dig 0
int 4294967296
<
assert
retsub

// string_reverse
stringreverse_17:
proto 1 1
byte ""
int 0
dupn 7
byte ""
dup
int 0
frame_dig -1
int 1
int 0
*
int 2
+
getbyte
frame_bury 3
frame_dig -1
int 1
int 1
*
int 2
+
getbyte
frame_bury 2
frame_dig -1
int 1
int 2
*
int 2
+
getbyte
frame_bury 1
int 3
frame_bury 11
frame_dig 11
itob
extract 6 0
byte 0x00
int 0
frame_dig 1
setbyte
byte 0x00
int 0
frame_dig 2
setbyte
concat
byte 0x00
int 0
frame_dig 3
setbyte
concat
concat
frame_bury 0
retsub

// array_complement
arraycomplement_18:
proto 1 1
byte ""
dupn 3
int 0
dupn 4
byte ""
dup
int 0
frame_dig -1
frame_dig -1
int 2
int 0
*
int 2
+
extract_uint16
int 2
+
int 0
int 1
+
frame_dig -1
int 0
extract_uint16
frame_bury 4
frame_dig 4
==
bnz arraycomplement_18_l8
frame_dig -1
int 2
int 0
*
int 2
+
int 2
+
extract_uint16
int 2
+
arraycomplement_18_l2:
substring3
frame_bury 1
frame_dig -1
frame_dig -1
int 2
int 1
*
int 2
+
extract_uint16
int 2
+
int 1
int 1
+
frame_dig -1
int 0
extract_uint16
frame_bury 5
frame_dig 5
==
bnz arraycomplement_18_l7
frame_dig -1
int 2
int 1
*
int 2
+
int 2
+
extract_uint16
int 2
+
arraycomplement_18_l4:
substring3
frame_bury 2
frame_dig -1
frame_dig -1
int 2
int 2
*
int 2
+
extract_uint16
int 2
+
int 2
int 1
+
frame_dig -1
int 0
extract_uint16
frame_bury 6
frame_dig 6
==
bnz arraycomplement_18_l6
frame_dig -1
int 2
int 2
*
int 2
+
int 2
+
extract_uint16
int 2
+
b arraycomplement_18_l9
arraycomplement_18_l6:
frame_dig -1
len
b arraycomplement_18_l9
arraycomplement_18_l7:
frame_dig -1
len
b arraycomplement_18_l4
arraycomplement_18_l8:
frame_dig -1
len
b arraycomplement_18_l2
arraycomplement_18_l9:
substring3
frame_bury 3
frame_dig 1
callsub stringreverse_17
frame_bury 1
frame_dig 2
callsub stringreverse_17
frame_bury 2
frame_dig 3
callsub stringreverse_17
frame_bury 3
int 3
frame_bury 11
frame_dig 11
itob
extract 6 0
frame_dig 1
frame_bury 10
frame_dig 10
frame_bury 9
int 6
frame_bury 7
frame_dig 7
frame_dig 10
len
+
frame_bury 8
frame_dig 8
int 65536
<
assert
frame_dig 7
itob
extract 6 0
frame_dig 2
frame_bury 10
frame_dig 9
frame_dig 10
concat
frame_bury 9
frame_dig 8
frame_bury 7
frame_dig 7
frame_dig 10
len
+
frame_bury 8
frame_dig 8
int 65536
<
assert
frame_dig 7
itob
extract 6 0
concat
frame_dig 3
frame_bury 10
frame_dig 9
frame_dig 10
concat
frame_bury 9
frame_dig 8
frame_bury 7
frame_dig 7
itob
extract 6 0
concat
frame_dig 9
concat
concat
frame_bury 0
retsub

// bool_comp
boolcomp_19:
proto 1 1
int 0
frame_dig -1
!
!
!
frame_bury 0
retsub

// array_complement
arraycomplement_20:
proto 1 1
byte ""
int 0
dupn 3
byte ""
dup
frame_dig -1
int 0
getbit
frame_bury 1
frame_dig -1
int 1
getbit
frame_bury 2
frame_dig 1
callsub boolcomp_19
frame_bury 1
frame_dig 2
callsub boolcomp_19
frame_bury 2
byte 0x00
int 0
frame_dig 1
setbit
int 1
frame_dig 2
setbit
frame_bury 0
retsub

// tuple_complement
tuplecomplement_21:
proto 1 1
byte ""
int 0
dupn 2
byte ""
dup
frame_dig -1
int 0
getbyte
frame_bury 1
frame_dig 1
callsub numericalcomp_23
frame_bury 1
byte 0x00
int 0
frame_dig 1
setbyte
frame_bury 0
retsub

// numerical_comp
numericalcomp_22:
proto 1 1
int 0
int 255
frame_dig -1
-
frame_bury 0
frame_dig 0
int 256
<
assert
retsub

// numerical_comp
numericalcomp_23:
proto 1 1
int 0
int 255
frame_dig -1
-
frame_bury 0
frame_dig 0
int 256
<
assert
retsub


================================================
FILE: tests/integration/teal/roundtrip/app_roundtrip_(bool,byte,address,string,uint64)_v6.teal
================================================
#pragma version 6
txna ApplicationArgs 0
store 1
load 1
callsub roundtripper_1
store 0
byte 0x151f7c75
load 0
concat
log
int 1
return

// tuple_complement
tuplecomplement_0:
store 6
load 6
int 0
getbit
store 8
load 6
int 1
getbyte
store 9
load 6
extract 2 32
store 10
load 6
load 6
int 34
extract_uint16
dig 1
len
substring3
store 11
load 6
int 36
extract_uint64
store 12
load 8
callsub boolcomp_2
store 8
load 9
callsub numericalcomp_3
store 9
load 10
callsub arraycomplement_5
store 10
load 11
callsub stringreverse_6
store 11
load 12
callsub numericalcomp_7
store 12
byte 0x00
int 0
load 8
setbit
byte 0x00
int 0
load 9
setbyte
concat
load 10
concat
load 11
store 63
load 63
store 62
int 44
store 61
load 61
itob
extract 6 0
concat
load 12
itob
concat
load 62
concat
store 7
load 7
retsub

// round_tripper
roundtripper_1:
store 2
load 2
callsub tuplecomplement_0
store 4
load 4
callsub tuplecomplement_0
store 5
load 2
store 67
load 67
store 66
int 6
store 64
load 64
load 67
len
+
store 65
load 65
int 65536
<
assert
load 64
itob
extract 6 0
load 4
store 67
load 66
load 67
concat
store 66
load 65
store 64
load 64
load 67
len
+
store 65
load 65
int 65536
<
assert
load 64
itob
extract 6 0
concat
load 5
store 67
load 66
load 67
concat
store 66
load 65
store 64
load 64
itob
extract 6 0
concat
load 66
concat
store 3
load 3
retsub

// bool_comp
boolcomp_2:
store 13
load 13
!
!
!
store 14
load 14
retsub

// numerical_comp
numericalcomp_3:
store 15
int 255
load 15
-
store 16
load 16
int 256
<
assert
load 16
retsub

// numerical_comp
numericalcomp_4:
store 51
int 255
load 51
-
store 52
load 52
int 256
<
assert
load 52
retsub

// array_complement
arraycomplement_5:
store 17
load 17
int 1
int 0
*
getbyte
store 19
load 17
int 1
int 1
*
getbyte
store 20
load 17
int 1
int 2
*
getbyte
store 21
load 17
int 1
int 3
*
getbyte
store 22
load 17
int 1
int 4
*
getbyte
store 23
load 17
int 1
int 5
*
getbyte
store 24
load 17
int 1
int 6
*
getbyte
store 25
load 17
int 1
int 7
*
getbyte
store 26
load 17
int 1
int 8
*
getbyte
store 27
load 17
int 1
int 9
*
getbyte
store 28
load 17
int 1
int 10
*
getbyte
store 29
load 17
int 1
int 11
*
getbyte
store 30
load 17
int 1
int 12
*
getbyte
store 31
load 17
int 1
int 13
*
getbyte
store 32
load 17
int 1
int 14
*
getbyte
store 33
load 17
int 1
int 15
*
getbyte
store 34
load 17
int 1
int 16
*
getbyte
store 35
load 17
int 1
int 17
*
getbyte
store 36
load 17
int 1
int 18
*
getbyte
store 37
load 17
int 1
int 19
*
getbyte
store 38
load 17
int 1
int 20
*
getbyte
store 39
load 17
int 1
int 21
*
getbyte
store 40
load 17
int 1
int 22
*
getbyte
store 41
load 17
int 1
int 23
*
getbyte
store 42
load 17
int 1
int 24
*
getbyte
store 43
load 17
int 1
int 25
*
getbyte
store 44
load 17
int 1
int 26
*
getbyte
store 45
load 17
int 1
int 27
*
getbyte
store 46
load 17
int 1
int 28
*
getbyte
store 47
load 17
int 1
int 29
*
getbyte
store 48
load 17
int 1
int 30
*
getbyte
store 49
load 17
int 1
int 31
*
getbyte
store 50
load 19
callsub numericalcomp_4
store 19
load 20
callsub numericalcomp_4
store 20
load 21
callsub numericalcomp_4
store 21
load 22
callsub numericalcomp_4
store 22
load 23
callsub numericalcomp_4
store 23
load 24
callsub numericalcomp_4
store 24
load 25
callsub numericalcomp_4
store 25
load 26
callsub numericalcomp_4
store 26
load 27
callsub numericalcomp_4
store 27
load 28
callsub numericalcomp_4
store 28
load 29
callsub numericalcomp_4
store 29
load 30
callsub numericalcomp_4
store 30
load 31
callsub numericalcomp_4
store 31
load 32
callsub numericalcomp_4
store 32
load 33
callsub numericalcomp_4
store 33
load 34
callsub numericalcomp_4
store 34
load 35
callsub numericalcomp_4
store 35
load 36
callsub numericalcomp_4
store 36
load 37
callsub numericalcomp_4
store 37
load 38
callsub numericalcomp_4
store 38
load 39
callsub numericalcomp_4
store 39
load 40
callsub numericalcomp_4
store 40
load 41
callsub numericalcomp_4
store 41
load 42
callsub numericalcomp_4
store 42
load 43
callsub numericalcomp_4
store 43
load 44
callsub numericalcomp_4
store 44
load 45
callsub numericalcomp_4
store 45
load 46
callsub numericalcomp_4
store 46
load 47
callsub numericalcomp_4
store 47
load 48
callsub numericalcomp_4
store 48
load 49
callsub numericalcomp_4
store 49
load 50
callsub numericalcomp_4
store 50
byte 0x00
int 0
load 19
setbyte
byte 0x00
int 0
load 20
setbyte
concat
byte 0x00
int 0
load 21
setbyte
concat
byte 0x00
int 0
load 22
setbyte
concat
byte 0x00
int 0
load 23
setbyte
concat
byte 0x00
int 0
load 24
setbyte
concat
byte 0x00
int 0
load 25
setbyte
concat
byte 0x00
int 0
load 26
setbyte
concat
byte 0x00
int 0
load 27
setbyte
concat
byte 0x00
int 0
load 28
setbyte
concat
byte 0x00
int 0
load 29
setbyte
concat
byte 0x00
int 0
load 30
setbyte
concat
byte 0x00
int 0
load 31
setbyte
concat
byte 0x00
int 0
load 32
setbyte
concat
byte 0x00
int 0
load 33
setbyte
concat
byte 0x00
int 0
load 34
setbyte
concat
byte 0x00
int 0
load 35
setbyte
concat
byte 0x00
int 0
load 36
setbyte
concat
byte 0x00
int 0
load 37
setbyte
concat
byte 0x00
int 0
load 38
setbyte
concat
byte 0x00
int 0
load 39
setbyte
concat
byte 0x00
int 0
load 40
setbyte
concat
byte 0x00
int 0
load 41
setbyte
concat
byte 0x00
int 0
load 42
setbyte
concat
byte 0x00
int 0
load 43
setbyte
concat
byte 0x00
int 0
load 44
setbyte
concat
byte 0x00
int 0
load 45
setbyte
concat
byte 0x00
int 0
load 46
setbyte
concat
byte 0x00
int 0
load 47
setbyte
concat
byte 0x00
int 0
load 48
setbyte
concat
byte 0x00
int 0
load 49
setbyte
concat
byte 0x00
int 0
load 50
setbyte
concat
store 18
load 18
retsub

// string_reverse
stringreverse_6:
store 53
load 53
int 1
int 0
*
int 2
+
getbyte
store 57
load 53
int 1
int 1
*
int 2
+
getbyte
store 56
load 53
int 1
int 2
*
int 2
+
getbyte
store 55
int 3
store 58
load 58
itob
extract 6 0
byte 0x00
int 0
load 55
setbyte
byte 0x00
int 0
load 56
setbyte
concat
byte 0x00
int 0
load 57
setbyte
concat
concat
store 54
load 54
retsub

// numerical_comp
numericalcomp_7:
store 59
int 18446744073709551615
load 59
-
store 60
load 60
retsub


================================================
FILE: tests/integration/teal/roundtrip/app_roundtrip_(bool,byte,address,string,uint64)_v8.teal
================================================
#pragma version 8
txna ApplicationArgs 0
store 1
load 1
callsub roundtripper_1
store 0
byte 0x151f7c75
load 0
concat
log
int 1
return

// tuple_complement
tuplecomplement_0:
proto 1 1
byte ""
int 0
dup
byte ""
dup
int 0
dupn 3
byte ""
dup
frame_dig -1
int 0
getbit
frame_bury 1
frame_dig -1
int 1
getbyte
frame_bury 2
frame_dig -1
extract 2 32
frame_bury 3
frame_dig -1
frame_dig -1
int 34
extract_uint16
dig 1
len
substring3
frame_bury 4
frame_dig -1
int 36
extract_uint64
frame_bury 5
frame_dig 1
callsub boolcomp_2
frame_bury 1
frame_dig 2
callsub numericalcomp_3
frame_bury 2
frame_dig 3
callsub arraycomplement_5
frame_bury 3
frame_dig 4
callsub stringreverse_6
frame_bury 4
frame_dig 5
callsub numericalcomp_7
frame_bury 5
byte 0x00
int 0
frame_dig 1
setbit
byte 0x00
int 0
frame_dig 2
setbyte
concat
frame_dig 3
concat
frame_dig 4
frame_bury 10
frame_dig 10
frame_bury 9
int 44
frame_bury 7
frame_dig 7
itob
extract 6 0
concat
frame_dig 5
itob
concat
frame_dig 9
concat
frame_bury 0
retsub

// round_tripper
roundtripper_1:
proto 1 1
byte ""
dupn 2
int 0
dup
byte ""
dup
frame_dig -1
callsub tuplecomplement_0
frame_bury 1
frame_dig 1
callsub tuplecomplement_0
frame_bury 2
frame_dig -1
frame_bury 6
frame_dig 6
frame_bury 5
int 6
frame_bury 3
frame_dig 3
frame_dig 6
len
+
frame_bury 4
frame_dig 4
int 65536
<
assert
frame_dig 3
itob
extract 6 0
frame_dig 1
frame_bury 6
frame_dig 5
frame_dig 6
concat
frame_bury 5
frame_dig 4
frame_bury 3
frame_dig 3
frame_dig 6
len
+
frame_bury 4
frame_dig 4
int 65536
<
assert
frame_dig 3
itob
extract 6 0
concat
frame_dig 2
frame_bury 6
frame_dig 5
frame_dig 6
concat
frame_bury 5
frame_dig 4
frame_bury 3
frame_dig 3
itob
extract 6 0
concat
frame_dig 5
concat
frame_bury 0
retsub

// bool_comp
boolcomp_2:
proto 1 1
int 0
frame_dig -1
!
!
!
frame_bury 0
retsub

// numerical_comp
numericalcomp_3:
proto 1 1
int 0
int 255
frame_dig -1
-
frame_bury 0
frame_dig 0
int 256
<
assert
retsub

// numerical_comp
numericalcomp_4:
proto 1 1
int 0
int 255
frame_dig -1
-
frame_bury 0
frame_dig 0
int 256
<
assert
retsub

// array_complement
arraycomplement_5:
proto 1 1
byte ""
int 0
dupn 33
byte ""
dup
frame_dig -1
int 1
int 0
*
getbyte
frame_bury 1
frame_dig -1
int 1
int 1
*
getbyte
frame_bury 2
frame_dig -1
int 1
int 2
*
getbyte
frame_bury 3
frame_dig -1
int 1
int 3
*
getbyte
frame_bury 4
frame_dig -1
int 1
int 4
*
getbyte
frame_bury 5
frame_dig -1
int 1
int 5
*
getbyte
frame_bury 6
frame_dig -1
int 1
int 6
*
getbyte
frame_bury 7
frame_dig -1
int 1
int 7
*
getbyte
frame_bury 8
frame_dig -1
int 1
int 8
*
getbyte
frame_bury 9
frame_dig -1
int 1
int 9
*
getbyte
frame_bury 10
frame_dig -1
int 1
int 10
*
getbyte
frame_bury 11
frame_dig -1
int 1
int 11
*
getbyte
frame_bury 12
frame_dig -1
int 1
int 12
*
getbyte
frame_bury 13
frame_dig -1
int 1
int 13
*
getbyte
frame_bury 14
frame_dig -1
int 1
int 14
*
getbyte
frame_bury 15
frame_dig -1
int 1
int 15
*
getbyte
frame_bury 16
frame_dig -1
int 1
int 16
*
getbyte
frame_bury 17
frame_dig -1
int 1
int 17
*
getbyte
frame_bury 18
frame_dig -1
int 1
int 18
*
getbyte
frame_bury 19
frame_dig -1
int 1
int 19
*
getbyte
frame_bury 20
frame_dig -1
int 1
int 20
*
getbyte
frame_bury 21
frame_dig -1
int 1
int 21
*
getbyte
frame_bury 22
frame_dig -1
int 1
int 22
*
getbyte
frame_bury 23
frame_dig -1
int 1
int 23
*
getbyte
frame_bury 24
frame_dig -1
int 1
int 24
*
getbyte
frame_bury 25
frame_dig -1
int 1
int 25
*
getbyte
frame_bury 26
frame_dig -1
int 1
int 26
*
getbyte
frame_bury 27
frame_dig -1
int 1
int 27
*
getbyte
frame_bury 28
frame_dig -1
int 1
int 28
*
getbyte
frame_bury 29
frame_dig -1
int 1
int 29
*
getbyte
frame_bury 30
frame_dig -1
int 1
int 30
*
getbyte
frame_bury 31
frame_dig -1
int 1
int 31
*
getbyte
frame_bury 32
frame_dig 1
callsub numericalcomp_4
frame_bury 1
frame_dig 2
callsub numericalcomp_4
frame_bury 2
frame_dig 3
callsub numericalcomp_4
frame_bury 3
frame_dig 4
callsub numericalcomp_4
frame_bury 4
frame_dig 5
callsub numericalcomp_4
frame_bury 5
frame_dig 6
callsub numericalcomp_4
frame_bury 6
frame_dig 7
callsub numericalcomp_4
frame_bury 7
frame_dig 8
callsub numericalcomp_4
frame_bury 8
frame_dig 9
callsub numericalcomp_4
frame_bury 9
frame_dig 10
callsub numericalcomp_4
frame_bury 10
frame_dig 11
callsub numericalcomp_4
frame_bury 11
frame_dig 12
callsub numericalcomp_4
frame_bury 12
frame_dig 13
callsub numericalcomp_4
frame_bury 13
frame_dig 14
callsub numericalcomp_4
frame_bury 14
frame_dig 15
callsub numericalcomp_4
frame_bury 15
frame_dig 16
callsub numericalcomp_4
frame_bury 16
frame_dig 17
callsub numericalcomp_4
frame_bury 17
frame_dig 18
callsub numericalcomp_4
frame_bury 18
frame_dig 19
callsub numericalcomp_4
frame_bury 19
frame_dig 20
callsub numericalcomp_4
frame_bury 20
frame_dig 21
callsub numericalcomp_4
frame_bury 21
frame_dig 22
callsub numericalcomp_4
frame_bury 22
frame_dig 23
callsub numericalcomp_4
frame_bury 23
frame_dig 24
callsub numericalcomp_4
frame_bury 24
frame_dig 25
callsub numericalcomp_4
frame_bury 25
frame_dig 26
callsub numericalcomp_4
frame_bury 26
frame_dig 27
callsub numericalcomp_4
frame_bury 27
frame_dig 28
callsub numericalcomp_4
frame_bury 28
frame_dig 29
callsub numericalcomp_4
frame_bury 29
frame_dig 30
callsub numericalcomp_4
frame_bury 30
frame_dig 31
callsub numericalcomp_4
frame_bury 31
frame_dig 32
callsub numericalcomp_4
frame_bury 32
byte 0x00
int 0
frame_dig 1
setbyte
byte 0x00
int 0
frame_dig 2
setbyte
concat
byte 0x00
int 0
frame_dig 3
setbyte
concat
byte 0x00
int 0
frame_dig 4
setbyte
concat
byte 0x00
int 0
frame_dig 5
setbyte
concat
byte 0x00
int 0
frame_dig 6
setbyte
concat
byte 0x00
int 0
frame_dig 7
setbyte
concat
byte 0x00
int 0
frame_dig 8
setbyte
concat
byte 0x00
int 0
frame_dig 9
setbyte
concat
byte 0x00
int 0
frame_dig 10
setbyte
concat
byte 0x00
int 0
frame_dig 11
setbyte
concat
byte 0x00
int 0
frame_dig 12
setbyte
concat
byte 0x00
int 0
frame_dig 13
setbyte
concat
byte 0x00
int 0
frame_dig 14
setbyte
concat
byte 0x00
int 0
frame_dig 15
setbyte
concat
byte 0x00
int 0
frame_dig 16
setbyte
concat
byte 0x00
int 0
frame_dig 17
setbyte
concat
byte 0x00
int 0
frame_dig 18
setbyte
concat
byte 0x00
int 0
frame_dig 19
setbyte
concat
byte 0x00
int 0
frame_dig 20
setbyte
concat
byte 0x00
int 0
frame_dig 21
setbyte
concat
byte 0x00
int 0
frame_dig 22
setbyte
concat
byte 0x00
int 0
frame_dig 23
setbyte
concat
byte 0x00
int 0
frame_dig 24
setbyte
concat
byte 0x00
int 0
frame_dig 25
setbyte
concat
byte 0x00
int 0
frame_dig 26
setbyte
concat
byte 0x00
int 0
frame_dig 27
setbyte
concat
byte 0x00
int 0
frame_dig 28
setbyte
concat
byte 0x00
int 0
frame_dig 29
setbyte
concat
byte 0x00
int 0
frame_dig 30
setbyte
concat
byte 0x00
int 0
frame_dig 31
setbyte
concat
byte 0x00
int 0
frame_dig 32
setbyte
concat
frame_bury 0
retsub

// string_reverse
stringreverse_6:
proto 1 1
byte ""
int 0
dupn 7
byte ""
dup
int 0
frame_dig -1
int 1
int 0
*
int 2
+
getbyte
frame_bury 3
frame_dig -1
int 1
int 1
*
int 2
+
getbyte
frame_bury 2
frame_dig -1
int 1
int 2
*
int 2
+
getbyte
frame_bury 1
int 3
frame_bury 11
frame_dig 11
itob
extract 6 0
byte 0x00
int 0
frame_dig 1
setbyte
byte 0x00
int 0
frame_dig 2
setbyte
concat
byte 0x00
int 0
frame_dig 3
setbyte
concat
concat
frame_bury 0
retsub

// numerical_comp
numericalcomp_7:
proto 1 1
int 0
int 18446744073709551615
frame_dig -1
-
frame_bury 0
retsub


================================================
FILE: tests/integration/teal/roundtrip/app_roundtrip_(bool,uint64,uint32)_v6.teal
================================================
#pragma version 6
txna ApplicationArgs 0
store 1
load 1
callsub roundtripper_1
store 0
byte 0x151f7c75
load 0
concat
log
int 1
return

// tuple_complement
tuplecomplement_0:
store 6
load 6
int 0
getbit
store 8
load 6
int 1
extract_uint64
store 9
load 6
int 9
extract_uint32
store 10
load 8
callsub boolcomp_2
store 8
load 9
callsub numericalcomp_3
store 9
load 10
callsub numericalcomp_4
store 10
byte 0x00
int 0
load 8
setbit
load 9
itob
concat
load 10
itob
extract 4 0
concat
store 7
load 7
retsub

// round_tripper
roundtripper_1:
store 2
load 2
callsub tuplecomplement_0
store 4
load 4
callsub tuplecomplement_0
store 5
load 2
load 4
concat
load 5
concat
store 3
load 3
retsub

// bool_comp
boolcomp_2:
store 11
load 11
!
!
!
store 12
load 12
retsub

// numerical_comp
numericalcomp_3:
store 13
int 18446744073709551615
load 13
-
store 14
load 14
retsub

// numerical_comp
numericalcomp_4:
store 15
int 4294967295
load 15
-
store 16
load 16
int 4294967296
<
assert
load 16
retsub


================================================
FILE: tests/integration/teal/roundtrip/app_roundtrip_(bool,uint64,uint32)_v8.teal
================================================
#pragma version 8
txna ApplicationArgs 0
store 1
load 1
callsub roundtripper_1
store 0
byte 0x151f7c75
load 0
concat
log
int 1
return

// tuple_complement
tuplecomplement_0:
proto 1 1
byte ""
int 0
dupn 4
byte ""
dup
frame_dig -1
int 0
getbit
frame_bury 1
frame_dig -1
int 1
extract_uint64
frame_bury 2
frame_dig -1
int 9
extract_uint32
frame_bury 3
frame_dig 1
callsub boolcomp_2
frame_bury 1
frame_dig 2
callsub numericalcomp_3
frame_bury 2
frame_dig 3
callsub numericalcomp_4
frame_bury 3
byte 0x00
int 0
frame_dig 1
setbit
frame_dig 2
itob
concat
frame_dig 3
itob
extract 4 0
concat
frame_bury 0
retsub

// round_tripper
roundtripper_1:
proto 1 1
byte ""
dupn 2
int 0
dup
byte ""
dup
frame_dig -1
callsub tuplecomplement_0
frame_bury 1
frame_dig 1
callsub tuplecomplement_0
frame_bury 2
frame_dig -1
frame_dig 1
concat
frame_dig 2
concat
frame_bury 0
retsub

// bool_comp
boolcomp_2:
proto 1 1
int 0
frame_dig -1
!
!
!
frame_bury 0
retsub

// numerical_comp
numericalcomp_3:
proto 1 1
int 0
int 18446744073709551615
frame_dig -1
-
frame_bury 0
retsub

// numerical_comp
numericalcomp_4:
proto 1 1
int 0
int 4294967295
frame_dig -1
-
frame_bury 0
frame_dig 0
int 4294967296
<
assert
retsub


================================================
FILE: tests/integration/teal/roundtrip/app_roundtrip_(byte)_v6.teal
================================================
#pragma version 6
txna ApplicationArgs 0
store 1
load 1
callsub roundtripper_1
store 0
byte 0x151f7c75
load 0
concat
log
int 1
return

// tuple_complement
tuplecomplement_0:
store 6
load 6
int 0
getbyte
store 8
load 8
callsub numericalcomp_2
store 8
byte 0x00
int 0
load 8
setbyte
store 7
load 7
retsub

// round_tripper
roundtripper_1:
store 2
load 2
callsub tuplecomplement_0
store 4
load 4
callsub tuplecomplement_0
store 5
load 2
load 4
concat
load 5
concat
store 3
load 3
retsub

// numerical_comp
numericalcomp_2:
store 9
int 255
load 9
-
store 10
load 10
int 256
<
assert
load 10
retsub


================================================
FILE: tests/integration/teal/roundtrip/app_roundtrip_(byte)_v8.teal
================================================
#pragma version 8
txna ApplicationArgs 0
store 1
load 1
callsub roundtripper_1
store 0
byte 0x151f7c75
load 0
concat
log
int 1
return

// tuple_complement
tuplecomplement_0:
proto 1 1
byte ""
int 0
dupn 2
byte ""
dup
frame_dig -1
int 0
getbyte
frame_bury 1
frame_dig 1
callsub numericalcomp_2
frame_bury 1
byte 0x00
int 0
frame_dig 1
setbyte
frame_bury 0
retsub

// round_tripper
roundtripper_1:
proto 1 1
byte ""
dupn 2
int 0
dup
byte ""
dup
frame_dig -1
callsub tuplecomplement_0
frame_bury 1
frame_dig 1
callsub tuplecomplement_0
frame_bury 2
frame_dig -1
frame_dig 1
concat
frame_dig 2
concat
frame_bury 0
retsub

// numerical_comp
numericalcomp_2:
proto 1 1
int 0
int 255
frame_dig -1
-
frame_bury 0
frame_dig 0
int 256
<
assert
retsub


================================================
FILE: tests/integration/teal/roundtrip/app_roundtrip_(byte,bool,uint64)_v6.teal
================================================
#pragma version 6
txna ApplicationArgs 0
store 1
load 1
callsub roundtripper_1
store 0
byte 0x151f7c75
load 0
concat
log
int 1
return

// tuple_complement
tuplecomplement_0:
store 6
load 6
int 0
getbyte
store 8
load 6
int 8
getbit
store 9
load 6
int 2
extract_uint64
store 10
load 8
callsub numericalcomp_2
store 8
load 9
callsub boolcomp_3
store 9
load 10
callsub numericalcomp_4
store 10
byte 0x00
int 0
load 8
setbyte
byte 0x00
int 0
load 9
setbit
concat
load 10
itob
concat
store 7
load 7
retsub

// round_tripper
roundtripper_1:
store 2
load 2
callsub tuplecomplement_0
store 4
load 4
callsub tuplecomplement_0
store 5
load 2
load 4
concat
load 5
concat
store 3
load 3
retsub

// numerical_comp
numericalcomp_2:
store 11
int 255
load 11
-
store 12
load 12
int 256
<
assert
load 12
retsub

// bool_comp
boolcomp_3:
store 13
load 13
!
!
!
store 14
load 14
retsub

// numerical_comp
numericalcomp_4:
store 15
int 18446744073709551615
load 15
-
store 16
load 16
retsub


================================================
FILE: tests/integration/teal/roundtrip/app_roundtrip_(byte,bool,uint64)_v8.teal
================================================
#pragma version 8
txna ApplicationArgs 0
store 1
load 1
callsub roundtripper_1
store 0
byte 0x151f7c75
load 0
concat
log
int 1
return

// tuple_complement
tuplecomplement_0:
proto 1 1
byte ""
int 0
dupn 4
byte ""
dup
frame_dig -1
int 0
getbyte
frame_bury 1
frame_dig -1
int 8
getbit
frame_bury 2
frame_dig -1
int 2
extract_uint64
frame_bury 3
frame_dig 1
callsub numericalcomp_2
frame_bury 1
frame_dig 2
callsub boolcomp_3
frame_bury 2
frame_dig 3
callsub numericalcomp_4
frame_bury 3
byte 0x00
int 0
frame_dig 1
setbyte
byte 0x00
int 0
frame_dig 2
setbit
concat
frame_dig 3
itob
concat
frame_bury 0
retsub

// round_tripper
roundtripper_1:
proto 1 1
byte ""
dupn 2
int 0
dup
byte ""
dup
frame_dig -1
callsub tuplecomplement_0
frame_bury 1
frame_dig 1
callsub tuplecomplement_0
frame_bury 2
frame_dig -1
frame_dig 1
concat
frame_dig 2
concat
frame_bury 0
retsub

// numerical_comp
numericalcomp_2:
proto 1 1
int 0
int 255
frame_dig -1
-
frame_bury 0
frame_dig 0
int 256
<
assert
retsub

// bool_comp
boolcomp_3:
proto 1 1
int 0
frame_dig -1
!
!
!
frame_bury 0
retsub

// numerical_comp
numericalcomp_4:
proto 1 1
int 0
int 18446744073709551615
frame_dig -1
-
frame_bury 0
retsub


================================================
FILE: tests/integration/teal/roundtrip/app_roundtrip_(byte[4],(bool,bool),uint64,address)[]_7_v6.teal
================================================
#pragma version 6
txna ApplicationArgs 0
store 1
load 1
callsub roundtripper_2
store 0
byte 0x151f7c75
load 0
concat
log
int 1
return

// tuple_complement
tuplecomplement_0:
store 15
load 15
extract 0 4
store 17
load 15
extract 4 1
store 18
load 15
int 5
extract_uint64
store 19
load 15
extract 13 0
store 20
load 17
callsub arraycomplement_4
store 17
load 18
callsub tuplecomplement_5
store 18
load 19
callsub numericalcomp_6
store 19
load 20
callsub arraycomplement_8
store 20
load 17
load 18
concat
load 19
itob
concat
load 20
concat
store 16
load 16
retsub

// array_complement
arraycomplement_1:
store 6
load 6
int 45
int 0
*
int 2
+
int 45
extract3
store 8
load 6
int 45
int 1
*
int 2
+
int 45
extract3
store 9
load 6
int 45
int 2
*
int 2
+
int 45
extract3
store 10
load 6
int 45
int 3
*
int 2
+
int 45
extract3
store 11
load 6
int 45
int 4
*
int 2
+
int 45
extract3
store 12
load 6
int 45
int 5
*
int 2
+
int 45
extract3
store 13
load 6
int 45
int 6
*
int 2
+
int 45
extract3
store 14
load 8
callsub tuplecomplement_0
store 8
load 9
callsub tuplecomplement_0
store 9
load 10
callsub tuplecomplement_0
store 10
load 11
callsub tuplecomplement_0
store 11
load 12
callsub tuplecomplement_0
store 12
load 13
callsub tuplecomplement_0
store 13
load 14
callsub tuplecomplement_0
store 14
int 7
store 75
load 75
itob
extract 6 0
load 8
load 9
concat
load 10
concat
load 11
concat
load 12
concat
load 13
concat
load 14
concat
concat
store 7
load 7
retsub

// round_tripper
roundtripper_2:
store 2
load 2
callsub arraycomplement_1
store 4
load 4
callsub arraycomplement_1
store 5
load 2
store 79
load 79
store 78
int 6
store 76
load 76
load 79
len
+
store 77
load 77
int 65536
<
assert
load 76
itob
extract 6 0
load 4
store 79
load 78
load 79
concat
store 78
load 77
store 76
load 76
load 79
len
+
store 77
load 77
int 65536
<
assert
load 76
itob
extract 6 0
concat
load 5
store 79
load 78
load 79
concat
store 78
load 77
store 76
load 76
itob
extract 6 0
concat
load 78
concat
store 3
load 3
retsub

// numerical_comp
numericalcomp_3:
store 27
int 255
load 27
-
store 28
load 28
int 256
<
assert
load 28
retsub

// array_complement
arraycomplement_4:
store 21
load 21
int 1
int 0
*
getbyte
store 23
load 21
int 1
int 1
*
getbyte
store 24
load 21
int 1
int 2
*
getbyte
store 25
load 21
int 1
int 3
*
getbyte
store 26
load 23
callsub numericalcomp_3
store 23
load 24
callsub numericalcomp_3
store 24
load 25
callsub numericalcomp_3
store 25
load 26
callsub numericalcomp_3
store 26
byte 0x00
int 0
load 23
setbyte
byte 0x00
int 0
load 24
setbyte
concat
byte 0x00
int 0
load 25
setbyte
concat
byte 0x00
int 0
load 26
setbyte
concat
store 22
load 22
retsub

// tuple_complement
tuplecomplement_5:
store 29
load 29
int 0
getbit
store 31
load 29
int 1
getbit
store 32
load 31
callsub boolcomp_9
store 31
load 32
callsub boolcomp_10
store 32
byte 0x00
int 0
load 31
setbit
int 1
load 32
setbit
store 30
load 30
retsub

// numerical_comp
numericalcomp_6:
store 37
int 18446744073709551615
load 37
-
store 38
load 38
retsub

// numerical_comp
numericalcomp_7:
store 73
int 255
load 73
-
store 74
load 74
int 256
<
assert
load 74
retsub

// array_complement
arraycomplement_8:
store 39
load 39
int 1
int 0
*
getbyte
store 41
load 39
int 1
int 1
*
getbyte
store 42
load 39
int 1
int 2
*
getbyte
store 43
load 39
int 1
int 3
*
getbyte
store 44
load 39
int 1
int 4
*
getbyte
store 45
load 39
int 1
int 5
*
getbyte
store 46
load 39
int 1
int 6
*
getbyte
store 47
load 39
int 1
int 7
*
getbyte
store 48
load 39
int 1
int 8
*
getbyte
store 49
load 39
int 1
int 9
*
getbyte
store 50
load 39
int 1
int 10
*
getbyte
store 51
load 39
int 1
int 11
*
getbyte
store 52
load 39
int 1
int 12
*
getbyte
store 53
load 39
int 1
int 13
*
getbyte
store 54
load 39
int 1
int 14
*
getbyte
store 55
load 39
int 1
int 15
*
getbyte
store 56
load 39
int 1
int 16
*
getbyte
store 57
load 39
int 1
int 17
*
getbyte
store 58
load 39
int 1
int 18
*
getbyte
store 59
load 39
int 1
int 19
*
getbyte
store 60
load 39
int 1
int 20
*
getbyte
store 61
load 39
int 1
int 21
*
getbyte
store 62
load 39
int 1
int 22
*
getbyte
store 63
load 39
int 1
int 23
*
getbyte
store 64
load 39
int 1
int 24
*
getbyte
store 65
load 39
int 1
int 25
*
getbyte
store 66
load 39
int 1
int 26
*
getbyte
store 67
load 39
int 1
int 27
*
getbyte
store 68
load 39
int 1
int 28
*
getbyte
store 69
load 39
int 1
int 29
*
getbyte
store 70
load 39
int 1
int 30
*
getbyte
store 71
load 39
int 1
int 31
*
getbyte
store 72
load 41
callsub numericalcomp_7
store 41
load 42
callsub numericalcomp_7
store 42
load 43
callsub numericalcomp_7
store 43
load 44
callsub numericalcomp_7
store 44
load 45
callsub numericalcomp_7
store 45
load 46
callsub numericalcomp_7
store 46
load 47
callsub numericalcomp_7
store 47
load 48
callsub numericalcomp_7
store 48
load 49
callsub numericalcomp_7
store 49
load 50
callsub numericalcomp_7
store 50
load 51
callsub numericalcomp_7
store 51
load 52
callsub numericalcomp_7
store 52
load 53
callsub numericalcomp_7
store 53
load 54
callsub numericalcomp_7
store 54
load 55
callsub numericalcomp_7
store 55
load 56
callsub numericalcomp_7
store 56
load 57
callsub numericalcomp_7
store 57
load 58
callsub numericalcomp_7
store 58
load 59
callsub numericalcomp_7
store 59
load 60
callsub numericalcomp_7
store 60
load 61
callsub numericalcomp_7
store 61
load 62
callsub numericalcomp_7
store 62
load 63
callsub numericalcomp_7
store 63
load 64
callsub numericalcomp_7
store 64
load 65
callsub numericalcomp_7
store 65
load 66
callsub numericalcomp_7
store 66
load 67
callsub numericalcomp_7
store 67
load 68
callsub numericalcomp_7
store 68
load 69
callsub numericalcomp_7
store 69
load 70
callsub numericalcomp_7
store 70
load 71
callsub numericalcomp_7
store 71
load 72
callsub numericalcomp_7
store 72
byte 0x00
int 0
load 41
setbyte
byte 0x00
int 0
load 42
setbyte
concat
byte 0x00
int 0
load 43
setbyte
concat
byte 0x00
int 0
load 44
setbyte
concat
byte 0x00
int 0
load 45
setbyte
concat
byte 0x00
int 0
load 46
setbyte
concat
byte 0x00
int 0
load 47
setbyte
concat
byte 0x00
int 0
load 48
setbyte
concat
byte 0x00
int 0
load 49
setbyte
concat
byte 0x00
int 0
load 50
setbyte
concat
byte 0x00
int 0
load 51
setbyte
concat
byte 0x00
int 0
load 52
setbyte
concat
byte 0x00
int 0
load 53
setbyte
concat
byte 0x00
int 0
load 54
setbyte
concat
byte 0x00
int 0
load 55
setbyte
concat
byte 0x00
int 0
load 56
setbyte
concat
byte 0x00
int 0
load 57
setbyte
concat
byte 0x00
int 0
load 58
setbyte
concat
byte 0x00
int 0
load 59
setbyte
concat
byte 0x00
int 0
load 60
setbyte
concat
byte 0x00
int 0
load 61
setbyte
concat
byte 0x00
int 0
load 62
setbyte
concat
byte 0x00
int 0
load 63
setbyte
concat
byte 0x00
int 0
load 64
setbyte
concat
byte 0x00
int 0
load 65
setbyte
concat
byte 0x00
int 0
load 66
setbyte
concat
byte 0x00
int 0
load 67
setbyte
concat
byte 0x00
int 0
load 68
setbyte
concat
byte 0x00
int 0
load 69
setbyte
concat
byte 0x00
int 0
load 70
setbyte
concat
byte 0x00
int 0
load 71
setbyte
concat
byte 0x00
int 0
load 72
setbyte
concat
store 40
load 40
retsub

// bool_comp
boolcomp_9:
store 33
load 33
!
!
!
store 34
load 34
retsub

// bool_comp
boolcomp_10:
store 35
load 35
!
!
!
store 36
load 36
retsub


================================================
FILE: tests/integration/teal/roundtrip/app_roundtrip_(byte[4],(bool,bool),uint64,address)[]_7_v8.teal
================================================
#pragma version 8
txna ApplicationArgs 0
store 1
load 1
callsub roundtripper_2
store 0
byte 0x151f7c75
load 0
concat
log
int 1
return

// tuple_complement
tuplecomplement_0:
proto 1 1
byte ""
dupn 2
int 0
byte ""
int 0
dupn 3
byte ""
dup
frame_dig -1
extract 0 4
frame_bury 1
frame_dig -1
extract 4 1
frame_bury 2
frame_dig -1
int 5
extract_uint64
frame_bury 3
frame_dig -1
extract 13 0
frame_bury 4
frame_dig 1
callsub arraycomplement_4
frame_bury 1
frame_dig 2
callsub tuplecomplement_5
frame_bury 2
frame_dig 3
callsub numericalcomp_6
frame_bury 3
frame_dig 4
callsub arraycomplement_8
frame_bury 4
frame_dig 1
frame_dig 2
concat
frame_dig 3
itob
concat
frame_dig 4
concat
frame_bury 0
retsub

// array_complement
arraycomplement_1:
proto 1 1
byte ""
dupn 7
int 0
dupn 8
byte ""
dup
int 0
frame_dig -1
int 45
int 0
*
int 2
+
int 45
extract3
frame_bury 1
frame_dig -1
int 45
int 1
*
int 2
+
int 45
extract3
frame_bury 2
frame_dig -1
int 45
int 2
*
int 2
+
int 45
extract3
frame_bury 3
frame_dig -1
int 45
int 3
*
int 2
+
int 45
extract3
frame_bury 4
frame_dig -1
int 45
int 4
*
int 2
+
int 45
extract3
frame_bury 5
frame_dig -1
int 45
int 5
*
int 2
+
int 45
extract3
frame_bury 6
frame_dig -1
int 45
int 6
*
int 2
+
int 45
extract3
frame_bury 7
frame_dig 1
callsub tuplecomplement_0
frame_bury 1
frame_dig 2
callsub tuplecomplement_0
frame_bury 2
frame_dig 3
callsub tuplecomplement_0
frame_bury 3
frame_dig 4
callsub tuplecomplement_0
frame_bury 4
frame_dig 5
callsub tuplecomplement_0
frame_bury 5
frame_dig 6
callsub tuplecomplement_0
frame_bury 6
frame_dig 7
callsub tuplecomplement_0
frame_bury 7
int 7
frame_bury 19
frame_dig 19
itob
extract 6 0
frame_dig 1
frame_dig 2
concat
frame_dig 3
concat
frame_dig 4
concat
frame_dig 5
concat
frame_dig 6
concat
frame_dig 7
concat
concat
frame_bury 0
retsub

// round_tripper
roundtripper_2:
proto 1 1
byte ""
dupn 2
int 0
dup
byte ""
dup
frame_dig -1
callsub arraycomplement_1
frame_bury 1
frame_dig 1
callsub arraycomplement_1
frame_bury 2
frame_dig -1
frame_bury 6
frame_dig 6
frame_bury 5
int 6
frame_bury 3
frame_dig 3
frame_dig 6
len
+
frame_bury 4
frame_dig 4
int 65536
<
assert
frame_dig 3
itob
extract 6 0
frame_dig 1
frame_bury 6
frame_dig 5
frame_dig 6
concat
frame_bury 5
frame_dig 4
frame_bury 3
frame_dig 3
frame_dig 6
len
+
frame_bury 4
frame_dig 4
int 65536
<
assert
frame_dig 3
itob
extract 6 0
concat
frame_dig 2
frame_bury 6
frame_dig 5
frame_dig 6
concat
frame_bury 5
frame_dig 4
frame_bury 3
frame_dig 3
itob
extract 6 0
concat
frame_dig 5
concat
frame_bury 0
retsub

// numerical_comp
numericalcomp_3:
proto 1 1
int 0
int 255
frame_dig -1
-
frame_bury 0
frame_dig 0
int 256
<
assert
retsub

// array_complement
arraycomplement_4:
proto 1 1
byte ""
int 0
dupn 5
byte ""
dup
frame_dig -1
int 1
int 0
*
getbyte
frame_bury 1
frame_dig -1
int 1
int 1
*
getbyte
frame_bury 2
frame_dig -1
int 1
int 2
*
getbyte
frame_bury 3
frame_dig -1
int 1
int 3
*
getbyte
frame_bury 4
frame_dig 1
callsub numericalcomp_3
frame_bury 1
frame_dig 2
callsub numericalcomp_3
frame_bury 2
frame_dig 3
callsub numericalcomp_3
frame_bury 3
frame_dig 4
callsub numericalcomp_3
frame_bury 4
byte 0x00
int 0
frame_dig 1
setbyte
byte 0x00
int 0
frame_dig 2
setbyte
concat
byte 0x00
int 0
frame_dig 3
setbyte
concat
byte 0x00
int 0
frame_dig 4
setbyte
concat
frame_bury 0
retsub

// tuple_complement
tuplecomplement_5:
proto 1 1
byte ""
int 0
dupn 3
byte ""
dup
frame_dig -1
int 0
getbit
frame_bury 1
frame_dig -1
int 1
getbit
frame_bury 2
frame_dig 1
callsub boolcomp_9
frame_bury 1
frame_dig 2
callsub boolcomp_10
frame_bury 2
byte 0x00
int 0
frame_dig 1
setbit
int 1
frame_dig 2
setbit
frame_bury 0
retsub

// numerical_comp
numericalcomp_6:
proto 1 1
int 0
int 18446744073709551615
frame_dig -1
-
frame_bury 0
retsub

// numerical_comp
numericalcomp_7:
proto 1 1
int 0
int 255
frame_dig -1
-
frame_bury 0
frame_dig 0
int 256
<
assert
retsub

// array_complement
arraycomplement_8:
proto 1 1
byte ""
int 0
dupn 33
byte ""
dup
frame_dig -1
int 1
int 0
*
getbyte
frame_bury 1
frame_dig -1
int 1
int 1
*
getbyte
frame_bury 2
frame_dig -1
int 1
int 2
*
getbyte
frame_bury 3
frame_dig -1
int 1
int 3
*
getbyte
frame_bury 4
frame_dig -1
int 1
int 4
*
getbyte
frame_bury 5
frame_dig -1
int 1
int 5
*
getbyte
frame_bury 6
frame_dig -1
int 1
int 6
*
getbyte
frame_bury 7
frame_dig -1
int 1
int 7
*
getbyte
frame_bury 8
frame_dig -1
int 1
int 8
*
getbyte
frame_bury 9
frame_dig -1
int 1
int 9
*
getbyte
frame_bury 10
frame_dig -1
int 1
int 10
*
getbyte
frame_bury 11
frame_dig -1
int 1
int 11
*
getbyte
frame_bury 12
frame_dig -1
int 1
int 12
*
getbyte
frame_bury 13
frame_dig -1
int 1
int 13
*
getbyte
frame_bury 14
frame_dig -1
int 1
int 14
*
getbyte
frame_bury 15
frame_dig -1
int 1
int 15
*
getbyte
frame_bury 16
frame_dig -1
int 1
int 16
*
getbyte
frame_bury 17
frame_dig -1
int 1
int 17
*
getbyte
frame_bury 18
frame_dig -1
int 1
int 18
*
getbyte
frame_bury 19
frame_dig -1
int 1
int 19
*
getbyte
frame_bury 20
frame_dig -1
int 1
int 20
*
getbyte
frame_bury 21
frame_dig -1
int 1
int 21
*
getbyte
frame_bury 22
frame_dig -1
int 1
int 22
*
getbyte
frame_bury 23
frame_dig -1
int 1
int 23
*
getbyte
frame_bury 24
frame_dig -1
int 1
int 24
*
getbyte
frame_bury 25
frame_dig -1
int 1
int 25
*
getbyte
frame_bury 26
frame_dig -1
int 1
int 26
*
getbyte
frame_bury 27
frame_dig -1
int 1
int 27
*
getbyte
frame_bury 28
frame_dig -1
int 1
int 28
*
getbyte
frame_bury 29
frame_dig -1
int 1
int 29
*
getbyte
frame_bury 30
frame_dig -1
int 1
int 30
*
getbyte
frame_bury 31
frame_dig -1
int 1
int 31
*
getbyte
frame_bury 32
frame_dig 1
callsub numericalcomp_7
frame_bury 1
frame_dig 2
callsub numericalcomp_7
frame_bury 2
frame_dig 3
callsub numericalcomp_7
frame_bury 3
frame_dig 4
callsub numericalcomp_7
frame_bury 4
frame_dig 5
callsub numericalcomp_7
frame_bury 5
frame_dig 6
callsub numericalcomp_7
frame_bury 6
frame_dig 7
callsub numericalcomp_7
frame_bury 7
frame_dig 8
callsub numericalcomp_7
frame_bury 8
frame_dig 9
callsub numericalcomp_7
frame_bury 9
frame_dig 10
callsub numericalcomp_7
frame_bury 10
frame_dig 11
callsub numericalcomp_7
frame_bury 11
frame_dig 12
callsub numericalcomp_7
frame_bury 12
frame_dig 13
callsub numericalcomp_7
frame_bury 13
frame_dig 14
callsub numericalcomp_7
frame_bury 14
frame_dig 15
callsub numericalcomp_7
frame_bury 15
frame_dig 16
callsub numericalcomp_7
frame_bury 16
frame_dig 17
callsub numericalcomp_7
frame_bury 17
frame_dig 18
callsub numericalcomp_7
frame_bury 18
frame_dig 19
callsub numericalcomp_7
frame_bury 19
frame_dig 20
callsub numericalcomp_7
frame_bury 20
frame_dig 21
callsub numericalcomp_7
frame_bury 21
frame_dig 22
callsub numericalcomp_7
frame_bury 22
frame_dig 23
callsub numericalcomp_7
frame_bury 23
frame_dig 24
callsub numericalcomp_7
frame_bury 24
frame_dig 25
callsub numericalcomp_7
frame_bury 25
frame_dig 26
callsub numericalcomp_7
frame_bury 26
frame_dig 27
callsub numericalcomp_7
frame_bury 27
frame_dig 28
callsub numericalcomp_7
frame_bury 28
frame_dig 29
callsub numericalcomp_7
frame_bury 29
frame_dig 30
callsub numericalcomp_7
frame_bury 30
frame_dig 31
callsub numericalcomp_7
frame_bury 31
frame_dig 32
callsub numericalcomp_7
frame_bury 32
byte 0x00
int 0
frame_dig 1
setbyte
byte 0x00
int 0
frame_dig 2
setbyte
concat
byte 0x00
int 0
frame_dig 3
setbyte
concat
byte 0x00
int 0
frame_dig 4
setbyte
concat
byte 0x00
int 0
frame_dig 5
setbyte
concat
byte 0x00
int 0
frame_dig 6
setbyte
concat
byte 0x00
int 0
frame_dig 7
setbyte
concat
byte 0x00
int 0
frame_dig 8
setbyte
concat
byte 0x00
int 0
frame_dig 9
setbyte
concat
byte 0x00
int 0
frame_dig 10
setbyte
concat
byte 0x00
int 0
frame_dig 11
setbyte
concat
byte 0x00
int 0
frame_dig 12
setbyte
concat
byte 0x00
int 0
frame_dig 13
setbyte
concat
byte 0x00
int 0
frame_dig 14
setbyte
concat
byte 0x00
int 0
frame_dig 15
setbyte
concat
byte 0x00
int 0
frame_dig 16
setbyte
concat
byte 0x00
int 0
frame_dig 17
setbyte
concat
byte 0x00
int 0
frame_dig 18
setbyte
concat
byte 0x00
int 0
frame_dig 19
setbyte
concat
byte 0x00
int 0
frame_dig 20
setbyte
concat
byte 0x00
int 0
frame_dig 21
setbyte
concat
byte 0x00
int 0
frame_dig 22
setbyte
concat
byte 0x00
int 0
frame_dig 23
setbyte
concat
byte 0x00
int 0
frame_dig 24
setbyte
concat
byte 0x00
int 0
frame_dig 25
setbyte
concat
byte 0x00
int 0
frame_dig 26
setbyte
concat
byte 0x00
int 0
frame_dig 27
setbyte
concat
byte 0x00
int 0
frame_dig 28
setbyte
concat
byte 0x00
int 0
frame_dig 29
setbyte
concat
byte 0x00
int 0
frame_dig 30
setbyte
concat
byte 0x00
int 0
frame_dig 31
setbyte
concat
byte 0x00
int 0
frame_dig 32
setbyte
concat
frame_bury 0
retsub

// bool_comp
boolcomp_9:
proto 1 1
int 0
frame_dig -1
!
!
!
frame_bury 0
retsub

// bool_comp
boolcomp_10:
proto 1 1
int 0
frame_dig -1
!
!
!
frame_bury 0
retsub


================================================
FILE: tests/integration/teal/roundtrip/app_roundtrip_(byte[],byte[3])_v6.teal
================================================
#pragma version 6
txna ApplicationArgs 0
store 1
load 1
callsub roundtripper_1
store 0
byte 0x151f7c75
load 0
concat
log
int 1
return

// tuple_complement
tuplecomplement_0:
store 6
load 6
load 6
int 0
extract_uint16
dig 1
len
substring3
store 8
load 6
extract 2 3
store 9
load 8
callsub arraycomplement_3
store 8
load 9
callsub arraycomplement_5
store 9
load 8
store 27
load 27
store 26
int 5
store 25
load 25
itob
extract 6 0
load 9
concat
load 26
concat
store 7
load 7
retsub

// round_tripper
roundtripper_1:
store 2
load 2
callsub tuplecomplement_0
store 4
load 4
callsub tuplecomplement_0
store 5
load 2
store 31
load 31
store 30
int 6
store 28
load 28
load 31
len
+
store 29
load 29
int 65536
<
assert
load 28
itob
extract 6 0
load 4
store 31
load 30
load 31
concat
store 30
load 29
store 28
load 28
load 31
len
+
store 29
load 29
int 65536
<
assert
load 28
itob
extract 6 0
concat
load 5
store 31
load 30
load 31
concat
store 30
load 29
store 28
load 28
itob
extract 6 0
concat
load 30
concat
store 3
load 3
retsub

// numerical_comp
numericalcomp_2:
store 15
int 255
load 15
-
store 16
load 16
int 256
<
assert
load 16
retsub

// array_complement
arraycomplement_3:
store 10
load 10
int 1
int 0
*
int 2
+
getbyte
store 12
load 10
int 1
int 1
*
int 2
+
getbyte
store 13
load 10
int 1
int 2
*
int 2
+
getbyte
store 14
load 12
callsub numericalcomp_2
store 12
load 13
callsub numericalcomp_2
store 13
load 14
callsub numericalcomp_2
store 14
int 3
store 17
load 17
itob
extract 6 0
byte 0x00
int 0
load 12
setbyte
byte 0x00
int 0
load 13
setbyte
concat
byte 0x00
int 0
load 14
setbyte
concat
concat
store 11
load 11
retsub

// numerical_comp
numericalcomp_4:
store 23
int 255
load 23
-
store 24
load 24
int 256
<
assert
load 24
retsub

// array_complement
arraycomplement_5:
store 18
load 18
int 1
int 0
*
getbyte
store 20
load 18
int 1
int 1
*
getbyte
store 21
load 18
int 1
int 2
*
getbyte
store 22
load 20
callsub numericalcomp_4
store 20
load 21
callsub numericalcomp_4
store 21
load 22
callsub numericalcomp_4
store 22
byte 0x00
int 0
load 20
setbyte
byte 0x00
int 0
load 21
setbyte
concat
byte 0x00
int 0
load 22
setbyte
concat
store 19
load 19
retsub


================================================
FILE: tests/integration/teal/roundtrip/app_roundtrip_(byte[],byte[3])_v8.teal
================================================
#pragma version 8
txna ApplicationArgs 0
store 1
load 1
callsub roundtripper_1
store 0
byte 0x151f7c75
load 0
concat
log
int 1
return

// tuple_complement
tuplecomplement_0:
proto 1 1
byte ""
dupn 2
int 0
dupn 3
byte ""
dup
frame_dig -1
frame_dig -1
int 0
extract_uint16
dig 1
len
substring3
frame_bury 1
frame_dig -1
extract 2 3
frame_bury 2
frame_dig 1
callsub arraycomplement_3
frame_bury 1
frame_dig 2
callsub arraycomplement_5
frame_bury 2
frame_dig 1
frame_bury 8
frame_dig 8
frame_bury 7
int 5
frame_bury 5
frame_dig 5
itob
extract 6 0
frame_dig 2
concat
frame_dig 7
concat
frame_bury 0
retsub

// round_tripper
roundtripper_1:
proto 1 1
byte ""
dupn 2
int 0
dup
byte ""
dup
frame_dig -1
callsub tuplecomplement_0
frame_bury 1
frame_dig 1
callsub tuplecomplement_0
frame_bury 2
frame_dig -1
frame_bury 6
frame_dig 6
frame_bury 5
int 6
frame_bury 3
frame_dig 3
frame_dig 6
len
+
frame_bury 4
frame_dig 4
int 65536
<
assert
frame_dig 3
itob
extract 6 0
frame_dig 1
frame_bury 6
frame_dig 5
frame_dig 6
concat
frame_bury 5
frame_dig 4
frame_bury 3
frame_dig 3
frame_dig 6
len
+
frame_bury 4
frame_dig 4
int 65536
<
assert
frame_dig 3
itob
extract 6 0
concat
frame_dig 2
frame_bury 6
frame_dig 5
frame_dig 6
concat
frame_bury 5
frame_dig 4
frame_bury 3
frame_dig 3
itob
extract 6 0
concat
frame_dig 5
concat
frame_bury 0
retsub

// numerical_comp
numericalcomp_2:
proto 1 1
int 0
int 255
frame_dig -1
-
frame_bury 0
frame_dig 0
int 256
<
assert
retsub

// array_complement
arraycomplement_3:
proto 1 1
byte ""
int 0
dupn 7
byte ""
dup
int 0
frame_dig -1
int 1
int 0
*
int 2
+
getbyte
frame_bury 1
frame_dig -1
int 1
int 1
*
int 2
+
getbyte
frame_bury 2
frame_dig -1
int 1
int 2
*
int 2
+
getbyte
frame_bury 3
frame_dig 1
callsub numericalcomp_2
frame_bury 1
frame_dig 2
callsub numericalcomp_2
frame_bury 2
frame_dig 3
callsub numericalcomp_2
frame_bury 3
int 3
frame_bury 11
frame_dig 11
itob
extract 6 0
byte 0x00
int 0
frame_dig 1
setbyte
byte 0x00
int 0
frame_dig 2
setbyte
concat
byte 0x00
int 0
frame_dig 3
setbyte
concat
concat
frame_bury 0
retsub

// numerical_comp
numericalcomp_4:
proto 1 1
int 0
int 255
frame_dig -1
-
frame_bury 0
frame_dig 0
int 256
<
assert
retsub

// array_complement
arraycomplement_5:
proto 1 1
byte ""
int 0
dupn 4
byte ""
dup
frame_dig -1
int 1
int 0
*
getbyte
frame_bury 1
frame_dig -1
int 1
int 1
*
getbyte
frame_bury 2
frame_dig -1
int 1
int 2
*
getbyte
frame_bury 3
frame_dig 1
callsub numericalcomp_4
frame_bury 1
frame_dig 2
callsub numericalcomp_4
frame_bury 2
frame_dig 3
callsub numericalcomp_4
frame_bury 3
byte 0x00
int 0
frame_dig 1
setbyte
byte 0x00
int 0
frame_dig 2
setbyte
concat
byte 0x00
int 0
frame_dig 3
setbyte
concat
frame_bury 0
retsub


================================================
FILE: tests/integration/teal/roundtrip/app_roundtrip_(uint16)_v6.teal
================================================
#pragma version 6
txna ApplicationArgs 0
store 1
load 1
callsub roundtripper_1
store 0
byte 0x151f7c75
load 0
concat
log
int 1
return

// tuple_complement
tuplecomplement_0:
store 6
load 6
int 0
extract_uint16
store 8
load 8
callsub numericalcomp_2
store 8
load 8
itob
extract 6 0
store 7
load 7
retsub

// round_tripper
roundtripper_1:
store 2
load 2
callsub tuplecomplement_0
store 4
load 4
callsub tuplecomplement_0
store 5
load 2
load 4
concat
load 5
concat
store 3
load 3
retsub

// numerical_comp
numericalcomp_2:
store 9
int 65535
load 9
-
store 10
load 10
int 65536
<
assert
load 10
retsub


================================================
FILE: tests/integration/teal/roundtrip/app_roundtrip_(uint16)_v8.teal
================================================
#pragma version 8
txna ApplicationArgs 0
store 1
load 1
callsub roundtripper_1
store 0
byte 0x151f7c75
load 0
concat
log
int 1
return

// tuple_complement
tuplecomplement_0:
proto 1 1
byte ""
int 0
dupn 2
byte ""
dup
frame_dig -1
int 0
extract_uint16
frame_bury 1
frame_dig 1
callsub numericalcomp_2
frame_bury 1
frame_dig 1
itob
extract 6 0
frame_bury 0
retsub

// round_tripper
roundtripper_1:
proto 1 1
byte ""
dupn 2
int 0
dup
byte ""
dup
frame_dig -1
callsub tuplecomplement_0
frame_bury 1
frame_dig 1
callsub tuplecomplement_0
frame_bury 2
frame_dig -1
frame_dig 1
concat
frame_dig 2
concat
frame_bury 0
retsub

// numerical_comp
numericalcomp_2:
proto 1 1
int 0
int 65535
frame_dig -1
-
frame_bury 0
frame_dig 0
int 65536
<
assert
retsub


================================================
FILE: tests/integration/teal/roundtrip/app_roundtrip_(uint16,uint8,byte)_v6.teal
================================================
#pragma version 6
txna ApplicationArgs 0
store 1
load 1
callsub roundtripper_1
store 0
byte 0x151f7c75
load 0
concat
log
int 1
return

// tuple_complement
tuplecomplement_0:
store 6
load 6
int 0
extract_uint16
store 8
load 6
int 2
getbyte
store 9
load 6
int 3
getbyte
store 10
load 8
callsub numericalcomp_2
store 8
load 9
callsub numericalcomp_3
store 9
load 10
callsub numericalcomp_4
store 10
load 8
itob
extract 6 0
byte 0x00
int 0
load 9
setbyte
concat
byte 0x00
int 0
load 10
setbyte
concat
store 7
load 7
retsub

// round_tripper
roundtripper_1:
store 2
load 2
callsub tuplecomplement_0
store 4
load 4
callsub tuplecomplement_0
store 5
load 2
load 4
concat
load 5
concat
store 3
load 3
retsub

// numerical_comp
numericalcomp_2:
store 11
int 65535
load 11
-
store 12
load 12
int 65536
<
assert
load 12
retsub

// numerical_comp
numericalcomp_3:
store 13
int 255
load 13
-
store 14
load 14
int 256
<
assert
load 14
retsub

// numerical_comp
numericalcomp_4:
store 15
int 255
load 15
-
store 16
load 16
int 256
<
assert
load 16
retsub


================================================
FILE: tests/integration/teal/roundtrip/app_roundtrip_(uint16,uint8,byte)_v8.teal
================================================
#pragma version 8
txna ApplicationArgs 0
store 1
load 1
callsub roundtripper_1
store 0
byte 0x151f7c75
load 0
concat
log
int 1
return

// tuple_complement
tuplecomplement_0:
proto 1 1
byte ""
int 0
dupn 4
byte ""
dup
frame_dig -1
int 0
extract_uint16
frame_bury 1
frame_dig -1
int 2
getbyte
frame_bury 2
frame_dig -1
int 3
getbyte
frame_bury 3
frame_dig 1
callsub numericalcomp_2
frame_bury 1
frame_dig 2
callsub numericalcomp_3
frame_bury 2
frame_dig 3
callsub numericalcomp_4
frame_bury 3
frame_dig 1
itob
extract 6 0
byte 0x00
int 0
frame_dig 2
setbyte
concat
byte 0x00
int 0
frame_dig 3
setbyte
concat
frame_bury 0
retsub

// round_tripper
roundtripper_1:
proto 1 1
byte ""
dupn 2
int 0
dup
byte ""
dup
frame_dig -1
callsub tuplecomplement_0
frame_bury 1
frame_dig 1
callsub tuplecomplement_0
frame_bury 2
frame_dig -1
frame_dig 1
concat
frame_dig 2
concat
frame_bury 0
retsub

// numerical_comp
numericalcomp_2:
proto 1 1
int 0
int 65535
frame_dig -1
-
frame_bury 0
frame_dig 0
int 65536
<
assert
retsub

// numerical_comp
numericalcomp_3:
proto 1 1
int 0
int 255
frame_dig -1
-
frame_bury 0
frame_dig 0
int 256
<
assert
retsub

// numerical_comp
numericalcomp_4:
proto 1 1
int 0
int 255
frame_dig -1
-
frame_bury 0
frame_dig 0
int 256
<
assert
retsub


================================================
FILE: tests/integration/teal/roundtrip/app_roundtrip_(uint32)_v6.teal
================================================
#pragma version 6
txna ApplicationArgs 0
store 1
load 1
callsub roundtripper_1
store 0
byte 0x151f7c75
load 0
concat
log
int 1
return

// tuple_complement
tuplecomplement_0:
store 6
load 6
int 0
extract_uint32
store 8
load 8
callsub numericalcomp_2
store 8
load 8
itob
extract 4 0
store 7
load 7
retsub

// round_tripper
roundtripper_1:
store 2
load 2
callsub tuplecomplement_0
store 4
load 4
callsub tuplecomplement_0
store 5
load 2
load 4
concat
load 5
concat
store 3
load 3
retsub

// numerical_comp
numericalcomp_2:
store 9
int 4294967295
load 9
-
store 10
load 10
int 4294967296
<
assert
load 10
retsub


================================================
FILE: tests/integration/teal/roundtrip/app_roundtrip_(uint32)_v8.teal
================================================
#pragma version 8
txna ApplicationArgs 0
store 1
load 1
callsub roundtripper_1
store 0
byte 0x151f7c75
load 0
concat
log
int 1
return

// tuple_complement
tuplecomplement_0:
proto 1 1
byte ""
int 0
dupn 2
byte ""
dup
frame_dig -1
int 0
extract_uint32
frame_bury 1
frame_dig 1
callsub numericalcomp_2
frame_bury 1
frame_dig 1
itob
extract 4 0
frame_bury 0
retsub

// round_tripper
roundtripper_1:
proto 1 1
byte ""
dupn 2
int 0
dup
byte ""
dup
frame_dig -1
callsub tuplecomplement_0
frame_bury 1
frame_dig 1
callsub tuplecomplement_0
frame_bury 2
frame_dig -1
frame_dig 1
concat
frame_dig 2
concat
frame_bury 0
retsub

// numerical_comp
numericalcomp_2:
proto 1 1
int 0
int 4294967295
frame_dig -1
-
frame_bury 0
frame_dig 0
int 4294967296
<
assert
retsub


================================================
FILE: tests/integration/teal/roundtrip/app_roundtrip_(uint32,uint16,uint8)_v6.teal
================================================
#pragma version 6
txna ApplicationArgs 0
store 1
load 1
callsub roundtripper_1
store 0
byte 0x151f7c75
load 0
concat
log
int 1
return

// tuple_complement
tuplecomplement_0:
store 6
load 6
int 0
extract_uint32
store 8
load 6
int 4
extract_uint16
store 9
load 6
int 6
getbyte
store 10
load 8
callsub numericalcomp_2
store 8
load 9
callsub numericalcomp_3
store 9
load 10
callsub numericalcomp_4
store 10
load 8
itob
extract 4 0
load 9
itob
extract 6 0
concat
byte 0x00
int 0
load 10
setbyte
concat
store 7
load 7
retsub

// round_tripper
roundtripper_1:
store 2
load 2
callsub tuplecomplement_0
store 4
load 4
callsub tuplecomplement_0
store 5
load 2
load 4
concat
load 5
concat
store 3
load 3
retsub

// numerical_comp
numericalcomp_2:
store 11
int 4294967295
load 11
-
store 12
load 12
int 4294967296
<
assert
load 12
retsub

// numerical_comp
numericalcomp_3:
store 13
int 65535
load 13
-
store 14
load 14
int 65536
<
assert
load 14
retsub

// numerical_comp
numericalcomp_4:
store 15
int 255
load 15
-
store 16
load 16
int 256
<
assert
load 16
retsub


================================================
FILE: tests/integration/teal/roundtrip/app_roundtrip_(uint32,uint16,uint8)_v8.teal
================================================
#pragma version 8
txna ApplicationArgs 0
store 1
load 1
callsub roundtripper_1
store 0
byte 0x151f7c75
load 0
concat
log
int 1
return

// tuple_complement
tuplecomplement_0:
proto 1 1
byte ""
int 0
dupn 4
byte ""
dup
frame_dig -1
int 0
extract_uint32
frame_bury 1
frame_dig -1
int 4
extract_uint16
frame_bury 2
frame_dig -1
int 6
getbyte
frame_bury 3
frame_dig 1
callsub numericalcomp_2
frame_bury 1
frame_dig 2
callsub numericalcomp_3
frame_bury 2
frame_dig 3
callsub numericalcomp_4
frame_bury 3
frame_dig 1
itob
extract 4 0
frame_dig 2
itob
extract 6 0
concat
byte 0x00
int 0
frame_dig 3
setbyte
concat
frame_bury 0
retsub

// round_tripper
roundtripper_1:
proto 1 1
byte ""
dupn 2
int 0
dup
byte ""
dup
frame_dig -1
callsub tuplecomplement_0
frame_bury 1
frame_dig 1
callsub tuplecomplement_0
frame_bury 2
frame_dig -1
frame_dig 1
concat
frame_dig 2
concat
frame_bury 0
retsub

// numerical_comp
numericalcomp_2:
proto 1 1
int 0
int 4294967295
frame_dig -1
-
frame_bury 0
frame_dig 0
int 4294967296
<
assert
retsub

// numerical_comp
numericalcomp_3:
proto 1 1
int 0
int 65535
frame_dig -1
-
frame_bury 0
frame_dig 0
int 65536
<
assert
retsub

// numerical_comp
numericalcomp_4:
proto 1 1
int 0
int 255
frame_dig -1
-
frame_bury 0
frame_dig 0
int 256
<
assert
retsub


================================================
FILE: tests/integration/teal/roundtrip/app_roundtrip_(uint64)_v6.teal
================================================
#pragma version 6
txna ApplicationArgs 0
store 1
load 1
callsub roundtripper_1
store 0
byte 0x151f7c75
load 0
concat
log
int 1
return

// tuple_complement
tuplecomplement_0:
store 6
load 6
btoi
store 8
load 8
callsub numericalcomp_2
store 8
load 8
itob
store 7
load 7
retsub

// round_tripper
roundtripper_1:
store 2
load 2
callsub tuplecomplement_0
store 4
load 4
callsub tuplecomplement_0
store 5
load 2
load 4
concat
load 5
concat
store 3
load 3
retsub

// numerical_comp
numericalcomp_2:
store 9
int 18446744073709551615
load 9
-
store 10
load 10
retsub


================================================
FILE: tests/integration/teal/roundtrip/app_roundtrip_(uint64)_v8.teal
================================================
#pragma version 8
txna ApplicationArgs 0
store 1
load 1
callsub roundtripper_1
store 0
byte 0x151f7c75
load 0
concat
log
int 1
return

// tuple_complement
tuplecomplement_0:
proto 1 1
byte ""
int 0
dupn 2
byte ""
dup
frame_dig -1
btoi
frame_bury 1
frame_dig 1
callsub numericalcomp_2
frame_bury 1
frame_dig 1
itob
frame_bury 0
retsub

// round_tripper
roundtripper_1:
proto 1 1
byte ""
dupn 2
int 0
dup
byte ""
dup
frame_dig -1
callsub tuplecomplement_0
frame_bury 1
frame_dig 1
callsub tuplecomplement_0
frame_bury 2
frame_dig -1
frame_dig 1
concat
frame_dig 2
concat
frame_bury 0
retsub

// numerical_comp
numericalcomp_2:
proto 1 1
int 0
int 18446744073709551615
frame_dig -1
-
frame_bury 0
retsub


================================================
FILE: tests/integration/teal/roundtrip/app_roundtrip_(uint64,uint32,uint16)_v6.teal
================================================
#pragma version 6
txna ApplicationArgs 0
store 1
load 1
callsub roundtripper_1
store 0
byte 0x151f7c75
load 0
concat
log
int 1
return

// tuple_complement
tuplecomplement_0:
store 6
load 6
int 0
extract_uint64
store 8
load 6
int 8
extract_uint32
store 9
load 6
int 12
extract_uint16
store 10
load 8
callsub numericalcomp_2
store 8
load 9
callsub numericalcomp_3
store 9
load 10
callsub numericalcomp_4
store 10
load 8
itob
load 9
itob
extract 4 0
concat
load 10
itob
extract 6 0
concat
store 7
load 7
retsub

// round_tripper
roundtripper_1:
store 2
load 2
callsub tuplecomplement_0
store 4
load 4
callsub tuplecomplement_0
store 5
load 2
load 4
concat
load 5
concat
store 3
load 3
retsub

// numerical_comp
numericalcomp_2:
store 11
int 18446744073709551615
load 11
-
store 12
load 12
retsub

// numerical_comp
numericalcomp_3:
store 13
int 4294967295
load 13
-
store 14
load 14
int 4294967296
<
assert
load 14
retsub

// numerical_comp
numericalcomp_4:
store 15
int 65535
load 15
-
store 16
load 16
int 65536
<
assert
load 16
retsub


================================================
FILE: tests/integration/teal/roundtrip/app_roundtrip_(uint64,uint32,uint16)_v8.teal
================================================
#pragma version 8
txna ApplicationArgs 0
store 1
load 1
callsub roundtripper_1
store 0
byte 0x151f7c75
load 0
concat
log
int 1
return

// tuple_complement
tuplecomplement_0:
proto 1 1
byte ""
int 0
dupn 4
byte ""
dup
frame_dig -1
int 0
extract_uint64
frame_bury 1
frame_dig -1
int 8
extract_uint32
frame_bury 2
frame_dig -1
int 12
extract_uint16
frame_bury 3
frame_dig 1
callsub numericalcomp_2
frame_bury 1
frame_dig 2
callsub numericalcomp_3
frame_bury 2
frame_dig 3
callsub numericalcomp_4
frame_bury 3
frame_dig 1
itob
frame_dig 2
itob
extract 4 0
concat
frame_dig 3
itob
extract 6 0
concat
frame_bury 0
retsub

// round_tripper
roundtripper_1:
proto 1 1
byte ""
dupn 2
int 0
dup
byte ""
dup
frame_dig -1
callsub tuplecomplement_0
frame_bury 1
frame_dig 1
callsub tuplecomplement_0
frame_bury 2
frame_dig -1
frame_dig 1
concat
frame_dig 2
concat
frame_bury 0
retsub

// numerical_comp
numericalcomp_2:
proto 1 1
int 0
int 18446744073709551615
frame_dig -1
-
frame_bury 0
retsub

// numerical_comp
numericalcomp_3:
proto 1 1
int 0
int 4294967295
frame_dig -1
-
frame_bury 0
frame_dig 0
int 4294967296
<
assert
retsub

// numerical_comp
numericalcomp_4:
proto 1 1
int 0
int 65535
frame_dig -1
-
frame_bury 0
frame_dig 0
int 65536
<
assert
retsub


================================================
FILE: tests/integration/teal/roundtrip/app_roundtrip_(uint8)_v6.teal
================================================
#pragma version 6
txna ApplicationArgs 0
store 1
load 1
callsub roundtripper_1
store 0
byte 0x151f7c75
load 0
concat
log
int 1
return

// tuple_complement
tuplecomplement_0:
store 6
load 6
int 0
getbyte
store 8
load 8
callsub numericalcomp_2
store 8
byte 0x00
int 0
load 8
setbyte
store 7
load 7
retsub

// round_tripper
roundtripper_1:
store 2
load 2
callsub tuplecomplement_0
store 4
load 4
callsub tuplecomplement_0
store 5
load 2
load 4
concat
load 5
concat
store 3
load 3
retsub

// numerical_comp
numericalcomp_2:
store 9
int 255
load 9
-
store 10
load 10
int 256
<
assert
load 10
retsub


================================================
FILE: tests/integration/teal/roundtrip/app_roundtrip_(uint8)_v8.teal
================================================
#pragma version 8
txna ApplicationArgs 0
store 1
load 1
callsub roundtripper_1
store 0
byte 0x151f7c75
load 0
concat
log
int 1
return

// tuple_complement
tuplecomplement_0:
proto 1 1
byte ""
int 0
dupn 2
byte ""
dup
frame_dig -1
int 0
getbyte
frame_bury 1
frame_dig 1
callsub numericalcomp_2
frame_bury 1
byte 0x00
int 0
frame_dig 1
setbyte
frame_bury 0
retsub

// round_tripper
roundtripper_1:
proto 1 1
byte ""
dupn 2
int 0
dup
byte ""
dup
frame_dig -1
callsub tuplecomplement_0
frame_bury 1
frame_dig 1
callsub tuplecomplement_0
frame_bury 2
frame_dig -1
frame_dig 1
concat
frame_dig 2
concat
frame_bury 0
retsub

// numerical_comp
numericalcomp_2:
proto 1 1
int 0
int 255
frame_dig -1
-
frame_bury 0
frame_dig 0
int 256
<
assert
retsub


================================================
FILE: tests/integration/teal/roundtrip/app_roundtrip_(uint8,byte,bool)_v6.teal
================================================
#pragma version 6
txna ApplicationArgs 0
store 1
load 1
callsub roundtripper_1
store 0
byte 0x151f7c75
load 0
concat
log
int 1
return

// tuple_complement
tuplecomplement_0:
store 6
load 6
int 0
getbyte
store 8
load 6
int 1
getbyte
store 9
load 6
int 16
getbit
store 10
load 8
callsub numericalcomp_2
store 8
load 9
callsub numericalcomp_3
store 9
load 10
callsub boolcomp_4
store 10
byte 0x00
int 0
load 8
setbyte
byte 0x00
int 0
load 9
setbyte
concat
byte 0x00
int 0
load 10
setbit
concat
store 7
load 7
retsub

// round_tripper
roundtripper_1:
store 2
load 2
callsub tuplecomplement_0
store 4
load 4
callsub tuplecomplement_0
store 5
load 2
load 4
concat
load 5
concat
store 3
load 3
retsub

// numerical_comp
numericalcomp_2:
store 11
int 255
load 11
-
store 12
load 12
int 256
<
assert
load 12
retsub

// numerical_comp
numericalcomp_3:
store 13
int 255
load 13
-
store 14
load 14
int 256
<
assert
load 14
retsub

// bool_comp
boolcomp_4:
store 15
load 15
!
!
!
store 16
load 16
retsub


================================================
FILE: tests/integration/teal/roundtrip/app_roundtrip_(uint8,byte,bool)_v8.teal
================================================
#pragma version 8
txna ApplicationArgs 0
store 1
load 1
callsub roundtripper_1
store 0
byte 0x151f7c75
load 0
concat
log
int 1
return

// tuple_complement
tuplecomplement_0:
proto 1 1
byte ""
int 0
dupn 4
byte ""
dup
frame_dig -1
int 0
getbyte
frame_bury 1
frame_dig -1
int 1
getbyte
frame_bury 2
frame_dig -1
int 16
getbit
frame_bury 3
frame_dig 1
callsub numericalcomp_2
frame_bury 1
frame_dig 2
callsub numericalcomp_3
frame_bury 2
frame_dig 3
callsub boolcomp_4
frame_bury 3
byte 0x00
int 0
frame_dig 1
setbyte
byte 0x00
int 0
frame_dig 2
setbyte
concat
byte 0x00
int 0
frame_dig 3
setbit
concat
frame_bury 0
retsub

// round_tripper
roundtripper_1:
proto 1 1
byte ""
dupn 2
int 0
dup
byte ""
dup
frame_dig -1
callsub tuplecomplement_0
frame_bury 1
frame_dig 1
callsub tuplecomplement_0
frame_bury 2
frame_dig -1
frame_dig 1
concat
frame_dig 2
concat
frame_bury 0
retsub

// numerical_comp
numericalcomp_2:
proto 1 1
int 0
int 255
frame_dig -1
-
frame_bury 0
frame_dig 0
int 256
<
assert
retsub

// numerical_comp
numericalcomp_3:
proto 1 1
int 0
int 255
frame_dig -1
-
frame_bury 0
frame_dig 0
int 256
<
assert
retsub

// bool_comp
boolcomp_4:
proto 1 1
int 0
frame_dig -1
!
!
!
frame_bury 0
retsub


================================================
FILE: tests/integration/teal/roundtrip/app_roundtrip_address[]_10_v6.teal
================================================
#pragma version 6
txna ApplicationArgs 0
store 1
load 1
callsub roundtripper_3
store 0
byte 0x151f7c75
load 0
concat
log
int 1
return

// numerical_comp
numericalcomp_0:
store 52
int 255
load 52
-
store 53
load 53
int 256
<
assert
load 53
retsub

// array_complement
arraycomplement_1:
store 18
load 18
int 1
int 0
*
getbyte
store 20
load 18
int 1
int 1
*
getbyte
store 21
load 18
int 1
int 2
*
getbyte
store 22
load 18
int 1
int 3
*
getbyte
store 23
load 18
int 1
int 4
*
getbyte
store 24
load 18
int 1
int 5
*
getbyte
store 25
load 18
int 1
int 6
*
getbyte
store 26
load 18
int 1
int 7
*
getbyte
store 27
load 18
int 1
int 8
*
getbyte
store 28
load 18
int 1
int 9
*
getbyte
store 29
load 18
int 1
int 10
*
getbyte
store 30
load 18
int 1
int 11
*
getbyte
store 31
load 18
int 1
int 12
*
getbyte
store 32
load 18
int 1
int 13
*
getbyte
store 33
load 18
int 1
int 14
*
getbyte
store 34
load 18
int 1
int 15
*
getbyte
store 35
load 18
int 1
int 16
*
getbyte
store 36
load 18
int 1
int 17
*
getbyte
store 37
load 18
int 1
int 18
*
getbyte
store 38
load 18
int 1
int 19
*
getbyte
store 39
load 18
int 1
int 20
*
getbyte
store 40
load 18
int 1
int 21
*
getbyte
store 41
load 18
int 1
int 22
*
getbyte
store 42
load 18
int 1
int 23
*
getbyte
store 43
load 18
int 1
int 24
*
getbyte
store 44
load 18
int 1
int 25
*
getbyte
store 45
load 18
int 1
int 26
*
getbyte
store 46
load 18
int 1
int 27
*
getbyte
store 47
load 18
int 1
int 28
*
getbyte
store 48
load 18
int 1
int 29
*
getbyte
store 49
load 18
int 1
int 30
*
getbyte
store 50
load 18
int 1
int 31
*
getbyte
store 51
load 20
callsub numericalcomp_0
store 20
load 21
callsub numericalcomp_0
store 21
load 22
callsub numericalcomp_0
store 22
load 23
callsub numericalcomp_0
store 23
load 24
callsub numericalcomp_0
store 24
load 25
callsub numericalcomp_0
store 25
load 26
callsub numericalcomp_0
store 26
load 27
callsub numericalcomp_0
store 27
load 28
callsub numericalcomp_0
store 28
load 29
callsub numericalcomp_0
store 29
load 30
callsub numericalcomp_0
store 30
load 31
callsub numericalcomp_0
store 31
load 32
callsub numericalcomp_0
store 32
load 33
callsub numericalcomp_0
store 33
load 34
callsub numericalcomp_0
store 34
load 35
callsub numericalcomp_0
store 35
load 36
callsub numericalcomp_0
store 36
load 37
callsub numericalcomp_0
store 37
load 38
callsub numericalcomp_0
store 38
load 39
callsub numericalcomp_0
store 39
load 40
callsub numericalcomp_0
store 40
load 41
callsub numericalcomp_0
store 41
load 42
callsub numericalcomp_0
store 42
load 43
callsub numericalcomp_0
store 43
load 44
callsub numericalcomp_0
store 44
load 45
callsub numericalcomp_0
store 45
load 46
callsub numericalcomp_0
store 46
load 47
callsub numericalcomp_0
store 47
load 48
callsub numericalcomp_0
store 48
load 49
callsub numericalcomp_0
store 49
load 50
callsub numericalcomp_0
store 50
load 51
callsub numericalcomp_0
store 51
byte 0x00
int 0
load 20
setbyte
byte 0x00
int 0
load 21
setbyte
concat
byte 0x00
int 0
load 22
setbyte
concat
byte 0x00
int 0
load 23
setbyte
concat
byte 0x00
int 0
load 24
setbyte
concat
byte 0x00
int 0
load 25
setbyte
concat
byte 0x00
int 0
load 26
setbyte
concat
byte 0x00
int 0
load 27
setbyte
concat
byte 0x00
int 0
load 28
setbyte
concat
byte 0x00
int 0
load 29
setbyte
concat
byte 0x00
int 0
load 30
setbyte
concat
byte 0x00
int 0
load 31
setbyte
concat
byte 0x00
int 0
load 32
setbyte
concat
byte 0x00
int 0
load 33
setbyte
concat
byte 0x00
int 0
load 34
setbyte
concat
byte 0x00
int 0
load 35
setbyte
concat
byte 0x00
int 0
load 36
setbyte
concat
byte 0x00
int 0
load 37
setbyte
concat
byte 0x00
int 0
load 38
setbyte
concat
byte 0x00
int 0
load 39
setbyte
concat
byte 0x00
int 0
load 40
setbyte
concat
byte 0x00
int 0
load 41
setbyte
concat
byte 0x00
int 0
load 42
setbyte
concat
byte 0x00
int 0
load 43
setbyte
concat
byte 0x00
int 0
load 44
setbyte
concat
byte 0x00
int 0
load 45
setbyte
concat
byte 0x00
int 0
load 46
setbyte
concat
byte 0x00
int 0
load 47
setbyte
concat
byte 0x00
int 0
load 48
setbyte
concat
byte 0x00
int 0
load 49
setbyte
concat
byte 0x00
int 0
load 50
setbyte
concat
byte 0x00
int 0
load 51
setbyte
concat
store 19
load 19
retsub

// array_complement
arraycomplement_2:
store 6
load 6
int 32
int 0
*
int 2
+
int 32
extract3
store 8
load 6
int 32
int 1
*
int 2
+
int 32
extract3
store 9
load 6
int 32
int 2
*
int 2
+
int 32
extract3
store 10
load 6
int 32
int 3
*
int 2
+
int 32
extract3
store 11
load 6
int 32
int 4
*
int 2
+
int 32
extract3
store 12
load 6
int 32
int 5
*
int 2
+
int 32
extract3
store 13
load 6
int 32
int 6
*
int 2
+
int 32
extract3
store 14
load 6
int 32
int 7
*
int 2
+
int 32
extract3
store 15
load 6
int 32
int 8
*
int 2
+
int 32
extract3
store 16
load 6
int 32
int 9
*
int 2
+
int 32
extract3
store 17
load 8
callsub arraycomplement_1
store 8
load 9
callsub arraycomplement_1
store 9
load 10
callsub arraycomplement_1
store 10
load 11
callsub arraycomplement_1
store 11
load 12
callsub arraycomplement_1
store 12
load 13
callsub arraycomplement_1
store 13
load 14
callsub arraycomplement_1
store 14
load 15
callsub arraycomplement_1
store 15
load 16
callsub arraycomplement_1
store 16
load 17
callsub arraycomplement_1
store 17
int 10
store 54
load 54
itob
extract 6 0
load 8
load 9
concat
load 10
concat
load 11
concat
load 12
concat
load 13
concat
load 14
concat
load 15
concat
load 16
concat
load 17
concat
concat
store 7
load 7
retsub

// round_tripper
roundtripper_3:
store 2
load 2
callsub arraycomplement_2
store 4
load 4
callsub arraycomplement_2
store 5
load 2
store 58
load 58
store 57
int 6
store 55
load 55
load 58
len
+
store 56
load 56
int 65536
<
assert
load 55
itob
extract 6 0
load 4
store 58
load 57
load 58
concat
store 57
load 56
store 55
load 55
load 58
len
+
store 56
load 56
int 65536
<
assert
load 55
itob
extract 6 0
concat
load 5
store 58
load 57
load 58
concat
store 57
load 56
store 55
load 55
itob
extract 6 0
concat
load 57
concat
store 3
load 3
retsub


================================================
FILE: tests/integration/teal/roundtrip/app_roundtrip_address[]_10_v8.teal
================================================
#pragma version 8
txna ApplicationArgs 0
store 1
load 1
callsub roundtripper_3
store 0
byte 0x151f7c75
load 0
concat
log
int 1
return

// numerical_comp
numericalcomp_0:
proto 1 1
int 0
int 255
frame_dig -1
-
frame_bury 0
frame_dig 0
int 256
<
assert
retsub

// array_complement
arraycomplement_1:
proto 1 1
byte ""
int 0
dupn 33
byte ""
dup
frame_dig -1
int 1
int 0
*
getbyte
frame_bury 1
frame_dig -1
int 1
int 1
*
getbyte
frame_bury 2
frame_dig -1
int 1
int 2
*
getbyte
frame_bury 3
frame_dig -1
int 1
int 3
*
getbyte
frame_bury 4
frame_dig -1
int 1
int 4
*
getbyte
frame_bury 5
frame_dig -1
int 1
int 5
*
getbyte
frame_bury 6
frame_dig -1
int 1
int 6
*
getbyte
frame_bury 7
frame_dig -1
int 1
int 7
*
getbyte
frame_bury 8
frame_dig -1
int 1
int 8
*
getbyte
frame_bury 9
frame_dig -1
int 1
int 9
*
getbyte
frame_bury 10
frame_dig -1
int 1
int 10
*
getbyte
frame_bury 11
frame_dig -1
int 1
int 11
*
getbyte
frame_bury 12
frame_dig -1
int 1
int 12
*
getbyte
frame_bury 13
frame_dig -1
int 1
int 13
*
getbyte
frame_bury 14
frame_dig -1
int 1
int 14
*
getbyte
frame_bury 15
frame_dig -1
int 1
int 15
*
getbyte
frame_bury 16
frame_dig -1
int 1
int 16
*
getbyte
frame_bury 17
frame_dig -1
int 1
int 17
*
getbyte
frame_bury 18
frame_dig -1
int 1
int 18
*
getbyte
frame_bury 19
frame_dig -1
int 1
int 19
*
getbyte
frame_bury 20
frame_dig -1
int 1
int 20
*
getbyte
frame_bury 21
frame_dig -1
int 1
int 21
*
getbyte
frame_bury 22
frame_dig -1
int 1
int 22
*
getbyte
frame_bury 23
frame_dig -1
int 1
int 23
*
getbyte
frame_bury 24
frame_dig -1
int 1
int 24
*
getbyte
frame_bury 25
frame_dig -1
int 1
int 25
*
getbyte
frame_bury 26
frame_dig -1
int 1
int 26
*
getbyte
frame_bury 27
frame_dig -1
int 1
int 27
*
getbyte
frame_bury 28
frame_dig -1
int 1
int 28
*
getbyte
frame_bury 29
frame_dig -1
int 1
int 29
*
getbyte
frame_bury 30
frame_dig -1
int 1
int 30
*
getbyte
frame_bury 31
frame_dig -1
int 1
int 31
*
getbyte
frame_bury 32
frame_dig 1
callsub numericalcomp_0
frame_bury 1
frame_dig 2
callsub numericalcomp_0
frame_bury 2
frame_dig 3
callsub numericalcomp_0
frame_bury 3
frame_dig 4
callsub numericalcomp_0
frame_bury 4
frame_dig 5
callsub numericalcomp_0
frame_bury 5
frame_dig 6
callsub numericalcomp_0
frame_bury 6
frame_dig 7
callsub numericalcomp_0
frame_bury 7
frame_dig 8
callsub numericalcomp_0
frame_bury 8
frame_dig 9
callsub numericalcomp_0
frame_bury 9
frame_dig 10
callsub numericalcomp_0
frame_bury 10
frame_dig 11
callsub numericalcomp_0
frame_bury 11
frame_dig 12
callsub numericalcomp_0
frame_bury 12
frame_dig 13
callsub numericalcomp_0
frame_bury 13
frame_dig 14
callsub numericalcomp_0
frame_bury 14
frame_dig 15
callsub numericalcomp_0
frame_bury 15
frame_dig 16
callsub numericalcomp_0
frame_bury 16
frame_dig 17
callsub numericalcomp_0
frame_bury 17
frame_dig 18
callsub numericalcomp_0
frame_bury 18
frame_dig 19
callsub numericalcomp_0
frame_bury 19
frame_dig 20
callsub numericalcomp_0
frame_bury 20
frame_dig 21
callsub numericalcomp_0
frame_bury 21
frame_dig 22
callsub numericalcomp_0
frame_bury 22
frame_dig 23
callsub numericalcomp_0
frame_bury 23
frame_dig 24
callsub numericalcomp_0
frame_bury 24
frame_dig 25
callsub numericalcomp_0
frame_bury 25
frame_dig 26
callsub numericalcomp_0
frame_bury 26
frame_dig 27
callsub numericalcomp_0
frame_bury 27
frame_dig 28
callsub numericalcomp_0
frame_bury 28
frame_dig 29
callsub numericalcomp_0
frame_bury 29
frame_dig 30
callsub numericalcomp_0
frame_bury 30
frame_dig 31
callsub numericalcomp_0
frame_bury 31
frame_dig 32
callsub numericalcomp_0
frame_bury 32
byte 0x00
int 0
frame_dig 1
setbyte
byte 0x00
int 0
frame_dig 2
setbyte
concat
byte 0x00
int 0
frame_dig 3
setbyte
concat
byte 0x00
int 0
frame_dig 4
setbyte
concat
byte 0x00
int 0
frame_dig 5
setbyte
concat
byte 0x00
int 0
frame_dig 6
setbyte
concat
byte 0x00
int 0
frame_dig 7
setbyte
concat
byte 0x00
int 0
frame_dig 8
setbyte
concat
byte 0x00
int 0
frame_dig 9
setbyte
concat
byte 0x00
int 0
frame_dig 10
setbyte
concat
byte 0x00
int 0
frame_dig 11
setbyte
concat
byte 0x00
int 0
frame_dig 12
setbyte
concat
byte 0x00
int 0
frame_dig 13
setbyte
concat
byte 0x00
int 0
frame_dig 14
setbyte
concat
byte 0x00
int 0
frame_dig 15
setbyte
concat
byte 0x00
int 0
frame_dig 16
setbyte
concat
byte 0x00
int 0
frame_dig 17
setbyte
concat
byte 0x00
int 0
frame_dig 18
setbyte
concat
byte 0x00
int 0
frame_dig 19
setbyte
concat
byte 0x00
int 0
frame_dig 20
setbyte
concat
byte 0x00
int 0
frame_dig 21
setbyte
concat
byte 0x00
int 0
frame_dig 22
setbyte
concat
byte 0x00
int 0
frame_dig 23
setbyte
concat
byte 0x00
int 0
frame_dig 24
setbyte
concat
byte 0x00
int 0
frame_dig 25
setbyte
concat
byte 0x00
int 0
frame_dig 26
setbyte
concat
byte 0x00
int 0
frame_dig 27
setbyte
concat
byte 0x00
int 0
frame_dig 28
setbyte
concat
byte 0x00
int 0
frame_dig 29
setbyte
concat
byte 0x00
int 0
frame_dig 30
setbyte
concat
byte 0x00
int 0
frame_dig 31
setbyte
concat
byte 0x00
int 0
frame_dig 32
setbyte
concat
frame_bury 0
retsub

// array_complement
arraycomplement_2:
proto 1 1
byte ""
dupn 10
int 0
dupn 11
byte ""
dup
int 0
frame_dig -1
int 32
int 0
*
int 2
+
int 32
extract3
frame_bury 1
frame_dig -1
int 32
int 1
*
int 2
+
int 32
extract3
frame_bury 2
frame_dig -1
int 32
int 2
*
int 2
+
int 32
extract3
frame_bury 3
frame_dig -1
int 32
int 3
*
int 2
+
int 32
extract3
frame_bury 4
frame_dig -1
int 32
int 4
*
int 2
+
int 32
extract3
frame_bury 5
frame_dig -1
int 32
int 5
*
int 2
+
int 32
extract3
frame_bury 6
frame_dig -1
int 32
int 6
*
int 2
+
int 32
extract3
frame_bury 7
frame_dig -1
int 32
int 7
*
int 2
+
int 32
extract3
frame_bury 8
frame_dig -1
int 32
int 8
*
int 2
+
int 32
extract3
frame_bury 9
frame_dig -1
int 32
int 9
*
int 2
+
int 32
extract3
frame_bury 10
frame_dig 1
callsub arraycomplement_1
frame_bury 1
frame_dig 2
callsub arraycomplement_1
frame_bury 2
frame_dig 3
callsub arraycomplement_1
frame_bury 3
frame_dig 4
callsub arraycomplement_1
frame_bury 4
frame_dig 5
callsub arraycomplement_1
frame_bury 5
frame_dig 6
callsub arraycomplement_1
frame_bury 6
frame_dig 7
callsub arraycomplement_1
frame_bury 7
frame_dig 8
callsub arraycomplement_1
frame_bury 8
frame_dig 9
callsub arraycomplement_1
frame_bury 9
frame_dig 10
callsub arraycomplement_1
frame_bury 10
int 10
frame_bury 25
frame_dig 25
itob
extract 6 0
frame_dig 1
frame_dig 2
concat
frame_dig 3
concat
frame_dig 4
concat
frame_dig 5
concat
frame_dig 6
concat
frame_dig 7
concat
frame_dig 8
concat
frame_dig 9
concat
frame_dig 10
concat
concat
frame_bury 0
retsub

// round_tripper
roundtripper_3:
proto 1 1
byte ""
dupn 2
int 0
dup
byte ""
dup
frame_dig -1
callsub arraycomplement_2
frame_bury 1
frame_dig 1
callsub arraycomplement_2
frame_bury 2
frame_dig -1
frame_bury 6
frame_dig 6
frame_bury 5
int 6
frame_bury 3
frame_dig 3
frame_dig 6
len
+
frame_bury 4
frame_dig 4
int 65536
<
assert
frame_dig 3
itob
extract 6 0
frame_dig 1
frame_bury 6
frame_dig 5
frame_dig 6
concat
frame_bury 5
frame_dig 4
frame_bury 3
frame_dig 3
frame_dig 6
len
+
frame_bury 4
frame_dig 4
int 65536
<
assert
frame_dig 3
itob
extract 6 0
concat
frame_dig 2
frame_bury 6
frame_dig 5
frame_dig 6
concat
frame_bury 5
frame_dig 4
frame_bury 3
frame_dig 3
itob
extract 6 0
concat
frame_dig 5
concat
frame_bury 0
retsub


================================================
FILE: tests/integration/teal/roundtrip/app_roundtrip_address_v6.teal
================================================
#pragma version 6
txna ApplicationArgs 0
store 1
load 1
callsub roundtripper_2
store 0
byte 0x151f7c75
load 0
concat
log
int 1
return

// numerical_comp
numericalcomp_0:
store 40
int 255
load 40
-
store 41
load 41
int 256
<
assert
load 41
retsub

// array_complement
arraycomplement_1:
store 6
load 6
int 1
int 0
*
getbyte
store 8
load 6
int 1
int 1
*
getbyte
store 9
load 6
int 1
int 2
*
getbyte
store 10
load 6
int 1
int 3
*
getbyte
store 11
load 6
int 1
int 4
*
getbyte
store 12
load 6
int 1
int 5
*
getbyte
store 13
load 6
int 1
int 6
*
getbyte
store 14
load 6
int 1
int 7
*
getbyte
store 15
load 6
int 1
int 8
*
getbyte
store 16
load 6
int 1
int 9
*
getbyte
store 17
load 6
int 1
int 10
*
getbyte
store 18
load 6
int 1
int 11
*
getbyte
store 19
load 6
int 1
int 12
*
getbyte
store 20
load 6
int 1
int 13
*
getbyte
store 21
load 6
int 1
int 14
*
getbyte
store 22
load 6
int 1
int 15
*
getbyte
store 23
load 6
int 1
int 16
*
getbyte
store 24
load 6
int 1
int 17
*
getbyte
store 25
load 6
int 1
int 18
*
getbyte
store 26
load 6
int 1
int 19
*
getbyte
store 27
load 6
int 1
int 20
*
getbyte
store 28
load 6
int 1
int 21
*
getbyte
store 29
load 6
int 1
int 22
*
getbyte
store 30
load 6
int 1
int 23
*
getbyte
store 31
load 6
int 1
int 24
*
getbyte
store 32
load 6
int 1
int 25
*
getbyte
store 33
load 6
int 1
int 26
*
getbyte
store 34
load 6
int 1
int 27
*
getbyte
store 35
load 6
int 1
int 28
*
getbyte
store 36
load 6
int 1
int 29
*
getbyte
store 37
load 6
int 1
int 30
*
getbyte
store 38
load 6
int 1
int 31
*
getbyte
store 39
load 8
callsub numericalcomp_0
store 8
load 9
callsub numericalcomp_0
store 9
load 10
callsub numericalcomp_0
store 10
load 11
callsub numericalcomp_0
store 11
load 12
callsub numericalcomp_0
store 12
load 13
callsub numericalcomp_0
store 13
load 14
callsub numericalcomp_0
store 14
load 15
callsub numericalcomp_0
store 15
load 16
callsub numericalcomp_0
store 16
load 17
callsub numericalcomp_0
store 17
load 18
callsub numericalcomp_0
store 18
load 19
callsub numericalcomp_0
store 19
load 20
callsub numericalcomp_0
store 20
load 21
callsub numericalcomp_0
store 21
load 22
callsub numericalcomp_0
store 22
load 23
callsub numericalcomp_0
store 23
load 24
callsub numericalcomp_0
store 24
load 25
callsub numericalcomp_0
store 25
load 26
callsub numericalcomp_0
store 26
load 27
callsub numericalcomp_0
store 27
load 28
callsub numericalcomp_0
store 28
load 29
callsub numericalcomp_0
store 29
load 30
callsub numericalcomp_0
store 30
load 31
callsub numericalcomp_0
store 31
load 32
callsub numericalcomp_0
store 32
load 33
callsub numericalcomp_0
store 33
load 34
callsub numericalcomp_0
store 34
load 35
callsub numericalcomp_0
store 35
load 36
callsub numericalcomp_0
store 36
load 37
callsub numericalcomp_0
store 37
load 38
callsub numericalcomp_0
store 38
load 39
callsub numericalcomp_0
store 39
byte 0x00
int 0
load 8
setbyte
byte 0x00
int 0
load 9
setbyte
concat
byte 0x00
int 0
load 10
setbyte
concat
byte 0x00
int 0
load 11
setbyte
concat
byte 0x00
int 0
load 12
setbyte
concat
byte 0x00
int 0
load 13
setbyte
concat
byte 0x00
int 0
load 14
setbyte
concat
byte 0x00
int 0
load 15
setbyte
concat
byte 0x00
int 0
load 16
setbyte
concat
byte 0x00
int 0
load 17
setbyte
concat
byte 0x00
int 0
load 18
setbyte
concat
byte 0x00
int 0
load 19
setbyte
concat
byte 0x00
int 0
load 20
setbyte
concat
byte 0x00
int 0
load 21
setbyte
concat
byte 0x00
int 0
load 22
setbyte
concat
byte 0x00
int 0
load 23
setbyte
concat
byte 0x00
int 0
load 24
setbyte
concat
byte 0x00
int 0
load 25
setbyte
concat
byte 0x00
int 0
load 26
setbyte
concat
byte 0x00
int 0
load 27
setbyte
concat
byte 0x00
int 0
load 28
setbyte
concat
byte 0x00
int 0
load 29
setbyte
concat
byte 0x00
int 0
load 30
setbyte
concat
byte 0x00
int 0
load 31
setbyte
concat
byte 0x00
int 0
load 32
setbyte
concat
byte 0x00
int 0
load 33
setbyte
concat
byte 0x00
int 0
load 34
setbyte
concat
byte 0x00
int 0
load 35
setbyte
concat
byte 0x00
int 0
load 36
setbyte
concat
byte 0x00
int 0
load 37
setbyte
concat
byte 0x00
int 0
load 38
setbyte
concat
byte 0x00
int 0
load 39
setbyte
concat
store 7
load 7
retsub

// round_tripper
roundtripper_2:
store 2
load 2
callsub arraycomplement_1
store 4
load 4
callsub arraycomplement_1
store 5
load 2
load 4
concat
load 5
concat
store 3
load 3
retsub


================================================
FILE: tests/integration/teal/roundtrip/app_roundtrip_address_v8.teal
================================================
#pragma version 8
txna ApplicationArgs 0
store 1
load 1
callsub roundtripper_2
store 0
byte 0x151f7c75
load 0
concat
log
int 1
return

// numerical_comp
numericalcomp_0:
proto 1 1
int 0
int 255
frame_dig -1
-
frame_bury 0
frame_dig 0
int 256
<
assert
retsub

// array_complement
arraycomplement_1:
proto 1 1
byte ""
int 0
dupn 33
byte ""
dup
frame_dig -1
int 1
int 0
*
getbyte
frame_bury 1
frame_dig -1
int 1
int 1
*
getbyte
frame_bury 2
frame_dig -1
int 1
int 2
*
getbyte
frame_bury 3
frame_dig -1
int 1
int 3
*
getbyte
frame_bury 4
frame_dig -1
int 1
int 4
*
getbyte
frame_bury 5
frame_dig -1
int 1
int 5
*
getbyte
frame_bury 6
frame_dig -1
int 1
int 6
*
getbyte
frame_bury 7
frame_dig -1
int 1
int 7
*
getbyte
frame_bury 8
frame_dig -1
int 1
int 8
*
getbyte
frame_bury 9
frame_dig -1
int 1
int 9
*
getbyte
frame_bury 10
frame_dig -1
int 1
int 10
*
getbyte
frame_bury 11
frame_dig -1
int 1
int 11
*
getbyte
frame_bury 12
frame_dig -1
int 1
int 12
*
getbyte
frame_bury 13
frame_dig -1
int 1
int 13
*
getbyte
frame_bury 14
frame_dig -1
int 1
int 14
*
getbyte
frame_bury 15
frame_dig -1
int 1
int 15
*
getbyte
frame_bury 16
frame_dig -1
int 1
int 16
*
getbyte
frame_bury 17
frame_dig -1
int 1
int 17
*
getbyte
frame_bury 18
frame_dig -1
int 1
int 18
*
getbyte
frame_bury 19
frame_dig -1
int 1
int 19
*
getbyte
frame_bury 20
frame_dig -1
int 1
int 20
*
getbyte
frame_bury 21
frame_dig -1
int 1
int 21
*
getbyte
frame_bury 22
frame_dig -1
int 1
int 22
*
getbyte
frame_bury 23
frame_dig -1
int 1
int 23
*
getbyte
frame_bury 24
frame_dig -1
int 1
int 24
*
getbyte
frame_bury 25
frame_dig -1
int 1
int 25
*
getbyte
frame_bury 26
frame_dig -1
int 1
int 26
*
getbyte
frame_bury 27
frame_dig -1
int 1
int 27
*
getbyte
frame_bury 28
frame_dig -1
int 1
int 28
*
getbyte
frame_bury 29
frame_dig -1
int 1
int 29
*
getbyte
frame_bury 30
frame_dig -1
int 1
int 30
*
getbyte
frame_bury 31
frame_dig -1
int 1
int 31
*
getbyte
frame_bury 32
frame_dig 1
callsub numericalcomp_0
frame_bury 1
frame_dig 2
callsub numericalcomp_0
frame_bury 2
frame_dig 3
callsub numericalcomp_0
frame_bury 3
frame_dig 4
callsub numericalcomp_0
frame_bury 4
frame_dig 5
callsub numericalcomp_0
frame_bury 5
frame_dig 6
callsub numericalcomp_0
frame_bury 6
frame_dig 7
callsub numericalcomp_0
frame_bury 7
frame_dig 8
callsub numericalcomp_0
frame_bury 8
frame_dig 9
callsub numericalcomp_0
frame_bury 9
frame_dig 10
callsub numericalcomp_0
frame_bury 10
frame_dig 11
callsub numericalcomp_0
frame_bury 11
frame_dig 12
callsub numericalcomp_0
frame_bury 12
frame_dig 13
callsub numericalcomp_0
frame_bury 13
frame_dig 14
callsub numericalcomp_0
frame_bury 14
frame_dig 15
callsub numericalcomp_0
frame_bury 15
frame_dig 16
callsub numericalcomp_0
frame_bury 16
frame_dig 17
callsub numericalcomp_0
frame_bury 17
frame_dig 18
callsub numericalcomp_0
frame_bury 18
frame_dig 19
callsub numericalcomp_0
frame_bury 19
frame_dig 20
callsub numericalcomp_0
frame_bury 20
frame_dig 21
callsub numericalcomp_0
frame_bury 21
frame_dig 22
callsub numericalcomp_0
frame_bury 22
frame_dig 23
callsub numericalcomp_0
frame_bury 23
frame_dig 24
callsub numericalcomp_0
frame_bury 24
frame_dig 25
callsub numericalcomp_0
frame_bury 25
frame_dig 26
callsub numericalcomp_0
frame_bury 26
frame_dig 27
callsub numericalcomp_0
frame_bury 27
frame_dig 28
callsub numericalcomp_0
frame_bury 28
frame_dig 29
callsub numericalcomp_0
frame_bury 29
frame_dig 30
callsub numericalcomp_0
frame_bury 30
frame_dig 31
callsub numericalcomp_0
frame_bury 31
frame_dig 32
callsub numericalcomp_0
frame_bury 32
byte 0x00
int 0
frame_dig 1
setbyte
byte 0x00
int 0
frame_dig 2
setbyte
concat
byte 0x00
int 0
frame_dig 3
setbyte
concat
byte 0x00
int 0
frame_dig 4
setbyte
concat
byte 0x00
int 0
frame_dig 5
setbyte
concat
byte 0x00
int 0
frame_dig 6
setbyte
concat
byte 0x00
int 0
frame_dig 7
setbyte
concat
byte 0x00
int 0
frame_dig 8
setbyte
concat
byte 0x00
int 0
frame_dig 9
setbyte
concat
byte 0x00
int 0
frame_dig 10
setbyte
concat
byte 0x00
int 0
frame_dig 11
setbyte
concat
byte 0x00
int 0
frame_dig 12
setbyte
concat
byte 0x00
int 0
frame_dig 13
setbyte
concat
byte 0x00
int 0
frame_dig 14
setbyte
concat
byte 0x00
int 0
frame_dig 15
setbyte
concat
byte 0x00
int 0
frame_dig 16
setbyte
concat
byte 0x00
int 0
frame_dig 17
setbyte
concat
byte 0x00
int 0
frame_dig 18
setbyte
concat
byte 0x00
int 0
frame_dig 19
setbyte
concat
byte 0x00
int 0
frame_dig 20
setbyte
concat
byte 0x00
int 0
frame_dig 21
setbyte
concat
byte 0x00
int 0
frame_dig 22
setbyte
concat
byte 0x00
int 0
frame_dig 23
setbyte
concat
byte 0x00
int 0
frame_dig 24
setbyte
concat
byte 0x00
int 0
frame_dig 25
setbyte
concat
byte 0x00
int 0
frame_dig 26
setbyte
concat
byte 0x00
int 0
frame_dig 27
setbyte
concat
byte 0x00
int 0
frame_dig 28
setbyte
concat
byte 0x00
int 0
frame_dig 29
setbyte
concat
byte 0x00
int 0
frame_dig 30
setbyte
concat
byte 0x00
int 0
frame_dig 31
setbyte
concat
byte 0x00
int 0
frame_dig 32
setbyte
concat
frame_bury 0
retsub

// round_tripper
roundtripper_2:
proto 1 1
byte ""
dupn 2
int 0
dup
byte ""
dup
frame_dig -1
callsub arraycomplement_1
frame_bury 1
frame_dig 1
callsub arraycomplement_1
frame_bury 2
frame_dig -1
frame_dig 1
concat
frame_dig 2
concat
frame_bury 0
retsub


================================================
FILE: tests/integration/teal/roundtrip/app_roundtrip_bool[1]_v6.teal
================================================
#pragma version 6
txna ApplicationArgs 0
store 1
load 1
callsub roundtripper_2
store 0
byte 0x151f7c75
load 0
concat
log
int 1
return

// bool_comp
boolcomp_0:
store 9
load 9
!
!
!
store 10
load 10
retsub

// array_complement
arraycomplement_1:
store 6
load 6
int 0
getbit
store 8
load 8
callsub boolcomp_0
store 8
byte 0x00
int 0
load 8
setbit
store 7
load 7
retsub

// round_tripper
roundtripper_2:
store 2
load 2
callsub arraycomplement_1
store 4
load 4
callsub arraycomplement_1
store 5
load 2
load 4
concat
load 5
concat
store 3
load 3
retsub


================================================
FILE: tests/integration/teal/roundtrip/app_roundtrip_bool[1]_v8.teal
================================================
#pragma version 8
txna ApplicationArgs 0
store 1
load 1
callsub roundtripper_2
store 0
byte 0x151f7c75
load 0
concat
log
int 1
return

// bool_comp
boolcomp_0:
proto 1 1
int 0
frame_dig -1
!
!
!
frame_bury 0
retsub

// array_complement
arraycomplement_1:
proto 1 1
byte ""
int 0
dupn 2
byte ""
dup
frame_dig -1
int 0
getbit
frame_bury 1
frame_dig 1
callsub boolcomp_0
frame_bury 1
byte 0x00
int 0
frame_dig 1
setbit
frame_bury 0
retsub

// round_tripper
roundtripper_2:
proto 1 1
byte ""
dupn 2
int 0
dup
byte ""
dup
frame_dig -1
callsub arraycomplement_1
frame_bury 1
frame_dig 1
callsub arraycomplement_1
frame_bury 2
frame_dig -1
frame_dig 1
concat
frame_dig 2
concat
frame_bury 0
retsub


================================================
FILE: tests/integration/teal/roundtrip/app_roundtrip_bool[3][]_11_v6.teal
================================================
#pragma version 6
txna ApplicationArgs 0
store 1
load 1
callsub roundtripper_3
store 0
byte 0x151f7c75
load 0
concat
log
int 1
return

// bool_comp
boolcomp_0:
store 24
load 24
!
!
!
store 25
load 25
retsub

// array_complement
arraycomplement_1:
store 19
load 19
int 0
getbit
store 21
load 19
int 1
getbit
store 22
load 19
int 2
getbit
store 23
load 21
callsub boolcomp_0
store 21
load 22
callsub boolcomp_0
store 22
load 23
callsub boolcomp_0
store 23
byte 0x00
int 0
load 21
setbit
int 1
load 22
setbit
int 2
load 23
setbit
store 20
load 20
retsub

// array_complement
arraycomplement_2:
store 6
load 6
int 1
int 0
*
int 2
+
int 1
extract3
store 8
load 6
int 1
int 1
*
int 2
+
int 1
extract3
store 9
load 6
int 1
int 2
*
int 2
+
int 1
extract3
store 10
load 6
int 1
int 3
*
int 2
+
int 1
extract3
store 11
load 6
int 1
int 4
*
int 2
+
int 1
extract3
store 12
load 6
int 1
int 5
*
int 2
+
int 1
extract3
store 13
load 6
int 1
int 6
*
int 2
+
int 1
extract3
store 14
load 6
int 1
int 7
*
int 2
+
int 1
extract3
store 15
load 6
int 1
int 8
*
int 2
+
int 1
extract3
store 16
load 6
int 1
int 9
*
int 2
+
int 1
extract3
store 17
load 6
int 1
int 10
*
int 2
+
int 1
extract3
store 18
load 8
callsub arraycomplement_1
store 8
load 9
callsub arraycomplement_1
store 9
load 10
callsub arraycomplement_1
store 10
load 11
callsub arraycomplement_1
store 11
load 12
callsub arraycomplement_1
store 12
load 13
callsub arraycomplement_1
store 13
load 14
callsub arraycomplement_1
store 14
load 15
callsub arraycomplement_1
store 15
load 16
callsub arraycomplement_1
store 16
load 17
callsub arraycomplement_1
store 17
load 18
callsub arraycomplement_1
store 18
int 11
store 26
load 26
itob
extract 6 0
load 8
load 9
concat
load 10
concat
load 11
concat
load 12
concat
load 13
concat
load 14
concat
load 15
concat
load 16
concat
load 17
concat
load 18
concat
concat
store 7
load 7
retsub

// round_tripper
roundtripper_3:
store 2
load 2
callsub arraycomplement_2
store 4
load 4
callsub arraycomplement_2
store 5
load 2
store 30
load 30
store 29
int 6
store 27
load 27
load 30
len
+
store 28
load 28
int 65536
<
assert
load 27
itob
extract 6 0
load 4
store 30
load 29
load 30
concat
store 29
load 28
store 27
load 27
load 30
len
+
store 28
load 28
int 65536
<
assert
load 27
itob
extract 6 0
concat
load 5
store 30
load 29
load 30
concat
store 29
load 28
store 27
load 27
itob
extract 6 0
concat
load 29
concat
store 3
load 3
retsub


================================================
FILE: tests/integration/teal/roundtrip/app_roundtrip_bool[3][]_11_v8.teal
================================================
#pragma version 8
txna ApplicationArgs 0
store 1
load 1
callsub roundtripper_3
store 0
byte 0x151f7c75
load 0
concat
log
int 1
return

// bool_comp
boolcomp_0:
proto 1 1
int 0
frame_dig -1
!
!
!
frame_bury 0
retsub

// array_complement
arraycomplement_1:
proto 1 1
byte ""
int 0
dupn 4
byte ""
dup
frame_dig -1
int 0
getbit
frame_bury 1
frame_dig -1
int 1
getbit
frame_bury 2
frame_dig -1
int 2
getbit
frame_bury 3
frame_dig 1
callsub boolcomp_0
frame_bury 1
frame_dig 2
callsub boolcomp_0
frame_bury 2
frame_dig 3
callsub boolcomp_0
frame_bury 3
byte 0x00
int 0
frame_dig 1
setbit
int 1
frame_dig 2
setbit
int 2
frame_dig 3
setbit
frame_bury 0
retsub

// array_complement
arraycomplement_2:
proto 1 1
byte ""
dupn 11
int 0
dupn 12
byte ""
dup
int 0
frame_dig -1
int 1
int 0
*
int 2
+
int 1
extract3
frame_bury 1
frame_dig -1
int 1
int 1
*
int 2
+
int 1
extract3
frame_bury 2
frame_dig -1
int 1
int 2
*
int 2
+
int 1
extract3
frame_bury 3
frame_dig -1
int 1
int 3
*
int 2
+
int 1
extract3
frame_bury 4
frame_dig -1
int 1
int 4
*
int 2
+
int 1
extract3
frame_bury 5
frame_dig -1
int 1
int 5
*
int 2
+
int 1
extract3
frame_bury 6
frame_dig -1
int 1
int 6
*
int 2
+
int 1
extract3
frame_bury 7
frame_dig -1
int 1
int 7
*
int 2
+
int 1
extract3
frame_bury 8
frame_dig -1
int 1
int 8
*
int 2
+
int 1
extract3
frame_bury 9
frame_dig -1
int 1
int 9
*
int 2
+
int 1
extract3
frame_bury 10
frame_dig -1
int 1
int 10
*
int 2
+
int 1
extract3
frame_bury 11
frame_dig 1
callsub arraycomplement_1
frame_bury 1
frame_dig 2
callsub arraycomplement_1
frame_bury 2
frame_dig 3
callsub arraycomplement_1
frame_bury 3
frame_dig 4
callsub arraycomplement_1
frame_bury 4
frame_dig 5
callsub arraycomplement_1
frame_bury 5
frame_dig 6
callsub arraycomplement_1
frame_bury 6
frame_dig 7
callsub arraycomplement_1
frame_bury 7
frame_dig 8
callsub arraycomplement_1
frame_bury 8
frame_dig 9
callsub arraycomplement_1
frame_bury 9
frame_dig 10
callsub arraycomplement_1
frame_bury 10
frame_dig 11
callsub arraycomplement_1
frame_bury 11
int 11
frame_bury 27
frame_dig 27
itob
extract 6 0
frame_dig 1
frame_dig 2
concat
frame_dig 3
concat
frame_dig 4
concat
frame_dig 5
concat
frame_dig 6
concat
frame_dig 7
concat
frame_dig 8
concat
frame_dig 9
concat
frame_dig 10
concat
frame_dig 11
concat
concat
frame_bury 0
retsub

// round_tripper
roundtripper_3:
proto 1 1
byte ""
dupn 2
int 0
dup
byte ""
dup
frame_dig -1
callsub arraycomplement_2
frame_bury 1
frame_dig 1
callsub arraycomplement_2
frame_bury 2
frame_dig -1
frame_bury 6
frame_dig 6
frame_bury 5
int 6
frame_bury 3
frame_dig 3
frame_dig 6
len
+
frame_bury 4
frame_dig 4
int 65536
<
assert
frame_dig 3
itob
extract 6 0
frame_dig 1
frame_bury 6
frame_dig 5
frame_dig 6
concat
frame_bury 5
frame_dig 4
frame_bury 3
frame_dig 3
frame_dig 6
len
+
frame_bury 4
frame_dig 4
int 65536
<
assert
frame_dig 3
itob
extract 6 0
concat
frame_dig 2
frame_bury 6
frame_dig 5
frame_dig 6
concat
frame_bury 5
frame_dig 4
frame_bury 3
frame_dig 3
itob
extract 6 0
concat
frame_dig 5
concat
frame_bury 0
retsub


================================================
FILE: tests/integration/teal/roundtrip/app_roundtrip_bool[42]_v6.teal
================================================
#pragma version 6
txna ApplicationArgs 0
store 1
load 1
callsub roundtripper_2
store 0
byte 0x151f7c75
load 0
concat
log
int 1
return

// bool_comp
boolcomp_0:
store 50
load 50
!
!
!
store 51
load 51
retsub

// array_complement
arraycomplement_1:
store 6
load 6
int 0
getbit
store 8
load 6
int 1
getbit
store 9
load 6
int 2
getbit
store 10
load 6
int 3
getbit
store 11
load 6
int 4
getbit
store 12
load 6
int 5
getbit
store 13
load 6
int 6
getbit
store 14
load 6
int 7
getbit
store 15
load 6
int 8
getbit
store 16
load 6
int 9
getbit
store 17
load 6
int 10
getbit
store 18
load 6
int 11
getbit
store 19
load 6
int 12
getbit
store 20
load 6
int 13
getbit
store 21
load 6
int 14
getbit
store 22
load 6
int 15
getbit
store 23
load 6
int 16
getbit
store 24
load 6
int 17
getbit
store 25
load 6
int 18
getbit
store 26
load 6
int 19
getbit
store 27
load 6
int 20
getbit
store 28
load 6
int 21
getbit
store 29
load 6
int 22
getbit
store 30
load 6
int 23
getbit
store 31
load 6
int 24
getbit
store 32
load 6
int 25
getbit
store 33
load 6
int 26
getbit
store 34
load 6
int 27
getbit
store 35
load 6
int 28
getbit
store 36
load 6
int 29
getbit
store 37
load 6
int 30
getbit
store 38
load 6
int 31
getbit
store 39
load 6
int 32
getbit
store 40
load 6
int 33
getbit
store 41
load 6
int 34
getbit
store 42
load 6
int 35
getbit
store 43
load 6
int 36
getbit
store 44
load 6
int 37
getbit
store 45
load 6
int 38
getbit
store 46
load 6
int 39
getbit
store 47
load 6
int 40
getbit
store 48
load 6
int 41
getbit
store 49
load 8
callsub boolcomp_0
store 8
load 9
callsub boolcomp_0
store 9
load 10
callsub boolcomp_0
store 10
load 11
callsub boolcomp_0
store 11
load 12
callsub boolcomp_0
store 12
load 13
callsub boolcomp_0
store 13
load 14
callsub boolcomp_0
store 14
load 15
callsub boolcomp_0
store 15
load 16
callsub boolcomp_0
store 16
load 17
callsub boolcomp_0
store 17
load 18
callsub boolcomp_0
store 18
load 19
callsub boolcomp_0
store 19
load 20
callsub boolcomp_0
store 20
load 21
callsub boolcomp_0
store 21
load 22
callsub boolcomp_0
store 22
load 23
callsub boolcomp_0
store 23
load 24
callsub boolcomp_0
store 24
load 25
callsub boolcomp_0
store 25
load 26
callsub boolcomp_0
store 26
load 27
callsub boolcomp_0
store 27
load 28
callsub boolcomp_0
store 28
load 29
callsub boolcomp_0
store 29
load 30
callsub boolcomp_0
store 30
load 31
callsub boolcomp_0
store 31
load 32
callsub boolcomp_0
store 32
load 33
callsub boolcomp_0
store 33
load 34
callsub boolcomp_0
store 34
load 35
callsub boolcomp_0
store 35
load 36
callsub boolcomp_0
store 36
load 37
callsub boolcomp_0
store 37
load 38
callsub boolcomp_0
store 38
load 39
callsub boolcomp_0
store 39
load 40
callsub boolcomp_0
store 40
load 41
callsub boolcomp_0
store 41
load 42
callsub boolcomp_0
store 42
load 43
callsub boolcomp_0
store 43
load 44
callsub boolcomp_0
store 44
load 45
callsub boolcomp_0
store 45
load 46
callsub boolcomp_0
store 46
load 47
callsub boolcomp_0
store 47
load 48
callsub boolcomp_0
store 48
load 49
callsub boolcomp_0
store 49
byte 0x000000000000
int 0
load 8
setbit
int 1
load 9
setbit
int 2
load 10
setbit
int 3
load 11
setbit
int 4
load 12
setbit
int 5
load 13
setbit
int 6
load 14
setbit
int 7
load 15
setbit
int 8
load 16
setbit
int 9
load 17
setbit
int 10
load 18
setbit
int 11
load 19
setbit
int 12
load 20
setbit
int 13
load 21
setbit
int 14
load 22
setbit
int 15
load 23
setbit
int 16
load 24
setbit
int 17
load 25
setbit
int 18
load 26
setbit
int 19
load 27
setbit
int 20
load 28
setbit
int 21
load 29
setbit
int 22
load 30
setbit
int 23
load 31
setbit
int 24
load 32
setbit
int 25
load 33
setbit
int 26
load 34
setbit
int 27
load 35
setbit
int 28
load 36
setbit
int 29
load 37
setbit
int 30
load 38
setbit
int 31
load 39
setbit
int 32
load 40
setbit
int 33
load 41
setbit
int 34
load 42
setbit
int 35
load 43
setbit
int 36
load 44
setbit
int 37
load 45
setbit
int 38
load 46
setbit
int 39
load 47
setbit
int 40
load 48
setbit
int 41
load 49
setbit
store 7
load 7
retsub

// round_tripper
roundtripper_2:
store 2
load 2
callsub arraycomplement_1
store 4
load 4
callsub arraycomplement_1
store 5
load 2
load 4
concat
load 5
concat
store 3
load 3
retsub


================================================
FILE: tests/integration/teal/roundtrip/app_roundtrip_bool[42]_v8.teal
================================================
#pragma version 8
txna ApplicationArgs 0
store 1
load 1
callsub roundtripper_2
store 0
byte 0x151f7c75
load 0
concat
log
int 1
return

// bool_comp
boolcomp_0:
proto 1 1
int 0
frame_dig -1
!
!
!
frame_bury 0
retsub

// array_complement
arraycomplement_1:
proto 1 1
byte ""
int 0
dupn 43
byte ""
dup
frame_dig -1
int 0
getbit
frame_bury 1
frame_dig -1
int 1
getbit
frame_bury 2
frame_dig -1
int 2
getbit
frame_bury 3
frame_dig -1
int 3
getbit
frame_bury 4
frame_dig -1
int 4
getbit
frame_bury 5
frame_dig -1
int 5
getbit
frame_bury 6
frame_dig -1
int 6
getbit
frame_bury 7
frame_dig -1
int 7
getbit
frame_bury 8
frame_dig -1
int 8
getbit
frame_bury 9
frame_dig -1
int 9
getbit
frame_bury 10
frame_dig -1
int 10
getbit
frame_bury 11
frame_dig -1
int 11
getbit
frame_bury 12
frame_dig -1
int 12
getbit
frame_bury 13
frame_dig -1
int 13
getbit
frame_bury 14
frame_dig -1
int 14
getbit
frame_bury 15
frame_dig -1
int 15
getbit
frame_bury 16
frame_dig -1
int 16
getbit
frame_bury 17
frame_dig -1
int 17
getbit
frame_bury 18
frame_dig -1
int 18
getbit
frame_bury 19
frame_dig -1
int 19
getbit
frame_bury 20
frame_dig -1
int 20
getbit
frame_bury 21
frame_dig -1
int 21
getbit
frame_bury 22
frame_dig -1
int 22
getbit
frame_bury 23
frame_dig -1
int 23
getbit
frame_bury 24
frame_dig -1
int 24
getbit
frame_bury 25
frame_dig -1
int 25
getbit
frame_bury 26
frame_dig -1
int 26
getbit
frame_bury 27
frame_dig -1
int 27
getbit
frame_bury 28
frame_dig -1
int 28
getbit
frame_bury 29
frame_dig -1
int 29
getbit
frame_bury 30
frame_dig -1
int 30
getbit
frame_bury 31
frame_dig -1
int 31
getbit
frame_bury 32
frame_dig -1
int 32
getbit
frame_bury 33
frame_dig -1
int 33
getbit
frame_bury 34
frame_dig -1
int 34
getbit
frame_bury 35
frame_dig -1
int 35
getbit
frame_bury 36
frame_dig -1
int 36
getbit
frame_bury 37
frame_dig -1
int 37
getbit
frame_bury 38
frame_dig -1
int 38
getbit
frame_bury 39
frame_dig -1
int 39
getbit
frame_bury 40
frame_dig -1
int 40
getbit
frame_bury 41
frame_dig -1
int 41
getbit
frame_bury 42
frame_dig 1
callsub boolcomp_0
frame_bury 1
frame_dig 2
callsub boolcomp_0
frame_bury 2
frame_dig 3
callsub boolcomp_0
frame_bury 3
frame_dig 4
callsub boolcomp_0
frame_bury 4
frame_dig 5
callsub boolcomp_0
frame_bury 5
frame_dig 6
callsub boolcomp_0
frame_bury 6
frame_dig 7
callsub boolcomp_0
frame_bury 7
frame_dig 8
callsub boolcomp_0
frame_bury 8
frame_dig 9
callsub boolcomp_0
frame_bury 9
frame_dig 10
callsub boolcomp_0
frame_bury 10
frame_dig 11
callsub boolcomp_0
frame_bury 11
frame_dig 12
callsub boolcomp_0
frame_bury 12
frame_dig 13
callsub boolcomp_0
frame_bury 13
frame_dig 14
callsub boolcomp_0
frame_bury 14
frame_dig 15
callsub boolcomp_0
frame_bury 15
frame_dig 16
callsub boolcomp_0
frame_bury 16
frame_dig 17
callsub boolcomp_0
frame_bury 17
frame_dig 18
callsub boolcomp_0
frame_bury 18
frame_dig 19
callsub boolcomp_0
frame_bury 19
frame_dig 20
callsub boolcomp_0
frame_bury 20
frame_dig 21
callsub boolcomp_0
frame_bury 21
frame_dig 22
callsub boolcomp_0
frame_bury 22
frame_dig 23
callsub boolcomp_0
frame_bury 23
frame_dig 24
callsub boolcomp_0
frame_bury 24
frame_dig 25
callsub boolcomp_0
frame_bury 25
frame_dig 26
callsub boolcomp_0
frame_bury 26
frame_dig 27
callsub boolcomp_0
frame_bury 27
frame_dig 28
callsub boolcomp_0
frame_bury 28
frame_dig 29
callsub boolcomp_0
frame_bury 29
frame_dig 30
callsub boolcomp_0
frame_bury 30
frame_dig 31
callsub boolcomp_0
frame_bury 31
frame_dig 32
callsub boolcomp_0
frame_bury 32
frame_dig 33
callsub boolcomp_0
frame_bury 33
frame_dig 34
callsub boolcomp_0
frame_bury 34
frame_dig 35
callsub boolcomp_0
frame_bury 35
frame_dig 36
callsub boolcomp_0
frame_bury 36
frame_dig 37
callsub boolcomp_0
frame_bury 37
frame_dig 38
callsub boolcomp_0
frame_bury 38
frame_dig 39
callsub boolcomp_0
frame_bury 39
frame_dig 40
callsub boolcomp_0
frame_bury 40
frame_dig 41
callsub boolcomp_0
frame_bury 41
frame_dig 42
callsub boolcomp_0
frame_bury 42
byte 0x000000000000
int 0
frame_dig 1
setbit
int 1
frame_dig 2
setbit
int 2
frame_dig 3
setbit
int 3
frame_dig 4
setbit
int 4
frame_dig 5
setbit
int 5
frame_dig 6
setbit
int 6
frame_dig 7
setbit
int 7
frame_dig 8
setbit
int 8
frame_dig 9
setbit
int 9
frame_dig 10
setbit
int 10
frame_dig 11
setbit
int 11
frame_dig 12
setbit
int 12
frame_dig 13
setbit
int 13
frame_dig 14
setbit
int 14
frame_dig 15
setbit
int 15
frame_dig 16
setbit
int 16
frame_dig 17
setbit
int 17
frame_dig 18
setbit
int 18
frame_dig 19
setbit
int 19
frame_dig 20
setbit
int 20
frame_dig 21
setbit
int 21
frame_dig 22
setbit
int 22
frame_dig 23
setbit
int 23
frame_dig 24
setbit
int 24
frame_dig 25
setbit
int 25
frame_dig 26
setbit
int 26
frame_dig 27
setbit
int 27
frame_dig 28
setbit
int 28
frame_dig 29
setbit
int 29
frame_dig 30
setbit
int 30
frame_dig 31
setbit
int 31
frame_dig 32
setbit
int 32
frame_dig 33
setbit
int 33
frame_dig 34
setbit
int 34
frame_dig 35
setbit
int 35
frame_dig 36
setbit
int 36
frame_dig 37
setbit
int 37
frame_dig 38
setbit
int 38
frame_dig 39
setbit
int 39
frame_dig 40
setbit
int 40
frame_dig 41
setbit
int 41
frame_dig 42
setbit
frame_bury 0
retsub

// round_tripper
roundtripper_2:
proto 1 1
byte ""
dupn 2
int 0
dup
byte ""
dup
frame_dig -1
callsub arraycomplement_1
frame_bury 1
frame_dig 1
callsub arraycomplement_1
frame_bury 2
frame_dig -1
frame_dig 1
concat
frame_dig 2
concat
frame_bury 0
retsub


================================================
FILE: tests/integration/teal/roundtrip/app_roundtrip_bool[]_0_v6.teal
================================================
#pragma version 6
txna ApplicationArgs 0
store 1
load 1
callsub roundtripper_1
store 0
byte 0x151f7c75
load 0
concat
log
int 1
return

// array_complement
arraycomplement_0:
store 6
int 0
store 8
load 8
itob
extract 6 0
byte ""
concat
store 7
load 7
retsub

// round_tripper
roundtripper_1:
store 2
load 2
callsub arraycomplement_0
store 4
load 4
callsub arraycomplement_0
store 5
load 2
store 12
load 12
store 11
int 6
store 9
load 9
load 12
len
+
store 10
load 10
int 65536
<
assert
load 9
itob
extract 6 0
load 4
store 12
load 11
load 12
concat
store 11
load 10
store 9
load 9
load 12
len
+
store 10
load 10
int 65536
<
assert
load 9
itob
extract 6 0
concat
load 5
store 12
load 11
load 12
concat
store 11
load 10
store 9
load 9
itob
extract 6 0
concat
load 11
concat
store 3
load 3
retsub


================================================
FILE: tests/integration/teal/roundtrip/app_roundtrip_bool[]_0_v8.teal
================================================
#pragma version 8
txna ApplicationArgs 0
store 1
load 1
callsub roundtripper_1
store 0
byte 0x151f7c75
load 0
concat
log
int 1
return

// array_complement
arraycomplement_0:
proto 1 1
byte ""
int 0
dup
byte ""
dup
int 0
int 0
frame_bury 5
frame_dig 5
itob
extract 6 0
byte ""
concat
frame_bury 0
retsub

// round_tripper
roundtripper_1:
proto 1 1
byte ""
dupn 2
int 0
dup
byte ""
dup
frame_dig -1
callsub arraycomplement_0
frame_bury 1
frame_dig 1
callsub arraycomplement_0
frame_bury 2
frame_dig -1
frame_bury 6
frame_dig 6
frame_bury 5
int 6
frame_bury 3
frame_dig 3
frame_dig 6
len
+
frame_bury 4
frame_dig 4
int 65536
<
assert
frame_dig 3
itob
extract 6 0
frame_dig 1
frame_bury 6
frame_dig 5
frame_dig 6
concat
frame_bury 5
frame_dig 4
frame_bury 3
frame_dig 3
frame_dig 6
len
+
frame_bury 4
frame_dig 4
int 65536
<
assert
frame_dig 3
itob
extract 6 0
concat
frame_dig 2
frame_bury 6
frame_dig 5
frame_dig 6
concat
frame_bury 5
frame_dig 4
frame_bury 3
frame_dig 3
itob
extract 6 0
concat
frame_dig 5
concat
frame_bury 0
retsub


================================================
FILE: tests/integration/teal/roundtrip/app_roundtrip_bool[]_1_v6.teal
================================================
#pragma version 6
txna ApplicationArgs 0
store 1
load 1
callsub roundtripper_2
store 0
byte 0x151f7c75
load 0
concat
log
int 1
return

// bool_comp
boolcomp_0:
store 9
load 9
!
!
!
store 10
load 10
retsub

// array_complement
arraycomplement_1:
store 6
load 6
int 0
int 16
+
getbit
store 8
load 8
callsub boolcomp_0
store 8
int 1
store 11
load 11
itob
extract 6 0
byte 0x00
int 0
load 8
setbit
concat
store 7
load 7
retsub

// round_tripper
roundtripper_2:
store 2
load 2
callsub arraycomplement_1
store 4
load 4
callsub arraycomplement_1
store 5
load 2
store 15
load 15
store 14
int 6
store 12
load 12
load 15
len
+
store 13
load 13
int 65536
<
assert
load 12
itob
extract 6 0
load 4
store 15
load 14
load 15
concat
store 14
load 13
store 12
load 12
load 15
len
+
store 13
load 13
int 65536
<
assert
load 12
itob
extract 6 0
concat
load 5
store 15
load 14
load 15
concat
store 14
load 13
store 12
load 12
itob
extract 6 0
concat
load 14
concat
store 3
load 3
retsub


================================================
FILE: tests/integration/teal/roundtrip/app_roundtrip_bool[]_1_v8.teal
================================================
#pragma version 8
txna ApplicationArgs 0
store 1
load 1
callsub roundtripper_2
store 0
byte 0x151f7c75
load 0
concat
log
int 1
return

// bool_comp
boolcomp_0:
proto 1 1
int 0
frame_dig -1
!
!
!
frame_bury 0
retsub

// array_complement
arraycomplement_1:
proto 1 1
byte ""
int 0
dupn 2
byte ""
dup
int 0
frame_dig -1
int 0
int 16
+
getbit
frame_bury 1
frame_dig 1
callsub boolcomp_0
frame_bury 1
int 1
frame_bury 6
frame_dig 6
itob
extract 6 0
byte 0x00
int 0
frame_dig 1
setbit
concat
frame_bury 0
retsub

// round_tripper
roundtripper_2:
proto 1 1
byte ""
dupn 2
int 0
dup
byte ""
dup
frame_dig -1
callsub arraycomplement_1
frame_bury 1
frame_dig 1
callsub arraycomplement_1
frame_bury 2
frame_dig -1
frame_bury 6
frame_dig 6
frame_bury 5
int 6
frame_bury 3
frame_dig 3
frame_dig 6
len
+
frame_bury 4
frame_dig 4
int 65536
<
assert
frame_dig 3
itob
extract 6 0
frame_dig 1
frame_bury 6
frame_dig 5
frame_dig 6
concat
frame_bury 5
frame_dig 4
frame_bury 3
frame_dig 3
frame_dig 6
len
+
frame_bury 4
frame_dig 4
int 65536
<
assert
frame_dig 3
itob
extract 6 0
concat
frame_dig 2
frame_bury 6
frame_dig 5
frame_dig 6
concat
frame_bury 5
frame_dig 4
frame_bury 3
frame_dig 3
itob
extract 6 0
concat
frame_dig 5
concat
frame_bury 0
retsub


================================================
FILE: tests/integration/teal/roundtrip/app_roundtrip_bool[]_42_v6.teal
================================================
#pragma version 6
txna ApplicationArgs 0
store 1
load 1
callsub roundtripper_2
store 0
byte 0x151f7c75
load 0
concat
log
int 1
return

// bool_comp
boolcomp_0:
store 50
load 50
!
!
!
store 51
load 51
retsub

// array_complement
arraycomplement_1:
store 6
load 6
int 0
int 16
+
getbit
store 8
load 6
int 1
int 16
+
getbit
store 9
load 6
int 2
int 16
+
getbit
store 10
load 6
int 3
int 16
+
getbit
store 11
load 6
int 4
int 16
+
getbit
store 12
load 6
int 5
int 16
+
getbit
store 13
load 6
int 6
int 16
+
getbit
store 14
load 6
int 7
int 16
+
getbit
store 15
load 6
int 8
int 16
+
getbit
store 16
load 6
int 9
int 16
+
getbit
store 17
load 6
int 10
int 16
+
getbit
store 18
load 6
int 11
int 16
+
getbit
store 19
load 6
int 12
int 16
+
getbit
store 20
load 6
int 13
int 16
+
getbit
store 21
load 6
int 14
int 16
+
getbit
store 22
load 6
int 15
int 16
+
getbit
store 23
load 6
int 16
int 16
+
getbit
store 24
load 6
int 17
int 16
+
getbit
store 25
load 6
int 18
int 16
+
getbit
store 26
load 6
int 19
int 16
+
getbit
store 27
load 6
int 20
int 16
+
getbit
store 28
load 6
int 21
int 16
+
getbit
store 29
load 6
int 22
int 16
+
getbit
store 30
load 6
int 23
int 16
+
getbit
store 31
load 6
int 24
int 16
+
getbit
store 32
load 6
int 25
int 16
+
getbit
store 33
load 6
int 26
int 16
+
getbit
store 34
load 6
int 27
int 16
+
getbit
store 35
load 6
int 28
int 16
+
getbit
store 36
load 6
int 29
int 16
+
getbit
store 37
load 6
int 30
int 16
+
getbit
store 38
load 6
int 31
int 16
+
getbit
store 39
load 6
int 32
int 16
+
getbit
store 40
load 6
int 33
int 16
+
getbit
store 41
load 6
int 34
int 16
+
getbit
store 42
load 6
int 35
int 16
+
getbit
store 43
load 6
int 36
int 16
+
getbit
store 44
load 6
int 37
int 16
+
getbit
store 45
load 6
int 38
int 16
+
getbit
store 46
load 6
int 39
int 16
+
getbit
store 47
load 6
int 40
int 16
+
getbit
store 48
load 6
int 41
int 16
+
getbit
store 49
load 8
callsub boolcomp_0
store 8
load 9
callsub boolcomp_0
store 9
load 10
callsub boolcomp_0
store 10
load 11
callsub boolcomp_0
store 11
load 12
callsub boolcomp_0
store 12
load 13
callsub boolcomp_0
store 13
load 14
callsub boolcomp_0
store 14
load 15
callsub boolcomp_0
store 15
load 16
callsub boolcomp_0
store 16
load 17
callsub boolcomp_0
store 17
load 18
callsub boolcomp_0
store 18
load 19
callsub boolcomp_0
store 19
load 20
callsub boolcomp_0
store 20
load 21
callsub boolcomp_0
store 21
load 22
callsub boolcomp_0
store 22
load 23
callsub boolcomp_0
store 23
load 24
callsub boolcomp_0
store 24
load 25
callsub boolcomp_0
store 25
load 26
callsub boolcomp_0
store 26
load 27
callsub boolcomp_0
store 27
load 28
callsub boolcomp_0
store 28
load 29
callsub boolcomp_0
store 29
load 30
callsub boolcomp_0
store 30
load 31
callsub boolcomp_0
store 31
load 32
callsub boolcomp_0
store 32
load 33
callsub boolcomp_0
store 33
load 34
callsub boolcomp_0
store 34
load 35
callsub boolcomp_0
store 35
load 36
callsub boolcomp_0
store 36
load 37
callsub boolcomp_0
store 37
load 38
callsub boolcomp_0
store 38
load 39
callsub boolcomp_0
store 39
load 40
callsub boolcomp_0
store 40
load 41
callsub boolcomp_0
store 41
load 42
callsub boolcomp_0
store 42
load 43
callsub boolcomp_0
store 43
load 44
callsub boolcomp_0
store 44
load 45
callsub boolcomp_0
store 45
load 46
callsub boolcomp_0
store 46
load 47
callsub boolcomp_0
store 47
load 48
callsub boolcomp_0
store 48
load 49
callsub boolcomp_0
store 49
int 42
store 52
load 52
itob
extract 6 0
byte 0x000000000000
int 0
load 8
setbit
int 1
load 9
setbit
int 2
load 10
setbit
int 3
load 11
setbit
int 4
load 12
setbit
int 5
load 13
setbit
int 6
load 14
setbit
int 7
load 15
setbit
int 8
load 16
setbit
int 9
load 17
setbit
int 10
load 18
setbit
int 11
load 19
setbit
int 12
load 20
setbit
int 13
load 21
setbit
int 14
load 22
setbit
int 15
load 23
setbit
int 16
load 24
setbit
int 17
load 25
setbit
int 18
load 26
setbit
int 19
load 27
setbit
int 20
load 28
setbit
int 21
load 29
setbit
int 22
load 30
setbit
int 23
load 31
setbit
int 24
load 32
setbit
int 25
load 33
setbit
int 26
load 34
setbit
int 27
load 35
setbit
int 28
load 36
setbit
int 29
load 37
setbit
int 30
load 38
setbit
int 31
load 39
setbit
int 32
load 40
setbit
int 33
load 41
setbit
int 34
load 42
setbit
int 35
load 43
setbit
int 36
load 44
setbit
int 37
load 45
setbit
int 38
load 46
setbit
int 39
load 47
setbit
int 40
load 48
setbit
int 41
load 49
setbit
concat
store 7
load 7
retsub

// round_tripper
roundtripper_2:
store 2
load 2
callsub arraycomplement_1
store 4
load 4
callsub arraycomplement_1
store 5
load 2
store 56
load 56
store 55
int 6
store 53
load 53
load 56
len
+
store 54
load 54
int 65536
<
assert
load 53
itob
extract 6 0
load 4
store 56
load 55
load 56
concat
store 55
load 54
store 53
load 53
load 56
len
+
store 54
load 54
int 65536
<
assert
load 53
itob
extract 6 0
concat
load 5
store 56
load 55
load 56
concat
store 55
load 54
store 53
load 53
itob
extract 6 0
concat
load 55
concat
store 3
load 3
retsub


================================================
FILE: tests/integration/teal/roundtrip/app_roundtrip_bool[]_42_v8.teal
================================================
#pragma version 8
txna ApplicationArgs 0
store 1
load 1
callsub roundtripper_2
store 0
byte 0x151f7c75
load 0
concat
log
int 1
return

// bool_comp
boolcomp_0:
proto 1 1
int 0
frame_dig -1
!
!
!
frame_bury 0
retsub

// array_complement
arraycomplement_1:
proto 1 1
byte ""
int 0
dupn 43
byte ""
dup
int 0
frame_dig -1
int 0
int 16
+
getbit
frame_bury 1
frame_dig -1
int 1
int 16
+
getbit
frame_bury 2
frame_dig -1
int 2
int 16
+
getbit
frame_bury 3
frame_dig -1
int 3
int 16
+
getbit
frame_bury 4
frame_dig -1
int 4
int 16
+
getbit
frame_bury 5
frame_dig -1
int 5
int 16
+
getbit
frame_bury 6
frame_dig -1
int 6
int 16
+
getbit
frame_bury 7
frame_dig -1
int 7
int 16
+
getbit
frame_bury 8
frame_dig -1
int 8
int 16
+
getbit
frame_bury 9
frame_dig -1
int 9
int 16
+
getbit
frame_bury 10
frame_dig -1
int 10
int 16
+
getbit
frame_bury 11
frame_dig -1
int 11
int 16
+
getbit
frame_bury 12
frame_dig -1
int 12
int 16
+
getbit
frame_bury 13
frame_dig -1
int 13
int 16
+
getbit
frame_bury 14
frame_dig -1
int 14
int 16
+
getbit
frame_bury 15
frame_dig -1
int 15
int 16
+
getbit
frame_bury 16
frame_dig -1
int 16
int 16
+
getbit
frame_bury 17
frame_dig -1
int 17
int 16
+
getbit
frame_bury 18
frame_dig -1
int 18
int 16
+
getbit
frame_bury 19
frame_dig -1
int 19
int 16
+
getbit
frame_bury 20
frame_dig -1
int 20
int 16
+
getbit
frame_bury 21
frame_dig -1
int 21
int 16
+
getbit
frame_bury 22
frame_dig -1
int 22
int 16
+
getbit
frame_bury 23
frame_dig -1
int 23
int 16
+
getbit
frame_bury 24
frame_dig -1
int 24
int 16
+
getbit
frame_bury 25
frame_dig -1
int 25
int 16
+
getbit
frame_bury 26
frame_dig -1
int 26
int 16
+
getbit
frame_bury 27
frame_dig -1
int 27
int 16
+
getbit
frame_bury 28
frame_dig -1
int 28
int 16
+
getbit
frame_bury 29
frame_dig -1
int 29
int 16
+
getbit
frame_bury 30
frame_dig -1
int 30
int 16
+
getbit
frame_bury 31
frame_dig -1
int 31
int 16
+
getbit
frame_bury 32
frame_dig -1
int 32
int 16
+
getbit
frame_bury 33
frame_dig -1
int 33
int 16
+
getbit
frame_bury 34
frame_dig -1
int 34
int 16
+
getbit
frame_bury 35
frame_dig -1
int 35
int 16
+
getbit
frame_bury 36
frame_dig -1
int 36
int 16
+
getbit
frame_bury 37
frame_dig -1
int 37
int 16
+
getbit
frame_bury 38
frame_dig -1
int 38
int 16
+
getbit
frame_bury 39
frame_dig -1
int 39
int 16
+
getbit
frame_bury 40
frame_dig -1
int 40
int 16
+
getbit
frame_bury 41
frame_dig -1
int 41
int 16
+
getbit
frame_bury 42
frame_dig 1
callsub boolcomp_0
frame_bury 1
frame_dig 2
callsub boolcomp_0
frame_bury 2
frame_dig 3
callsub boolcomp_0
frame_bury 3
frame_dig 4
callsub boolcomp_0
frame_bury 4
frame_dig 5
callsub boolcomp_0
frame_bury 5
frame_dig 6
callsub boolcomp_0
frame_bury 6
frame_dig 7
callsub boolcomp_0
frame_bury 7
frame_dig 8
callsub boolcomp_0
frame_bury 8
frame_dig 9
callsub boolcomp_0
frame_bury 9
frame_dig 10
callsub boolcomp_0
frame_bury 10
frame_dig 11
callsub boolcomp_0
frame_bury 11
frame_dig 12
callsub boolcomp_0
frame_bury 12
frame_dig 13
callsub boolcomp_0
frame_bury 13
frame_dig 14
callsub boolcomp_0
frame_bury 14
frame_dig 15
callsub boolcomp_0
frame_bury 15
frame_dig 16
callsub boolcomp_0
frame_bury 16
frame_dig 17
callsub boolcomp_0
frame_bury 17
frame_dig 18
callsub boolcomp_0
frame_bury 18
frame_dig 19
callsub boolcomp_0
frame_bury 19
frame_dig 20
callsub boolcomp_0
frame_bury 20
frame_dig 21
callsub boolcomp_0
frame_bury 21
frame_dig 22
callsub boolcomp_0
frame_bury 22
frame_dig 23
callsub boolcomp_0
frame_bury 23
frame_dig 24
callsub boolcomp_0
frame_bury 24
frame_dig 25
callsub boolcomp_0
frame_bury 25
frame_dig 26
callsub boolcomp_0
frame_bury 26
frame_dig 27
callsub boolcomp_0
frame_bury 27
frame_dig 28
callsub boolcomp_0
frame_bury 28
frame_dig 29
callsub boolcomp_0
frame_bury 29
frame_dig 30
callsub boolcomp_0
frame_bury 30
frame_dig 31
callsub boolcomp_0
frame_bury 31
frame_dig 32
callsub boolcomp_0
frame_bury 32
frame_dig 33
callsub boolcomp_0
frame_bury 33
frame_dig 34
callsub boolcomp_0
frame_bury 34
frame_dig 35
callsub boolcomp_0
frame_bury 35
frame_dig 36
callsub boolcomp_0
frame_bury 36
frame_dig 37
callsub boolcomp_0
frame_bury 37
frame_dig 38
callsub boolcomp_0
frame_bury 38
frame_dig 39
callsub boolcomp_0
frame_bury 39
frame_dig 40
callsub boolcomp_0
frame_bury 40
frame_dig 41
callsub boolcomp_0
frame_bury 41
frame_dig 42
callsub boolcomp_0
frame_bury 42
int 42
frame_bury 47
frame_dig 47
itob
extract 6 0
byte 0x000000000000
int 0
frame_dig 1
setbit
int 1
frame_dig 2
setbit
int 2
frame_dig 3
setbit
int 3
frame_dig 4
setbit
int 4
frame_dig 5
setbit
int 5
frame_dig 6
setbit
int 6
frame_dig 7
setbit
int 7
frame_dig 8
setbit
int 8
frame_dig 9
setbit
int 9
frame_dig 10
setbit
int 10
frame_dig 11
setbit
int 11
frame_dig 12
setbit
int 12
frame_dig 13
setbit
int 13
frame_dig 14
setbit
int 14
frame_dig 15
setbit
int 15
frame_dig 16
setbit
int 16
frame_dig 17
setbit
int 17
frame_dig 18
setbit
int 18
frame_dig 19
setbit
int 19
frame_dig 20
setbit
int 20
frame_dig 21
setbit
int 21
frame_dig 22
setbit
int 22
frame_dig 23
setbit
int 23
frame_dig 24
setbit
int 24
frame_dig 25
setbit
int 25
frame_dig 26
setbit
int 26
frame_dig 27
setbit
int 27
frame_dig 28
setbit
int 28
frame_dig 29
setbit
int 29
frame_dig 30
setbit
int 30
frame_dig 31
setbit
int 31
frame_dig 32
setbit
int 32
frame_dig 33
setbit
int 33
frame_dig 34
setbit
int 34
frame_dig 35
setbit
int 35
frame_dig 36
setbit
int 36
frame_dig 37
setbit
int 37
frame_dig 38
setbit
int 38
frame_dig 39
setbit
int 39
frame_dig 40
setbit
int 40
frame_dig 41
setbit
int 41
frame_dig 42
setbit
concat
frame_bury 0
retsub

// round_tripper
roundtripper_2:
proto 1 1
byte ""
dupn 2
int 0
dup
byte ""
dup
frame_dig -1
callsub arraycomplement_1
frame_bury 1
frame_dig 1
callsub arraycomplement_1
frame_bury 2
frame_dig -1
frame_bury 6
frame_dig 6
frame_bury 5
int 6
frame_bury 3
frame_dig 3
frame_dig 6
len
+
frame_bury 4
frame_dig 4
int 65536
<
assert
frame_dig 3
itob
extract 6 0
frame_dig 1
frame_bury 6
frame_dig 5
frame_dig 6
concat
frame_bury 5
frame_dig 4
frame_bury 3
frame_dig 3
frame_dig 6
len
+
frame_bury 4
frame_dig 4
int 65536
<
assert
frame_dig 3
itob
extract 6 0
concat
frame_dig 2
frame_bury 6
frame_dig 5
frame_dig 6
concat
frame_bury 5
frame_dig 4
frame_bury 3
frame_dig 3
itob
extract 6 0
concat
frame_dig 5
concat
frame_bury 0
retsub


================================================
FILE: tests/integration/teal/roundtrip/app_roundtrip_bool_v6.teal
================================================
#pragma version 6
txna ApplicationArgs 0
int 0
int 8
*
getbit
store 1
load 1
callsub roundtripper_1
store 0
byte 0x151f7c75
load 0
concat
log
int 1
return

// bool_comp
boolcomp_0:
store 6
load 6
!
!
!
store 7
load 7
retsub

// round_tripper
roundtripper_1:
store 2
load 2
callsub boolcomp_0
store 4
load 4
callsub boolcomp_0
store 5
byte 0x00
int 0
load 2
setbit
int 1
load 4
setbit
int 2
load 5
setbit
store 3
load 3
retsub


================================================
FILE: tests/integration/teal/roundtrip/app_roundtrip_bool_v8.teal
================================================
#pragma version 8
txna ApplicationArgs 0
int 0
int 8
*
getbit
store 1
load 1
callsub roundtripper_1
store 0
byte 0x151f7c75
load 0
concat
log
int 1
return

// bool_comp
boolcomp_0:
proto 1 1
int 0
frame_dig -1
!
!
!
frame_bury 0
retsub

// round_tripper
roundtripper_1:
proto 1 1
byte ""
int 0
dupn 3
byte ""
dup
frame_dig -1
callsub boolcomp_0
frame_bury 1
frame_dig 1
callsub boolcomp_0
frame_bury 2
byte 0x00
int 0
frame_dig -1
setbit
int 1
frame_dig 1
setbit
int 2
frame_dig 2
setbit
frame_bury 0
retsub


================================================
FILE: tests/integration/teal/roundtrip/app_roundtrip_byte[16]_v6.teal
================================================
#pragma version 6
txna ApplicationArgs 0
store 1
load 1
callsub roundtripper_2
store 0
byte 0x151f7c75
load 0
concat
log
int 1
return

// numerical_comp
numericalcomp_0:
store 24
int 255
load 24
-
store 25
load 25
int 256
<
assert
load 25
retsub

// array_complement
arraycomplement_1:
store 6
load 6
int 1
int 0
*
getbyte
store 8
load 6
int 1
int 1
*
getbyte
store 9
load 6
int 1
int 2
*
getbyte
store 10
load 6
int 1
int 3
*
getbyte
store 11
load 6
int 1
int 4
*
getbyte
store 12
load 6
int 1
int 5
*
getbyte
store 13
load 6
int 1
int 6
*
getbyte
store 14
load 6
int 1
int 7
*
getbyte
store 15
load 6
int 1
int 8
*
getbyte
store 16
load 6
int 1
int 9
*
getbyte
store 17
load 6
int 1
int 10
*
getbyte
store 18
load 6
int 1
int 11
*
getbyte
store 19
load 6
int 1
int 12
*
getbyte
store 20
load 6
int 1
int 13
*
getbyte
store 21
load 6
int 1
int 14
*
getbyte
store 22
load 6
int 1
int 15
*
getbyte
store 23
load 8
callsub numericalcomp_0
store 8
load 9
callsub numericalcomp_0
store 9
load 10
callsub numericalcomp_0
store 10
load 11
callsub numericalcomp_0
store 11
load 12
callsub numericalcomp_0
store 12
load 13
callsub numericalcomp_0
store 13
load 14
callsub numericalcomp_0
store 14
load 15
callsub numericalcomp_0
store 15
load 16
callsub numericalcomp_0
store 16
load 17
callsub numericalcomp_0
store 17
load 18
callsub numericalcomp_0
store 18
load 19
callsub numericalcomp_0
store 19
load 20
callsub numericalcomp_0
store 20
load 21
callsub numericalcomp_0
store 21
load 22
callsub numericalcomp_0
store 22
load 23
callsub numericalcomp_0
store 23
byte 0x00
int 0
load 8
setbyte
byte 0x00
int 0
load 9
setbyte
concat
byte 0x00
int 0
load 10
setbyte
concat
byte 0x00
int 0
load 11
setbyte
concat
byte 0x00
int 0
load 12
setbyte
concat
byte 0x00
int 0
load 13
setbyte
concat
byte 0x00
int 0
load 14
setbyte
concat
byte 0x00
int 0
load 15
setbyte
concat
byte 0x00
int 0
load 16
setbyte
concat
byte 0x00
int 0
load 17
setbyte
concat
byte 0x00
int 0
load 18
setbyte
concat
byte 0x00
int 0
load 19
setbyte
concat
byte 0x00
int 0
load 20
setbyte
concat
byte 0x00
int 0
load 21
setbyte
concat
byte 0x00
int 0
load 22
setbyte
concat
byte 0x00
int 0
load 23
setbyte
concat
store 7
load 7
retsub

// round_tripper
roundtripper_2:
store 2
load 2
callsub arraycomplement_1
store 4
load 4
callsub arraycomplement_1
store 5
load 2
load 4
concat
load 5
concat
store 3
load 3
retsub


================================================
FILE: tests/integration/teal/roundtrip/app_roundtrip_byte[16]_v8.teal
================================================
#pragma version 8
txna ApplicationArgs 0
store 1
load 1
callsub roundtripper_2
store 0
byte 0x151f7c75
load 0
concat
log
int 1
return

// numerical_comp
numericalcomp_0:
proto 1 1
int 0
int 255
frame_dig -1
-
frame_bury 0
frame_dig 0
int 256
<
assert
retsub

// array_complement
arraycomplement_1:
proto 1 1
byte ""
int 0
dupn 17
byte ""
dup
frame_dig -1
int 1
int 0
*
getbyte
frame_bury 1
frame_dig -1
int 1
int 1
*
getbyte
frame_bury 2
frame_dig -1
int 1
int 2
*
getbyte
frame_bury 3
frame_dig -1
int 1
int 3
*
getbyte
frame_bury 4
frame_dig -1
int 1
int 4
*
getbyte
frame_bury 5
frame_dig -1
int 1
int 5
*
getbyte
frame_bury 6
frame_dig -1
int 1
int 6
*
getbyte
frame_bury 7
frame_dig -1
int 1
int 7
*
getbyte
frame_bury 8
frame_dig -1
int 1
int 8
*
getbyte
frame_bury 9
frame_dig -1
int 1
int 9
*
getbyte
frame_bury 10
frame_dig -1
int 1
int 10
*
getbyte
frame_bury 11
frame_dig -1
int 1
int 11
*
getbyte
frame_bury 12
frame_dig -1
int 1
int 12
*
getbyte
frame_bury 13
frame_dig -1
int 1
int 13
*
getbyte
frame_bury 14
frame_dig -1
int 1
int 14
*
getbyte
frame_bury 15
frame_dig -1
int 1
int 15
*
getbyte
frame_bury 16
frame_dig 1
callsub numericalcomp_0
frame_bury 1
frame_dig 2
callsub numericalcomp_0
frame_bury 2
frame_dig 3
callsub numericalcomp_0
frame_bury 3
frame_dig 4
callsub numericalcomp_0
frame_bury 4
frame_dig 5
callsub numericalcomp_0
frame_bury 5
frame_dig 6
callsub numericalcomp_0
frame_bury 6
frame_dig 7
callsub numericalcomp_0
frame_bury 7
frame_dig 8
callsub numericalcomp_0
frame_bury 8
frame_dig 9
callsub numericalcomp_0
frame_bury 9
frame_dig 10
callsub numericalcomp_0
frame_bury 10
frame_dig 11
callsub numericalcomp_0
frame_bury 11
frame_dig 12
callsub numericalcomp_0
frame_bury 12
frame_dig 13
callsub numericalcomp_0
frame_bury 13
frame_dig 14
callsub numericalcomp_0
frame_bury 14
frame_dig 15
callsub numericalcomp_0
frame_bury 15
frame_dig 16
callsub numericalcomp_0
frame_bury 16
byte 0x00
int 0
frame_dig 1
setbyte
byte 0x00
int 0
frame_dig 2
setbyte
concat
byte 0x00
int 0
frame_dig 3
setbyte
concat
byte 0x00
int 0
frame_dig 4
setbyte
concat
byte 0x00
int 0
frame_dig 5
setbyte
concat
byte 0x00
int 0
frame_dig 6
setbyte
concat
byte 0x00
int 0
frame_dig 7
setbyte
concat
byte 0x00
int 0
frame_dig 8
setbyte
concat
byte 0x00
int 0
frame_dig 9
setbyte
concat
byte 0x00
int 0
frame_dig 10
setbyte
concat
byte 0x00
int 0
frame_dig 11
setbyte
concat
byte 0x00
int 0
frame_dig 12
setbyte
concat
byte 0x00
int 0
frame_dig 13
setbyte
concat
byte 0x00
int 0
frame_dig 14
setbyte
concat
byte 0x00
int 0
frame_dig 15
setbyte
concat
byte 0x00
int 0
frame_dig 16
setbyte
concat
frame_bury 0
retsub

// round_tripper
roundtripper_2:
proto 1 1
byte ""
dupn 2
int 0
dup
byte ""
dup
frame_dig -1
callsub arraycomplement_1
frame_bury 1
frame_dig 1
callsub arraycomplement_1
frame_bury 2
frame_dig -1
frame_dig 1
concat
frame_dig 2
concat
frame_bury 0
retsub


================================================
FILE: tests/integration/teal/roundtrip/app_roundtrip_byte[]_36_v6.teal
================================================
#pragma version 6
txna ApplicationArgs 0
store 1
load 1
callsub roundtripper_2
store 0
byte 0x151f7c75
load 0
concat
log
int 1
return

// numerical_comp
numericalcomp_0:
store 44
int 255
load 44
-
store 45
load 45
int 256
<
assert
load 45
retsub

// array_complement
arraycomplement_1:
store 6
load 6
int 1
int 0
*
int 2
+
getbyte
store 8
load 6
int 1
int 1
*
int 2
+
getbyte
store 9
load 6
int 1
int 2
*
int 2
+
getbyte
store 10
load 6
int 1
int 3
*
int 2
+
getbyte
store 11
load 6
int 1
int 4
*
int 2
+
getbyte
store 12
load 6
int 1
int 5
*
int 2
+
getbyte
store 13
load 6
int 1
int 6
*
int 2
+
getbyte
store 14
load 6
int 1
int 7
*
int 2
+
getbyte
store 15
load 6
int 1
int 8
*
int 2
+
getbyte
store 16
load 6
int 1
int 9
*
int 2
+
getbyte
store 17
load 6
int 1
int 10
*
int 2
+
getbyte
store 18
load 6
int 1
int 11
*
int 2
+
getbyte
store 19
load 6
int 1
int 12
*
int 2
+
getbyte
store 20
load 6
int 1
int 13
*
int 2
+
getbyte
store 21
load 6
int 1
int 14
*
int 2
+
getbyte
store 22
load 6
int 1
int 15
*
int 2
+
getbyte
store 23
load 6
int 1
int 16
*
int 2
+
getbyte
store 24
load 6
int 1
int 17
*
int 2
+
getbyte
store 25
load 6
int 1
int 18
*
int 2
+
getbyte
store 26
load 6
int 1
int 19
*
int 2
+
getbyte
store 27
load 6
int 1
int 20
*
int 2
+
getbyte
store 28
load 6
int 1
int 21
*
int 2
+
getbyte
store 29
load 6
int 1
int 22
*
int 2
+
getbyte
store 30
load 6
int 1
int 23
*
int 2
+
getbyte
store 31
load 6
int 1
int 24
*
int 2
+
getbyte
store 32
load 6
int 1
int 25
*
int 2
+
getbyte
store 33
load 6
int 1
int 26
*
int 2
+
getbyte
store 34
load 6
int 1
int 27
*
int 2
+
getbyte
store 35
load 6
int 1
int 28
*
int 2
+
getbyte
store 36
load 6
int 1
int 29
*
int 2
+
getbyte
store 37
load 6
int 1
int 30
*
int 2
+
getbyte
store 38
load 6
int 1
int 31
*
int 2
+
getbyte
store 39
load 6
int 1
int 32
*
int 2
+
getbyte
store 40
load 6
int 1
int 33
*
int 2
+
getbyte
store 41
load 6
int 1
int 34
*
int 2
+
getbyte
store 42
load 6
int 1
int 35
*
int 2
+
getbyte
store 43
load 8
callsub numericalcomp_0
store 8
load 9
callsub numericalcomp_0
store 9
load 10
callsub numericalcomp_0
store 10
load 11
callsub numericalcomp_0
store 11
load 12
callsub numericalcomp_0
store 12
load 13
callsub numericalcomp_0
store 13
load 14
callsub numericalcomp_0
store 14
load 15
callsub numericalcomp_0
store 15
load 16
callsub numericalcomp_0
store 16
load 17
callsub numericalcomp_0
store 17
load 18
callsub numericalcomp_0
store 18
load 19
callsub numericalcomp_0
store 19
load 20
callsub numericalcomp_0
store 20
load 21
callsub numericalcomp_0
store 21
load 22
callsub numericalcomp_0
store 22
load 23
callsub numericalcomp_0
store 23
load 24
callsub numericalcomp_0
store 24
load 25
callsub numericalcomp_0
store 25
load 26
callsub numericalcomp_0
store 26
load 27
callsub numericalcomp_0
store 27
load 28
callsub numericalcomp_0
store 28
load 29
callsub numericalcomp_0
store 29
load 30
callsub numericalcomp_0
store 30
load 31
callsub numericalcomp_0
store 31
load 32
callsub numericalcomp_0
store 32
load 33
callsub numericalcomp_0
store 33
load 34
callsub numericalcomp_0
store 34
load 35
callsub numericalcomp_0
store 35
load 36
callsub numericalcomp_0
store 36
load 37
callsub numericalcomp_0
store 37
load 38
callsub numericalcomp_0
store 38
load 39
callsub numericalcomp_0
store 39
load 40
callsub numericalcomp_0
store 40
load 41
callsub numericalcomp_0
store 41
load 42
callsub numericalcomp_0
store 42
load 43
callsub numericalcomp_0
store 43
int 36
store 46
load 46
itob
extract 6 0
byte 0x00
int 0
load 8
setbyte
byte 0x00
int 0
load 9
setbyte
concat
byte 0x00
int 0
load 10
setbyte
concat
byte 0x00
int 0
load 11
setbyte
concat
byte 0x00
int 0
load 12
setbyte
concat
byte 0x00
int 0
load 13
setbyte
concat
byte 0x00
int 0
load 14
setbyte
concat
byte 0x00
int 0
load 15
setbyte
concat
byte 0x00
int 0
load 16
setbyte
concat
byte 0x00
int 0
load 17
setbyte
concat
byte 0x00
int 0
load 18
setbyte
concat
byte 0x00
int 0
load 19
setbyte
concat
byte 0x00
int 0
load 20
setbyte
concat
byte 0x00
int 0
load 21
setbyte
concat
byte 0x00
int 0
load 22
setbyte
concat
byte 0x00
int 0
load 23
setbyte
concat
byte 0x00
int 0
load 24
setbyte
concat
byte 0x00
int 0
load 25
setbyte
concat
byte 0x00
int 0
load 26
setbyte
concat
byte 0x00
int 0
load 27
setbyte
concat
byte 0x00
int 0
load 28
setbyte
concat
byte 0x00
int 0
load 29
setbyte
concat
byte 0x00
int 0
load 30
setbyte
concat
byte 0x00
int 0
load 31
setbyte
concat
byte 0x00
int 0
load 32
setbyte
concat
byte 0x00
int 0
load 33
setbyte
concat
byte 0x00
int 0
load 34
setbyte
concat
byte 0x00
int 0
load 35
setbyte
concat
byte 0x00
int 0
load 36
setbyte
concat
byte 0x00
int 0
load 37
setbyte
concat
byte 0x00
int 0
load 38
setbyte
concat
byte 0x00
int 0
load 39
setbyte
concat
byte 0x00
int 0
load 40
setbyte
concat
byte 0x00
int 0
load 41
setbyte
concat
byte 0x00
int 0
load 42
setbyte
concat
byte 0x00
int 0
load 43
setbyte
concat
concat
store 7
load 7
retsub

// round_tripper
roundtripper_2:
store 2
load 2
callsub arraycomplement_1
store 4
load 4
callsub arraycomplement_1
store 5
load 2
store 50
load 50
store 49
int 6
store 47
load 47
load 50
len
+
store 48
load 48
int 65536
<
assert
load 47
itob
extract 6 0
load 4
store 50
load 49
load 50
concat
store 49
load 48
store 47
load 47
load 50
len
+
store 48
load 48
int 65536
<
assert
load 47
itob
extract 6 0
concat
load 5
store 50
load 49
load 50
concat
store 49
load 48
store 47
load 47
itob
extract 6 0
concat
load 49
concat
store 3
load 3
retsub


================================================
FILE: tests/integration/teal/roundtrip/app_roundtrip_byte[]_36_v8.teal
================================================
#pragma version 8
txna ApplicationArgs 0
store 1
load 1
callsub roundtripper_2
store 0
byte 0x151f7c75
load 0
concat
log
int 1
return

// numerical_comp
numericalcomp_0:
proto 1 1
int 0
int 255
frame_dig -1
-
frame_bury 0
frame_dig 0
int 256
<
assert
retsub

// array_complement
arraycomplement_1:
proto 1 1
byte ""
int 0
dupn 73
byte ""
dup
int 0
frame_dig -1
int 1
int 0
*
int 2
+
getbyte
frame_bury 1
frame_dig -1
int 1
int 1
*
int 2
+
getbyte
frame_bury 2
frame_dig -1
int 1
int 2
*
int 2
+
getbyte
frame_bury 3
frame_dig -1
int 1
int 3
*
int 2
+
getbyte
frame_bury 4
frame_dig -1
int 1
int 4
*
int 2
+
getbyte
frame_bury 5
frame_dig -1
int 1
int 5
*
int 2
+
getbyte
frame_bury 6
frame_dig -1
int 1
int 6
*
int 2
+
getbyte
frame_bury 7
frame_dig -1
int 1
int 7
*
int 2
+
getbyte
frame_bury 8
frame_dig -1
int 1
int 8
*
int 2
+
getbyte
frame_bury 9
frame_dig -1
int 1
int 9
*
int 2
+
getbyte
frame_bury 10
frame_dig -1
int 1
int 10
*
int 2
+
getbyte
frame_bury 11
frame_dig -1
int 1
int 11
*
int 2
+
getbyte
frame_bury 12
frame_dig -1
int 1
int 12
*
int 2
+
getbyte
frame_bury 13
frame_dig -1
int 1
int 13
*
int 2
+
getbyte
frame_bury 14
frame_dig -1
int 1
int 14
*
int 2
+
getbyte
frame_bury 15
frame_dig -1
int 1
int 15
*
int 2
+
getbyte
frame_bury 16
frame_dig -1
int 1
int 16
*
int 2
+
getbyte
frame_bury 17
frame_dig -1
int 1
int 17
*
int 2
+
getbyte
frame_bury 18
frame_dig -1
int 1
int 18
*
int 2
+
getbyte
frame_bury 19
frame_dig -1
int 1
int 19
*
int 2
+
getbyte
frame_bury 20
frame_dig -1
int 1
int 20
*
int 2
+
getbyte
frame_bury 21
frame_dig -1
int 1
int 21
*
int 2
+
getbyte
frame_bury 22
frame_dig -1
int 1
int 22
*
int 2
+
getbyte
frame_bury 23
frame_dig -1
int 1
int 23
*
int 2
+
getbyte
frame_bury 24
frame_dig -1
int 1
int 24
*
int 2
+
getbyte
frame_bury 25
frame_dig -1
int 1
int 25
*
int 2
+
getbyte
frame_bury 26
frame_dig -1
int 1
int 26
*
int 2
+
getbyte
frame_bury 27
frame_dig -1
int 1
int 27
*
int 2
+
getbyte
frame_bury 28
frame_dig -1
int 1
int 28
*
int 2
+
getbyte
frame_bury 29
frame_dig -1
int 1
int 29
*
int 2
+
getbyte
frame_bury 30
frame_dig -1
int 1
int 30
*
int 2
+
getbyte
frame_bury 31
frame_dig -1
int 1
int 31
*
int 2
+
getbyte
frame_bury 32
frame_dig -1
int 1
int 32
*
int 2
+
getbyte
frame_bury 33
frame_dig -1
int 1
int 33
*
int 2
+
getbyte
frame_bury 34
frame_dig -1
int 1
int 34
*
int 2
+
getbyte
frame_bury 35
frame_dig -1
int 1
int 35
*
int 2
+
getbyte
frame_bury 36
frame_dig 1
callsub numericalcomp_0
frame_bury 1
frame_dig 2
callsub numericalcomp_0
frame_bury 2
frame_dig 3
callsub numericalcomp_0
frame_bury 3
frame_dig 4
callsub numericalcomp_0
frame_bury 4
frame_dig 5
callsub numericalcomp_0
frame_bury 5
frame_dig 6
callsub numericalcomp_0
frame_bury 6
frame_dig 7
callsub numericalcomp_0
frame_bury 7
frame_dig 8
callsub numericalcomp_0
frame_bury 8
frame_dig 9
callsub numericalcomp_0
frame_bury 9
frame_dig 10
callsub numericalcomp_0
frame_bury 10
frame_dig 11
callsub numericalcomp_0
frame_bury 11
frame_dig 12
callsub numericalcomp_0
frame_bury 12
frame_dig 13
callsub numericalcomp_0
frame_bury 13
frame_dig 14
callsub numericalcomp_0
frame_bury 14
frame_dig 15
callsub numericalcomp_0
frame_bury 15
frame_dig 16
callsub numericalcomp_0
frame_bury 16
frame_dig 17
callsub numericalcomp_0
frame_bury 17
frame_dig 18
callsub numericalcomp_0
frame_bury 18
frame_dig 19
callsub numericalcomp_0
frame_bury 19
frame_dig 20
callsub numericalcomp_0
frame_bury 20
frame_dig 21
callsub numericalcomp_0
frame_bury 21
frame_dig 22
callsub numericalcomp_0
frame_bury 22
frame_dig 23
callsub numericalcomp_0
frame_bury 23
frame_dig 24
callsub numericalcomp_0
frame_bury 24
frame_dig 25
callsub numericalcomp_0
frame_bury 25
frame_dig 26
callsub numericalcomp_0
frame_bury 26
frame_dig 27
callsub numericalcomp_0
frame_bury 27
frame_dig 28
callsub numericalcomp_0
frame_bury 28
frame_dig 29
callsub numericalcomp_0
frame_bury 29
frame_dig 30
callsub numericalcomp_0
frame_bury 30
frame_dig 31
callsub numericalcomp_0
frame_bury 31
frame_dig 32
callsub numericalcomp_0
frame_bury 32
frame_dig 33
callsub numericalcomp_0
frame_bury 33
frame_dig 34
callsub numericalcomp_0
frame_bury 34
frame_dig 35
callsub numericalcomp_0
frame_bury 35
frame_dig 36
callsub numericalcomp_0
frame_bury 36
int 36
frame_bury 77
frame_dig 77
itob
extract 6 0
byte 0x00
int 0
frame_dig 1
setbyte
byte 0x00
int 0
frame_dig 2
setbyte
concat
byte 0x00
int 0
frame_dig 3
setbyte
concat
byte 0x00
int 0
frame_dig 4
setbyte
concat
byte 0x00
int 0
frame_dig 5
setbyte
concat
byte 0x00
int 0
frame_dig 6
setbyte
concat
byte 0x00
int 0
frame_dig 7
setbyte
concat
byte 0x00
int 0
frame_dig 8
setbyte
concat
byte 0x00
int 0
frame_dig 9
setbyte
concat
byte 0x00
int 0
frame_dig 10
setbyte
concat
byte 0x00
int 0
frame_dig 11
setbyte
concat
byte 0x00
int 0
frame_dig 12
setbyte
concat
byte 0x00
int 0
frame_dig 13
setbyte
concat
byte 0x00
int 0
frame_dig 14
setbyte
concat
byte 0x00
int 0
frame_dig 15
setbyte
concat
byte 0x00
int 0
frame_dig 16
setbyte
concat
byte 0x00
int 0
frame_dig 17
setbyte
concat
byte 0x00
int 0
frame_dig 18
setbyte
concat
byte 0x00
int 0
frame_dig 19
setbyte
concat
byte 0x00
int 0
frame_dig 20
setbyte
concat
byte 0x00
int 0
frame_dig 21
setbyte
concat
byte 0x00
int 0
frame_dig 22
setbyte
concat
byte 0x00
int 0
frame_dig 23
setbyte
concat
byte 0x00
int 0
frame_dig 24
setbyte
concat
byte 0x00
int 0
frame_dig 25
setbyte
concat
byte 0x00
int 0
frame_dig 26
setbyte
concat
byte 0x00
int 0
frame_dig 27
setbyte
concat
byte 0x00
int 0
frame_dig 28
setbyte
concat
byte 0x00
int 0
frame_dig 29
setbyte
concat
byte 0x00
int 0
frame_dig 30
setbyte
concat
byte 0x00
int 0
frame_dig 31
setbyte
concat
byte 0x00
int 0
frame_dig 32
setbyte
concat
byte 0x00
int 0
frame_dig 33
setbyte
concat
byte 0x00
int 0
frame_dig 34
setbyte
concat
byte 0x00
int 0
frame_dig 35
setbyte
concat
byte 0x00
int 0
frame_dig 36
setbyte
concat
concat
frame_bury 0
retsub

// round_tripper
roundtripper_2:
proto 1 1
byte ""
dupn 2
int 0
dup
byte ""
dup
frame_dig -1
callsub arraycomplement_1
frame_bury 1
frame_dig 1
callsub arraycomplement_1
frame_bury 2
frame_dig -1
frame_bury 6
frame_dig 6
frame_bury 5
int 6
frame_bury 3
frame_dig 3
frame_dig 6
len
+
frame_bury 4
frame_dig 4
int 65536
<
assert
frame_dig 3
itob
extract 6 0
frame_dig 1
frame_bury 6
frame_dig 5
frame_dig 6
concat
frame_bury 5
frame_dig 4
frame_bury 3
frame_dig 3
frame_dig 6
len
+
frame_bury 4
frame_dig 4
int 65536
<
assert
frame_dig 3
itob
extract 6 0
concat
frame_dig 2
frame_bury 6
frame_dig 5
frame_dig 6
concat
frame_bury 5
frame_dig 4
frame_bury 3
frame_dig 3
itob
extract 6 0
concat
frame_dig 5
concat
frame_bury 0
retsub


================================================
FILE: tests/integration/teal/roundtrip/app_roundtrip_byte_v6.teal
================================================
#pragma version 6
txna ApplicationArgs 0
int 0
getbyte
store 1
load 1
callsub roundtripper_1
store 0
byte 0x151f7c75
load 0
concat
log
int 1
return

// numerical_comp
numericalcomp_0:
store 6
int 255
load 6
-
store 7
load 7
int 256
<
assert
load 7
retsub

// round_tripper
roundtripper_1:
store 2
load 2
callsub numericalcomp_0
store 4
load 4
callsub numericalcomp_0
store 5
byte 0x00
int 0
load 2
setbyte
byte 0x00
int 0
load 4
setbyte
concat
byte 0x00
int 0
load 5
setbyte
concat
store 3
load 3
retsub


================================================
FILE: tests/integration/teal/roundtrip/app_roundtrip_byte_v8.teal
================================================
#pragma version 8
txna ApplicationArgs 0
int 0
getbyte
store 1
load 1
callsub roundtripper_1
store 0
byte 0x151f7c75
load 0
concat
log
int 1
return

// numerical_comp
numericalcomp_0:
proto 1 1
int 0
int 255
frame_dig -1
-
frame_bury 0
frame_dig 0
int 256
<
assert
retsub

// round_tripper
roundtripper_1:
proto 1 1
byte ""
int 0
dupn 3
byte ""
dup
frame_dig -1
callsub numericalcomp_0
frame_bury 1
frame_dig 1
callsub numericalcomp_0
frame_bury 2
byte 0x00
int 0
frame_dig -1
setbyte
byte 0x00
int 0
frame_dig 1
setbyte
concat
byte 0x00
int 0
frame_dig 2
setbyte
concat
frame_bury 0
retsub


================================================
FILE: tests/integration/teal/roundtrip/app_roundtrip_string_0_v6.teal
================================================
#pragma version 6
txna ApplicationArgs 0
store 1
load 1
callsub roundtripper_1
store 0
byte 0x151f7c75
load 0
concat
log
int 1
return

// string_reverse
stringreverse_0:
store 6
int 0
store 8
load 8
itob
extract 6 0
byte ""
concat
store 7
load 7
retsub

// round_tripper
roundtripper_1:
store 2
load 2
callsub stringreverse_0
store 4
load 4
callsub stringreverse_0
store 5
load 2
store 12
load 12
store 11
int 6
store 9
load 9
load 12
len
+
store 10
load 10
int 65536
<
assert
load 9
itob
extract 6 0
load 4
store 12
load 11
load 12
concat
store 11
load 10
store 9
load 9
load 12
len
+
store 10
load 10
int 65536
<
assert
load 9
itob
extract 6 0
concat
load 5
store 12
load 11
load 12
concat
store 11
load 10
store 9
load 9
itob
extract 6 0
concat
load 11
concat
store 3
load 3
retsub


================================================
FILE: tests/integration/teal/roundtrip/app_roundtrip_string_0_v8.teal
================================================
#pragma version 8
txna ApplicationArgs 0
store 1
load 1
callsub roundtripper_1
store 0
byte 0x151f7c75
load 0
concat
log
int 1
return

// string_reverse
stringreverse_0:
proto 1 1
byte ""
int 0
dup
byte ""
dup
int 0
int 0
frame_bury 5
frame_dig 5
itob
extract 6 0
byte ""
concat
frame_bury 0
retsub

// round_tripper
roundtripper_1:
proto 1 1
byte ""
dupn 2
int 0
dup
byte ""
dup
frame_dig -1
callsub stringreverse_0
frame_bury 1
frame_dig 1
callsub stringreverse_0
frame_bury 2
frame_dig -1
frame_bury 6
frame_dig 6
frame_bury 5
int 6
frame_bury 3
frame_dig 3
frame_dig 6
len
+
frame_bury 4
frame_dig 4
int 65536
<
assert
frame_dig 3
itob
extract 6 0
frame_dig 1
frame_bury 6
frame_dig 5
frame_dig 6
concat
frame_bury 5
frame_dig 4
frame_bury 3
frame_dig 3
frame_dig 6
len
+
frame_bury 4
frame_dig 4
int 65536
<
assert
frame_dig 3
itob
extract 6 0
concat
frame_dig 2
frame_bury 6
frame_dig 5
frame_dig 6
concat
frame_bury 5
frame_dig 4
frame_bury 3
frame_dig 3
itob
extract 6 0
concat
frame_dig 5
concat
frame_bury 0
retsub


================================================
FILE: tests/integration/teal/roundtrip/app_roundtrip_string_13_v6.teal
================================================
#pragma version 6
txna ApplicationArgs 0
store 1
load 1
callsub roundtripper_1
store 0
byte 0x151f7c75
load 0
concat
log
int 1
return

// string_reverse
stringreverse_0:
store 6
load 6
int 1
int 0
*
int 2
+
getbyte
store 20
load 6
int 1
int 1
*
int 2
+
getbyte
store 19
load 6
int 1
int 2
*
int 2
+
getbyte
store 18
load 6
int 1
int 3
*
int 2
+
getbyte
store 17
load 6
int 1
int 4
*
int 2
+
getbyte
store 16
load 6
int 1
int 5
*
int 2
+
getbyte
store 15
load 6
int 1
int 6
*
int 2
+
getbyte
store 14
load 6
int 1
int 7
*
int 2
+
getbyte
store 13
load 6
int 1
int 8
*
int 2
+
getbyte
store 12
load 6
int 1
int 9
*
int 2
+
getbyte
store 11
load 6
int 1
int 10
*
int 2
+
getbyte
store 10
load 6
int 1
int 11
*
int 2
+
getbyte
store 9
load 6
int 1
int 12
*
int 2
+
getbyte
store 8
int 13
store 21
load 21
itob
extract 6 0
byte 0x00
int 0
load 8
setbyte
byte 0x00
int 0
load 9
setbyte
concat
byte 0x00
int 0
load 10
setbyte
concat
byte 0x00
int 0
load 11
setbyte
concat
byte 0x00
int 0
load 12
setbyte
concat
byte 0x00
int 0
load 13
setbyte
concat
byte 0x00
int 0
load 14
setbyte
concat
byte 0x00
int 0
load 15
setbyte
concat
byte 0x00
int 0
load 16
setbyte
concat
byte 0x00
int 0
load 17
setbyte
concat
byte 0x00
int 0
load 18
setbyte
concat
byte 0x00
int 0
load 19
setbyte
concat
byte 0x00
int 0
load 20
setbyte
concat
concat
store 7
load 7
retsub

// round_tripper
roundtripper_1:
store 2
load 2
callsub stringreverse_0
store 4
load 4
callsub stringreverse_0
store 5
load 2
store 25
load 25
store 24
int 6
store 22
load 22
load 25
len
+
store 23
load 23
int 65536
<
assert
load 22
itob
extract 6 0
load 4
store 25
load 24
load 25
concat
store 24
load 23
store 22
load 22
load 25
len
+
store 23
load 23
int 65536
<
assert
load 22
itob
extract 6 0
concat
load 5
store 25
load 24
load 25
concat
store 24
load 23
store 22
load 22
itob
extract 6 0
concat
load 24
concat
store 3
load 3
retsub


================================================
FILE: tests/integration/teal/roundtrip/app_roundtrip_string_13_v8.teal
================================================
#pragma version 8
txna ApplicationArgs 0
store 1
load 1
callsub roundtripper_1
store 0
byte 0x151f7c75
load 0
concat
log
int 1
return

// string_reverse
stringreverse_0:
proto 1 1
byte ""
int 0
dupn 27
byte ""
dup
int 0
frame_dig -1
int 1
int 0
*
int 2
+
getbyte
frame_bury 13
frame_dig -1
int 1
int 1
*
int 2
+
getbyte
frame_bury 12
frame_dig -1
int 1
int 2
*
int 2
+
getbyte
frame_bury 11
frame_dig -1
int 1
int 3
*
int 2
+
getbyte
frame_bury 10
frame_dig -1
int 1
int 4
*
int 2
+
getbyte
frame_bury 9
frame_dig -1
int 1
int 5
*
int 2
+
getbyte
frame_bury 8
frame_dig -1
int 1
int 6
*
int 2
+
getbyte
frame_bury 7
frame_dig -1
int 1
int 7
*
int 2
+
getbyte
frame_bury 6
frame_dig -1
int 1
int 8
*
int 2
+
getbyte
frame_bury 5
frame_dig -1
int 1
int 9
*
int 2
+
getbyte
frame_bury 4
frame_dig -1
int 1
int 10
*
int 2
+
getbyte
frame_bury 3
frame_dig -1
int 1
int 11
*
int 2
+
getbyte
frame_bury 2
frame_dig -1
int 1
int 12
*
int 2
+
getbyte
frame_bury 1
int 13
frame_bury 31
frame_dig 31
itob
extract 6 0
byte 0x00
int 0
frame_dig 1
setbyte
byte 0x00
int 0
frame_dig 2
setbyte
concat
byte 0x00
int 0
frame_dig 3
setbyte
concat
byte 0x00
int 0
frame_dig 4
setbyte
concat
byte 0x00
int 0
frame_dig 5
setbyte
concat
byte 0x00
int 0
frame_dig 6
setbyte
concat
byte 0x00
int 0
frame_dig 7
setbyte
concat
byte 0x00
int 0
frame_dig 8
setbyte
concat
byte 0x00
int 0
frame_dig 9
setbyte
concat
byte 0x00
int 0
frame_dig 10
setbyte
concat
byte 0x00
int 0
frame_dig 11
setbyte
concat
byte 0x00
int 0
frame_dig 12
setbyte
concat
byte 0x00
int 0
frame_dig 13
setbyte
concat
concat
frame_bury 0
retsub

// round_tripper
roundtripper_1:
proto 1 1
byte ""
dupn 2
int 0
dup
byte ""
dup
frame_dig -1
callsub stringreverse_0
frame_bury 1
frame_dig 1
callsub stringreverse_0
frame_bury 2
frame_dig -1
frame_bury 6
frame_dig 6
frame_bury 5
int 6
frame_bury 3
frame_dig 3
frame_dig 6
len
+
frame_bury 4
frame_dig 4
int 65536
<
assert
frame_dig 3
itob
extract 6 0
frame_dig 1
frame_bury 6
frame_dig 5
frame_dig 6
concat
frame_bury 5
frame_dig 4
frame_bury 3
frame_dig 3
frame_dig 6
len
+
frame_bury 4
frame_dig 4
int 65536
<
assert
frame_dig 3
itob
extract 6 0
concat
frame_dig 2
frame_bury 6
frame_dig 5
frame_dig 6
concat
frame_bury 5
frame_dig 4
frame_bury 3
frame_dig 3
itob
extract 6 0
concat
frame_dig 5
concat
frame_bury 0
retsub


================================================
FILE: tests/integration/teal/roundtrip/app_roundtrip_string_1_v6.teal
================================================
#pragma version 6
txna ApplicationArgs 0
store 1
load 1
callsub roundtripper_1
store 0
byte 0x151f7c75
load 0
concat
log
int 1
return

// string_reverse
stringreverse_0:
store 6
load 6
int 1
int 0
*
int 2
+
getbyte
store 8
int 1
store 9
load 9
itob
extract 6 0
byte 0x00
int 0
load 8
setbyte
concat
store 7
load 7
retsub

// round_tripper
roundtripper_1:
store 2
load 2
callsub stringreverse_0
store 4
load 4
callsub stringreverse_0
store 5
load 2
store 13
load 13
store 12
int 6
store 10
load 10
load 13
len
+
store 11
load 11
int 65536
<
assert
load 10
itob
extract 6 0
load 4
store 13
load 12
load 13
concat
store 12
load 11
store 10
load 10
load 13
len
+
store 11
load 11
int 65536
<
assert
load 10
itob
extract 6 0
concat
load 5
store 13
load 12
load 13
concat
store 12
load 11
store 10
load 10
itob
extract 6 0
concat
load 12
concat
store 3
load 3
retsub


================================================
FILE: tests/integration/teal/roundtrip/app_roundtrip_string_1_v8.teal
================================================
#pragma version 8
txna ApplicationArgs 0
store 1
load 1
callsub roundtripper_1
store 0
byte 0x151f7c75
load 0
concat
log
int 1
return

// string_reverse
stringreverse_0:
proto 1 1
byte ""
int 0
dupn 3
byte ""
dup
int 0
frame_dig -1
int 1
int 0
*
int 2
+
getbyte
frame_bury 1
int 1
frame_bury 7
frame_dig 7
itob
extract 6 0
byte 0x00
int 0
frame_dig 1
setbyte
concat
frame_bury 0
retsub

// round_tripper
roundtripper_1:
proto 1 1
byte ""
dupn 2
int 0
dup
byte ""
dup
frame_dig -1
callsub stringreverse_0
frame_bury 1
frame_dig 1
callsub stringreverse_0
frame_bury 2
frame_dig -1
frame_bury 6
frame_dig 6
frame_bury 5
int 6
frame_bury 3
frame_dig 3
frame_dig 6
len
+
frame_bury 4
frame_dig 4
int 65536
<
assert
frame_dig 3
itob
extract 6 0
frame_dig 1
frame_bury 6
frame_dig 5
frame_dig 6
concat
frame_bury 5
frame_dig 4
frame_bury 3
frame_dig 3
frame_dig 6
len
+
frame_bury 4
frame_dig 4
int 65536
<
assert
frame_dig 3
itob
extract 6 0
concat
frame_dig 2
frame_bury 6
frame_dig 5
frame_dig 6
concat
frame_bury 5
frame_dig 4
frame_bury 3
frame_dig 3
itob
extract 6 0
concat
frame_dig 5
concat
frame_bury 0
retsub


================================================
FILE: tests/integration/teal/roundtrip/app_roundtrip_uint16_v6.teal
================================================
#pragma version 6
txna ApplicationArgs 0
int 0
extract_uint16
store 1
load 1
callsub roundtripper_1
store 0
byte 0x151f7c75
load 0
concat
log
int 1
return

// numerical_comp
numericalcomp_0:
store 6
int 65535
load 6
-
store 7
load 7
int 65536
<
assert
load 7
retsub

// round_tripper
roundtripper_1:
store 2
load 2
callsub numericalcomp_0
store 4
load 4
callsub numericalcomp_0
store 5
load 2
itob
extract 6 0
load 4
itob
extract 6 0
concat
load 5
itob
extract 6 0
concat
store 3
load 3
retsub


================================================
FILE: tests/integration/teal/roundtrip/app_roundtrip_uint16_v8.teal
================================================
#pragma version 8
txna ApplicationArgs 0
int 0
extract_uint16
store 1
load 1
callsub roundtripper_1
store 0
byte 0x151f7c75
load 0
concat
log
int 1
return

// numerical_comp
numericalcomp_0:
proto 1 1
int 0
int 65535
frame_dig -1
-
frame_bury 0
frame_dig 0
int 65536
<
assert
retsub

// round_tripper
roundtripper_1:
proto 1 1
byte ""
int 0
dupn 3
byte ""
dup
frame_dig -1
callsub numericalcomp_0
frame_bury 1
frame_dig 1
callsub numericalcomp_0
frame_bury 2
frame_dig -1
itob
extract 6 0
frame_dig 1
itob
extract 6 0
concat
frame_dig 2
itob
extract 6 0
concat
frame_bury 0
retsub


================================================
FILE: tests/integration/teal/roundtrip/app_roundtrip_uint32_v6.teal
================================================
#pragma version 6
txna ApplicationArgs 0
int 0
extract_uint32
store 1
load 1
callsub roundtripper_1
store 0
byte 0x151f7c75
load 0
concat
log
int 1
return

// numerical_comp
numericalcomp_0:
store 6
int 4294967295
load 6
-
store 7
load 7
int 4294967296
<
assert
load 7
retsub

// round_tripper
roundtripper_1:
store 2
load 2
callsub numericalcomp_0
store 4
load 4
callsub numericalcomp_0
store 5
load 2
itob
extract 4 0
load 4
itob
extract 4 0
concat
load 5
itob
extract 4 0
concat
store 3
load 3
retsub


================================================
FILE: tests/integration/teal/roundtrip/app_roundtrip_uint32_v8.teal
================================================
#pragma version 8
txna ApplicationArgs 0
int 0
extract_uint32
store 1
load 1
callsub roundtripper_1
store 0
byte 0x151f7c75
load 0
concat
log
int 1
return

// numerical_comp
numericalcomp_0:
proto 1 1
int 0
int 4294967295
frame_dig -1
-
frame_bury 0
frame_dig 0
int 4294967296
<
assert
retsub

// round_tripper
roundtripper_1:
proto 1 1
byte ""
int 0
dupn 3
byte ""
dup
frame_dig -1
callsub numericalcomp_0
frame_bury 1
frame_dig 1
callsub numericalcomp_0
frame_bury 2
frame_dig -1
itob
extract 4 0
frame_dig 1
itob
extract 4 0
concat
frame_dig 2
itob
extract 4 0
concat
frame_bury 0
retsub


================================================
FILE: tests/integration/teal/roundtrip/app_roundtrip_uint64[1]_v6.teal
================================================
#pragma version 6
txna ApplicationArgs 0
store 1
load 1
callsub roundtripper_2
store 0
byte 0x151f7c75
load 0
concat
log
int 1
return

// numerical_comp
numericalcomp_0:
store 9
int 18446744073709551615
load 9
-
store 10
load 10
retsub

// array_complement
arraycomplement_1:
store 6
load 6
int 8
int 0
*
extract_uint64
store 8
load 8
callsub numericalcomp_0
store 8
load 8
itob
store 7
load 7
retsub

// round_tripper
roundtripper_2:
store 2
load 2
callsub arraycomplement_1
store 4
load 4
callsub arraycomplement_1
store 5
load 2
load 4
concat
load 5
concat
store 3
load 3
retsub


================================================
FILE: tests/integration/teal/roundtrip/app_roundtrip_uint64[1]_v8.teal
================================================
#pragma version 8
txna ApplicationArgs 0
store 1
load 1
callsub roundtripper_2
store 0
byte 0x151f7c75
load 0
concat
log
int 1
return

// numerical_comp
numericalcomp_0:
proto 1 1
int 0
int 18446744073709551615
frame_dig -1
-
frame_bury 0
retsub

// array_complement
arraycomplement_1:
proto 1 1
byte ""
int 0
dupn 2
byte ""
dup
frame_dig -1
int 8
int 0
*
extract_uint64
frame_bury 1
frame_dig 1
callsub numericalcomp_0
frame_bury 1
frame_dig 1
itob
frame_bury 0
retsub

// round_tripper
roundtripper_2:
proto 1 1
byte ""
dupn 2
int 0
dup
byte ""
dup
frame_dig -1
callsub arraycomplement_1
frame_bury 1
frame_dig 1
callsub arraycomplement_1
frame_bury 2
frame_dig -1
frame_dig 1
concat
frame_dig 2
concat
frame_bury 0
retsub


================================================
FILE: tests/integration/teal/roundtrip/app_roundtrip_uint64[42]_v6.teal
================================================
#pragma version 6
txna ApplicationArgs 0
store 1
load 1
callsub roundtripper_2
store 0
byte 0x151f7c75
load 0
concat
log
int 1
return

// numerical_comp
numericalcomp_0:
store 50
int 18446744073709551615
load 50
-
store 51
load 51
retsub

// array_complement
arraycomplement_1:
store 6
load 6
int 8
int 0
*
extract_uint64
store 8
load 6
int 8
int 1
*
extract_uint64
store 9
load 6
int 8
int 2
*
extract_uint64
store 10
load 6
int 8
int 3
*
extract_uint64
store 11
load 6
int 8
int 4
*
extract_uint64
store 12
load 6
int 8
int 5
*
extract_uint64
store 13
load 6
int 8
int 6
*
extract_uint64
store 14
load 6
int 8
int 7
*
extract_uint64
store 15
load 6
int 8
int 8
*
extract_uint64
store 16
load 6
int 8
int 9
*
extract_uint64
store 17
load 6
int 8
int 10
*
extract_uint64
store 18
load 6
int 8
int 11
*
extract_uint64
store 19
load 6
int 8
int 12
*
extract_uint64
store 20
load 6
int 8
int 13
*
extract_uint64
store 21
load 6
int 8
int 14
*
extract_uint64
store 22
load 6
int 8
int 15
*
extract_uint64
store 23
load 6
int 8
int 16
*
extract_uint64
store 24
load 6
int 8
int 17
*
extract_uint64
store 25
load 6
int 8
int 18
*
extract_uint64
store 26
load 6
int 8
int 19
*
extract_uint64
store 27
load 6
int 8
int 20
*
extract_uint64
store 28
load 6
int 8
int 21
*
extract_uint64
store 29
load 6
int 8
int 22
*
extract_uint64
store 30
load 6
int 8
int 23
*
extract_uint64
store 31
load 6
int 8
int 24
*
extract_uint64
store 32
load 6
int 8
int 25
*
extract_uint64
store 33
load 6
int 8
int 26
*
extract_uint64
store 34
load 6
int 8
int 27
*
extract_uint64
store 35
load 6
int 8
int 28
*
extract_uint64
store 36
load 6
int 8
int 29
*
extract_uint64
store 37
load 6
int 8
int 30
*
extract_uint64
store 38
load 6
int 8
int 31
*
extract_uint64
store 39
load 6
int 8
int 32
*
extract_uint64
store 40
load 6
int 8
int 33
*
extract_uint64
store 41
load 6
int 8
int 34
*
extract_uint64
store 42
load 6
int 8
int 35
*
extract_uint64
store 43
load 6
int 8
int 36
*
extract_uint64
store 44
load 6
int 8
int 37
*
extract_uint64
store 45
load 6
int 8
int 38
*
extract_uint64
store 46
load 6
int 8
int 39
*
extract_uint64
store 47
load 6
int 8
int 40
*
extract_uint64
store 48
load 6
int 8
int 41
*
extract_uint64
store 49
load 8
callsub numericalcomp_0
store 8
load 9
callsub numericalcomp_0
store 9
load 10
callsub numericalcomp_0
store 10
load 11
callsub numericalcomp_0
store 11
load 12
callsub numericalcomp_0
store 12
load 13
callsub numericalcomp_0
store 13
load 14
callsub numericalcomp_0
store 14
load 15
callsub numericalcomp_0
store 15
load 16
callsub numericalcomp_0
store 16
load 17
callsub numericalcomp_0
store 17
load 18
callsub numericalcomp_0
store 18
load 19
callsub numericalcomp_0
store 19
load 20
callsub numericalcomp_0
store 20
load 21
callsub numericalcomp_0
store 21
load 22
callsub numericalcomp_0
store 22
load 23
callsub numericalcomp_0
store 23
load 24
callsub numericalcomp_0
store 24
load 25
callsub numericalcomp_0
store 25
load 26
callsub numericalcomp_0
store 26
load 27
callsub numericalcomp_0
store 27
load 28
callsub numericalcomp_0
store 28
load 29
callsub numericalcomp_0
store 29
load 30
callsub numericalcomp_0
store 30
load 31
callsub numericalcomp_0
store 31
load 32
callsub numericalcomp_0
store 32
load 33
callsub numericalcomp_0
store 33
load 34
callsub numericalcomp_0
store 34
load 35
callsub numericalcomp_0
store 35
load 36
callsub numericalcomp_0
store 36
load 37
callsub numericalcomp_0
store 37
load 38
callsub numericalcomp_0
store 38
load 39
callsub numericalcomp_0
store 39
load 40
callsub numericalcomp_0
store 40
load 41
callsub numericalcomp_0
store 41
load 42
callsub numericalcomp_0
store 42
load 43
callsub numericalcomp_0
store 43
load 44
callsub numericalcomp_0
store 44
load 45
callsub numericalcomp_0
store 45
load 46
callsub numericalcomp_0
store 46
load 47
callsub numericalcomp_0
store 47
load 48
callsub numericalcomp_0
store 48
load 49
callsub numericalcomp_0
store 49
load 8
itob
load 9
itob
concat
load 10
itob
concat
load 11
itob
concat
load 12
itob
concat
load 13
itob
concat
load 14
itob
concat
load 15
itob
concat
load 16
itob
concat
load 17
itob
concat
load 18
itob
concat
load 19
itob
concat
load 20
itob
concat
load 21
itob
concat
load 22
itob
concat
load 23
itob
concat
load 24
itob
concat
load 25
itob
concat
load 26
itob
concat
load 27
itob
concat
load 28
itob
concat
load 29
itob
concat
load 30
itob
concat
load 31
itob
concat
load 32
itob
concat
load 33
itob
concat
load 34
itob
concat
load 35
itob
concat
load 36
itob
concat
load 37
itob
concat
load 38
itob
concat
load 39
itob
concat
load 40
itob
concat
load 41
itob
concat
load 42
itob
concat
load 43
itob
concat
load 44
itob
concat
load 45
itob
concat
load 46
itob
concat
load 47
itob
concat
load 48
itob
concat
load 49
itob
concat
store 7
load 7
retsub

// round_tripper
roundtripper_2:
store 2
load 2
callsub arraycomplement_1
store 4
load 4
callsub arraycomplement_1
store 5
load 2
load 4
concat
load 5
concat
store 3
load 3
retsub


================================================
FILE: tests/integration/teal/roundtrip/app_roundtrip_uint64[42]_v8.teal
================================================
#pragma version 8
txna ApplicationArgs 0
store 1
load 1
callsub roundtripper_2
store 0
byte 0x151f7c75
load 0
concat
log
int 1
return

// numerical_comp
numericalcomp_0:
proto 1 1
int 0
int 18446744073709551615
frame_dig -1
-
frame_bury 0
retsub

// array_complement
arraycomplement_1:
proto 1 1
byte ""
int 0
dupn 43
byte ""
dup
frame_dig -1
int 8
int 0
*
extract_uint64
frame_bury 1
frame_dig -1
int 8
int 1
*
extract_uint64
frame_bury 2
frame_dig -1
int 8
int 2
*
extract_uint64
frame_bury 3
frame_dig -1
int 8
int 3
*
extract_uint64
frame_bury 4
frame_dig -1
int 8
int 4
*
extract_uint64
frame_bury 5
frame_dig -1
int 8
int 5
*
extract_uint64
frame_bury 6
frame_dig -1
int 8
int 6
*
extract_uint64
frame_bury 7
frame_dig -1
int 8
int 7
*
extract_uint64
frame_bury 8
frame_dig -1
int 8
int 8
*
extract_uint64
frame_bury 9
frame_dig -1
int 8
int 9
*
extract_uint64
frame_bury 10
frame_dig -1
int 8
int 10
*
extract_uint64
frame_bury 11
frame_dig -1
int 8
int 11
*
extract_uint64
frame_bury 12
frame_dig -1
int 8
int 12
*
extract_uint64
frame_bury 13
frame_dig -1
int 8
int 13
*
extract_uint64
frame_bury 14
frame_dig -1
int 8
int 14
*
extract_uint64
frame_bury 15
frame_dig -1
int 8
int 15
*
extract_uint64
frame_bury 16
frame_dig -1
int 8
int 16
*
extract_uint64
frame_bury 17
frame_dig -1
int 8
int 17
*
extract_uint64
frame_bury 18
frame_dig -1
int 8
int 18
*
extract_uint64
frame_bury 19
frame_dig -1
int 8
int 19
*
extract_uint64
frame_bury 20
frame_dig -1
int 8
int 20
*
extract_uint64
frame_bury 21
frame_dig -1
int 8
int 21
*
extract_uint64
frame_bury 22
frame_dig -1
int 8
int 22
*
extract_uint64
frame_bury 23
frame_dig -1
int 8
int 23
*
extract_uint64
frame_bury 24
frame_dig -1
int 8
int 24
*
extract_uint64
frame_bury 25
frame_dig -1
int 8
int 25
*
extract_uint64
frame_bury 26
frame_dig -1
int 8
int 26
*
extract_uint64
frame_bury 27
frame_dig -1
int 8
int 27
*
extract_uint64
frame_bury 28
frame_dig -1
int 8
int 28
*
extract_uint64
frame_bury 29
frame_dig -1
int 8
int 29
*
extract_uint64
frame_bury 30
frame_dig -1
int 8
int 30
*
extract_uint64
frame_bury 31
frame_dig -1
int 8
int 31
*
extract_uint64
frame_bury 32
frame_dig -1
int 8
int 32
*
extract_uint64
frame_bury 33
frame_dig -1
int 8
int 33
*
extract_uint64
frame_bury 34
frame_dig -1
int 8
int 34
*
extract_uint64
frame_bury 35
frame_dig -1
int 8
int 35
*
extract_uint64
frame_bury 36
frame_dig -1
int 8
int 36
*
extract_uint64
frame_bury 37
frame_dig -1
int 8
int 37
*
extract_uint64
frame_bury 38
frame_dig -1
int 8
int 38
*
extract_uint64
frame_bury 39
frame_dig -1
int 8
int 39
*
extract_uint64
frame_bury 40
frame_dig -1
int 8
int 40
*
extract_uint64
frame_bury 41
frame_dig -1
int 8
int 41
*
extract_uint64
frame_bury 42
frame_dig 1
callsub numericalcomp_0
frame_bury 1
frame_dig 2
callsub numericalcomp_0
frame_bury 2
frame_dig 3
callsub numericalcomp_0
frame_bury 3
frame_dig 4
callsub numericalcomp_0
frame_bury 4
frame_dig 5
callsub numericalcomp_0
frame_bury 5
frame_dig 6
callsub numericalcomp_0
frame_bury 6
frame_dig 7
callsub numericalcomp_0
frame_bury 7
frame_dig 8
callsub numericalcomp_0
frame_bury 8
frame_dig 9
callsub numericalcomp_0
frame_bury 9
frame_dig 10
callsub numericalcomp_0
frame_bury 10
frame_dig 11
callsub numericalcomp_0
frame_bury 11
frame_dig 12
callsub numericalcomp_0
frame_bury 12
frame_dig 13
callsub numericalcomp_0
frame_bury 13
frame_dig 14
callsub numericalcomp_0
frame_bury 14
frame_dig 15
callsub numericalcomp_0
frame_bury 15
frame_dig 16
callsub numericalcomp_0
frame_bury 16
frame_dig 17
callsub numericalcomp_0
frame_bury 17
frame_dig 18
callsub numericalcomp_0
frame_bury 18
frame_dig 19
callsub numericalcomp_0
frame_bury 19
frame_dig 20
callsub numericalcomp_0
frame_bury 20
frame_dig 21
callsub numericalcomp_0
frame_bury 21
frame_dig 22
callsub numericalcomp_0
frame_bury 22
frame_dig 23
callsub numericalcomp_0
frame_bury 23
frame_dig 24
callsub numericalcomp_0
frame_bury 24
frame_dig 25
callsub numericalcomp_0
frame_bury 25
frame_dig 26
callsub numericalcomp_0
frame_bury 26
frame_dig 27
callsub numericalcomp_0
frame_bury 27
frame_dig 28
callsub numericalcomp_0
frame_bury 28
frame_dig 29
callsub numericalcomp_0
frame_bury 29
frame_dig 30
callsub numericalcomp_0
frame_bury 30
frame_dig 31
callsub numericalcomp_0
frame_bury 31
frame_dig 32
callsub numericalcomp_0
frame_bury 32
frame_dig 33
callsub numericalcomp_0
frame_bury 33
frame_dig 34
callsub numericalcomp_0
frame_bury 34
frame_dig 35
callsub numericalcomp_0
frame_bury 35
frame_dig 36
callsub numericalcomp_0
frame_bury 36
frame_dig 37
callsub numericalcomp_0
frame_bury 37
frame_dig 38
callsub numericalcomp_0
frame_bury 38
frame_dig 39
callsub numericalcomp_0
frame_bury 39
frame_dig 40
callsub numericalcomp_0
frame_bury 40
frame_dig 41
callsub numericalcomp_0
frame_bury 41
frame_dig 42
callsub numericalcomp_0
frame_bury 42
frame_dig 1
itob
frame_dig 2
itob
concat
frame_dig 3
itob
concat
frame_dig 4
itob
concat
frame_dig 5
itob
concat
frame_dig 6
itob
concat
frame_dig 7
itob
concat
frame_dig 8
itob
concat
frame_dig 9
itob
concat
frame_dig 10
itob
concat
frame_dig 11
itob
concat
frame_dig 12
itob
concat
frame_dig 13
itob
concat
frame_dig 14
itob
concat
frame_dig 15
itob
concat
frame_dig 16
itob
concat
frame_dig 17
itob
concat
frame_dig 18
itob
concat
frame_dig 19
itob
concat
frame_dig 20
itob
concat
frame_dig 21
itob
concat
frame_dig 22
itob
concat
frame_dig 23
itob
concat
frame_dig 24
itob
concat
frame_dig 25
itob
concat
frame_dig 26
itob
concat
frame_dig 27
itob
concat
frame_dig 28
itob
concat
frame_dig 29
itob
concat
frame_dig 30
itob
concat
frame_dig 31
itob
concat
frame_dig 32
itob
concat
frame_dig 33
itob
concat
frame_dig 34
itob
concat
frame_dig 35
itob
concat
frame_dig 36
itob
concat
frame_dig 37
itob
concat
frame_dig 38
itob
concat
frame_dig 39
itob
concat
frame_dig 40
itob
concat
frame_dig 41
itob
concat
frame_dig 42
itob
concat
frame_bury 0
retsub

// round_tripper
roundtripper_2:
proto 1 1
byte ""
dupn 2
int 0
dup
byte ""
dup
frame_dig -1
callsub arraycomplement_1
frame_bury 1
frame_dig 1
callsub arraycomplement_1
frame_bury 2
frame_dig -1
frame_dig 1
concat
frame_dig 2
concat
frame_bury 0
retsub


================================================
FILE: tests/integration/teal/roundtrip/app_roundtrip_uint64[]_0_v6.teal
================================================
#pragma version 6
txna ApplicationArgs 0
store 1
load 1
callsub roundtripper_1
store 0
byte 0x151f7c75
load 0
concat
log
int 1
return

// array_complement
arraycomplement_0:
store 6
int 0
store 8
load 8
itob
extract 6 0
byte ""
concat
store 7
load 7
retsub

// round_tripper
roundtripper_1:
store 2
load 2
callsub arraycomplement_0
store 4
load 4
callsub arraycomplement_0
store 5
load 2
store 12
load 12
store 11
int 6
store 9
load 9
load 12
len
+
store 10
load 10
int 65536
<
assert
load 9
itob
extract 6 0
load 4
store 12
load 11
load 12
concat
store 11
load 10
store 9
load 9
load 12
len
+
store 10
load 10
int 65536
<
assert
load 9
itob
extract 6 0
concat
load 5
store 12
load 11
load 12
concat
store 11
load 10
store 9
load 9
itob
extract 6 0
concat
load 11
concat
store 3
load 3
retsub


================================================
FILE: tests/integration/teal/roundtrip/app_roundtrip_uint64[]_0_v8.teal
================================================
#pragma version 8
txna ApplicationArgs 0
store 1
load 1
callsub roundtripper_1
store 0
byte 0x151f7c75
load 0
concat
log
int 1
return

// array_complement
arraycomplement_0:
proto 1 1
byte ""
int 0
dup
byte ""
dup
int 0
int 0
frame_bury 5
frame_dig 5
itob
extract 6 0
byte ""
concat
frame_bury 0
retsub

// round_tripper
roundtripper_1:
proto 1 1
byte ""
dupn 2
int 0
dup
byte ""
dup
frame_dig -1
callsub arraycomplement_0
frame_bury 1
frame_dig 1
callsub arraycomplement_0
frame_bury 2
frame_dig -1
frame_bury 6
frame_dig 6
frame_bury 5
int 6
frame_bury 3
frame_dig 3
frame_dig 6
len
+
frame_bury 4
frame_dig 4
int 65536
<
assert
frame_dig 3
itob
extract 6 0
frame_dig 1
frame_bury 6
frame_dig 5
frame_dig 6
concat
frame_bury 5
frame_dig 4
frame_bury 3
frame_dig 3
frame_dig 6
len
+
frame_bury 4
frame_dig 4
int 65536
<
assert
frame_dig 3
itob
extract 6 0
concat
frame_dig 2
frame_bury 6
frame_dig 5
frame_dig 6
concat
frame_bury 5
frame_dig 4
frame_bury 3
frame_dig 3
itob
extract 6 0
concat
frame_dig 5
concat
frame_bury 0
retsub


================================================
FILE: tests/integration/teal/roundtrip/app_roundtrip_uint64[]_1_v6.teal
================================================
#pragma version 6
txna ApplicationArgs 0
store 1
load 1
callsub roundtripper_2
store 0
byte 0x151f7c75
load 0
concat
log
int 1
return

// numerical_comp
numericalcomp_0:
store 9
int 18446744073709551615
load 9
-
store 10
load 10
retsub

// array_complement
arraycomplement_1:
store 6
load 6
int 8
int 0
*
int 2
+
extract_uint64
store 8
load 8
callsub numericalcomp_0
store 8
int 1
store 11
load 11
itob
extract 6 0
load 8
itob
concat
store 7
load 7
retsub

// round_tripper
roundtripper_2:
store 2
load 2
callsub arraycomplement_1
store 4
load 4
callsub arraycomplement_1
store 5
load 2
store 15
load 15
store 14
int 6
store 12
load 12
load 15
len
+
store 13
load 13
int 65536
<
assert
load 12
itob
extract 6 0
load 4
store 15
load 14
load 15
concat
store 14
load 13
store 12
load 12
load 15
len
+
store 13
load 13
int 65536
<
assert
load 12
itob
extract 6 0
concat
load 5
store 15
load 14
load 15
concat
store 14
load 13
store 12
load 12
itob
extract 6 0
concat
load 14
concat
store 3
load 3
retsub


================================================
FILE: tests/integration/teal/roundtrip/app_roundtrip_uint64[]_1_v8.teal
================================================
#pragma version 8
txna ApplicationArgs 0
store 1
load 1
callsub roundtripper_2
store 0
byte 0x151f7c75
load 0
concat
log
int 1
return

// numerical_comp
numericalcomp_0:
proto 1 1
int 0
int 18446744073709551615
frame_dig -1
-
frame_bury 0
retsub

// array_complement
arraycomplement_1:
proto 1 1
byte ""
int 0
dupn 3
byte ""
dup
int 0
frame_dig -1
int 8
int 0
*
int 2
+
extract_uint64
frame_bury 1
frame_dig 1
callsub numericalcomp_0
frame_bury 1
int 1
frame_bury 7
frame_dig 7
itob
extract 6 0
frame_dig 1
itob
concat
frame_bury 0
retsub

// round_tripper
roundtripper_2:
proto 1 1
byte ""
dupn 2
int 0
dup
byte ""
dup
frame_dig -1
callsub arraycomplement_1
frame_bury 1
frame_dig 1
callsub arraycomplement_1
frame_bury 2
frame_dig -1
frame_bury 6
frame_dig 6
frame_bury 5
int 6
frame_bury 3
frame_dig 3
frame_dig 6
len
+
frame_bury 4
frame_dig 4
int 65536
<
assert
frame_dig 3
itob
extract 6 0
frame_dig 1
frame_bury 6
frame_dig 5
frame_dig 6
concat
frame_bury 5
frame_dig 4
frame_bury 3
frame_dig 3
frame_dig 6
len
+
frame_bury 4
frame_dig 4
int 65536
<
assert
frame_dig 3
itob
extract 6 0
concat
frame_dig 2
frame_bury 6
frame_dig 5
frame_dig 6
concat
frame_bury 5
frame_dig 4
frame_bury 3
frame_dig 3
itob
extract 6 0
concat
frame_dig 5
concat
frame_bury 0
retsub


================================================
FILE: tests/integration/teal/roundtrip/app_roundtrip_uint64[]_42_v6.teal
================================================
#pragma version 6
txna ApplicationArgs 0
store 1
load 1
callsub roundtripper_2
store 0
byte 0x151f7c75
load 0
concat
log
int 1
return

// numerical_comp
numericalcomp_0:
store 50
int 18446744073709551615
load 50
-
store 51
load 51
retsub

// array_complement
arraycomplement_1:
store 6
load 6
int 8
int 0
*
int 2
+
extract_uint64
store 8
load 6
int 8
int 1
*
int 2
+
extract_uint64
store 9
load 6
int 8
int 2
*
int 2
+
extract_uint64
store 10
load 6
int 8
int 3
*
int 2
+
extract_uint64
store 11
load 6
int 8
int 4
*
int 2
+
extract_uint64
store 12
load 6
int 8
int 5
*
int 2
+
extract_uint64
store 13
load 6
int 8
int 6
*
int 2
+
extract_uint64
store 14
load 6
int 8
int 7
*
int 2
+
extract_uint64
store 15
load 6
int 8
int 8
*
int 2
+
extract_uint64
store 16
load 6
int 8
int 9
*
int 2
+
extract_uint64
store 17
load 6
int 8
int 10
*
int 2
+
extract_uint64
store 18
load 6
int 8
int 11
*
int 2
+
extract_uint64
store 19
load 6
int 8
int 12
*
int 2
+
extract_uint64
store 20
load 6
int 8
int 13
*
int 2
+
extract_uint64
store 21
load 6
int 8
int 14
*
int 2
+
extract_uint64
store 22
load 6
int 8
int 15
*
int 2
+
extract_uint64
store 23
load 6
int 8
int 16
*
int 2
+
extract_uint64
store 24
load 6
int 8
int 17
*
int 2
+
extract_uint64
store 25
load 6
int 8
int 18
*
int 2
+
extract_uint64
store 26
load 6
int 8
int 19
*
int 2
+
extract_uint64
store 27
load 6
int 8
int 20
*
int 2
+
extract_uint64
store 28
load 6
int 8
int 21
*
int 2
+
extract_uint64
store 29
load 6
int 8
int 22
*
int 2
+
extract_uint64
store 30
load 6
int 8
int 23
*
int 2
+
extract_uint64
store 31
load 6
int 8
int 24
*
int 2
+
extract_uint64
store 32
load 6
int 8
int 25
*
int 2
+
extract_uint64
store 33
load 6
int 8
int 26
*
int 2
+
extract_uint64
store 34
load 6
int 8
int 27
*
int 2
+
extract_uint64
store 35
load 6
int 8
int 28
*
int 2
+
extract_uint64
store 36
load 6
int 8
int 29
*
int 2
+
extract_uint64
store 37
load 6
int 8
int 30
*
int 2
+
extract_uint64
store 38
load 6
int 8
int 31
*
int 2
+
extract_uint64
store 39
load 6
int 8
int 32
*
int 2
+
extract_uint64
store 40
load 6
int 8
int 33
*
int 2
+
extract_uint64
store 41
load 6
int 8
int 34
*
int 2
+
extract_uint64
store 42
load 6
int 8
int 35
*
int 2
+
extract_uint64
store 43
load 6
int 8
int 36
*
int 2
+
extract_uint64
store 44
load 6
int 8
int 37
*
int 2
+
extract_uint64
store 45
load 6
int 8
int 38
*
int 2
+
extract_uint64
store 46
load 6
int 8
int 39
*
int 2
+
extract_uint64
store 47
load 6
int 8
int 40
*
int 2
+
extract_uint64
store 48
load 6
int 8
int 41
*
int 2
+
extract_uint64
store 49
load 8
callsub numericalcomp_0
store 8
load 9
callsub numericalcomp_0
store 9
load 10
callsub numericalcomp_0
store 10
load 11
callsub numericalcomp_0
store 11
load 12
callsub numericalcomp_0
store 12
load 13
callsub numericalcomp_0
store 13
load 14
callsub numericalcomp_0
store 14
load 15
callsub numericalcomp_0
store 15
load 16
callsub numericalcomp_0
store 16
load 17
callsub numericalcomp_0
store 17
load 18
callsub numericalcomp_0
store 18
load 19
callsub numericalcomp_0
store 19
load 20
callsub numericalcomp_0
store 20
load 21
callsub numericalcomp_0
store 21
load 22
callsub numericalcomp_0
store 22
load 23
callsub numericalcomp_0
store 23
load 24
callsub numericalcomp_0
store 24
load 25
callsub numericalcomp_0
store 25
load 26
callsub numericalcomp_0
store 26
load 27
callsub numericalcomp_0
store 27
load 28
callsub numericalcomp_0
store 28
load 29
callsub numericalcomp_0
store 29
load 30
callsub numericalcomp_0
store 30
load 31
callsub numericalcomp_0
store 31
load 32
callsub numericalcomp_0
store 32
load 33
callsub numericalcomp_0
store 33
load 34
callsub numericalcomp_0
store 34
load 35
callsub numericalcomp_0
store 35
load 36
callsub numericalcomp_0
store 36
load 37
callsub numericalcomp_0
store 37
load 38
callsub numericalcomp_0
store 38
load 39
callsub numericalcomp_0
store 39
load 40
callsub numericalcomp_0
store 40
load 41
callsub numericalcomp_0
store 41
load 42
callsub numericalcomp_0
store 42
load 43
callsub numericalcomp_0
store 43
load 44
callsub numericalcomp_0
store 44
load 45
callsub numericalcomp_0
store 45
load 46
callsub numericalcomp_0
store 46
load 47
callsub numericalcomp_0
store 47
load 48
callsub numericalcomp_0
store 48
load 49
callsub numericalcomp_0
store 49
int 42
store 52
load 52
itob
extract 6 0
load 8
itob
load 9
itob
concat
load 10
itob
concat
load 11
itob
concat
load 12
itob
concat
load 13
itob
concat
load 14
itob
concat
load 15
itob
concat
load 16
itob
concat
load 17
itob
concat
load 18
itob
concat
load 19
itob
concat
load 20
itob
concat
load 21
itob
concat
load 22
itob
concat
load 23
itob
concat
load 24
itob
concat
load 25
itob
concat
load 26
itob
concat
load 27
itob
concat
load 28
itob
concat
load 29
itob
concat
load 30
itob
concat
load 31
itob
concat
load 32
itob
concat
load 33
itob
concat
load 34
itob
concat
load 35
itob
concat
load 36
itob
concat
load 37
itob
concat
load 38
itob
concat
load 39
itob
concat
load 40
itob
concat
load 41
itob
concat
load 42
itob
concat
load 43
itob
concat
load 44
itob
concat
load 45
itob
concat
load 46
itob
concat
load 47
itob
concat
load 48
itob
concat
load 49
itob
concat
concat
store 7
load 7
retsub

// round_tripper
roundtripper_2:
store 2
load 2
callsub arraycomplement_1
store 4
load 4
callsub arraycomplement_1
store 5
load 2
store 56
load 56
store 55
int 6
store 53
load 53
load 56
len
+
store 54
load 54
int 65536
<
assert
load 53
itob
extract 6 0
load 4
store 56
load 55
load 56
concat
store 55
load 54
store 53
load 53
load 56
len
+
store 54
load 54
int 65536
<
assert
load 53
itob
extract 6 0
concat
load 5
store 56
load 55
load 56
concat
store 55
load 54
store 53
load 53
itob
extract 6 0
concat
load 55
concat
store 3
load 3
retsub


================================================
FILE: tests/integration/teal/roundtrip/app_roundtrip_uint64[]_42_v8.teal
================================================
#pragma version 8
txna ApplicationArgs 0
store 1
load 1
callsub roundtripper_2
store 0
byte 0x151f7c75
load 0
concat
log
int 1
return

// numerical_comp
numericalcomp_0:
proto 1 1
int 0
int 18446744073709551615
frame_dig -1
-
frame_bury 0
retsub

// array_complement
arraycomplement_1:
proto 1 1
byte ""
int 0
dupn 85
byte ""
dup
int 0
frame_dig -1
int 8
int 0
*
int 2
+
extract_uint64
frame_bury 1
frame_dig -1
int 8
int 1
*
int 2
+
extract_uint64
frame_bury 2
frame_dig -1
int 8
int 2
*
int 2
+
extract_uint64
frame_bury 3
frame_dig -1
int 8
int 3
*
int 2
+
extract_uint64
frame_bury 4
frame_dig -1
int 8
int 4
*
int 2
+
extract_uint64
frame_bury 5
frame_dig -1
int 8
int 5
*
int 2
+
extract_uint64
frame_bury 6
frame_dig -1
int 8
int 6
*
int 2
+
extract_uint64
frame_bury 7
frame_dig -1
int 8
int 7
*
int 2
+
extract_uint64
frame_bury 8
frame_dig -1
int 8
int 8
*
int 2
+
extract_uint64
frame_bury 9
frame_dig -1
int 8
int 9
*
int 2
+
extract_uint64
frame_bury 10
frame_dig -1
int 8
int 10
*
int 2
+
extract_uint64
frame_bury 11
frame_dig -1
int 8
int 11
*
int 2
+
extract_uint64
frame_bury 12
frame_dig -1
int 8
int 12
*
int 2
+
extract_uint64
frame_bury 13
frame_dig -1
int 8
int 13
*
int 2
+
extract_uint64
frame_bury 14
frame_dig -1
int 8
int 14
*
int 2
+
extract_uint64
frame_bury 15
frame_dig -1
int 8
int 15
*
int 2
+
extract_uint64
frame_bury 16
frame_dig -1
int 8
int 16
*
int 2
+
extract_uint64
frame_bury 17
frame_dig -1
int 8
int 17
*
int 2
+
extract_uint64
frame_bury 18
frame_dig -1
int 8
int 18
*
int 2
+
extract_uint64
frame_bury 19
frame_dig -1
int 8
int 19
*
int 2
+
extract_uint64
frame_bury 20
frame_dig -1
int 8
int 20
*
int 2
+
extract_uint64
frame_bury 21
frame_dig -1
int 8
int 21
*
int 2
+
extract_uint64
frame_bury 22
frame_dig -1
int 8
int 22
*
int 2
+
extract_uint64
frame_bury 23
frame_dig -1
int 8
int 23
*
int 2
+
extract_uint64
frame_bury 24
frame_dig -1
int 8
int 24
*
int 2
+
extract_uint64
frame_bury 25
frame_dig -1
int 8
int 25
*
int 2
+
extract_uint64
frame_bury 26
frame_dig -1
int 8
int 26
*
int 2
+
extract_uint64
frame_bury 27
frame_dig -1
int 8
int 27
*
int 2
+
extract_uint64
frame_bury 28
frame_dig -1
int 8
int 28
*
int 2
+
extract_uint64
frame_bury 29
frame_dig -1
int 8
int 29
*
int 2
+
extract_uint64
frame_bury 30
frame_dig -1
int 8
int 30
*
int 2
+
extract_uint64
frame_bury 31
frame_dig -1
int 8
int 31
*
int 2
+
extract_uint64
frame_bury 32
frame_dig -1
int 8
int 32
*
int 2
+
extract_uint64
frame_bury 33
frame_dig -1
int 8
int 33
*
int 2
+
extract_uint64
frame_bury 34
frame_dig -1
int 8
int 34
*
int 2
+
extract_uint64
frame_bury 35
frame_dig -1
int 8
int 35
*
int 2
+
extract_uint64
frame_bury 36
frame_dig -1
int 8
int 36
*
int 2
+
extract_uint64
frame_bury 37
frame_dig -1
int 8
int 37
*
int 2
+
extract_uint64
frame_bury 38
frame_dig -1
int 8
int 38
*
int 2
+
extract_uint64
frame_bury 39
frame_dig -1
int 8
int 39
*
int 2
+
extract_uint64
frame_bury 40
frame_dig -1
int 8
int 40
*
int 2
+
extract_uint64
frame_bury 41
frame_dig -1
int 8
int 41
*
int 2
+
extract_uint64
frame_bury 42
frame_dig 1
callsub numericalcomp_0
frame_bury 1
frame_dig 2
callsub numericalcomp_0
frame_bury 2
frame_dig 3
callsub numericalcomp_0
frame_bury 3
frame_dig 4
callsub numericalcomp_0
frame_bury 4
frame_dig 5
callsub numericalcomp_0
frame_bury 5
frame_dig 6
callsub numericalcomp_0
frame_bury 6
frame_dig 7
callsub numericalcomp_0
frame_bury 7
frame_dig 8
callsub numericalcomp_0
frame_bury 8
frame_dig 9
callsub numericalcomp_0
frame_bury 9
frame_dig 10
callsub numericalcomp_0
frame_bury 10
frame_dig 11
callsub numericalcomp_0
frame_bury 11
frame_dig 12
callsub numericalcomp_0
frame_bury 12
frame_dig 13
callsub numericalcomp_0
frame_bury 13
frame_dig 14
callsub numericalcomp_0
frame_bury 14
frame_dig 15
callsub numericalcomp_0
frame_bury 15
frame_dig 16
callsub numericalcomp_0
frame_bury 16
frame_dig 17
callsub numericalcomp_0
frame_bury 17
frame_dig 18
callsub numericalcomp_0
frame_bury 18
frame_dig 19
callsub numericalcomp_0
frame_bury 19
frame_dig 20
callsub numericalcomp_0
frame_bury 20
frame_dig 21
callsub numericalcomp_0
frame_bury 21
frame_dig 22
callsub numericalcomp_0
frame_bury 22
frame_dig 23
callsub numericalcomp_0
frame_bury 23
frame_dig 24
callsub numericalcomp_0
frame_bury 24
frame_dig 25
callsub numericalcomp_0
frame_bury 25
frame_dig 26
callsub numericalcomp_0
frame_bury 26
frame_dig 27
callsub numericalcomp_0
frame_bury 27
frame_dig 28
callsub numericalcomp_0
frame_bury 28
frame_dig 29
callsub numericalcomp_0
frame_bury 29
frame_dig 30
callsub numericalcomp_0
frame_bury 30
frame_dig 31
callsub numericalcomp_0
frame_bury 31
frame_dig 32
callsub numericalcomp_0
frame_bury 32
frame_dig 33
callsub numericalcomp_0
frame_bury 33
frame_dig 34
callsub numericalcomp_0
frame_bury 34
frame_dig 35
callsub numericalcomp_0
frame_bury 35
frame_dig 36
callsub numericalcomp_0
frame_bury 36
frame_dig 37
callsub numericalcomp_0
frame_bury 37
frame_dig 38
callsub numericalcomp_0
frame_bury 38
frame_dig 39
callsub numericalcomp_0
frame_bury 39
frame_dig 40
callsub numericalcomp_0
frame_bury 40
frame_dig 41
callsub numericalcomp_0
frame_bury 41
frame_dig 42
callsub numericalcomp_0
frame_bury 42
int 42
frame_bury 89
frame_dig 89
itob
extract 6 0
frame_dig 1
itob
frame_dig 2
itob
concat
frame_dig 3
itob
concat
frame_dig 4
itob
concat
frame_dig 5
itob
concat
frame_dig 6
itob
concat
frame_dig 7
itob
concat
frame_dig 8
itob
concat
frame_dig 9
itob
concat
frame_dig 10
itob
concat
frame_dig 11
itob
concat
frame_dig 12
itob
concat
frame_dig 13
itob
concat
frame_dig 14
itob
concat
frame_dig 15
itob
concat
frame_dig 16
itob
concat
frame_dig 17
itob
concat
frame_dig 18
itob
concat
frame_dig 19
itob
concat
frame_dig 20
itob
concat
frame_dig 21
itob
concat
frame_dig 22
itob
concat
frame_dig 23
itob
concat
frame_dig 24
itob
concat
frame_dig 25
itob
concat
frame_dig 26
itob
concat
frame_dig 27
itob
concat
frame_dig 28
itob
concat
frame_dig 29
itob
concat
frame_dig 30
itob
concat
frame_dig 31
itob
concat
frame_dig 32
itob
concat
frame_dig 33
itob
concat
frame_dig 34
itob
concat
frame_dig 35
itob
concat
frame_dig 36
itob
concat
frame_dig 37
itob
concat
frame_dig 38
itob
concat
frame_dig 39
itob
concat
frame_dig 40
itob
concat
frame_dig 41
itob
concat
frame_dig 42
itob
concat
concat
frame_bury 0
retsub

// round_tripper
roundtripper_2:
proto 1 1
byte ""
dupn 2
int 0
dup
byte ""
dup
frame_dig -1
callsub arraycomplement_1
frame_bury 1
frame_dig 1
callsub arraycomplement_1
frame_bury 2
frame_dig -1
frame_bury 6
frame_dig 6
frame_bury 5
int 6
frame_bury 3
frame_dig 3
frame_dig 6
len
+
frame_bury 4
frame_dig 4
int 65536
<
assert
frame_dig 3
itob
extract 6 0
frame_dig 1
frame_bury 6
frame_dig 5
frame_dig 6
concat
frame_bury 5
frame_dig 4
frame_bury 3
frame_dig 3
frame_dig 6
len
+
frame_bury 4
frame_dig 4
int 65536
<
assert
frame_dig 3
itob
extract 6 0
concat
frame_dig 2
frame_bury 6
frame_dig 5
frame_dig 6
concat
frame_bury 5
frame_dig 4
frame_bury 3
frame_dig 3
itob
extract 6 0
concat
frame_dig 5
concat
frame_bury 0
retsub


================================================
FILE: tests/integration/teal/roundtrip/app_roundtrip_uint64_v6.teal
================================================
#pragma version 6
txna ApplicationArgs 0
btoi
store 1
load 1
callsub roundtripper_1
store 0
byte 0x151f7c75
load 0
concat
log
int 1
return

// numerical_comp
numericalcomp_0:
store 6
int 18446744073709551615
load 6
-
store 7
load 7
retsub

// round_tripper
roundtripper_1:
store 2
load 2
callsub numericalcomp_0
store 4
load 4
callsub numericalcomp_0
store 5
load 2
itob
load 4
itob
concat
load 5
itob
concat
store 3
load 3
retsub


================================================
FILE: tests/integration/teal/roundtrip/app_roundtrip_uint64_v8.teal
================================================
#pragma version 8
txna ApplicationArgs 0
btoi
store 1
load 1
callsub roundtripper_1
store 0
byte 0x151f7c75
load 0
concat
log
int 1
return

// numerical_comp
numericalcomp_0:
proto 1 1
int 0
int 18446744073709551615
frame_dig -1
-
frame_bury 0
retsub

// round_tripper
roundtripper_1:
proto 1 1
byte ""
int 0
dupn 3
byte ""
dup
frame_dig -1
callsub numericalcomp_0
frame_bury 1
frame_dig 1
callsub numericalcomp_0
frame_bury 2
frame_dig -1
itob
frame_dig 1
itob
concat
frame_dig 2
itob
concat
frame_bury 0
retsub


================================================
FILE: tests/integration/teal/roundtrip/app_roundtrip_uint8_v6.teal
================================================
#pragma version 6
txna ApplicationArgs 0
int 0
getbyte
store 1
load 1
callsub roundtripper_1
store 0
byte 0x151f7c75
load 0
concat
log
int 1
return

// numerical_comp
numericalcomp_0:
store 6
int 255
load 6
-
store 7
load 7
int 256
<
assert
load 7
retsub

// round_tripper
roundtripper_1:
store 2
load 2
callsub numericalcomp_0
store 4
load 4
callsub numericalcomp_0
store 5
byte 0x00
int 0
load 2
setbyte
byte 0x00
int 0
load 4
setbyte
concat
byte 0x00
int 0
load 5
setbyte
concat
store 3
load 3
retsub


================================================
FILE: tests/integration/teal/roundtrip/app_roundtrip_uint8_v8.teal
================================================
#pragma version 8
txna ApplicationArgs 0
int 0
getbyte
store 1
load 1
callsub roundtripper_1
store 0
byte 0x151f7c75
load 0
concat
log
int 1
return

// numerical_comp
numericalcomp_0:
proto 1 1
int 0
int 255
frame_dig -1
-
frame_bury 0
frame_dig 0
int 256
<
assert
retsub

// round_tripper
roundtripper_1:
proto 1 1
byte ""
int 0
dupn 3
byte ""
dup
frame_dig -1
callsub numericalcomp_0
frame_bury 1
frame_dig 1
callsub numericalcomp_0
frame_bury 2
byte 0x00
int 0
frame_dig -1
setbyte
byte 0x00
int 0
frame_dig 1
setbyte
concat
byte 0x00
int 0
frame_dig 2
setbyte
concat
frame_bury 0
retsub


================================================
FILE: tests/integration/teal/stability/app_exp.teal
================================================
#pragma version 6
callsub exp_0
store 0
load 0
itob
log
load 0
return

// exp
exp_0:
pushint 2 // 2
pushint 10 // 10
exp
retsub


================================================
FILE: tests/integration/teal/stability/app_oldfac.teal
================================================
#pragma version 6
intcblock 1
txna ApplicationArgs 0
btoi
callsub oldfac_0
store 0
load 0
itob
log
load 0
return

// oldfac
oldfac_0:
store 1
load 1
pushint 2 // 2
<
bnz oldfac_0_l2
load 1
load 1
intc_0 // 1
-
load 1
swap
callsub oldfac_0
swap
store 1
*
b oldfac_0_l3
oldfac_0_l2:
intc_0 // 1
oldfac_0_l3:
retsub


================================================
FILE: tests/integration/teal/stability/app_slow_fibonacci.teal
================================================
#pragma version 6
intcblock 1
txna ApplicationArgs 0
btoi
callsub slowfibonacci_0
store 0
load 0
itob
log
load 0
return

// slow_fibonacci
slowfibonacci_0:
store 1
load 1
intc_0 // 1
<=
bnz slowfibonacci_0_l2
load 1
pushint 2 // 2
-
load 1
swap
callsub slowfibonacci_0
swap
store 1
load 1
intc_0 // 1
-
load 1
swap
callsub slowfibonacci_0
swap
store 1
+
b slowfibonacci_0_l3
slowfibonacci_0_l2:
load 1
slowfibonacci_0_l3:
retsub


================================================
FILE: tests/integration/teal/stability/app_square.teal
================================================
#pragma version 6
txna ApplicationArgs 0
btoi
callsub square_0
store 0
load 0
itob
log
load 0
return

// square
square_0:
store 1
load 1
pushint 2 // 2
exp
retsub


================================================
FILE: tests/integration/teal/stability/app_square_byref.teal
================================================
#pragma version 6
txna ApplicationArgs 0
btoi
store 1
pushint 1 // 1
callsub squarebyref_0
pushint 1337 // 1337
store 0
load 0
itob
log
load 0
return

// square_byref
squarebyref_0:
store 2
load 2
load 2
loads
load 2
loads
*
stores
retsub


================================================
FILE: tests/integration/teal/stability/app_string_mult.teal
================================================
#pragma version 6
intcblock 1
txna ApplicationArgs 0
store 1
intc_0 // 1
txna ApplicationArgs 1
btoi
callsub stringmult_0
store 0
load 0
log
load 0
len
return

// string_mult
stringmult_0:
store 3
store 2
intc_0 // 1
store 4
load 2
loads
store 5
load 2
pushbytes 0x // ""
stores
stringmult_0_l1:
load 4
load 3
<=
bz stringmult_0_l3
load 2
load 2
loads
load 5
concat
stores
load 4
intc_0 // 1
+
store 4
b stringmult_0_l1
stringmult_0_l3:
load 2
loads
retsub


================================================
FILE: tests/integration/teal/stability/app_swap.teal
================================================
#pragma version 6
txna ApplicationArgs 0
store 1
txna ApplicationArgs 1
store 2
pushint 1 // 1
pushint 2 // 2
callsub swap_0
pushint 1337 // 1337
store 0
load 0
itob
log
load 0
return

// swap
swap_0:
store 4
store 3
load 3
loads
store 5
load 3
load 4
loads
stores
load 4
load 5
stores
retsub


================================================
FILE: tests/integration/teal/stability/lsig_exp.teal
================================================
#pragma version 6
callsub exp_0
return

// exp
exp_0:
pushint 2 // 2
pushint 10 // 10
exp
retsub


================================================
FILE: tests/integration/teal/stability/lsig_oldfac.teal
================================================
#pragma version 6
intcblock 1
arg 0
btoi
callsub oldfac_0
return

// oldfac
oldfac_0:
store 0
load 0
pushint 2 // 2
<
bnz oldfac_0_l2
load 0
load 0
intc_0 // 1
-
load 0
swap
callsub oldfac_0
swap
store 0
*
b oldfac_0_l3
oldfac_0_l2:
intc_0 // 1
oldfac_0_l3:
retsub


================================================
FILE: tests/integration/teal/stability/lsig_slow_fibonacci.teal
================================================
#pragma version 6
intcblock 1
arg 0
btoi
callsub slowfibonacci_0
return

// slow_fibonacci
slowfibonacci_0:
store 0
load 0
intc_0 // 1
<=
bnz slowfibonacci_0_l2
load 0
pushint 2 // 2
-
load 0
swap
callsub slowfibonacci_0
swap
store 0
load 0
intc_0 // 1
-
load 0
swap
callsub slowfibonacci_0
swap
store 0
+
b slowfibonacci_0_l3
slowfibonacci_0_l2:
load 0
slowfibonacci_0_l3:
retsub


================================================
FILE: tests/integration/teal/stability/lsig_square.teal
================================================
#pragma version 6
arg 0
btoi
callsub square_0
return

// square
square_0:
store 0
load 0
pushint 2 // 2
exp
retsub


================================================
FILE: tests/integration/teal/stability/lsig_square_byref.teal
================================================
#pragma version 6
arg 0
btoi
store 1
pushint 1 // 1
callsub squarebyref_0
pushint 1337 // 1337
return

// square_byref
squarebyref_0:
store 0
load 0
load 0
loads
load 0
loads
*
stores
retsub


================================================
FILE: tests/integration/teal/stability/lsig_string_mult.teal
================================================
#pragma version 6
intcblock 1
arg 0
store 4
pushint 4 // 4
arg 1
btoi
callsub stringmult_0
len
return

// string_mult
stringmult_0:
store 1
store 0
intc_0 // 1
store 2
load 0
loads
store 3
load 0
pushbytes 0x // ""
stores
stringmult_0_l1:
load 2
load 1
<=
bz stringmult_0_l3
load 0
load 0
loads
load 3
concat
stores
load 2
intc_0 // 1
+
store 2
b stringmult_0_l1
stringmult_0_l3:
load 0
loads
retsub


================================================
FILE: tests/integration/teal/stability/lsig_swap.teal
================================================
#pragma version 6
arg 0
store 3
arg 1
store 4
pushint 3 // 3
pushint 4 // 4
callsub swap_0
pushint 1337 // 1337
return

// swap
swap_0:
store 1
store 0
load 0
loads
store 2
load 0
load 1
loads
stores
load 1
load 2
stores
retsub


================================================
FILE: tests/teal/__init__.py
================================================
[Empty file]


================================================
FILE: tests/teal/rps.py
================================================
""" Rock Paper Scissors example taken from https://github.com/gr8h/project_rps (15 Feb 2023)
"""

from base64 import b64decode
from dataclasses import dataclass
from typing import Dict

from algosdk.v2client.algod import AlgodClient

from pyteal import *
from pyteal.ast import *
from pyteal.ast.bytes import Bytes


def event(
    init: Expr = Reject(),
    delete: Expr = Reject(),
    update: Expr = Reject(),
    opt_in: Expr = Reject(),
    close_out: Expr = Reject(),
    no_op: Expr = Reject(),
) -> Expr:
    return Cond(
        [Txn.application_id() == Int(0), init],
        [Txn.on_completion() == OnComplete.DeleteApplication, delete],
        [Txn.on_completion() == OnComplete.UpdateApplication, update],
        [Txn.on_completion() == OnComplete.OptIn, opt_in],
        [Txn.on_completion() == OnComplete.CloseOut, close_out],
        [Txn.on_completion() == OnComplete.NoOp, no_op],
    )


def check_rekey_zero(
    num_transactions: int,
):
    return Assert(
        And(
            *[
                Gtxn[i].rekey_to() == Global.zero_address()
                for i in range(num_transactions)
            ]
        )
    )


def check_self(
    group_size: Expr = Int(1),
    group_index: Expr = Int(0),
):
    return Assert(
        And(
            Global.group_size() == group_size,
            Txn.group_index() == group_index,
        )
    )


def application(pyteal: Expr) -> str:
    return compileTeal(pyteal, mode=Mode.Application, version=MAX_TEAL_VERSION)


@dataclass
class CompiledSignature:
    address: str
    bytecode_b64: str
    teal: str


def signature(algod_client: AlgodClient, pyteal: Expr) -> CompiledSignature:
    teal = compileTeal(pyteal, mode=Mode.Signature, version=MAX_TEAL_VERSION)
    compilation_result = algod_client.compile(teal)
    return CompiledSignature(
        address=compilation_result["hash"],
        bytecode_b64=compilation_result["result"],
        teal=teal,
    )


def approval_program():
    # locals
    local_opponent = Bytes("opponent")  # byteslice
    local_bet = Bytes("bet")  # uint64
    local_private_play = Bytes("private_play")  # byteslice
    local_play = Bytes("play")  # byteslice

    op_challenge = Bytes("challenge")
    op_accept = Bytes("accept")
    op_reveal = Bytes("reveal")

    @Subroutine(TealType.none)
    def reset(account: Expr):
        return Seq(
            App.localPut(account, local_opponent, Bytes("")),
            App.localPut(account, local_bet, Int(0)),
            App.localPut(account, local_private_play, Bytes("")),
            App.localPut(account, local_play, Bytes("")),
        )

    @Subroutine(TealType.uint64)
    def is_account_empty(account: Expr):
        return Return(
            And(
                App.localGet(account, local_opponent) == Bytes(""),
                App.localGet(account, local_bet) == Int(0),
                App.localGet(account, local_private_play) == Bytes(""),
                App.localGet(account, local_play) == Bytes(""),
            )
        )

    @Subroutine(TealType.uint64)
    def is_valid_play(play: Expr):
        first_ch = ScratchVar(TealType.bytes)
        return Seq(
            first_ch.store(Substring(play, Int(0), Int(1))),
            Return(
                Or(
                    first_ch.load() == Bytes("r"),
                    first_ch.load() == Bytes("p"),
                    first_ch.load() == Bytes("s"),
                )
            ),
        )

    @Subroutine(TealType.uint64)
    def play_value(p: Expr):
        first_letter = ScratchVar()
        return Seq(
            first_letter.store(Substring(p, Int(0), Int(1))),
            Return(
                Cond(
                    [first_letter.load() == Bytes("r"), Int(0)],
                    [first_letter.load() == Bytes("p"), Int(1)],
                    [first_letter.load() == Bytes("s"), Int(2)],
                )
            ),
        )

    @Subroutine(TealType.uint64)
    def get_winner_account_index(challanger_play: Expr, opponent_play: Expr):
        return Return(
            Cond(
                [challanger_play == opponent_play, Int(2)],  # a tie
                [
                    (challanger_play + Int(1)) % Int(3) == opponent_play,
                    Int(1),
                ],  # opponent wins
                [
                    (opponent_play + Int(1)) % Int(3) == challanger_play,
                    Int(0),
                ],  # challanger wins
            )
        )

    @Subroutine(TealType.none)
    def send_reward(account_index: Expr, amount: Expr):
        return Seq(
            InnerTxnBuilder.Begin(),
            InnerTxnBuilder.SetFields(
                {
                    TxnField.type_enum: TxnType.Payment,
                    TxnField.receiver: Txn.accounts[account_index],
                    TxnField.amount: amount,
                }
            ),
            InnerTxnBuilder.Submit(),
        )

    @Subroutine(TealType.none)
    def create_challenge():
        return Seq(
            Assert(
                And(
                    # check that we have two txn, one for the payment
                    Global.group_size() == Int(2),
                    Txn.group_index() == Int(0),
                    # security checks
                    Gtxn[1].close_remainder_to() == Global.zero_address(),
                    Gtxn[0].rekey_to() == Global.zero_address(),
                    Gtxn[1].rekey_to() == Global.zero_address(),
                    # check 2nd txn is a payment for the bet
                    Gtxn[1].type_enum() == TxnType.Payment,
                    # check the reciver is the application
                    Gtxn[1].receiver() == Global.current_application_address(),
                    # check the amount == the amount of the challanger
                    Gtxn[1].amount() == App.localGet(Txn.accounts[1], local_bet),
                    # check that the challanger is opted in
                    App.optedIn(Txn.accounts[1], Global.current_application_id()),
                    # check that challanger account is the correct account
                    Txn.sender() == App.localGet(Txn.accounts[1], local_opponent),
                    # check hashed/private play
                    Txn.application_args.length() == Int(2),
                    is_valid_play(Txn.application_args[1]),
                )
            ),
            App.localPut(Txn.sender(), local_opponent, Txn.accounts[1]),
            App.localPut(Txn.sender(), local_bet, Gtxn[1].amount()),
            App.localPut(Txn.sender(), local_play, Txn.application_args[1]),
            Approve(),
        )

    @Subroutine(TealType.none)
    def accept_challenge():
        return Seq(
            Assert(
                And(
                    # check that we have two txn, one for the payment
                    Global.group_size() == Int(2),
                    Txn.group_index() == Int(0),
                    # security checks
                    Gtxn[1].close_remainder_to() == Global.zero_address(),
                    Gtxn[0].rekey_to() == Global.zero_address(),
                    Gtxn[1].rekey_to() == Global.zero_address(),
                    # check 2nd txn is a payment for the bet
                    Gtxn[1].type_enum() == TxnType.Payment,
                    # check the reciver is the application
                    Gtxn[1].receiver() == Global.current_application_address(),
                    # check that the opponent is opted in
                    App.optedIn(Txn.accounts[1], Global.current_application_id()),
                    # check accounts avilability to play
                    is_account_empty(Txn.sender()),
                    is_account_empty(Txn.accounts[1]),
                    # check hashed/private play
                    Txn.application_args.length() == Int(2),
                )
            ),
            App.localPut(Txn.sender(), local_opponent, Txn.accounts[1]),
            App.localPut(Txn.sender(), local_bet, Gtxn[1].amount()),
            App.localPut(Txn.sender(), local_private_play, Txn.application_args[1]),
            Approve(),
        )

    @Subroutine(TealType.none)
    def reveal():
        challenger_play = ScratchVar(TealType.uint64)
        opponent_play = ScratchVar(TealType.uint64)
        winner_index = ScratchVar(TealType.uint64)
        bet = ScratchVar(TealType.uint64)

        return Seq(
            Assert(
                And(
                    # check that we have one txn
                    Global.group_size() == Int(1),
                    Txn.group_index() == Int(0),
                    # security checks
                    Gtxn[0].rekey_to() == Global.zero_address(),
                    # check accounts are opponents to each other
                    App.localGet(Txn.sender(), local_opponent) == Txn.accounts[1],
                    App.localGet(Txn.accounts[1], local_opponent) == Txn.sender(),
                    # check accounts have the same bet
                    App.localGet(Txn.sender(), local_bet)
                    == App.localGet(Txn.accounts[1], local_bet),
                    # check account has submit a play
                    App.localGet(Txn.sender(), local_private_play) != Bytes(""),
                    App.localGet(Txn.accounts[1], local_play) != Bytes(""),
                    # the private_play is valid
                    Txn.application_args.length() == Int(2),
                    Sha256(Txn.application_args[1])
                    == App.localGet(Int(0), local_private_play),
                )
            ),
            challenger_play.store(play_value(Txn.application_args[1])),
            opponent_play.store(play_value(App.localGet(Txn.accounts[1], local_play))),
            bet.store(App.localGet(Txn.sender(), local_bet)),
            winner_index.store(
                get_winner_account_index(challenger_play.load(), opponent_play.load())
            ),
            If(winner_index.load() == Int(2))
            .Then(
                Seq(
                    send_reward(Txn.sender(), bet.load()),
                    send_reward(Txn.accounts[1], bet.load()),
                )
            )
            .Else(Seq(send_reward(winner_index.load(), bet.load() * Int(2)))),
            reset(Txn.sender()),
            reset(Txn.accounts[1]),
            Approve(),
        )

    return event(
        init=Approve(),
        opt_in=Seq(
            reset(Int(0)),
            Approve(),
        ),
        no_op=Seq(
            Cond(
                [
                    Txn.application_args[0] == op_challenge,
                    create_challenge(),
                ],
                [
                    Txn.application_args[0] == op_accept,
                    accept_challenge(),
                ],
                [
                    Txn.application_args[0] == op_reveal,
                    reveal(),
                ],
            ),
            Reject(),
        ),
    )


def clear_state_program():
    return Int(0)


if __name__ == "__main__":
    with open("vote_approval.teal", "w") as f:
        compiled = compileTeal(approval_program(), Mode.Application, version=6)
        f.write(compiled)

    with open("vote_clear_state.teal", "w") as f:
        compiled = compileTeal(clear_state_program(), Mode.Application, version=6)
        f.write(compiled)



================================================
FILE: tests/teal/rps.teal
================================================
#pragma version 6
txn ApplicationID
int 0
==
bnz main_l19
txn OnCompletion
int DeleteApplication
==
bnz main_l18
txn OnCompletion
int UpdateApplication
==
bnz main_l17
txn OnCompletion
int OptIn
==
bnz main_l16
txn OnCompletion
int CloseOut
==
bnz main_l15
txn OnCompletion
int NoOp
==
bnz main_l7
err
main_l7:
txna ApplicationArgs 0
byte "challenge"
==
bnz main_l14
txna ApplicationArgs 0
byte "accept"
==
bnz main_l13
txna ApplicationArgs 0
byte "reveal"
==
bnz main_l11
err
main_l11:
callsub reveal_8
main_l12:
int 0
return
main_l13:
callsub acceptchallenge_7
b main_l12
main_l14:
callsub createchallenge_6
b main_l12
main_l15:
int 0
return
main_l16:
int 0
callsub reset_0
int 1
return
main_l17:
int 0
return
main_l18:
int 0
return
main_l19:
int 1
return

// reset
reset_0:
store 0
load 0
byte "opponent"
byte ""
app_local_put
load 0
byte "bet"
int 0
app_local_put
load 0
byte "private_play"
byte ""
app_local_put
load 0
byte "play"
byte ""
app_local_put
retsub

// is_account_empty
isaccountempty_1:
store 3
load 3
byte "opponent"
app_local_get
byte ""
==
load 3
byte "bet"
app_local_get
int 0
==
&&
load 3
byte "private_play"
app_local_get
byte ""
==
&&
load 3
byte "play"
app_local_get
byte ""
==
&&
retsub

// is_valid_play
isvalidplay_2:
store 1
load 1
extract 0 1
store 2
load 2
byte "r"
==
load 2
byte "p"
==
||
load 2
byte "s"
==
||
retsub

// play_value
playvalue_3:
store 8
load 8
extract 0 1
store 9
load 9
byte "r"
==
bnz playvalue_3_l6
load 9
byte "p"
==
bnz playvalue_3_l5
load 9
byte "s"
==
bnz playvalue_3_l4
err
playvalue_3_l4:
int 2
b playvalue_3_l7
playvalue_3_l5:
int 1
b playvalue_3_l7
playvalue_3_l6:
int 0
playvalue_3_l7:
retsub

// get_winner_account_index
getwinneraccountindex_4:
store 11
store 10
load 10
load 11
==
bnz getwinneraccountindex_4_l6
load 10
int 1
+
int 3
%
load 11
==
bnz getwinneraccountindex_4_l5
load 11
int 1
+
int 3
%
load 10
==
bnz getwinneraccountindex_4_l4
err
getwinneraccountindex_4_l4:
int 0
b getwinneraccountindex_4_l7
getwinneraccountindex_4_l5:
int 1
b getwinneraccountindex_4_l7
getwinneraccountindex_4_l6:
int 2
getwinneraccountindex_4_l7:
retsub

// send_reward
sendreward_5:
store 13
store 12
itxn_begin
int pay
itxn_field TypeEnum
load 12
txnas Accounts
itxn_field Receiver
load 13
itxn_field Amount
itxn_submit
retsub

// create_challenge
createchallenge_6:
global GroupSize
int 2
==
txn GroupIndex
int 0
==
&&
gtxn 1 CloseRemainderTo
global ZeroAddress
==
&&
gtxn 0 RekeyTo
global ZeroAddress
==
&&
gtxn 1 RekeyTo
global ZeroAddress
==
&&
gtxn 1 TypeEnum
int pay
==
&&
gtxn 1 Receiver
global CurrentApplicationAddress
==
&&
gtxn 1 Amount
txna Accounts 1
byte "bet"
app_local_get
==
&&
txna Accounts 1
global CurrentApplicationID
app_opted_in
&&
txn Sender
txna Accounts 1
byte "opponent"
app_local_get
==
&&
txn NumAppArgs
int 2
==
&&
txna ApplicationArgs 1
callsub isvalidplay_2
&&
assert
txn Sender
byte "opponent"
txna Accounts 1
app_local_put
txn Sender
byte "bet"
gtxn 1 Amount
app_local_put
txn Sender
byte "play"
txna ApplicationArgs 1
app_local_put
int 1
return

// accept_challenge
acceptchallenge_7:
global GroupSize
int 2
==
txn GroupIndex
int 0
==
&&
gtxn 1 CloseRemainderTo
global ZeroAddress
==
&&
gtxn 0 RekeyTo
global ZeroAddress
==
&&
gtxn 1 RekeyTo
global ZeroAddress
==
&&
gtxn 1 TypeEnum
int pay
==
&&
gtxn 1 Receiver
global CurrentApplicationAddress
==
&&
txna Accounts 1
global CurrentApplicationID
app_opted_in
&&
txn Sender
callsub isaccountempty_1
&&
txna Accounts 1
callsub isaccountempty_1
&&
txn NumAppArgs
int 2
==
&&
assert
txn Sender
byte "opponent"
txna Accounts 1
app_local_put
txn Sender
byte "bet"
gtxn 1 Amount
app_local_put
txn Sender
byte "private_play"
txna ApplicationArgs 1
app_local_put
int 1
return

// reveal
reveal_8:
global GroupSize
int 1
==
txn GroupIndex
int 0
==
&&
gtxn 0 RekeyTo
global ZeroAddress
==
&&
txn Sender
byte "opponent"
app_local_get
txna Accounts 1
==
&&
txna Accounts 1
byte "opponent"
app_local_get
txn Sender
==
&&
txn Sender
byte "bet"
app_local_get
txna Accounts 1
byte "bet"
app_local_get
==
&&
txn Sender
byte "private_play"
app_local_get
byte ""
!=
&&
txna Accounts 1
byte "play"
app_local_get
byte ""
!=
&&
txn NumAppArgs
int 2
==
&&
txna ApplicationArgs 1
sha256
int 0
byte "private_play"
app_local_get
==
&&
assert
txna ApplicationArgs 1
callsub playvalue_3
store 4
txna Accounts 1
byte "play"
app_local_get
callsub playvalue_3
store 5
txn Sender
byte "bet"
app_local_get
store 7
load 4
load 5
callsub getwinneraccountindex_4
store 6
load 6
int 2
==
bnz reveal_8_l2
load 6
load 7
int 2
*
callsub sendreward_5
b reveal_8_l3
reveal_8_l2:
txn Sender
load 7
callsub sendreward_5
txna Accounts 1
load 7
callsub sendreward_5
reveal_8_l3:
txn Sender
callsub reset_0
txna Accounts 1
callsub reset_0
int 1
return


================================================
FILE: tests/teal/user_guide_snippet_dynamic_scratch_var.teal
================================================
#pragma version 6
int 0
store 1
int 7
store 0
load 1
load 1
loads
int 3
+
stores
load 0
int 10
==
assert
int 1
return


================================================
FILE: tests/teal/user_guide_snippet_recursiveIsEven.teal
================================================
#pragma version 6
int 15
callsub recursiveIsEven_0
return

// recursiveIsEven
recursiveIsEven_0:
store 0
load 0
int 0
==
bnz recursiveIsEven_0_l4
load 0
int 1
==
bnz recursiveIsEven_0_l3
load 0
int 2
-
load 0
swap
callsub recursiveIsEven_0
swap
store 0
b recursiveIsEven_0_l5
recursiveIsEven_0_l3:
int 0
b recursiveIsEven_0_l5
recursiveIsEven_0_l4:
int 1
recursiveIsEven_0_l5:
retsub


================================================
FILE: tests/teal/router/nontriv_clear_approval_v6.teal
================================================
#pragma version 6
txn NumAppArgs
int 0
==
bnz main_l20
txna ApplicationArgs 0
method "add(uint64,uint64)uint64"
==
bnz main_l19
txna ApplicationArgs 0
method "sub(uint64,uint64)uint64"
==
bnz main_l18
txna ApplicationArgs 0
method "mul(uint64,uint64)uint64"
==
bnz main_l17
txna ApplicationArgs 0
method "div(uint64,uint64)uint64"
==
bnz main_l16
txna ApplicationArgs 0
method "mod(uint64,uint64)uint64"
==
bnz main_l15
txna ApplicationArgs 0
method "all_laid_to_args(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)uint64"
==
bnz main_l14
txna ApplicationArgs 0
method "empty_return_subroutine()void"
==
bnz main_l13
txna ApplicationArgs 0
method "log_1()uint64"
==
bnz main_l12
txna ApplicationArgs 0
method "log_creation()string"
==
bnz main_l11
err
main_l11:
txn OnCompletion
int NoOp
==
txn ApplicationID
int 0
==
&&
assert
callsub logcreation_8
store 67
byte 0x151f7c75
load 67
concat
log
int 1
return
main_l12:
txn OnCompletion
int NoOp
==
txn ApplicationID
int 0
!=
&&
txn OnCompletion
int OptIn
==
txn ApplicationID
int 0
!=
&&
||
assert
callsub log1_7
store 65
byte 0x151f7c75
load 65
itob
concat
log
int 1
return
main_l13:
txn OnCompletion
int NoOp
==
txn ApplicationID
int 0
!=
&&
txn OnCompletion
int OptIn
==
||
assert
callsub emptyreturnsubroutine_6
int 1
return
main_l14:
txn OnCompletion
int NoOp
==
txn ApplicationID
int 0
!=
&&
assert
txna ApplicationArgs 1
btoi
store 30
txna ApplicationArgs 2
btoi
store 31
txna ApplicationArgs 3
btoi
store 32
txna ApplicationArgs 4
btoi
store 33
txna ApplicationArgs 5
btoi
store 34
txna ApplicationArgs 6
btoi
store 35
txna ApplicationArgs 7
btoi
store 36
txna ApplicationArgs 8
btoi
store 37
txna ApplicationArgs 9
btoi
store 38
txna ApplicationArgs 10
btoi
store 39
txna ApplicationArgs 11
btoi
store 40
txna ApplicationArgs 12
btoi
store 41
txna ApplicationArgs 13
btoi
store 42
txna ApplicationArgs 14
btoi
store 43
txna ApplicationArgs 15
store 46
load 46
int 0
extract_uint64
store 44
load 46
int 8
extract_uint64
store 45
load 30
load 31
load 32
load 33
load 34
load 35
load 36
load 37
load 38
load 39
load 40
load 41
load 42
load 43
load 44
load 45
callsub alllaidtoargs_5
store 47
byte 0x151f7c75
load 47
itob
concat
log
int 1
return
main_l15:
txn OnCompletion
int NoOp
==
txn ApplicationID
int 0
!=
&&
assert
txna ApplicationArgs 1
btoi
store 24
txna ApplicationArgs 2
btoi
store 25
load 24
load 25
callsub mod_4
store 26
byte 0x151f7c75
load 26
itob
concat
log
int 1
return
main_l16:
txn OnCompletion
int NoOp
==
txn ApplicationID
int 0
!=
&&
assert
txna ApplicationArgs 1
btoi
store 18
txna ApplicationArgs 2
btoi
store 19
load 18
load 19
callsub div_3
store 20
byte 0x151f7c75
load 20
itob
concat
log
int 1
return
main_l17:
txn OnCompletion
int NoOp
==
txn ApplicationID
int 0
!=
&&
assert
txna ApplicationArgs 1
btoi
store 12
txna ApplicationArgs 2
btoi
store 13
load 12
load 13
callsub mul_2
store 14
byte 0x151f7c75
load 14
itob
concat
log
int 1
return
main_l18:
txn OnCompletion
int NoOp
==
txn ApplicationID
int 0
!=
&&
assert
txna ApplicationArgs 1
btoi
store 6
txna ApplicationArgs 2
btoi
store 7
load 6
load 7
callsub sub_1
store 8
byte 0x151f7c75
load 8
itob
concat
log
int 1
return
main_l19:
txn OnCompletion
int NoOp
==
txn ApplicationID
int 0
!=
&&
assert
txna ApplicationArgs 1
btoi
store 0
txna ApplicationArgs 2
btoi
store 1
load 0
load 1
callsub add_0
store 2
byte 0x151f7c75
load 2
itob
concat
log
int 1
return
main_l20:
txn OnCompletion
int OptIn
==
bnz main_l22
err
main_l22:
txn ApplicationID
int 0
!=
assert
byte "optin call"
log
int 1
return

// add
add_0:
store 4
store 3
load 3
load 4
+
store 5
load 5
retsub

// sub
sub_1:
store 10
store 9
load 9
load 10
-
store 11
load 11
retsub

// mul
mul_2:
store 16
store 15
load 15
load 16
*
store 17
load 17
retsub

// div
div_3:
store 22
store 21
load 21
load 22
/
store 23
load 23
retsub

// mod
mod_4:
store 28
store 27
load 27
load 28
%
store 29
load 29
retsub

// all_laid_to_args
alllaidtoargs_5:
store 63
store 62
store 61
store 60
store 59
store 58
store 57
store 56
store 55
store 54
store 53
store 52
store 51
store 50
store 49
store 48
load 48
load 49
+
load 50
+
load 51
+
load 52
+
load 53
+
load 54
+
load 55
+
load 56
+
load 57
+
load 58
+
load 59
+
load 60
+
load 61
+
load 62
+
load 63
+
store 64
load 64
retsub

// empty_return_subroutine
emptyreturnsubroutine_6:
byte "appear in both approval and clear state"
log
retsub

// log_1
log1_7:
int 1
store 66
load 66
retsub

// log_creation
logcreation_8:
byte 0x00106c6f6767696e67206372656174696f6e
store 68
load 68
retsub


================================================
FILE: tests/teal/router/nontriv_clear_approval_v8.teal
================================================
#pragma version 8
txn NumAppArgs
int 0
==
bnz main_l20
txna ApplicationArgs 0
method "add(uint64,uint64)uint64"
==
bnz main_l19
txna ApplicationArgs 0
method "sub(uint64,uint64)uint64"
==
bnz main_l18
txna ApplicationArgs 0
method "mul(uint64,uint64)uint64"
==
bnz main_l17
txna ApplicationArgs 0
method "div(uint64,uint64)uint64"
==
bnz main_l16
txna ApplicationArgs 0
method "mod(uint64,uint64)uint64"
==
bnz main_l15
txna ApplicationArgs 0
method "all_laid_to_args(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)uint64"
==
bnz main_l14
txna ApplicationArgs 0
method "empty_return_subroutine()void"
==
bnz main_l13
txna ApplicationArgs 0
method "log_1()uint64"
==
bnz main_l12
txna ApplicationArgs 0
method "log_creation()string"
==
bnz main_l11
err
main_l11:
txn OnCompletion
int NoOp
==
txn ApplicationID
int 0
==
&&
assert
callsub logcreationcaster_17
int 1
return
main_l12:
txn OnCompletion
int NoOp
==
txn ApplicationID
int 0
!=
&&
txn OnCompletion
int OptIn
==
txn ApplicationID
int 0
!=
&&
||
assert
callsub log1caster_16
int 1
return
main_l13:
txn OnCompletion
int NoOp
==
txn ApplicationID
int 0
!=
&&
txn OnCompletion
int OptIn
==
||
assert
callsub emptyreturnsubroutinecaster_15
int 1
return
main_l14:
txn OnCompletion
int NoOp
==
txn ApplicationID
int 0
!=
&&
assert
callsub alllaidtoargscaster_14
int 1
return
main_l15:
txn OnCompletion
int NoOp
==
txn ApplicationID
int 0
!=
&&
assert
callsub modcaster_13
int 1
return
main_l16:
txn OnCompletion
int NoOp
==
txn ApplicationID
int 0
!=
&&
assert
callsub divcaster_12
int 1
return
main_l17:
txn OnCompletion
int NoOp
==
txn ApplicationID
int 0
!=
&&
assert
callsub mulcaster_11
int 1
return
main_l18:
txn OnCompletion
int NoOp
==
txn ApplicationID
int 0
!=
&&
assert
callsub subcaster_10
int 1
return
main_l19:
txn OnCompletion
int NoOp
==
txn ApplicationID
int 0
!=
&&
assert
callsub addcaster_9
int 1
return
main_l20:
txn OnCompletion
int OptIn
==
bnz main_l22
err
main_l22:
txn ApplicationID
int 0
!=
assert
byte "optin call"
log
int 1
return

// add
add_0:
proto 2 1
int 0
frame_dig -2
frame_dig -1
+
frame_bury 0
retsub

// sub
sub_1:
proto 2 1
int 0
frame_dig -2
frame_dig -1
-
frame_bury 0
retsub

// mul
mul_2:
proto 2 1
int 0
frame_dig -2
frame_dig -1
*
frame_bury 0
retsub

// div
div_3:
proto 2 1
int 0
frame_dig -2
frame_dig -1
/
frame_bury 0
retsub

// mod
mod_4:
proto 2 1
int 0
frame_dig -2
frame_dig -1
%
frame_bury 0
retsub

// all_laid_to_args
alllaidtoargs_5:
proto 16 1
int 0
frame_dig -16
frame_dig -15
+
frame_dig -14
+
frame_dig -13
+
frame_dig -12
+
frame_dig -11
+
frame_dig -10
+
frame_dig -9
+
frame_dig -8
+
frame_dig -7
+
frame_dig -6
+
frame_dig -5
+
frame_dig -4
+
frame_dig -3
+
frame_dig -2
+
frame_dig -1
+
frame_bury 0
retsub

// empty_return_subroutine
emptyreturnsubroutine_6:
proto 0 0
byte "appear in both approval and clear state"
log
retsub

// log_1
log1_7:
proto 0 1
int 0
int 1
frame_bury 0
retsub

// log_creation
logcreation_8:
proto 0 1
byte ""
byte 0x00106c6f6767696e67206372656174696f6e
frame_bury 0
retsub

// add_caster
addcaster_9:
proto 0 0
int 0
dupn 2
txna ApplicationArgs 1
btoi
frame_bury 1
txna ApplicationArgs 2
btoi
frame_bury 2
frame_dig 1
frame_dig 2
callsub add_0
frame_bury 0
byte 0x151f7c75
frame_dig 0
itob
concat
log
retsub

// sub_caster
subcaster_10:
proto 0 0
int 0
dupn 2
txna ApplicationArgs 1
btoi
frame_bury 1
txna ApplicationArgs 2
btoi
frame_bury 2
frame_dig 1
frame_dig 2
callsub sub_1
frame_bury 0
byte 0x151f7c75
frame_dig 0
itob
concat
log
retsub

// mul_caster
mulcaster_11:
proto 0 0
int 0
dupn 2
txna ApplicationArgs 1
btoi
frame_bury 1
txna ApplicationArgs 2
btoi
frame_bury 2
frame_dig 1
frame_dig 2
callsub mul_2
frame_bury 0
byte 0x151f7c75
frame_dig 0
itob
concat
log
retsub

// div_caster
divcaster_12:
proto 0 0
int 0
dupn 2
txna ApplicationArgs 1
btoi
frame_bury 1
txna ApplicationArgs 2
btoi
frame_bury 2
frame_dig 1
frame_dig 2
callsub div_3
frame_bury 0
byte 0x151f7c75
frame_dig 0
itob
concat
log
retsub

// mod_caster
modcaster_13:
proto 0 0
int 0
dupn 2
txna ApplicationArgs 1
btoi
frame_bury 1
txna ApplicationArgs 2
btoi
frame_bury 2
frame_dig 1
frame_dig 2
callsub mod_4
frame_bury 0
byte 0x151f7c75
frame_dig 0
itob
concat
log
retsub

// all_laid_to_args_caster
alllaidtoargscaster_14:
proto 0 0
int 0
dupn 16
byte ""
txna ApplicationArgs 1
btoi
frame_bury 1
txna ApplicationArgs 2
btoi
frame_bury 2
txna ApplicationArgs 3
btoi
frame_bury 3
txna ApplicationArgs 4
btoi
frame_bury 4
txna ApplicationArgs 5
btoi
frame_bury 5
txna ApplicationArgs 6
btoi
frame_bury 6
txna ApplicationArgs 7
btoi
frame_bury 7
txna ApplicationArgs 8
btoi
frame_bury 8
txna ApplicationArgs 9
btoi
frame_bury 9
txna ApplicationArgs 10
btoi
frame_bury 10
txna ApplicationArgs 11
btoi
frame_bury 11
txna ApplicationArgs 12
btoi
frame_bury 12
txna ApplicationArgs 13
btoi
frame_bury 13
txna ApplicationArgs 14
btoi
frame_bury 14
txna ApplicationArgs 15
frame_bury 17
frame_dig 17
int 0
extract_uint64
frame_bury 15
frame_dig 17
int 8
extract_uint64
frame_bury 16
frame_dig 1
frame_dig 2
frame_dig 3
frame_dig 4
frame_dig 5
frame_dig 6
frame_dig 7
frame_dig 8
frame_dig 9
frame_dig 10
frame_dig 11
frame_dig 12
frame_dig 13
frame_dig 14
frame_dig 15
frame_dig 16
callsub alllaidtoargs_5
frame_bury 0
byte 0x151f7c75
frame_dig 0
itob
concat
log
retsub

// empty_return_subroutine_caster
emptyreturnsubroutinecaster_15:
proto 0 0
callsub emptyreturnsubroutine_6
retsub

// log_1_caster
log1caster_16:
proto 0 0
int 0
callsub log1_7
frame_bury 0
byte 0x151f7c75
frame_dig 0
itob
concat
log
retsub

// log_creation_caster
logcreationcaster_17:
proto 0 0
byte ""
callsub logcreation_8
frame_bury 0
byte 0x151f7c75
frame_dig 0
concat
log
retsub


================================================
FILE: tests/teal/router/nontriv_clear_clear_v6.teal
================================================
#pragma version 6
txn NumAppArgs
int 2
<
bnz main_l8
txna ApplicationArgs 0
byte "CLEANUP"
!=
bnz main_l7
txna ApplicationArgs 1
byte "ABORTING"
!=
bnz main_l6
int 1
bnz main_l5
err
main_l5:
int 0
return
main_l6:
int 1
return
main_l7:
int 1
return
main_l8:
int 1
return


================================================
FILE: tests/teal/router/nontriv_clear_clear_v8.teal
================================================
#pragma version 8
txn NumAppArgs
int 2
<
bnz main_l8
txna ApplicationArgs 0
byte "CLEANUP"
!=
bnz main_l7
txna ApplicationArgs 1
byte "ABORTING"
!=
bnz main_l6
int 1
bnz main_l5
err
main_l5:
int 0
return
main_l6:
int 1
return
main_l7:
int 1
return
main_l8:
int 1
return


================================================
FILE: tests/teal/router/questionable_approval_v6.teal
================================================
#pragma version 6
txn NumAppArgs
int 0
==
bnz main_l20
txna ApplicationArgs 0
method "add(uint64,uint64)uint64"
==
bnz main_l19
txna ApplicationArgs 0
method "sub(uint64,uint64)uint64"
==
bnz main_l18
txna ApplicationArgs 0
method "mul(uint64,uint64)uint64"
==
bnz main_l17
txna ApplicationArgs 0
method "div(uint64,uint64)uint64"
==
bnz main_l16
txna ApplicationArgs 0
method "mod(uint64,uint64)uint64"
==
bnz main_l15
txna ApplicationArgs 0
method "all_laid_to_args(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)uint64"
==
bnz main_l14
txna ApplicationArgs 0
method "empty_return_subroutine()void"
==
bnz main_l13
txna ApplicationArgs 0
method "log_1()uint64"
==
bnz main_l12
txna ApplicationArgs 0
method "log_creation()string"
==
bnz main_l11
err
main_l11:
txn OnCompletion
int NoOp
==
txn ApplicationID
int 0
==
&&
assert
callsub logcreation_8
store 67
byte 0x151f7c75
load 67
concat
log
int 1
return
main_l12:
txn OnCompletion
int NoOp
==
txn ApplicationID
int 0
!=
&&
txn OnCompletion
int OptIn
==
txn ApplicationID
int 0
!=
&&
||
assert
callsub log1_7
store 65
byte 0x151f7c75
load 65
itob
concat
log
int 1
return
main_l13:
txn OnCompletion
int NoOp
==
txn ApplicationID
int 0
!=
&&
txn OnCompletion
int OptIn
==
||
assert
callsub emptyreturnsubroutine_6
int 1
return
main_l14:
txn OnCompletion
int NoOp
==
txn ApplicationID
int 0
!=
&&
assert
txna ApplicationArgs 1
btoi
store 30
txna ApplicationArgs 2
btoi
store 31
txna ApplicationArgs 3
btoi
store 32
txna ApplicationArgs 4
btoi
store 33
txna ApplicationArgs 5
btoi
store 34
txna ApplicationArgs 6
btoi
store 35
txna ApplicationArgs 7
btoi
store 36
txna ApplicationArgs 8
btoi
store 37
txna ApplicationArgs 9
btoi
store 38
txna ApplicationArgs 10
btoi
store 39
txna ApplicationArgs 11
btoi
store 40
txna ApplicationArgs 12
btoi
store 41
txna ApplicationArgs 13
btoi
store 42
txna ApplicationArgs 14
btoi
store 43
txna ApplicationArgs 15
store 46
load 46
int 0
extract_uint64
store 44
load 46
int 8
extract_uint64
store 45
load 30
load 31
load 32
load 33
load 34
load 35
load 36
load 37
load 38
load 39
load 40
load 41
load 42
load 43
load 44
load 45
callsub alllaidtoargs_5
store 47
byte 0x151f7c75
load 47
itob
concat
log
int 1
return
main_l15:
txn OnCompletion
int NoOp
==
txn ApplicationID
int 0
!=
&&
assert
txna ApplicationArgs 1
btoi
store 24
txna ApplicationArgs 2
btoi
store 25
load 24
load 25
callsub mod_4
store 26
byte 0x151f7c75
load 26
itob
concat
log
int 1
return
main_l16:
txn OnCompletion
int NoOp
==
txn ApplicationID
int 0
!=
&&
assert
txna ApplicationArgs 1
btoi
store 18
txna ApplicationArgs 2
btoi
store 19
load 18
load 19
callsub div_3
store 20
byte 0x151f7c75
load 20
itob
concat
log
int 1
return
main_l17:
txn OnCompletion
int NoOp
==
txn ApplicationID
int 0
!=
&&
assert
txna ApplicationArgs 1
btoi
store 12
txna ApplicationArgs 2
btoi
store 13
load 12
load 13
callsub mul_2
store 14
byte 0x151f7c75
load 14
itob
concat
log
int 1
return
main_l18:
txn OnCompletion
int NoOp
==
txn ApplicationID
int 0
!=
&&
assert
txna ApplicationArgs 1
btoi
store 6
txna ApplicationArgs 2
btoi
store 7
load 6
load 7
callsub sub_1
store 8
byte 0x151f7c75
load 8
itob
concat
log
int 1
return
main_l19:
txn OnCompletion
int NoOp
==
txn ApplicationID
int 0
!=
&&
assert
txna ApplicationArgs 1
btoi
store 0
txna ApplicationArgs 2
btoi
store 1
load 0
load 1
callsub add_0
store 2
byte 0x151f7c75
load 2
itob
concat
log
int 1
return
main_l20:
txn OnCompletion
int OptIn
==
bnz main_l22
err
main_l22:
txn ApplicationID
int 0
!=
assert
byte "optin call"
log
int 1
return

// add
add_0:
store 4
store 3
load 3
load 4
+
store 5
load 5
retsub

// sub
sub_1:
store 10
store 9
load 9
load 10
-
store 11
load 11
retsub

// mul
mul_2:
store 16
store 15
load 15
load 16
*
store 17
load 17
retsub

// div
div_3:
store 22
store 21
load 21
load 22
/
store 23
load 23
retsub

// mod
mod_4:
store 28
store 27
load 27
load 28
%
store 29
load 29
retsub

// all_laid_to_args
alllaidtoargs_5:
store 63
store 62
store 61
store 60
store 59
store 58
store 57
store 56
store 55
store 54
store 53
store 52
store 51
store 50
store 49
store 48
load 48
load 49
+
load 50
+
load 51
+
load 52
+
load 53
+
load 54
+
load 55
+
load 56
+
load 57
+
load 58
+
load 59
+
load 60
+
load 61
+
load 62
+
load 63
+
store 64
load 64
retsub

// empty_return_subroutine
emptyreturnsubroutine_6:
byte "appear in both approval and clear state"
log
retsub

// log_1
log1_7:
int 1
store 66
load 66
retsub

// log_creation
logcreation_8:
byte 0x00106c6f6767696e67206372656174696f6e
store 68
load 68
retsub


================================================
FILE: tests/teal/router/questionable_clear_v6.teal
================================================
#pragma version 6
int 1
return


================================================
FILE: tests/teal/router/questionableFP_approval_v8.teal
================================================
#pragma version 8
txn NumAppArgs
int 0
==
bnz main_l20
txna ApplicationArgs 0
method "add(uint64,uint64)uint64"
==
bnz main_l19
txna ApplicationArgs 0
method "sub(uint64,uint64)uint64"
==
bnz main_l18
txna ApplicationArgs 0
method "mul(uint64,uint64)uint64"
==
bnz main_l17
txna ApplicationArgs 0
method "div(uint64,uint64)uint64"
==
bnz main_l16
txna ApplicationArgs 0
method "mod(uint64,uint64)uint64"
==
bnz main_l15
txna ApplicationArgs 0
method "all_laid_to_args(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)uint64"
==
bnz main_l14
txna ApplicationArgs 0
method "empty_return_subroutine()void"
==
bnz main_l13
txna ApplicationArgs 0
method "log_1()uint64"
==
bnz main_l12
txna ApplicationArgs 0
method "log_creation()string"
==
bnz main_l11
err
main_l11:
txn OnCompletion
int NoOp
==
txn ApplicationID
int 0
==
&&
assert
callsub logcreationcaster_17
int 1
return
main_l12:
txn OnCompletion
int NoOp
==
txn ApplicationID
int 0
!=
&&
txn OnCompletion
int OptIn
==
txn ApplicationID
int 0
!=
&&
||
assert
callsub log1caster_16
int 1
return
main_l13:
txn OnCompletion
int NoOp
==
txn ApplicationID
int 0
!=
&&
txn OnCompletion
int OptIn
==
||
assert
callsub emptyreturnsubroutinecaster_15
int 1
return
main_l14:
txn OnCompletion
int NoOp
==
txn ApplicationID
int 0
!=
&&
assert
callsub alllaidtoargscaster_14
int 1
return
main_l15:
txn OnCompletion
int NoOp
==
txn ApplicationID
int 0
!=
&&
assert
callsub modcaster_13
int 1
return
main_l16:
txn OnCompletion
int NoOp
==
txn ApplicationID
int 0
!=
&&
assert
callsub divcaster_12
int 1
return
main_l17:
txn OnCompletion
int NoOp
==
txn ApplicationID
int 0
!=
&&
assert
callsub mulcaster_11
int 1
return
main_l18:
txn OnCompletion
int NoOp
==
txn ApplicationID
int 0
!=
&&
assert
callsub subcaster_10
int 1
return
main_l19:
txn OnCompletion
int NoOp
==
txn ApplicationID
int 0
!=
&&
assert
callsub addcaster_9
int 1
return
main_l20:
txn OnCompletion
int OptIn
==
bnz main_l22
err
main_l22:
txn ApplicationID
int 0
!=
assert
byte "optin call"
log
int 1
return

// add
add_0:
proto 2 1
int 0
frame_dig -2
frame_dig -1
+
frame_bury 0
retsub

// sub
sub_1:
proto 2 1
int 0
frame_dig -2
frame_dig -1
-
frame_bury 0
retsub

// mul
mul_2:
proto 2 1
int 0
frame_dig -2
frame_dig -1
*
frame_bury 0
retsub

// div
div_3:
proto 2 1
int 0
frame_dig -2
frame_dig -1
/
frame_bury 0
retsub

// mod
mod_4:
proto 2 1
int 0
frame_dig -2
frame_dig -1
%
frame_bury 0
retsub

// all_laid_to_args
alllaidtoargs_5:
proto 16 1
int 0
frame_dig -16
frame_dig -15
+
frame_dig -14
+
frame_dig -13
+
frame_dig -12
+
frame_dig -11
+
frame_dig -10
+
frame_dig -9
+
frame_dig -8
+
frame_dig -7
+
frame_dig -6
+
frame_dig -5
+
frame_dig -4
+
frame_dig -3
+
frame_dig -2
+
frame_dig -1
+
frame_bury 0
retsub

// empty_return_subroutine
emptyreturnsubroutine_6:
proto 0 0
byte "appear in both approval and clear state"
log
retsub

// log_1
log1_7:
proto 0 1
int 0
int 1
frame_bury 0
retsub

// log_creation
logcreation_8:
proto 0 1
byte ""
byte 0x00106c6f6767696e67206372656174696f6e
frame_bury 0
retsub

// add_caster
addcaster_9:
proto 0 0
int 0
dupn 2
txna ApplicationArgs 1
btoi
frame_bury 1
txna ApplicationArgs 2
btoi
frame_bury 2
frame_dig 1
frame_dig 2
callsub add_0
frame_bury 0
byte 0x151f7c75
frame_dig 0
itob
concat
log
retsub

// sub_caster
subcaster_10:
proto 0 0
int 0
dupn 2
txna ApplicationArgs 1
btoi
frame_bury 1
txna ApplicationArgs 2
btoi
frame_bury 2
frame_dig 1
frame_dig 2
callsub sub_1
frame_bury 0
byte 0x151f7c75
frame_dig 0
itob
concat
log
retsub

// mul_caster
mulcaster_11:
proto 0 0
int 0
dupn 2
txna ApplicationArgs 1
btoi
frame_bury 1
txna ApplicationArgs 2
btoi
frame_bury 2
frame_dig 1
frame_dig 2
callsub mul_2
frame_bury 0
byte 0x151f7c75
frame_dig 0
itob
concat
log
retsub

// div_caster
divcaster_12:
proto 0 0
int 0
dupn 2
txna ApplicationArgs 1
btoi
frame_bury 1
txna ApplicationArgs 2
btoi
frame_bury 2
frame_dig 1
frame_dig 2
callsub div_3
frame_bury 0
byte 0x151f7c75
frame_dig 0
itob
concat
log
retsub

// mod_caster
modcaster_13:
proto 0 0
int 0
dupn 2
txna ApplicationArgs 1
btoi
frame_bury 1
txna ApplicationArgs 2
btoi
frame_bury 2
frame_dig 1
frame_dig 2
callsub mod_4
frame_bury 0
byte 0x151f7c75
frame_dig 0
itob
concat
log
retsub

// all_laid_to_args_caster
alllaidtoargscaster_14:
proto 0 0
int 0
dupn 16
byte ""
txna ApplicationArgs 1
btoi
frame_bury 1
txna ApplicationArgs 2
btoi
frame_bury 2
txna ApplicationArgs 3
btoi
frame_bury 3
txna ApplicationArgs 4
btoi
frame_bury 4
txna ApplicationArgs 5
btoi
frame_bury 5
txna ApplicationArgs 6
btoi
frame_bury 6
txna ApplicationArgs 7
btoi
frame_bury 7
txna ApplicationArgs 8
btoi
frame_bury 8
txna ApplicationArgs 9
btoi
frame_bury 9
txna ApplicationArgs 10
btoi
frame_bury 10
txna ApplicationArgs 11
btoi
frame_bury 11
txna ApplicationArgs 12
btoi
frame_bury 12
txna ApplicationArgs 13
btoi
frame_bury 13
txna ApplicationArgs 14
btoi
frame_bury 14
txna ApplicationArgs 15
frame_bury 17
frame_dig 17
int 0
extract_uint64
frame_bury 15
frame_dig 17
int 8
extract_uint64
frame_bury 16
frame_dig 1
frame_dig 2
frame_dig 3
frame_dig 4
frame_dig 5
frame_dig 6
frame_dig 7
frame_dig 8
frame_dig 9
frame_dig 10
frame_dig 11
frame_dig 12
frame_dig 13
frame_dig 14
frame_dig 15
frame_dig 16
callsub alllaidtoargs_5
frame_bury 0
byte 0x151f7c75
frame_dig 0
itob
concat
log
retsub

// empty_return_subroutine_caster
emptyreturnsubroutinecaster_15:
proto 0 0
callsub emptyreturnsubroutine_6
retsub

// log_1_caster
log1caster_16:
proto 0 0
int 0
callsub log1_7
frame_bury 0
byte 0x151f7c75
frame_dig 0
itob
concat
log
retsub

// log_creation_caster
logcreationcaster_17:
proto 0 0
byte ""
callsub logcreation_8
frame_bury 0
byte 0x151f7c75
frame_dig 0
concat
log
retsub


================================================
FILE: tests/teal/router/questionableFP_clear_v8.teal
================================================
#pragma version 8
int 1
return


================================================
FILE: tests/teal/router/yacc_approval_v6.teal
================================================
#pragma version 6
txna ApplicationArgs 0
method "add(uint64,uint64)uint64"
==
bnz main_l18
txna ApplicationArgs 0
method "sub(uint64,uint64)uint64"
==
bnz main_l17
txna ApplicationArgs 0
method "mul(uint64,uint64)uint64"
==
bnz main_l16
txna ApplicationArgs 0
method "div(uint64,uint64)uint64"
==
bnz main_l15
txna ApplicationArgs 0
method "mod(uint64,uint64)uint64"
==
bnz main_l14
txna ApplicationArgs 0
method "all_laid_to_args(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)uint64"
==
bnz main_l13
txna ApplicationArgs 0
method "empty_return_subroutine()void"
==
bnz main_l12
txna ApplicationArgs 0
method "log_1()uint64"
==
bnz main_l11
txna ApplicationArgs 0
method "log_creation()string"
==
bnz main_l10
err
main_l10:
txn OnCompletion
int NoOp
==
txn ApplicationID
int 0
==
&&
assert
callsub logcreation_8
store 67
byte 0x151f7c75
load 67
concat
log
int 1
return
main_l11:
txn OnCompletion
int NoOp
==
txn ApplicationID
int 0
!=
&&
txn OnCompletion
int OptIn
==
txn ApplicationID
int 0
!=
&&
||
assert
callsub log1_7
store 65
byte 0x151f7c75
load 65
itob
concat
log
int 1
return
main_l12:
txn OnCompletion
int NoOp
==
txn ApplicationID
int 0
!=
&&
txn OnCompletion
int OptIn
==
||
assert
callsub emptyreturnsubroutine_6
int 1
return
main_l13:
txn OnCompletion
int NoOp
==
txn ApplicationID
int 0
!=
&&
assert
txna ApplicationArgs 1
btoi
store 30
txna ApplicationArgs 2
btoi
store 31
txna ApplicationArgs 3
btoi
store 32
txna ApplicationArgs 4
btoi
store 33
txna ApplicationArgs 5
btoi
store 34
txna ApplicationArgs 6
btoi
store 35
txna ApplicationArgs 7
btoi
store 36
txna ApplicationArgs 8
btoi
store 37
txna ApplicationArgs 9
btoi
store 38
txna ApplicationArgs 10
btoi
store 39
txna ApplicationArgs 11
btoi
store 40
txna ApplicationArgs 12
btoi
store 41
txna ApplicationArgs 13
btoi
store 42
txna ApplicationArgs 14
btoi
store 43
txna ApplicationArgs 15
store 46
load 46
int 0
extract_uint64
store 44
load 46
int 8
extract_uint64
store 45
load 30
load 31
load 32
load 33
load 34
load 35
load 36
load 37
load 38
load 39
load 40
load 41
load 42
load 43
load 44
load 45
callsub alllaidtoargs_5
store 47
byte 0x151f7c75
load 47
itob
concat
log
int 1
return
main_l14:
txn OnCompletion
int NoOp
==
txn ApplicationID
int 0
!=
&&
assert
txna ApplicationArgs 1
btoi
store 24
txna ApplicationArgs 2
btoi
store 25
load 24
load 25
callsub mod_4
store 26
byte 0x151f7c75
load 26
itob
concat
log
int 1
return
main_l15:
txn OnCompletion
int NoOp
==
txn ApplicationID
int 0
!=
&&
assert
txna ApplicationArgs 1
btoi
store 18
txna ApplicationArgs 2
btoi
store 19
load 18
load 19
callsub div_3
store 20
byte 0x151f7c75
load 20
itob
concat
log
int 1
return
main_l16:
txn OnCompletion
int NoOp
==
txn ApplicationID
int 0
!=
&&
assert
txna ApplicationArgs 1
btoi
store 12
txna ApplicationArgs 2
btoi
store 13
load 12
load 13
callsub mul_2
store 14
byte 0x151f7c75
load 14
itob
concat
log
int 1
return
main_l17:
txn OnCompletion
int NoOp
==
txn ApplicationID
int 0
!=
&&
assert
txna ApplicationArgs 1
btoi
store 6
txna ApplicationArgs 2
btoi
store 7
load 6
load 7
callsub sub_1
store 8
byte 0x151f7c75
load 8
itob
concat
log
int 1
return
main_l18:
txn OnCompletion
int NoOp
==
txn ApplicationID
int 0
!=
&&
assert
txna ApplicationArgs 1
btoi
store 0
txna ApplicationArgs 2
btoi
store 1
load 0
load 1
callsub add_0
store 2
byte 0x151f7c75
load 2
itob
concat
log
int 1
return

// add
add_0:
store 4
store 3
load 3
load 4
+
store 5
load 5
retsub

// sub
sub_1:
store 10
store 9
load 9
load 10
-
store 11
load 11
retsub

// mul
mul_2:
store 16
store 15
load 15
load 16
*
store 17
load 17
retsub

// div
div_3:
store 22
store 21
load 21
load 22
/
store 23
load 23
retsub

// mod
mod_4:
store 28
store 27
load 27
load 28
%
store 29
load 29
retsub

// all_laid_to_args
alllaidtoargs_5:
store 63
store 62
store 61
store 60
store 59
store 58
store 57
store 56
store 55
store 54
store 53
store 52
store 51
store 50
store 49
store 48
load 48
load 49
+
load 50
+
load 51
+
load 52
+
load 53
+
load 54
+
load 55
+
load 56
+
load 57
+
load 58
+
load 59
+
load 60
+
load 61
+
load 62
+
load 63
+
store 64
load 64
retsub

// empty_return_subroutine
emptyreturnsubroutine_6:
byte "appear in both approval and clear state"
log
retsub

// log_1
log1_7:
int 1
store 66
load 66
retsub

// log_creation
logcreation_8:
byte 0x00106c6f6767696e67206372656174696f6e
store 68
load 68
retsub


================================================
FILE: tests/teal/router/yacc_clear_v6.teal
================================================
#pragma version 6
int 1
return


================================================
FILE: tests/teal/router/yaccFP_approval_v8.teal
================================================
#pragma version 8
txna ApplicationArgs 0
method "add(uint64,uint64)uint64"
==
bnz main_l18
txna ApplicationArgs 0
method "sub(uint64,uint64)uint64"
==
bnz main_l17
txna ApplicationArgs 0
method "mul(uint64,uint64)uint64"
==
bnz main_l16
txna ApplicationArgs 0
method "div(uint64,uint64)uint64"
==
bnz main_l15
txna ApplicationArgs 0
method "mod(uint64,uint64)uint64"
==
bnz main_l14
txna ApplicationArgs 0
method "all_laid_to_args(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)uint64"
==
bnz main_l13
txna ApplicationArgs 0
method "empty_return_subroutine()void"
==
bnz main_l12
txna ApplicationArgs 0
method "log_1()uint64"
==
bnz main_l11
txna ApplicationArgs 0
method "log_creation()string"
==
bnz main_l10
err
main_l10:
txn OnCompletion
int NoOp
==
txn ApplicationID
int 0
==
&&
assert
callsub logcreationcaster_17
int 1
return
main_l11:
txn OnCompletion
int NoOp
==
txn ApplicationID
int 0
!=
&&
txn OnCompletion
int OptIn
==
txn ApplicationID
int 0
!=
&&
||
assert
callsub log1caster_16
int 1
return
main_l12:
txn OnCompletion
int NoOp
==
txn ApplicationID
int 0
!=
&&
txn OnCompletion
int OptIn
==
||
assert
callsub emptyreturnsubroutinecaster_15
int 1
return
main_l13:
txn OnCompletion
int NoOp
==
txn ApplicationID
int 0
!=
&&
assert
callsub alllaidtoargscaster_14
int 1
return
main_l14:
txn OnCompletion
int NoOp
==
txn ApplicationID
int 0
!=
&&
assert
callsub modcaster_13
int 1
return
main_l15:
txn OnCompletion
int NoOp
==
txn ApplicationID
int 0
!=
&&
assert
callsub divcaster_12
int 1
return
main_l16:
txn OnCompletion
int NoOp
==
txn ApplicationID
int 0
!=
&&
assert
callsub mulcaster_11
int 1
return
main_l17:
txn OnCompletion
int NoOp
==
txn ApplicationID
int 0
!=
&&
assert
callsub subcaster_10
int 1
return
main_l18:
txn OnCompletion
int NoOp
==
txn ApplicationID
int 0
!=
&&
assert
callsub addcaster_9
int 1
return

// add
add_0:
proto 2 1
int 0
frame_dig -2
frame_dig -1
+
frame_bury 0
retsub

// sub
sub_1:
proto 2 1
int 0
frame_dig -2
frame_dig -1
-
frame_bury 0
retsub

// mul
mul_2:
proto 2 1
int 0
frame_dig -2
frame_dig -1
*
frame_bury 0
retsub

// div
div_3:
proto 2 1
int 0
frame_dig -2
frame_dig -1
/
frame_bury 0
retsub

// mod
mod_4:
proto 2 1
int 0
frame_dig -2
frame_dig -1
%
frame_bury 0
retsub

// all_laid_to_args
alllaidtoargs_5:
proto 16 1
int 0
frame_dig -16
frame_dig -15
+
frame_dig -14
+
frame_dig -13
+
frame_dig -12
+
frame_dig -11
+
frame_dig -10
+
frame_dig -9
+
frame_dig -8
+
frame_dig -7
+
frame_dig -6
+
frame_dig -5
+
frame_dig -4
+
frame_dig -3
+
frame_dig -2
+
frame_dig -1
+
frame_bury 0
retsub

// empty_return_subroutine
emptyreturnsubroutine_6:
proto 0 0
byte "appear in both approval and clear state"
log
retsub

// log_1
log1_7:
proto 0 1
int 0
int 1
frame_bury 0
retsub

// log_creation
logcreation_8:
proto 0 1
byte ""
byte 0x00106c6f6767696e67206372656174696f6e
frame_bury 0
retsub

// add_caster
addcaster_9:
proto 0 0
int 0
dupn 2
txna ApplicationArgs 1
btoi
frame_bury 1
txna ApplicationArgs 2
btoi
frame_bury 2
frame_dig 1
frame_dig 2
callsub add_0
frame_bury 0
byte 0x151f7c75
frame_dig 0
itob
concat
log
retsub

// sub_caster
subcaster_10:
proto 0 0
int 0
dupn 2
txna ApplicationArgs 1
btoi
frame_bury 1
txna ApplicationArgs 2
btoi
frame_bury 2
frame_dig 1
frame_dig 2
callsub sub_1
frame_bury 0
byte 0x151f7c75
frame_dig 0
itob
concat
log
retsub

// mul_caster
mulcaster_11:
proto 0 0
int 0
dupn 2
txna ApplicationArgs 1
btoi
frame_bury 1
txna ApplicationArgs 2
btoi
frame_bury 2
frame_dig 1
frame_dig 2
callsub mul_2
frame_bury 0
byte 0x151f7c75
frame_dig 0
itob
concat
log
retsub

// div_caster
divcaster_12:
proto 0 0
int 0
dupn 2
txna ApplicationArgs 1
btoi
frame_bury 1
txna ApplicationArgs 2
btoi
frame_bury 2
frame_dig 1
frame_dig 2
callsub div_3
frame_bury 0
byte 0x151f7c75
frame_dig 0
itob
concat
log
retsub

// mod_caster
modcaster_13:
proto 0 0
int 0
dupn 2
txna ApplicationArgs 1
btoi
frame_bury 1
txna ApplicationArgs 2
btoi
frame_bury 2
frame_dig 1
frame_dig 2
callsub mod_4
frame_bury 0
byte 0x151f7c75
frame_dig 0
itob
concat
log
retsub

// all_laid_to_args_caster
alllaidtoargscaster_14:
proto 0 0
int 0
dupn 16
byte ""
txna ApplicationArgs 1
btoi
frame_bury 1
txna ApplicationArgs 2
btoi
frame_bury 2
txna ApplicationArgs 3
btoi
frame_bury 3
txna ApplicationArgs 4
btoi
frame_bury 4
txna ApplicationArgs 5
btoi
frame_bury 5
txna ApplicationArgs 6
btoi
frame_bury 6
txna ApplicationArgs 7
btoi
frame_bury 7
txna ApplicationArgs 8
btoi
frame_bury 8
txna ApplicationArgs 9
btoi
frame_bury 9
txna ApplicationArgs 10
btoi
frame_bury 10
txna ApplicationArgs 11
btoi
frame_bury 11
txna ApplicationArgs 12
btoi
frame_bury 12
txna ApplicationArgs 13
btoi
frame_bury 13
txna ApplicationArgs 14
btoi
frame_bury 14
txna ApplicationArgs 15
frame_bury 17
frame_dig 17
int 0
extract_uint64
frame_bury 15
frame_dig 17
int 8
extract_uint64
frame_bury 16
frame_dig 1
frame_dig 2
frame_dig 3
frame_dig 4
frame_dig 5
frame_dig 6
frame_dig 7
frame_dig 8
frame_dig 9
frame_dig 10
frame_dig 11
frame_dig 12
frame_dig 13
frame_dig 14
frame_dig 15
frame_dig 16
callsub alllaidtoargs_5
frame_bury 0
byte 0x151f7c75
frame_dig 0
itob
concat
log
retsub

// empty_return_subroutine_caster
emptyreturnsubroutinecaster_15:
proto 0 0
callsub emptyreturnsubroutine_6
retsub

// log_1_caster
log1caster_16:
proto 0 0
int 0
callsub log1_7
frame_bury 0
byte 0x151f7c75
frame_dig 0
itob
concat
log
retsub

// log_creation_caster
logcreationcaster_17:
proto 0 0
byte ""
callsub logcreation_8
frame_bury 0
byte 0x151f7c75
frame_dig 0
concat
log
retsub


================================================
FILE: tests/teal/router/yaccFP_clear_v8.teal
================================================
#pragma version 8
int 1
return


================================================
FILE: tests/unit/__init__.py
================================================
[Empty file]


================================================
FILE: tests/unit/blackbox_test.py
================================================
# TODO: add blackbox_test.py to multithreaded tests when following issue has been fixed:
# 	https://github.com/algorand/pyteal/issues/199


from itertools import product
from pathlib import Path
from typing import Literal, Optional, Tuple
from unittest.mock import MagicMock

import pytest
from algosdk.v2client.algod import AlgodClient
from graviton.inspector import DryRunProperty as DRProp

import pyteal as pt
from tests.blackbox import (
    Blackbox,
    BlackboxWrapper,
    PyTealDryRunExecutor,
    RouterSimulation,
)
from tests.compile_asserts import assert_teal_as_expected

PATH = Path.cwd() / "tests" / "unit"
FIXTURES = PATH / "teal"
GENERATED = PATH / "generated"

# ---- Subroutine Unit Test Examples ---- #


@Blackbox(input_types=[])
@pt.Subroutine(pt.TealType.none)
def utest_noop():
    return pt.Pop(pt.Int(0))


@Blackbox(input_types=[pt.TealType.uint64, pt.TealType.bytes, pt.TealType.anytype])
@pt.Subroutine(pt.TealType.none)
def utest_noop_args(x, y, z):
    return pt.Pop(pt.Int(0))


@Blackbox(input_types=[])
@pt.Subroutine(pt.TealType.uint64)
def utest_int():
    return pt.Int(0)


@Blackbox(input_types=[pt.TealType.uint64, pt.TealType.bytes, pt.TealType.anytype])
@pt.Subroutine(pt.TealType.uint64)
def utest_int_args(x, y, z):
    return pt.Int(0)


@Blackbox(input_types=[])
@pt.Subroutine(pt.TealType.bytes)
def utest_bytes():
    return pt.Bytes("")


@Blackbox(input_types=[pt.TealType.uint64, pt.TealType.bytes, pt.TealType.anytype])
@pt.Subroutine(pt.TealType.bytes)
def utest_bytes_args(x, y, z):
    return pt.Bytes("")


@Blackbox(input_types=[])
@pt.Subroutine(pt.TealType.anytype)
def utest_any():
    x = pt.ScratchVar(pt.TealType.anytype)
    return pt.Seq(x.store(pt.Int(0)), x.load())


@Blackbox(input_types=[pt.TealType.uint64, pt.TealType.bytes, pt.TealType.anytype])
@pt.Subroutine(pt.TealType.anytype)
def utest_any_args(x, y, z):
    x = pt.ScratchVar(pt.TealType.anytype)
    return pt.Seq(x.store(pt.Int(0)), x.load())


UNITS = [
    utest_noop,
    utest_noop_args,
    utest_int,
    utest_int_args,
    utest_bytes,
    utest_bytes_args,
    utest_any,
    utest_any_args,
]


# ---- ABI Return Subroutine Unit Test Examples ---- #


@Blackbox(input_types=[])
@pt.ABIReturnSubroutine
def fn_0arg_0ret() -> pt.Expr:
    return pt.Return()


@Blackbox(input_types=[])
@pt.ABIReturnSubroutine
def fn_0arg_uint64_ret(*, output: pt.abi.Uint64) -> pt.Expr:
    return output.set(1)


@Blackbox(input_types=[None])
@pt.ABIReturnSubroutine
def fn_1arg_0ret(a: pt.abi.Uint64) -> pt.Expr:
    return pt.Return()


@Blackbox(input_types=[None])
@pt.ABIReturnSubroutine
def fn_1arg_1ret(a: pt.abi.Uint64, *, output: pt.abi.Uint64) -> pt.Expr:
    return output.set(a)


@Blackbox(input_types=[None, None])
@pt.ABIReturnSubroutine
def fn_2arg_0ret(
    a: pt.abi.Uint64, b: pt.abi.StaticArray[pt.abi.Byte, Literal[10]]
) -> pt.Expr:
    return pt.Return()


@Blackbox(input_types=[pt.TealType.bytes])
@pt.ABIReturnSubroutine
def fn_1tt_arg_uint64_ret(x, *, output: pt.abi.Uint64) -> pt.Expr:
    return output.set(1)


@Blackbox(input_types=[None, pt.TealType.uint64, None])
@pt.ABIReturnSubroutine
def fn_3mixed_args_0ret(
    a: pt.abi.Uint64, b: pt.ScratchVar, C: pt.abi.StaticArray[pt.abi.Byte, Literal[10]]
) -> pt.Expr:
    return pt.Return()


@Blackbox(input_types=[None, pt.TealType.bytes])
@pt.ABIReturnSubroutine
def fn_2mixed_arg_1ret(
    a: pt.abi.Uint64, b: pt.ScratchVar, *, output: pt.abi.Uint64
) -> pt.Expr:
    return pt.Seq(b.store(a.encode()), output.set(a))


ABI_UNITS = [
    (fn_0arg_0ret, None),
    (fn_0arg_uint64_ret, pt.abi.Uint64()),
    (fn_1arg_0ret, None),
    (fn_1arg_1ret, pt.abi.Uint64()),
    (fn_2arg_0ret, None),
    (fn_1tt_arg_uint64_ret, pt.abi.Uint64()),
    (fn_3mixed_args_0ret, None),
    (fn_2mixed_arg_1ret, pt.abi.Uint64()),
]


# ---- test functions ---- #


@pytest.mark.parametrize("subr, mode", product(UNITS, pt.Mode))
@pytest.mark.serial  # Serial due to scratch generation
def test_blackbox_pyteal(subr: BlackboxWrapper, mode: pt.Mode):
    is_app = mode == pt.Mode.Application
    name = f"{'app' if is_app else 'lsig'}_{subr.name()}"

    compiled = PyTealDryRunExecutor(subr, mode).compile(version=6)
    tealdir = GENERATED / "blackbox"
    tealdir.mkdir(parents=True, exist_ok=True)
    save_to = tealdir / (name + ".teal")
    with open(save_to, "w") as f:
        f.write(compiled)

    assert_teal_as_expected(save_to, FIXTURES / "blackbox" / (name + ".teal"))


@pytest.mark.parametrize("subr_abi, mode", product(ABI_UNITS, pt.Mode))
@pytest.mark.serial  # Serial due to scratch generation
def test_abi_blackbox_pyteal(
    subr_abi: Tuple[BlackboxWrapper, Optional[pt.ast.abi.BaseType]], mode: pt.Mode
):
    subr, abi_return_type = subr_abi
    name = f"{'app' if mode == pt.Mode.Application else 'lsig'}_{subr.name()}"
    print(f"Case {subr.name()=}, {abi_return_type=}, {mode=} ------> {name=}")

    pdre = PyTealDryRunExecutor(subr, mode)
    assert pdre.is_abi(), "should be an ABI subroutine"

    arg_types = pdre.abi_argument_types()
    if subr.name() != "fn_1tt_arg_uint64_ret":
        assert not arg_types or any(
            arg_types
        ), "abi_argument_types() should have had some abi info"

    if abi_return_type:
        expected_sdk_return_type = pt.abi.algosdk_from_type_spec(
            abi_return_type.type_spec()
        )
        assert expected_sdk_return_type == pdre.abi_return_type()
    else:
        assert pdre.abi_return_type() is None

    compiled = pdre.compile(version=6)
    tealdir = GENERATED / "abi"
    tealdir.mkdir(parents=True, exist_ok=True)
    save_to = tealdir / (name + ".teal")
    with open(save_to, "w") as f:
        f.write(compiled)

    assert_teal_as_expected(save_to, FIXTURES / "abi" / (name + ".teal"))


@pytest.mark.parametrize("mode", (pt.Mode.Application, pt.Mode.Signature))
@pytest.mark.parametrize(
    "fn, expected_is_abi", ((utest_noop, False), (fn_0arg_uint64_ret, True))
)
@pytest.mark.serial
def test_PyTealBlackboxExecutor_is_abi(
    mode: pt.Mode, fn: BlackboxWrapper, expected_is_abi: bool
):
    p = PyTealDryRunExecutor(fn, mode)
    assert p.is_abi() == expected_is_abi
    if expected_is_abi:
        assert p.abi_argument_types() is not None
        assert p.abi_return_type() is not None
    else:
        assert p.abi_argument_types() is None
        assert p.abi_return_type() is None


@pytest.mark.parametrize("mode", (pt.Mode.Application, pt.Mode.Signature))
@pytest.mark.parametrize(
    "fn, expected_arg_count",
    (
        (fn_0arg_uint64_ret, 0),
        (fn_1arg_0ret, 1),
        (fn_1arg_1ret, 1),
        (fn_2arg_0ret, 2),
        (fn_2mixed_arg_1ret, 2),
    ),
)
@pytest.mark.serial
def test_PyTealBlackboxExecutor_abi_argument_types(
    mode: pt.Mode, fn: BlackboxWrapper, expected_arg_count: int
):
    actual = PyTealDryRunExecutor(fn, mode).abi_argument_types()
    assert actual is not None
    assert len(actual) == expected_arg_count


@pytest.mark.parametrize("mode", (pt.Mode.Application, pt.Mode.Signature))
@pytest.mark.parametrize(
    "fn, expected_does_produce_type",
    (
        (fn_0arg_uint64_ret, True),
        (fn_1arg_0ret, False),
        (fn_1arg_1ret, True),
        (fn_2arg_0ret, False),
        (fn_2mixed_arg_1ret, True),
    ),
)
@pytest.mark.serial
def test_PyTealBlackboxExecutor_abi_return_type(
    mode: pt.Mode, fn: BlackboxWrapper, expected_does_produce_type: bool
):
    if expected_does_produce_type:
        assert PyTealDryRunExecutor(fn, mode).abi_return_type() is not None
    else:
        assert PyTealDryRunExecutor(fn, mode).abi_return_type() is None


def successful_RouterSimulation(router, model_router, predicates, algod):
    rsim = RouterSimulation(
        router,
        predicates,
        model_router=model_router,
        algod=algod,
    )
    assert rsim.router == router
    assert rsim.predicates == predicates
    assert rsim.model_router == model_router
    assert rsim.algod == algod

    return rsim


def failing_RouterSimulation(router, model_router, predicates, algod, err_msg):
    with pytest.raises(AssertionError) as ae:
        RouterSimulation(
            router,
            predicates,
            model_router=model_router,
            algod=algod,
        )
    assert err_msg == str(ae.value)


def test_RouterSimulation_init():
    router = "not a router"
    model_router = "not a router either"
    predicates = "totally unchecked at init"
    algod = MagicMock(spec=AlgodClient)

    # many paths to misery:
    err_msg = "Wrong type for Base Router: <class 'str'>"
    failing_RouterSimulation(router, model_router, predicates, algod, err_msg)

    router = pt.Router("test_router")
    err_msg = "make sure to give at least one key/value pair in method_configs"
    failing_RouterSimulation(router, model_router, predicates, algod, err_msg)

    router.add_method_handler(
        pt.ABIReturnSubroutine(lambda: pt.Int(1)), overriding_name="foo"
    )
    err_msg = "Wrong type for predicates: <class 'str'>. Please provide: dict[str | None, dict[graviton.DryRunProporty, Any]."
    failing_RouterSimulation(router, model_router, predicates, algod, err_msg)

    predicates = {}
    err_msg = "Please provide at least one method to call and assert against."
    failing_RouterSimulation(router, model_router, predicates, algod, err_msg)

    predicates = {3: "blah"}
    err_msg = "Predicates method '3' has type <class 'int'> but only 'str' and 'NoneType' and Literal['ClearStateCall'] (== ClearStateCall) are allowed."
    failing_RouterSimulation(router, model_router, predicates, algod, err_msg)

    predicates = {Literal[42]: "blah"}
    err_msg = "Predicates method 'typing.Literal[42]' is not allowed. Only Literal['ClearStateCall'] (== ClearStateCall) is allowed for a Literal."
    failing_RouterSimulation(router, model_router, predicates, algod, err_msg)

    predicates = {"bar": {DRProp.passed: True}, "foo": {}}
    err_msg = "Every method must provide at least one predicate for assertion but method 'foo' is missing predicates."
    failing_RouterSimulation(router, model_router, predicates, algod, err_msg)

    predicates = {"bar": {DRProp.passed: True}, "foo": 42}
    err_msg = "Method 'foo' is expected to have dict[graviton.DryRunProperty, Any] for its predicates value but the type is <class 'int'>."
    failing_RouterSimulation(router, model_router, predicates, algod, err_msg)

    predicates = {"bar": {DRProp.passed: True}, "foo": {"blah": 45}}
    err_msg = "Method 'foo' is expected to have dict[graviton.DryRunProperty, Any] for its predicates value but predicates['foo'] has key 'blah' of <class 'str'>."
    failing_RouterSimulation(router, model_router, predicates, algod, err_msg)

    predicates = {"bar": {DRProp.passed: True}, "foo": {DRProp.budgetAdded: 45}}
    err_msg = "Wrong type for Model Router: <class 'str'>"
    failing_RouterSimulation(router, model_router, predicates, algod, err_msg)

    model_router = pt.Router("test_router")
    err_msg = "make sure to give at least one key/value pair in method_configs"
    failing_RouterSimulation(router, model_router, predicates, algod, err_msg)

    # Finally, two happy paths
    model_router.add_method_handler(
        pt.ABIReturnSubroutine(lambda: pt.Int(1)), overriding_name="foo"
    )
    successful_RouterSimulation(router, model_router, predicates, algod)

    model_router = None
    successful_RouterSimulation(router, model_router, predicates, algod)



================================================
FILE: tests/unit/compile_test.py
================================================
from pathlib import Path
import pytest
import json

import pyteal as pt


def test_abi_algobank():
    from pyteal.compiler.optimizer import OptimizeOptions

    from examples.application.abi.algobank import router

    approval_program, clear_state_program, contract = router.compile_program(
        version=6, optimize=OptimizeOptions(scratch_slots=True)
    )
    target_dir = Path.cwd() / "examples" / "application" / "abi"

    with open(
        target_dir / "algobank_approval.teal", "r"
    ) as expected_approval_program_file:
        expected_approval_program = "".join(
            expected_approval_program_file.readlines()
        ).strip()
        assert approval_program == expected_approval_program

    with open(
        target_dir / "algobank_clear_state.teal", "r"
    ) as expected_clear_state_program_file:
        expected_clear_state_program = "".join(
            expected_clear_state_program_file.readlines()
        ).strip()
        assert clear_state_program == expected_clear_state_program

    with open(target_dir / "algobank.json", "r") as expected_contract_file:
        expected_contract = json.load(expected_contract_file)
        assert contract.dictify() == expected_contract


def test_basic_bank():
    from examples.signature.basic import bank_for_account

    program = bank_for_account(
        "ZZAF5ARA4MEC5PVDOP64JM5O5MQST63Q2KOY2FLYFLXXD3PFSNJJBYAFZM"
    )

    target_path = Path.cwd() / "examples" / "signature" / "basic.teal"

    with open(target_path, "r") as target_file:
        target = "".join(target_file.readlines()).strip()
        assert pt.compileTeal(program, mode=pt.Mode.Signature, version=3) == target


def test_atomic_swap():
    from examples.signature.atomic_swap import htlc

    program = htlc()

    target_path = Path.cwd() / "examples" / "signature" / "atomic_swap.teal"

    with open(target_path, "r") as target_file:
        target = "".join(target_file.readlines()).strip()
        assert pt.compileTeal(program, mode=pt.Mode.Signature, version=2) == target


def test_periodic_payment():
    from examples.signature.periodic_payment import periodic_payment

    program = periodic_payment()

    target_path = Path.cwd() / "examples" / "signature" / "periodic_payment.teal"
    with open(target_path, "r") as target_file:
        target = "".join(target_file.readlines()).strip()
        assert pt.compileTeal(program, mode=pt.Mode.Signature, version=2) == target


def test_split():
    from examples.signature.split import split

    program = split()

    target_path = Path.cwd() / "examples" / "signature" / "split.teal"

    with open(target_path, "r") as target_file:
        target = "".join(target_file.readlines()).strip()
        assert pt.compileTeal(program, mode=pt.Mode.Signature, version=2) == target


def test_dutch_auction():
    from examples.signature.dutch_auction import dutch_auction

    program = dutch_auction()

    target_path = Path.cwd() / "examples" / "signature" / "dutch_auction.teal"

    with open(target_path, "r") as target_file:
        target = "".join(target_file.readlines()).strip()
        assert pt.compileTeal(program, mode=pt.Mode.Signature, version=2) == target


def test_recurring_swap():
    from examples.signature.recurring_swap import recurring_swap

    program = recurring_swap()

    target_path = Path.cwd() / "examples" / "signature" / "recurring_swap.teal"

    with open(target_path, "r") as target_file:
        target = "".join(target_file.readlines()).strip()
        assert pt.compileTeal(program, mode=pt.Mode.Signature, version=2) == target


def test_asset():
    from examples.application.asset import approval_program, clear_state_program

    approval = approval_program()
    clear_state = clear_state_program()

    # only checking for successful compilation for now
    pt.compileTeal(approval, mode=pt.Mode.Application, version=2)
    pt.compileTeal(clear_state, mode=pt.Mode.Application, version=2)


def test_security_token():
    from examples.application.security_token import (
        approval_program,
        clear_state_program,
    )

    approval = approval_program()
    clear_state = clear_state_program()

    # only checking for successful compilation for now
    pt.compileTeal(approval, mode=pt.Mode.Application, version=2)
    pt.compileTeal(clear_state, mode=pt.Mode.Application, version=2)


def test_vote():
    from examples.application.vote import approval_program, clear_state_program

    approval = approval_program()
    clear_state = clear_state_program()

    # only checking for successful compilation for now
    pt.compileTeal(approval, mode=pt.Mode.Application, version=2)
    pt.compileTeal(clear_state, mode=pt.Mode.Application, version=2)


def test_cond():
    cond1 = pt.Txn.fee() < pt.Int(2000)
    cond2 = pt.Txn.amount() > pt.Int(5000)
    cond3 = pt.Txn.receiver() == pt.Txn.sender()
    core = pt.Cond(
        [pt.Global.group_size() == pt.Int(2), cond1],
        [pt.Global.group_size() == pt.Int(3), cond2],
        [pt.Global.group_size() == pt.Int(4), cond3],
    )
    pt.compileTeal(core, mode=pt.Mode.Signature, version=2)


@pytest.mark.timeout(5)
def test_many_ifs():
    """
    Test with many pt.If statements to trigger potential corner cases in code generation.
    Previous versions of PyTeal took an exponential time to generate the TEAL code for this PyTEAL.
    """

    sv = pt.ScratchVar(pt.TealType.uint64)
    s = pt.Seq(
        [
            pt.If(
                pt.Int(3 * i) == pt.Int(3 * i),
                sv.store(pt.Int(3 * i + 1)),
                sv.store(pt.Int(3 * i + 2)),
            )
            for i in range(30)
        ]
        + [pt.Return(sv.load())]
    )

    pt.compileTeal(s, mode=pt.Mode.Signature, version=2)



================================================
FILE: tests/unit/feature_gates_test.py
================================================
import pytest

from feature_gates import FeatureGates


@pytest.mark.serial
def test_feature_gates():
    with pytest.raises(ValueError, match="Unknown feature='foo'"):
        FeatureGates.get("foo")

    with pytest.raises(ValueError, match="Cannot set unknown feature='foo'"):
        FeatureGates.set("foo", 42)

    default_sourcemap_gate: bool = FeatureGates._gates.sourcemap_enabled
    default_sourcemap_debug_gate: bool = FeatureGates._gates.sourcemap_debug
    assert FeatureGates.get("sourcemap_enabled") is default_sourcemap_gate
    assert FeatureGates.get("sourcemap_debug") is default_sourcemap_debug_gate
    assert FeatureGates.sourcemap_enabled() is default_sourcemap_gate
    assert FeatureGates.sourcemap_debug() is default_sourcemap_debug_gate

    from pyteal import stack_frame

    assert stack_frame.NatalStackFrame.sourcemapping_is_off() is True

    # enable source mapping:
    FeatureGates.set("sourcemap_enabled", True)
    FeatureGates.set("sourcemap_debug", True)
    assert FeatureGates._gates.sourcemap_enabled is True
    assert FeatureGates._gates.sourcemap_debug is True
    assert FeatureGates.get("sourcemap_enabled") is True
    assert FeatureGates.get("sourcemap_debug") is True
    assert FeatureGates.sourcemap_enabled() is True
    assert FeatureGates.sourcemap_debug() is True

    assert stack_frame.NatalStackFrame.sourcemapping_is_off() is False

    # disable source mapping:
    FeatureGates.set("sourcemap_enabled", False)
    FeatureGates.set("sourcemap_debug", False)
    assert FeatureGates._gates.sourcemap_enabled is False
    assert FeatureGates._gates.sourcemap_debug is False
    assert FeatureGates.get("sourcemap_enabled") is False
    assert FeatureGates.get("sourcemap_debug") is False
    assert FeatureGates.sourcemap_enabled() is False
    assert FeatureGates.sourcemap_debug() is False



================================================
FILE: tests/unit/module_test.py
================================================
from pyteal import *


def test_export_int():
    from pyteal import ast

    assert int != ast.int



================================================
FILE: tests/unit/pass_by_ref_test.py
================================================
import pytest

import pyteal as pt

from tests.compile_asserts import assert_new_v_old

# TODO: remove these skips when the following is fixed: https://github.com/algorand/pyteal/issues/199
STABLE_SLOT_GENERATION = False


# ### TESTS FOR NEW PyTEAL THAT USES PASS-BY-REF / DYNAMIC
@pt.Subroutine(pt.TealType.none)
def logcat_dynamic(first: pt.ScratchVar, an_int):
    return pt.Seq(
        first.store(pt.Concat(first.load(), pt.Itob(an_int))),
        pt.Log(first.load()),
    )


def sub_logcat_dynamic():
    first = pt.ScratchVar(pt.TealType.bytes)
    return pt.Seq(
        first.store(pt.Bytes("hello")),
        logcat_dynamic(first, pt.Int(42)),
        pt.Assert(pt.Bytes("hello42") == first.load()),
        pt.Int(1),
    )


def wilt_the_stilt():
    player_score = pt.DynamicScratchVar(pt.TealType.uint64)

    wilt = pt.ScratchVar(pt.TealType.uint64, 129)
    kobe = pt.ScratchVar(pt.TealType.uint64)
    dt = pt.ScratchVar(pt.TealType.uint64, 131)

    return pt.Seq(
        player_score.set_index(wilt),
        player_score.store(pt.Int(100)),
        player_score.set_index(kobe),
        player_score.store(pt.Int(81)),
        player_score.set_index(dt),
        player_score.store(pt.Int(73)),
        pt.Assert(player_score.load() == pt.Int(73)),
        pt.Assert(player_score.index() == pt.Int(131)),
        player_score.set_index(wilt),
        pt.Assert(player_score.load() == pt.Int(100)),
        pt.Assert(player_score.index() == pt.Int(129)),
        pt.Int(100),
    )


@pt.Subroutine(pt.TealType.none)
def swap(x: pt.ScratchVar, y: pt.ScratchVar):
    z = pt.ScratchVar(pt.TealType.anytype)
    return pt.Seq(
        z.store(x.load()),
        x.store(y.load()),
        y.store(z.load()),
    )


@pt.Subroutine(pt.TealType.none)
def cat(x, y):
    return pt.Pop(pt.Concat(x, y))


def swapper():
    a = pt.ScratchVar(pt.TealType.bytes)
    b = pt.ScratchVar(pt.TealType.bytes)
    return pt.Seq(
        a.store(pt.Bytes("hello")),
        b.store(pt.Bytes("goodbye")),
        cat(a.load(), b.load()),
        swap(a, b),
        pt.Assert(a.load() == pt.Bytes("goodbye")),
        pt.Assert(b.load() == pt.Bytes("hello")),
        pt.Int(1000),
    )


@pt.Subroutine(pt.TealType.uint64)
def mixed_annotations(x: pt.Expr, y: pt.Expr, z: pt.ScratchVar) -> pt.Expr:
    return pt.Seq(
        z.store(x),
        pt.Log(pt.Concat(y, pt.Bytes("="), pt.Itob(x))),
        x,
    )


def sub_mixed():
    x = pt.Int(42)
    y = pt.Bytes("x")
    z = pt.ScratchVar(pt.TealType.uint64)
    return mixed_annotations(x, y, z)


def lots_o_vars():
    z = pt.Int(0)
    one = pt.ScratchVar()
    two = pt.ScratchVar()
    three = pt.ScratchVar()
    four = pt.ScratchVar()
    five = pt.Bytes("five")
    six = pt.Bytes("six")
    seven = pt.Bytes("seven")
    eight = pt.Bytes("eight")
    nine = pt.Bytes("nine")
    ten = pt.Bytes("ten")
    eleven = pt.Bytes("eleven")
    twelve = pt.Bytes("twelve")
    int_cursor = pt.DynamicScratchVar(pt.TealType.uint64)
    bytes_cursor = pt.DynamicScratchVar(pt.TealType.bytes)
    thirteen = pt.ScratchVar(pt.TealType.uint64, 13)
    fourteen = pt.ScratchVar(pt.TealType.bytes, 14)
    fifteen = pt.ScratchVar(pt.TealType.uint64)
    sixteen = pt.ScratchVar(pt.TealType.bytes)
    leet = pt.Int(1337)
    ngl = pt.Bytes("NGL: ")
    return (
        pt.If(
            pt.Or(
                pt.App.id() == pt.Int(0), pt.Txn.application_args.length() == pt.Int(0)
            )
        )
        .Then(pt.Int(1))
        .Else(
            pt.Seq(
                one.store(pt.Int(1)),
                two.store(pt.Bytes("two")),
                three.store(pt.Int(3)),
                four.store(pt.Bytes("four")),
                pt.App.localPut(z, five, pt.Int(5)),
                pt.App.localPut(z, six, six),
                pt.App.localPut(z, seven, pt.Int(7)),
                pt.App.localPut(z, eight, eight),
                pt.App.globalPut(nine, pt.Int(9)),
                pt.App.globalPut(ten, ten),
                pt.App.globalPut(eleven, pt.Int(11)),
                pt.App.globalPut(twelve, twelve),
                one.store(one.load() + leet),
                two.store(pt.Concat(ngl, two.load())),
                three.store(three.load() + leet),
                four.store(pt.Concat(ngl, four.load())),
                pt.App.localPut(z, five, leet + pt.App.localGet(z, five)),
                pt.App.localPut(z, six, pt.Concat(ngl, pt.App.localGet(z, six))),
                pt.App.localPut(z, seven, pt.App.localGet(z, seven)),
                pt.App.localPut(z, eight, pt.Concat(ngl, pt.App.localGet(z, eight))),
                pt.App.globalPut(nine, leet + pt.App.globalGet(nine)),
                pt.App.globalPut(ten, pt.Concat(ngl, pt.App.globalGet(ten))),
                pt.App.globalPut(eleven, leet + pt.App.globalGet(eleven)),
                pt.App.globalPut(twelve, pt.Concat(ngl, pt.App.globalGet(twelve))),
                thirteen.store(pt.Btoi(pt.Txn.application_args[0])),
                fourteen.store(pt.Txn.application_args[1]),
                fifteen.store(pt.Btoi(pt.Txn.application_args[2])),
                sixteen.store(pt.Txn.application_args[3]),
                pt.Pop(one.load()),
                pt.Pop(two.load()),
                pt.Pop(three.load()),
                pt.Pop(four.load()),
                pt.Pop(pt.App.localGet(z, five)),
                pt.Pop(pt.App.localGet(z, six)),
                pt.Pop(pt.App.localGet(z, seven)),
                pt.Pop(pt.App.localGet(z, eight)),
                pt.Pop(pt.App.globalGet(nine)),
                pt.Pop(pt.App.globalGet(ten)),
                pt.Pop(pt.App.globalGet(eleven)),
                pt.Pop(pt.App.globalGet(twelve)),
                int_cursor.set_index(thirteen),
                pt.Log(pt.Itob(int_cursor.load())),
                bytes_cursor.set_index(fourteen),
                pt.Log(bytes_cursor.load()),
                int_cursor.set_index(fifteen),
                pt.Log(pt.Itob(int_cursor.load())),
                bytes_cursor.set_index(sixteen),
                pt.Log(bytes_cursor.load()),
                leet,
            )
        )
    )


def empty_scratches():
    cursor = pt.DynamicScratchVar()
    i1 = pt.ScratchVar(pt.TealType.uint64, 0)
    i2 = pt.ScratchVar(pt.TealType.uint64, 2)
    i3 = pt.ScratchVar(pt.TealType.uint64, 4)
    s1 = pt.ScratchVar(pt.TealType.bytes, 1)
    s2 = pt.ScratchVar(pt.TealType.bytes, 3)
    s3 = pt.ScratchVar(pt.TealType.bytes, 5)
    return pt.Seq(
        cursor.set_index(i1),
        cursor.store(pt.Int(0)),
        cursor.set_index(s1),
        cursor.store(pt.Bytes("")),
        cursor.set_index(i2),
        cursor.store(pt.Int(0)),
        cursor.set_index(s2),
        cursor.store(pt.Bytes("")),
        cursor.set_index(i3),
        cursor.store(pt.Int(0)),
        cursor.set_index(s3),
        cursor.store(pt.Bytes("")),
        pt.Int(42),
    )


@pt.Subroutine(pt.TealType.uint64)
def oldfac(n):
    return pt.If(n < pt.Int(2)).Then(pt.Int(1)).Else(n * oldfac(n - pt.Int(1)))


ISSUE_199_CASES = (
    sub_logcat_dynamic,
    swapper,
    wilt_the_stilt,
    sub_mixed,
    lots_o_vars,
    empty_scratches,
)


@pytest.mark.skipif(not STABLE_SLOT_GENERATION, reason="cf. #199")
@pytest.mark.parametrize("pt", ISSUE_199_CASES)
def test_teal_output_is_unchanged(pt):
    assert_new_v_old(pt, 6, "unchanged")


# #### pt.Subroutine Definitions for pass-by-ref guardrails testing #####
@pt.Subroutine(pt.TealType.uint64)
def ok(x):
    # not really ok at runtime... but should be ok at compile time
    return ok(x)


@pt.Subroutine(pt.TealType.uint64)
def ok_byref(x: pt.ScratchVar):
    return pt.Int(42)


@pt.Subroutine(pt.TealType.uint64)
def ok_indirect1(x):
    return ok_indirect2(x)


@pt.Subroutine(pt.TealType.uint64)
def ok_indirect2(x):
    return ok_indirect1(x)


@pt.Subroutine(pt.TealType.uint64)
def not_ok(x: pt.ScratchVar):
    # not ok both at compile and runtime
    return not_ok(x)


@pt.Subroutine(pt.TealType.uint64)
def not_ok_indirect1(x: pt.ScratchVar):
    return not_ok_indirect2(x)


@pt.Subroutine(pt.TealType.uint64)
def not_ok_indirect2(x: pt.ScratchVar):
    return not_ok_indirect1(x)


"""
Complex subroutine graph example:

a --> b --> a (loop)
        --> e
        --> f
    --> *c--> g --> a (loop)
        --> h
    --> d --> d (loop)
        --> i
        --> j

*c - this is the only "pass by-ref" subroutine
Expect the following error path: c-->g-->a-->c
"""


@pt.Subroutine(pt.TealType.uint64)
def a(x):
    tmp = pt.ScratchVar(pt.TealType.uint64)
    return pt.Seq(tmp.store(x), b(x) + c(tmp) + d(x))


@pt.Subroutine(pt.TealType.uint64)
def b(x):
    return a(x) + e(x) * f(x)


@pt.Subroutine(pt.TealType.uint64)
def c(x: pt.ScratchVar):
    return g(pt.Int(42)) - h(x.load())


@pt.Subroutine(pt.TealType.uint64)
def d(x):
    return d(x) + i(pt.Int(11)) * j(x)


@pt.Subroutine(pt.TealType.uint64)
def e(x):
    return pt.Int(42)


@pt.Subroutine(pt.TealType.uint64)
def f(x):
    return pt.Int(42)


@pt.Subroutine(pt.TealType.uint64)
def g(x):
    return a(pt.Int(17))


@pt.Subroutine(pt.TealType.uint64)
def h(x):
    return pt.Int(42)


@pt.Subroutine(pt.TealType.uint64)
def i(x):
    return pt.Int(42)


@pt.Subroutine(pt.TealType.uint64)
def j(x):
    return pt.Int(42)


@pt.Subroutine(pt.TealType.none)
def tally(n, result: pt.ScratchVar):
    return (
        pt.If(n == pt.Int(0))
        .Then(result.store(pt.Bytes("")))
        .Else(
            pt.Seq(
                tally(n - pt.Int(1), result),
                result.store(pt.Concat(result.load(), pt.Bytes("a"))),
            )
        )
    )


@pt.Subroutine(pt.TealType.none)
def factorial_BAD(n: pt.ScratchVar):
    tmp = pt.ScratchVar(pt.TealType.uint64)
    return (
        pt.If(n.load() <= pt.Int(1))
        .Then(n.store(pt.Int(1)))
        .Else(
            pt.Seq(
                tmp.store(n.load() - pt.Int(1)),
                factorial_BAD(tmp),
                n.store(n.load() * tmp.load()),
            )
        )
    )


@pt.Subroutine(pt.TealType.none)
def factorial(n: pt.ScratchVar):
    tmp = pt.ScratchVar(pt.TealType.uint64)
    return (
        pt.If(n.load() <= pt.Int(1))
        .Then(n.store(pt.Int(1)))
        .Else(
            pt.Seq(
                tmp.store(n.load()),
                n.store(n.load() - pt.Int(1)),
                factorial(n),
                n.store(n.load() * tmp.load()),
            )
        )
    )


@pt.Subroutine(pt.TealType.none)
def plus_one(n: pt.ScratchVar):
    tmp = pt.ScratchVar(pt.TealType.uint64)
    return (
        pt.If(n.load() == pt.Int(0))
        .Then(n.store(pt.Int(1)))
        .Else(
            pt.Seq(
                tmp.store(n.load() - pt.Int(1)),
                plus_one(tmp),
                n.store(tmp.load() + pt.Int(1)),
            )
        )
    )


def make_creatable_factory(approval):
    """
    Wrap a pyteal program with code that:
    * approves immediately in the case of app creation (appId == 0)
    * runs the original code otherwise
    """

    def func():
        return (
            pt.If(pt.Txn.application_id() == pt.Int(0)).Then(pt.Int(1)).Else(approval())
        )

    func.__name__ = approval.__name__
    return func


def fac_by_ref():
    n = pt.ScratchVar(pt.TealType.uint64)
    return pt.Seq(
        n.store(pt.Int(10)),
        factorial(n),
        n.load(),
    )


def fac_by_ref_BAD():
    n = pt.ScratchVar(pt.TealType.uint64)
    return pt.Seq(
        n.store(pt.Int(10)),
        factorial_BAD(n),
        n.load(),
    )


# Proved correct via blackbox testing, but BANNING for now
def fac_by_ref_args():
    n = pt.ScratchVar(pt.TealType.uint64)
    return pt.Seq(
        pt.If(
            pt.Or(
                pt.App.id() == pt.Int(0),
                pt.Txn.application_args.length() == pt.Int(0),
            )
        )
        .Then(pt.Int(1))
        .Else(
            pt.Seq(
                n.store(pt.Btoi(pt.Txn.application_args[0])),
                factorial(n),
                n.load(),
            )
        )
    )


def tallygo():
    result = pt.ScratchVar(pt.TealType.bytes)
    # pt.If-Then is a hook for creating + opting in without providing any args
    return (
        pt.If(
            pt.Or(
                pt.App.id() == pt.Int(0), pt.Txn.application_args.length() == pt.Int(0)
            )
        )
        .Then(pt.Int(1))
        .Else(
            pt.Seq(
                result.store(pt.Bytes("dummy")),
                tally(pt.Int(4), result),
                pt.Btoi(result.load()),
            )
        )
    )


TESTABLE_CASES = [(oldfac, [pt.TealType.uint64])]


# ---- Approval PyTEAL Expressions (COPACETIC) ---- #

approval_ok = ok(pt.Int(42))

x_scratchvar = pt.ScratchVar(pt.TealType.uint64)

approval_ok_byref = pt.Seq(x_scratchvar.store(pt.Int(42)), ok_byref(x_scratchvar))

approval_ok_indirect = ok_indirect1(pt.Int(42))

# ---- BANNED Approval PyTEAL Expressions (wrapped in a function) ---- #


@pt.Subroutine(pt.TealType.none)
def subr_string_mult(s: pt.ScratchVar, n):
    tmp = pt.ScratchVar(pt.TealType.bytes)
    return (
        pt.If(n == pt.Int(0))
        .Then(s.store(pt.Bytes("")))
        .Else(
            pt.Seq(
                tmp.store(s.load()),
                subr_string_mult(s, n - pt.Int(1)),
                s.store(pt.Concat(s.load(), tmp.load())),
            )
        )
    )


def string_mult():
    s = pt.ScratchVar(pt.TealType.bytes)
    return pt.Seq(
        s.store(pt.Txn.application_args[0]),
        subr_string_mult(s, pt.Btoi(pt.Txn.application_args[1])),
        pt.Log(s.load()),
        pt.Int(100),
    )


def approval_not_ok():
    return pt.Seq(x_scratchvar.store(pt.Int(42)), not_ok(x_scratchvar))


def approval_not_ok_indirect():
    return pt.Seq(x_scratchvar.store(pt.Int(42)), not_ok_indirect1(x_scratchvar))


def approval_its_complicated():
    return a(pt.Int(42))


def increment():
    n = pt.ScratchVar(pt.TealType.uint64)
    return pt.Seq(n.store(pt.Int(4)), plus_one(n), pt.Int(1))


COPACETIC_APPROVALS = [approval_ok, approval_ok_byref, approval_ok_indirect]


@pytest.mark.parametrize("approval", COPACETIC_APPROVALS)
def test_pass_by_ref_guardrails_COPACETIC(approval):
    assert pt.compileTeal(approval, pt.Mode.Application, version=6)


ILLEGAL_APPROVALS = {
    approval_not_ok: "not_ok()-->not_ok()",
    approval_not_ok_indirect: "not_ok_indirect1()-->not_ok_indirect2()-->not_ok_indirect1()",
    approval_its_complicated: "c()-->g()-->a()-->c()",
    fac_by_ref: "factorial()-->factorial()",
    fac_by_ref_args: "factorial()-->factorial()",
    fac_by_ref_BAD: "factorial_BAD()-->factorial_BAD()",
    increment: "plus_one()-->plus_one()",
    string_mult: "subr_string_mult()-->subr_string_mult()",
    tallygo: "tally()-->tally()",
}


@pytest.mark.parametrize("approval_func, suffix", ILLEGAL_APPROVALS.items())
def test_pass_by_ref_guardrails_BANNED(approval_func, suffix):
    with pytest.raises(pt.TealInputError) as err:
        pt.compileTeal(approval_func(), pt.Mode.Application, version=6)

    prefix = "ScratchVar arguments not allowed in recursive subroutines, but a recursive call-path was detected: "
    assert f"{prefix}{suffix}" in str(err)


def should_it_work() -> pt.Expr:
    xs = [
        pt.ScratchVar(pt.TealType.uint64),
        pt.ScratchVar(pt.TealType.uint64),
    ]

    def store_initial_values():
        return [s.store(pt.Int(i + 1)) for i, s in enumerate(xs)]

    d = pt.DynamicScratchVar(pt.TealType.uint64)

    @pt.Subroutine(pt.TealType.none)
    def retrieve_and_increment(s: pt.ScratchVar):
        return pt.Seq(d.set_index(s), d.store(d.load() + pt.Int(1)))

    def asserts():
        return [pt.Assert(x.load() == pt.Int(i + 2)) for i, x in enumerate(xs)]

    return pt.Seq(
        pt.Seq(store_initial_values()),
        pt.Seq([retrieve_and_increment(x) for x in xs]),
        pt.Seq(asserts()),
        pt.Int(1),
    )


def test_cannot_set_index_with_dynamic():
    with pytest.raises(pt.TealInputError) as tie:
        pt.compileTeal(should_it_work(), pt.Mode.Application, version=6)

    assert (
        "Only allowed to use ScratchVar objects for setting indices, but was given a"
        in str(tie)
    )



================================================
FILE: tests/unit/pre_v6_test.py
================================================
import pytest

import pyteal as pt

from tests.compile_asserts import assert_new_v_old

# ---- TESTS FOR PyTEAL THAT PREDATE PASS-BY-REF - assert that changes to compiler don't affect the generated TEAL ---- #


@pt.Subroutine(pt.TealType.bytes)
def logcat(some_bytes, an_int):
    catted = pt.ScratchVar(pt.TealType.bytes)
    return pt.Seq(
        catted.store(pt.Concat(some_bytes, pt.Itob(an_int))),
        pt.Log(catted.load()),
        catted.load(),
    )


def sub_logcat():
    return pt.Seq(
        pt.Assert(logcat(pt.Bytes("hello"), pt.Int(42)) == pt.Bytes("hello42")),
        pt.Int(1),
    )


@pt.Subroutine(pt.TealType.uint64)
def slow_fibonacci(n):
    return (
        pt.If(n <= pt.Int(1))
        .Then(n)
        .Else(slow_fibonacci(n - pt.Int(2)) + slow_fibonacci(n - pt.Int(1)))
    )


def sub_slowfib():
    return slow_fibonacci(pt.Int(3))


@pt.Subroutine(pt.TealType.uint64)
def fast_fibonacci(n):
    i = pt.ScratchVar(pt.TealType.uint64)
    a = pt.ScratchVar(pt.TealType.uint64)
    b = pt.ScratchVar(pt.TealType.uint64)
    return pt.Seq(
        a.store(pt.Int(0)),
        b.store(pt.Int(1)),
        pt.For(i.store(pt.Int(1)), i.load() <= n, i.store(i.load() + pt.Int(1))).Do(
            pt.Seq(
                b.store(a.load() + b.load()),
                a.store(b.load() - a.load()),
            )
        ),
        a.load(),
    )


def sub_fastfib():
    return fast_fibonacci(pt.Int(3))


@pt.Subroutine(pt.TealType.uint64)
def recursiveIsEven(i):
    return (
        pt.If(i == pt.Int(0))
        .Then(pt.Int(1))
        .ElseIf(i == pt.Int(1))
        .Then(pt.Int(0))
        .Else(recursiveIsEven(i - pt.Int(2)))
    )


def sub_even():
    return pt.Seq(
        pt.Pop(recursiveIsEven(pt.Int(1000))),
        recursiveIsEven(pt.Int(1001)),
    )


PT_CASES = (sub_logcat, sub_slowfib, sub_fastfib, sub_even)


@pytest.mark.parametrize("pt_case", PT_CASES)
def test_old(pt_case):
    assert_new_v_old(pt_case, 5, "pre_v6")



================================================
FILE: tests/unit/sourcemap_constructs_allpy_test.py
================================================
from feature_gates import FeatureGates

import pytest

from tests.unit.sourcemap_constructs311_test import (
    CONSTRUCTS,
    CONSTRUCTS_LATEST_VERSION,
    constructs_test,
)


@pytest.fixture
def sourcemap_enabled():
    previous = FeatureGates.sourcemap_enabled()
    FeatureGates.set_sourcemap_enabled(True)
    yield
    FeatureGates.set_sourcemap_enabled(previous)


@pytest.mark.slow
@pytest.mark.serial
@pytest.mark.parametrize("i, test_case", enumerate(CONSTRUCTS))
@pytest.mark.parametrize("mode", ["Application", "Signature"])
@pytest.mark.parametrize("version", range(2, CONSTRUCTS_LATEST_VERSION + 1))
def test_constructs_very_slow(sourcemap_enabled, i, test_case, mode, version):
    constructs_test(i, test_case, mode, version)



================================================
FILE: tests/unit/sourcemap_monkey_raises_test.py
================================================
from contextlib import contextmanager

import pytest

from feature_gates import FeatureGates


@contextmanager
def sourcemap_disabled():
    previous = FeatureGates.sourcemap_enabled()
    FeatureGates.set_sourcemap_enabled(False)
    yield
    FeatureGates.set_sourcemap_enabled(previous)


@pytest.mark.serial
def test_sourcemap_fails_elegantly_when_disabled():
    from examples.application.abi.algobank import router
    from pyteal import OptimizeOptions
    from pyteal.errors import SourceMapDisabledError

    with sourcemap_disabled():
        with pytest.raises(
            SourceMapDisabledError, match="because stack frame discovery is turned off"
        ):
            router.compile(
                version=6,
                optimize=OptimizeOptions(scratch_slots=True),
                with_sourcemaps=True,
            )



================================================
FILE: tests/unit/sourcemap_monkey_unit_test.py
================================================
from ast import FunctionDef
from contextlib import contextmanager
from pathlib import Path
import pytest
import sys
from unittest import mock

STABLE_SLOT_GENERATION = False  # Compiling Algobabank with sourcemap enabled is flaky due to issue 199, so skipping for now

ALGOBANK = Path.cwd() / "examples" / "application" / "abi"

FIXTURES = Path.cwd() / "tests" / "unit" / "sourcemaps"


@pytest.fixture
def sourcemap_enabled():
    from feature_gates import FeatureGates

    previous = FeatureGates.sourcemap_enabled()
    FeatureGates.set_sourcemap_enabled(True)
    yield
    FeatureGates.set_sourcemap_enabled(previous)


@pytest.fixture
def StackFrame_keep_all_debugging():
    from pyteal.stack_frame import NatalStackFrame

    NatalStackFrame._keep_all_debugging = True
    yield
    NatalStackFrame._keep_all_debugging = False


@pytest.fixture
def sourcemap_debug():
    from feature_gates import FeatureGates

    previous = FeatureGates.sourcemap_debug()
    FeatureGates.set_sourcemap_debug(True)
    yield
    FeatureGates.set_sourcemap_debug(previous)


@pytest.mark.skipif(
    sys.version_info < (3, 11),
    reason="Currently, this test only works in python 3.11 and above",
)
@pytest.mark.serial
def test_r3sourcemap(sourcemap_debug, sourcemap_enabled):
    from examples.application.abi.algobank import router
    from pyteal.ast.router import _RouterCompileInput
    from pyteal import OptimizeOptions
    from pyteal.compiler.sourcemap import R3SourceMap

    filename = "dummy filename"
    rci = _RouterCompileInput(
        version=6,
        assemble_constants=False,
        optimize=OptimizeOptions(scratch_slots=True),
        approval_filename=filename,
        with_sourcemaps=True,
    )
    compile_bundle = router._build_impl(rci)

    ptsm = compile_bundle.approval_sourcemapper
    assert ptsm

    actual_unparsed = [x._hybrid_w_offset() for x in ptsm._cached_tmis]
    assert_algobank_unparsed_as_expected(actual_unparsed)

    r3sm = ptsm._cached_r3sourcemap
    assert r3sm

    assert filename == r3sm.filename
    assert str(r3sm.source_root).startswith(str(Path.cwd()))
    assert list(range(len(r3sm.entries))) == [line for line, _ in r3sm.entries]
    assert all(c == 0 for _, c in r3sm.entries)
    assert all(x == (0,) for x in r3sm.index)
    assert len(r3sm.entries) == len(r3sm.index)

    this_file = __file__.split("/")[-1]
    expected_source_files = [
        "examples/application/abi/algobank.py",
        f"tests/unit/{this_file}",
    ]
    assert expected_source_files == r3sm.source_files

    r3sm_json = r3sm.to_json()

    assert "mappings" in r3sm_json
    assert (
        "AA8DqB;AC5CN;AAAA;AAAA;AAAA;AAsBf;AAAA;AAAA;AAAA;AAwBA;AAAA;AAAA;AAAA;AAaA;AAAA;AAAA;AAAA;ADfqB;ACerB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAbA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAxBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;ADsBqB;ACtBrB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AApBc;AAAA;AAAA;AAAA;AAAA;AAEC;AAAA;AAAA;AAAA;AAEG;AAAA;AAAA;AAAA;AAIS;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAbZ;AAaY;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAHA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAJT;AAAA;AAAA;AAAA;AAAA;AAZd;AACc;AAAd;AAA4C;AAAc;AAA3B;AAA/B;AAFuB;AAaT;AAAA;AAFH;AAAwB;AAAA;AAFzB;AAAA;AAAA;AAAA;AAAA;AAAwB;AAAA;AAdtC;AAAA;AAAA;AACkB;AAAgB;AAAhB;AAAP;AADX;AAkCA;AAAA;AAAA;AAAA;AAAA;AAae;AAAA;AAA0B;AAAA;AAA1B;AAAP;AACO;AAAA;AAA4B;AAA5B;AAAP;AAEI;AAAA;AACA;AACa;AAAA;AAAkB;AAA/B;AAAmD;AAAA;AAAnD;AAHJ;AAfR;AAwBA;AAAA;AAAA;AASmC;AAAgB;AAA7B;AATtB;AAaA;AAAA;AAAA;AAAA;AAAA;AAoBY;AACA;AACa;AAAc;AAA3B;AAA+C;AAA/C;AAHJ;AAKA;AACA;AAAA;AAG2B;AAAA;AAH3B;AAIyB;AAJzB;AAKsB;AALtB;AAQA;AAjCR"
        == r3sm_json["mappings"]
    )

    assert "file" in r3sm_json
    assert filename == r3sm_json["file"]

    assert "sources" in r3sm_json

    # jsonizing creates it's own separate order based on first seen and defaultdict with autoindex
    expected_json_source_files = [
        f"tests/unit/{this_file}",
        "examples/application/abi/algobank.py",
    ]
    assert set(expected_json_source_files) == set(r3sm_json["sources"])

    assert "sourceRoot" in r3sm_json
    assert r3sm.source_root == r3sm_json["sourceRoot"]

    target = "\n".join(r.target_extract for r in r3sm.entries.values())  # type: ignore
    round_trip = R3SourceMap.from_json(r3sm_json, target=target)

    assert r3sm_json == round_trip.to_json()


@pytest.mark.serial
def test_reconstruct(sourcemap_enabled):
    from examples.application.abi.algobank import router
    from pyteal.ast.router import _RouterCompileInput
    from pyteal import OptimizeOptions

    rci = _RouterCompileInput(
        version=6,
        assemble_constants=False,
        optimize=OptimizeOptions(scratch_slots=True),
        with_sourcemaps=True,
    )
    compile_bundle = router._build_impl(rci)

    assert compile_bundle.approval_sourcemapper
    assert compile_bundle.clear_sourcemapper

    def compare_and_assert(file, sourcemap):
        with open(ALGOBANK / file, "r") as f:
            expected_lines = f.read().splitlines()
            actual_lines = sourcemap.pure_teal().splitlines()
            assert len(expected_lines) == len(actual_lines)
            assert expected_lines == actual_lines

    if STABLE_SLOT_GENERATION:
        compare_and_assert(
            "algobank_approval.teal", compile_bundle.approval_sourcemapper
        )
    compare_and_assert("algobank_clear_state.teal", compile_bundle.clear_sourcemapper)


@pytest.mark.serial
def test_feature_gate_for_frames(sourcemap_enabled):
    from feature_gates import FeatureGates

    assert FeatureGates.sourcemap_enabled() is True
    from pyteal.stack_frame import NatalStackFrame

    assert NatalStackFrame.sourcemapping_is_off() is False


def make(x, y, z):
    import pyteal as pt

    return pt.Int(x) + pt.Int(y) + pt.Int(z)


@pytest.mark.serial
def test_lots_o_indirection(sourcemap_enabled):
    import pyteal as pt

    e1 = pt.Seq(pt.Pop(make(1, 2, 3)), pt.Pop(make(4, 5, 6)), make(7, 8, 9))

    @pt.Subroutine(pt.TealType.uint64)
    def foo(x):
        return pt.Seq(pt.Pop(e1), e1)

    pt.Compilation(foo(pt.Int(42)), pt.Mode.Application, version=6)._compile_impl(
        with_sourcemap=True
    )


@pytest.mark.serial
def test_frame_info_is_right_before_core_last_drop_idx(
    sourcemap_enabled,
    StackFrame_keep_all_debugging,
):
    import pyteal as pt
    from pyteal.stack_frame import StackFrame

    e1 = pt.Seq(pt.Pop(make(1, 2, 3)), pt.Pop(make(4, 5, 6)), make(7, 8, 9))

    frame_infos = e1.stack_frames._frames
    last_drop_idx = 1
    assert StackFrame._frame_info_is_right_before_core(
        frame_infos[last_drop_idx].frame_info
    ), "Uh oh! Something about NatalStackFrame has changes which puts in jeopardy Source Map functionality"


def router_static_abisubroutine(pt):
    AppId = pt.abi.Uint64

    class Foo:
        """Some class docstring"""

        page_size = pt.Int(128 - 1)

        account = pt.abi.Address()
        app_id = pt.abi.Uint64()

        @staticmethod
        @pt.ABIReturnSubroutine
        def set_foo(
            _app_id: AppId,
        ) -> pt.Expr:  # type: ignore
            "Some docstring"
            return Foo.app_id.set(_app_id)

    router = pt.Router("foo")
    router.add_method_handler(
        Foo.set_foo,
        "set_foo",
        pt.MethodConfig(no_op=pt.CallConfig.CALL),
        "Foo the foo",
    )
    return router


SUCCESSFUL_SUBROUTINE_LINENO = 209


@pytest.mark.serial
def test_hybrid_w_offset(sourcemap_debug, sourcemap_enabled):
    from feature_gates import FeatureGates
    from pyteal import stack_frame

    assert FeatureGates.sourcemap_enabled() is True
    assert FeatureGates.sourcemap_debug() is True
    assert stack_frame.NatalStackFrame.sourcemapping_is_off() is False
    assert stack_frame.NatalStackFrame._debugging() is True

    import pyteal as pt

    router = router_static_abisubroutine(pt)
    rci = pt.ast.router._RouterCompileInput(
        version=7,
        assemble_constants=True,
        with_sourcemaps=True,
    )

    sourcemap = router._build_impl(rci).approval_sourcemapper

    # expected:
    etarget = "def set_foo(_app_id: AppId) -> pt.Expr:"
    func_source = f'@staticmethod\n@pt.ABIReturnSubroutine\n{etarget}\n    """Some docstring"""\n    return Foo.app_id.set(_app_id)'

    # actual:
    lbf = sourcemap._best_frames[-1]
    hwo = lbf._hybrid_w_offset()
    nsource = lbf.node_source()
    raw_code = lbf.raw_code()
    naive_line = lbf.frame_info.lineno

    # consistent across versions:
    assert etarget == hwo[0]
    assert func_source == nsource

    # inconsistent between 3.10 and 3.11:
    if sys.version_info[:2] <= (3, 10):
        assert 0 == hwo[1]
        assert "def set_foo(" == raw_code
        assert SUCCESSFUL_SUBROUTINE_LINENO == naive_line
    else:
        assert 1 == hwo[1]
        assert "@pt.ABIReturnSubroutine" == raw_code
        assert SUCCESSFUL_SUBROUTINE_LINENO - 1 == naive_line


PyTealFrame_CASES = [
    (
        "some code",
        False,
        "some chunk",
        ("some chunk", 0),
    ),
    (
        "some code",
        True,
        "some chunk",
        ("some chunk", 0),
    ),
    (
        "first line",
        True,
        "first line and more\nsecond line",
        ("first line and more", 0),
    ),
    (
        "first line",
        True,
        "first line and more\ndef second line",
        ("def second line", 1),
    ),
    (
        "first line",
        False,
        None,
        ("first line", 0),
    ),
    (
        "first line",
        True,
        None,
        ("first line", 0),
    ),
]


@contextmanager
def patch_pt_frame(code, is_funcdef, pt_chunk):
    from pyteal.stack_frame import PyTealFrame

    node = None
    if is_funcdef:
        node = FunctionDef(name="foo", body=[], decorator_list=[], returns=None)

    frame = PyTealFrame(
        frame_info="dummy frame_info", node=node, creator=None, full_stack=None
    )
    with mock.patch.object(frame, "raw_code", return_value=code), mock.patch.object(
        frame, "node_source", return_value=pt_chunk
    ):
        yield frame


@pytest.mark.parametrize("code, is_funcdef, pt_chunk, expected", PyTealFrame_CASES)
def test_mock_hybrid_w_offset(code, is_funcdef, pt_chunk, expected):
    with patch_pt_frame(code, is_funcdef, pt_chunk) as pt_frame:
        assert expected == pt_frame._hybrid_w_offset()


def test_tabulate_args_can_be_dictified():
    from pyteal.compiler.sourcemap import _PyTealSourceMapper, TealMapItem

    tmi = TealMapItem(
        pt_frame=mock.MagicMock(),
        teal_lineno=13,
        teal_line="some teal line",
        teal_component="some teal component",
    )
    all_cols = {v: v for v in _PyTealSourceMapper._tabulate_param_defaults.values()}
    full_dict = tmi.asdict(**all_cols)
    assert set(all_cols.keys()) == set(full_dict.keys())


def assert_algobank_unparsed_as_expected(actual):
    expected = [
        (0, ("router._build_impl(rci)", 0)),
        (
            1,
            (
                "BareCallActions(no_op=OnCompleteAction(action=Approve(), call_config=CallConfig.CREATE), opt_in=OnCompleteAction(action=Approve(), call_config=CallConfig.ALL), close_out=OnCompleteAction(action=transfer_balance_to_lost, call_config=CallConfig.CALL), update_application=OnCompleteAction(action=assert_sender_is_creator, call_config=CallConfig.CALL), delete_application=OnCompleteAction(action=assert_sender_is_creator, call_config=CallConfig.CALL))",
                0,
            ),
        ),
        (
            2,
            (
                "BareCallActions(no_op=OnCompleteAction(action=Approve(), call_config=CallConfig.CREATE), opt_in=OnCompleteAction(action=Approve(), call_config=CallConfig.ALL), close_out=OnCompleteAction(action=transfer_balance_to_lost, call_config=CallConfig.CALL), update_application=OnCompleteAction(action=assert_sender_is_creator, call_config=CallConfig.CALL), delete_application=OnCompleteAction(action=assert_sender_is_creator, call_config=CallConfig.CALL))",
                0,
            ),
        ),
        (
            3,
            (
                "BareCallActions(no_op=OnCompleteAction(action=Approve(), call_config=CallConfig.CREATE), opt_in=OnCompleteAction(action=Approve(), call_config=CallConfig.ALL), close_out=OnCompleteAction(action=transfer_balance_to_lost, call_config=CallConfig.CALL), update_application=OnCompleteAction(action=assert_sender_is_creator, call_config=CallConfig.CALL), delete_application=OnCompleteAction(action=assert_sender_is_creator, call_config=CallConfig.CALL))",
                0,
            ),
        ),
        (
            4,
            (
                "BareCallActions(no_op=OnCompleteAction(action=Approve(), call_config=CallConfig.CREATE), opt_in=OnCompleteAction(action=Approve(), call_config=CallConfig.ALL), close_out=OnCompleteAction(action=transfer_balance_to_lost, call_config=CallConfig.CALL), update_application=OnCompleteAction(action=assert_sender_is_creator, call_config=CallConfig.CALL), delete_application=OnCompleteAction(action=assert_sender_is_creator, call_config=CallConfig.CALL))",
                0,
            ),
        ),
        (
            5,
            (
                "def deposit(payment: abi.PaymentTransaction, sender: abi.Account) -> Expr:",
                1,
            ),
        ),
        (
            6,
            (
                "def deposit(payment: abi.PaymentTransaction, sender: abi.Account) -> Expr:",
                1,
            ),
        ),
        (
            7,
            (
                "def deposit(payment: abi.PaymentTransaction, sender: abi.Account) -> Expr:",
                1,
            ),
        ),
        (
            8,
            (
                "def deposit(payment: abi.PaymentTransaction, sender: abi.Account) -> Expr:",
                1,
            ),
        ),
        (9, ("def getBalance(user: abi.Account, *, output: abi.Uint64) -> Expr:", 1)),
        (10, ("def getBalance(user: abi.Account, *, output: abi.Uint64) -> Expr:", 1)),
        (11, ("def getBalance(user: abi.Account, *, output: abi.Uint64) -> Expr:", 1)),
        (12, ("def getBalance(user: abi.Account, *, output: abi.Uint64) -> Expr:", 1)),
        (13, ("def withdraw(amount: abi.Uint64, recipient: abi.Account) -> Expr:", 1)),
        (14, ("def withdraw(amount: abi.Uint64, recipient: abi.Account) -> Expr:", 1)),
        (15, ("def withdraw(amount: abi.Uint64, recipient: abi.Account) -> Expr:", 1)),
        (16, ("def withdraw(amount: abi.Uint64, recipient: abi.Account) -> Expr:", 1)),
        (17, ("router._build_impl(rci)", 0)),
        (18, ("def withdraw(amount: abi.Uint64, recipient: abi.Account) -> Expr:", 1)),
        (19, ("def withdraw(amount: abi.Uint64, recipient: abi.Account) -> Expr:", 1)),
        (20, ("def withdraw(amount: abi.Uint64, recipient: abi.Account) -> Expr:", 1)),
        (21, ("def withdraw(amount: abi.Uint64, recipient: abi.Account) -> Expr:", 1)),
        (22, ("def withdraw(amount: abi.Uint64, recipient: abi.Account) -> Expr:", 1)),
        (23, ("def withdraw(amount: abi.Uint64, recipient: abi.Account) -> Expr:", 1)),
        (24, ("def withdraw(amount: abi.Uint64, recipient: abi.Account) -> Expr:", 1)),
        (25, ("def withdraw(amount: abi.Uint64, recipient: abi.Account) -> Expr:", 1)),
        (26, ("def withdraw(amount: abi.Uint64, recipient: abi.Account) -> Expr:", 1)),
        (27, ("def withdraw(amount: abi.Uint64, recipient: abi.Account) -> Expr:", 1)),
        (28, ("def withdraw(amount: abi.Uint64, recipient: abi.Account) -> Expr:", 1)),
        (29, ("def withdraw(amount: abi.Uint64, recipient: abi.Account) -> Expr:", 1)),
        (30, ("def withdraw(amount: abi.Uint64, recipient: abi.Account) -> Expr:", 1)),
        (31, ("def withdraw(amount: abi.Uint64, recipient: abi.Account) -> Expr:", 1)),
        (32, ("def withdraw(amount: abi.Uint64, recipient: abi.Account) -> Expr:", 1)),
        (33, ("def withdraw(amount: abi.Uint64, recipient: abi.Account) -> Expr:", 1)),
        (34, ("def withdraw(amount: abi.Uint64, recipient: abi.Account) -> Expr:", 1)),
        (35, ("def withdraw(amount: abi.Uint64, recipient: abi.Account) -> Expr:", 1)),
        (36, ("def withdraw(amount: abi.Uint64, recipient: abi.Account) -> Expr:", 1)),
        (37, ("def withdraw(amount: abi.Uint64, recipient: abi.Account) -> Expr:", 1)),
        (38, ("def withdraw(amount: abi.Uint64, recipient: abi.Account) -> Expr:", 1)),
        (39, ("def getBalance(user: abi.Account, *, output: abi.Uint64) -> Expr:", 1)),
        (40, ("def getBalance(user: abi.Account, *, output: abi.Uint64) -> Expr:", 1)),
        (41, ("def getBalance(user: abi.Account, *, output: abi.Uint64) -> Expr:", 1)),
        (42, ("def getBalance(user: abi.Account, *, output: abi.Uint64) -> Expr:", 1)),
        (43, ("def getBalance(user: abi.Account, *, output: abi.Uint64) -> Expr:", 1)),
        (44, ("def getBalance(user: abi.Account, *, output: abi.Uint64) -> Expr:", 1)),
        (45, ("def getBalance(user: abi.Account, *, output: abi.Uint64) -> Expr:", 1)),
        (46, ("def getBalance(user: abi.Account, *, output: abi.Uint64) -> Expr:", 1)),
        (47, ("def getBalance(user: abi.Account, *, output: abi.Uint64) -> Expr:", 1)),
        (48, ("def getBalance(user: abi.Account, *, output: abi.Uint64) -> Expr:", 1)),
        (49, ("def getBalance(user: abi.Account, *, output: abi.Uint64) -> Expr:", 1)),
        (50, ("def getBalance(user: abi.Account, *, output: abi.Uint64) -> Expr:", 1)),
        (51, ("def getBalance(user: abi.Account, *, output: abi.Uint64) -> Expr:", 1)),
        (52, ("def getBalance(user: abi.Account, *, output: abi.Uint64) -> Expr:", 1)),
        (53, ("def getBalance(user: abi.Account, *, output: abi.Uint64) -> Expr:", 1)),
        (54, ("def getBalance(user: abi.Account, *, output: abi.Uint64) -> Expr:", 1)),
        (55, ("def getBalance(user: abi.Account, *, output: abi.Uint64) -> Expr:", 1)),
        (56, ("def getBalance(user: abi.Account, *, output: abi.Uint64) -> Expr:", 1)),
        (57, ("def getBalance(user: abi.Account, *, output: abi.Uint64) -> Expr:", 1)),
        (58, ("def getBalance(user: abi.Account, *, output: abi.Uint64) -> Expr:", 1)),
        (59, ("def getBalance(user: abi.Account, *, output: abi.Uint64) -> Expr:", 1)),
        (
            60,
            (
                "def deposit(payment: abi.PaymentTransaction, sender: abi.Account) -> Expr:",
                1,
            ),
        ),
        (
            61,
            (
                "def deposit(payment: abi.PaymentTransaction, sender: abi.Account) -> Expr:",
                1,
            ),
        ),
        (
            62,
            (
                "def deposit(payment: abi.PaymentTransaction, sender: abi.Account) -> Expr:",
                1,
            ),
        ),
        (
            63,
            (
                "def deposit(payment: abi.PaymentTransaction, sender: abi.Account) -> Expr:",
                1,
            ),
        ),
        (
            64,
            (
                "def deposit(payment: abi.PaymentTransaction, sender: abi.Account) -> Expr:",
                1,
            ),
        ),
        (
            65,
            (
                "def deposit(payment: abi.PaymentTransaction, sender: abi.Account) -> Expr:",
                1,
            ),
        ),
        (
            66,
            (
                "def deposit(payment: abi.PaymentTransaction, sender: abi.Account) -> Expr:",
                1,
            ),
        ),
        (
            67,
            (
                "def deposit(payment: abi.PaymentTransaction, sender: abi.Account) -> Expr:",
                1,
            ),
        ),
        (
            68,
            (
                "def deposit(payment: abi.PaymentTransaction, sender: abi.Account) -> Expr:",
                1,
            ),
        ),
        (
            69,
            (
                "def deposit(payment: abi.PaymentTransaction, sender: abi.Account) -> Expr:",
                1,
            ),
        ),
        (
            70,
            (
                "def deposit(payment: abi.PaymentTransaction, sender: abi.Account) -> Expr:",
                1,
            ),
        ),
        (
            71,
            (
                "def deposit(payment: abi.PaymentTransaction, sender: abi.Account) -> Expr:",
                1,
            ),
        ),
        (
            72,
            (
                "def deposit(payment: abi.PaymentTransaction, sender: abi.Account) -> Expr:",
                1,
            ),
        ),
        (
            73,
            (
                "def deposit(payment: abi.PaymentTransaction, sender: abi.Account) -> Expr:",
                1,
            ),
        ),
        (
            74,
            (
                "def deposit(payment: abi.PaymentTransaction, sender: abi.Account) -> Expr:",
                1,
            ),
        ),
        (
            75,
            (
                "def deposit(payment: abi.PaymentTransaction, sender: abi.Account) -> Expr:",
                1,
            ),
        ),
        (
            76,
            (
                "def deposit(payment: abi.PaymentTransaction, sender: abi.Account) -> Expr:",
                1,
            ),
        ),
        (
            77,
            (
                "def deposit(payment: abi.PaymentTransaction, sender: abi.Account) -> Expr:",
                1,
            ),
        ),
        (
            78,
            (
                "def deposit(payment: abi.PaymentTransaction, sender: abi.Account) -> Expr:",
                1,
            ),
        ),
        (
            79,
            (
                "def deposit(payment: abi.PaymentTransaction, sender: abi.Account) -> Expr:",
                1,
            ),
        ),
        (
            80,
            (
                "def deposit(payment: abi.PaymentTransaction, sender: abi.Account) -> Expr:",
                1,
            ),
        ),
        (
            81,
            (
                "def deposit(payment: abi.PaymentTransaction, sender: abi.Account) -> Expr:",
                1,
            ),
        ),
        (
            82,
            (
                "def deposit(payment: abi.PaymentTransaction, sender: abi.Account) -> Expr:",
                1,
            ),
        ),
        (
            83,
            (
                "def deposit(payment: abi.PaymentTransaction, sender: abi.Account) -> Expr:",
                1,
            ),
        ),
        (
            84,
            (
                "def deposit(payment: abi.PaymentTransaction, sender: abi.Account) -> Expr:",
                1,
            ),
        ),
        (85, ("router._build_impl(rci)", 0)),
        (
            86,
            (
                "def deposit(payment: abi.PaymentTransaction, sender: abi.Account) -> Expr:",
                1,
            ),
        ),
        (
            87,
            (
                "def deposit(payment: abi.PaymentTransaction, sender: abi.Account) -> Expr:",
                1,
            ),
        ),
        (
            88,
            (
                "def deposit(payment: abi.PaymentTransaction, sender: abi.Account) -> Expr:",
                1,
            ),
        ),
        (
            89,
            (
                "def deposit(payment: abi.PaymentTransaction, sender: abi.Account) -> Expr:",
                1,
            ),
        ),
        (
            90,
            (
                "def deposit(payment: abi.PaymentTransaction, sender: abi.Account) -> Expr:",
                1,
            ),
        ),
        (
            91,
            (
                "def deposit(payment: abi.PaymentTransaction, sender: abi.Account) -> Expr:",
                1,
            ),
        ),
        (
            92,
            (
                "def deposit(payment: abi.PaymentTransaction, sender: abi.Account) -> Expr:",
                1,
            ),
        ),
        (
            93,
            (
                "def deposit(payment: abi.PaymentTransaction, sender: abi.Account) -> Expr:",
                1,
            ),
        ),
        (
            94,
            (
                "def deposit(payment: abi.PaymentTransaction, sender: abi.Account) -> Expr:",
                1,
            ),
        ),
        (95, ("OnCompleteAction(action=Approve(), call_config=CallConfig.CREATE)", 0)),
        (96, ("OnCompleteAction(action=Approve(), call_config=CallConfig.CREATE)", 0)),
        (97, ("OnCompleteAction(action=Approve(), call_config=CallConfig.CREATE)", 0)),
        (98, ("OnCompleteAction(action=Approve(), call_config=CallConfig.CREATE)", 0)),
        (99, ("OnCompleteAction(action=Approve(), call_config=CallConfig.CREATE)", 0)),
        (100, ("OnCompleteAction(action=Approve(), call_config=CallConfig.ALL)", 0)),
        (101, ("OnCompleteAction(action=Approve(), call_config=CallConfig.ALL)", 0)),
        (102, ("OnCompleteAction(action=Approve(), call_config=CallConfig.ALL)", 0)),
        (103, ("OnCompleteAction(action=Approve(), call_config=CallConfig.ALL)", 0)),
        (
            104,
            (
                "OnCompleteAction(action=transfer_balance_to_lost, call_config=CallConfig.CALL)",
                0,
            ),
        ),
        (
            105,
            (
                "OnCompleteAction(action=transfer_balance_to_lost, call_config=CallConfig.CALL)",
                0,
            ),
        ),
        (
            106,
            (
                "OnCompleteAction(action=transfer_balance_to_lost, call_config=CallConfig.CALL)",
                0,
            ),
        ),
        (
            107,
            (
                "OnCompleteAction(action=transfer_balance_to_lost, call_config=CallConfig.CALL)",
                0,
            ),
        ),
        (
            108,
            (
                "OnCompleteAction(action=assert_sender_is_creator, call_config=CallConfig.CALL)",
                0,
            ),
        ),
        (
            109,
            (
                "OnCompleteAction(action=assert_sender_is_creator, call_config=CallConfig.CALL)",
                0,
            ),
        ),
        (
            110,
            (
                "OnCompleteAction(action=assert_sender_is_creator, call_config=CallConfig.CALL)",
                0,
            ),
        ),
        (
            111,
            (
                "OnCompleteAction(action=assert_sender_is_creator, call_config=CallConfig.CALL)",
                0,
            ),
        ),
        (
            112,
            (
                "OnCompleteAction(action=assert_sender_is_creator, call_config=CallConfig.CALL)",
                0,
            ),
        ),
        (
            113,
            (
                "OnCompleteAction(action=assert_sender_is_creator, call_config=CallConfig.CALL)",
                0,
            ),
        ),
        (
            114,
            (
                "OnCompleteAction(action=assert_sender_is_creator, call_config=CallConfig.CALL)",
                0,
            ),
        ),
        (
            115,
            (
                "OnCompleteAction(action=assert_sender_is_creator, call_config=CallConfig.CALL)",
                0,
            ),
        ),
        (
            116,
            (
                "BareCallActions(no_op=OnCompleteAction(action=Approve(), call_config=CallConfig.CREATE), opt_in=OnCompleteAction(action=Approve(), call_config=CallConfig.ALL), close_out=OnCompleteAction(action=transfer_balance_to_lost, call_config=CallConfig.CALL), update_application=OnCompleteAction(action=assert_sender_is_creator, call_config=CallConfig.CALL), delete_application=OnCompleteAction(action=assert_sender_is_creator, call_config=CallConfig.CALL))",
                0,
            ),
        ),
        (
            117,
            (
                "OnCompleteAction(action=assert_sender_is_creator, call_config=CallConfig.CALL)",
                0,
            ),
        ),
        (
            118,
            (
                "OnCompleteAction(action=assert_sender_is_creator, call_config=CallConfig.CALL)",
                0,
            ),
        ),
        (
            119,
            (
                "OnCompleteAction(action=assert_sender_is_creator, call_config=CallConfig.CALL)",
                0,
            ),
        ),
        (
            120,
            (
                "OnCompleteAction(action=assert_sender_is_creator, call_config=CallConfig.CALL)",
                0,
            ),
        ),
        (
            121,
            (
                "OnCompleteAction(action=assert_sender_is_creator, call_config=CallConfig.CALL)",
                0,
            ),
        ),
        (
            122,
            (
                "OnCompleteAction(action=assert_sender_is_creator, call_config=CallConfig.CALL)",
                0,
            ),
        ),
        (
            123,
            (
                "OnCompleteAction(action=assert_sender_is_creator, call_config=CallConfig.CALL)",
                0,
            ),
        ),
        (
            124,
            (
                "OnCompleteAction(action=assert_sender_is_creator, call_config=CallConfig.CALL)",
                0,
            ),
        ),
        (
            125,
            (
                "OnCompleteAction(action=assert_sender_is_creator, call_config=CallConfig.CALL)",
                0,
            ),
        ),
        (
            126,
            (
                "OnCompleteAction(action=assert_sender_is_creator, call_config=CallConfig.CALL)",
                0,
            ),
        ),
        (
            127,
            (
                "OnCompleteAction(action=assert_sender_is_creator, call_config=CallConfig.CALL)",
                0,
            ),
        ),
        (
            128,
            (
                "OnCompleteAction(action=assert_sender_is_creator, call_config=CallConfig.CALL)",
                0,
            ),
        ),
        (
            129,
            (
                "OnCompleteAction(action=assert_sender_is_creator, call_config=CallConfig.CALL)",
                0,
            ),
        ),
        (
            130,
            (
                "OnCompleteAction(action=assert_sender_is_creator, call_config=CallConfig.CALL)",
                0,
            ),
        ),
        (
            131,
            (
                "OnCompleteAction(action=assert_sender_is_creator, call_config=CallConfig.CALL)",
                0,
            ),
        ),
        (
            132,
            (
                "OnCompleteAction(action=assert_sender_is_creator, call_config=CallConfig.CALL)",
                0,
            ),
        ),
        (
            133,
            (
                "OnCompleteAction(action=transfer_balance_to_lost, call_config=CallConfig.CALL)",
                0,
            ),
        ),
        (
            134,
            (
                "OnCompleteAction(action=transfer_balance_to_lost, call_config=CallConfig.CALL)",
                0,
            ),
        ),
        (
            135,
            (
                "OnCompleteAction(action=transfer_balance_to_lost, call_config=CallConfig.CALL)",
                0,
            ),
        ),
        (
            136,
            (
                "OnCompleteAction(action=transfer_balance_to_lost, call_config=CallConfig.CALL)",
                0,
            ),
        ),
        (
            137,
            (
                "OnCompleteAction(action=transfer_balance_to_lost, call_config=CallConfig.CALL)",
                0,
            ),
        ),
        (138, ("Bytes('lost')", 0)),
        (139, ("Bytes('lost')", 0)),
        (140, ("App.globalGet(Bytes('lost'))", 0)),
        (141, ("Txn.sender()", 0)),
        (142, ("Bytes('balance')", 0)),
        (143, ("App.localGet(Txn.sender(), Bytes('balance'))", 0)),
        (
            144,
            (
                "App.globalGet(Bytes('lost')) + App.localGet(Txn.sender(), Bytes('balance'))",
                0,
            ),
        ),
        (
            145,
            (
                "App.globalPut(Bytes('lost'), App.globalGet(Bytes('lost')) + App.localGet(Txn.sender(), Bytes('balance')))",
                0,
            ),
        ),
        (
            146,
            (
                "OnCompleteAction(action=transfer_balance_to_lost, call_config=CallConfig.CALL)",
                0,
            ),
        ),
        (
            147,
            (
                "OnCompleteAction(action=transfer_balance_to_lost, call_config=CallConfig.CALL)",
                0,
            ),
        ),
        (148, ("OnCompleteAction(action=Approve(), call_config=CallConfig.ALL)", 0)),
        (149, ("Approve()", 0)),
        (150, ("Approve()", 0)),
        (151, ("OnCompleteAction(action=Approve(), call_config=CallConfig.CREATE)", 0)),
        (152, ("OnCompleteAction(action=Approve(), call_config=CallConfig.CREATE)", 0)),
        (153, ("OnCompleteAction(action=Approve(), call_config=CallConfig.CREATE)", 0)),
        (154, ("OnCompleteAction(action=Approve(), call_config=CallConfig.CREATE)", 0)),
        (155, ("OnCompleteAction(action=Approve(), call_config=CallConfig.CREATE)", 0)),
        (156, ("Approve()", 0)),
        (157, ("Approve()", 0)),
        (158, ("def assert_sender_is_creator() -> Expr:", 1)),
        (159, ("def assert_sender_is_creator() -> Expr:", 1)),
        (160, ("def assert_sender_is_creator() -> Expr:", 1)),
        (161, ("Txn.sender()", 0)),
        (162, ("Global.creator_address()", 0)),
        (163, ("Txn.sender() == Global.creator_address()", 0)),
        (164, ("Assert(Txn.sender() == Global.creator_address())", 0)),
        (165, ("def assert_sender_is_creator() -> Expr:", 1)),
        (
            166,
            (
                "def deposit(payment: abi.PaymentTransaction, sender: abi.Account) -> Expr:",
                1,
            ),
        ),
        (
            167,
            (
                "def deposit(payment: abi.PaymentTransaction, sender: abi.Account) -> Expr:",
                1,
            ),
        ),
        (
            168,
            (
                "def deposit(payment: abi.PaymentTransaction, sender: abi.Account) -> Expr:",
                1,
            ),
        ),
        (
            169,
            (
                "def deposit(payment: abi.PaymentTransaction, sender: abi.Account) -> Expr:",
                1,
            ),
        ),
        (
            170,
            (
                "def deposit(payment: abi.PaymentTransaction, sender: abi.Account) -> Expr:",
                1,
            ),
        ),
        (171, ("payment.get()", 0)),
        (172, ("payment.get().sender()", 0)),
        (173, ("sender.address()", 0)),
        (174, ("sender.address()", 0)),
        (175, ("payment.get().sender() == sender.address()", 0)),
        (176, ("Assert(payment.get().sender() == sender.address())", 0)),
        (177, ("payment.get()", 0)),
        (178, ("payment.get().receiver()", 0)),
        (179, ("Global.current_application_address()", 0)),
        (180, ("payment.get().receiver() == Global.current_application_address()", 0)),
        (
            181,
            (
                "Assert(payment.get().receiver() == Global.current_application_address())",
                0,
            ),
        ),
        (182, ("sender.address()", 0)),
        (183, ("sender.address()", 0)),
        (184, ("Bytes('balance')", 0)),
        (185, ("sender.address()", 0)),
        (186, ("sender.address()", 0)),
        (187, ("Bytes('balance')", 0)),
        (188, ("App.localGet(sender.address(), Bytes('balance'))", 0)),
        (189, ("payment.get()", 0)),
        (190, ("payment.get().amount()", 0)),
        (
            191,
            (
                "App.localGet(sender.address(), Bytes('balance')) + payment.get().amount()",
                0,
            ),
        ),
        (
            192,
            (
                "App.localPut(sender.address(), Bytes('balance'), App.localGet(sender.address(), Bytes('balance')) + payment.get().amount())",
                0,
            ),
        ),
        (
            193,
            (
                "def deposit(payment: abi.PaymentTransaction, sender: abi.Account) -> Expr:",
                1,
            ),
        ),
        (194, ("def getBalance(user: abi.Account, *, output: abi.Uint64) -> Expr:", 1)),
        (195, ("def getBalance(user: abi.Account, *, output: abi.Uint64) -> Expr:", 1)),
        (196, ("def getBalance(user: abi.Account, *, output: abi.Uint64) -> Expr:", 1)),
        (197, ("user.address()", 0)),
        (198, ("Bytes('balance')", 0)),
        (199, ("App.localGet(user.address(), Bytes('balance'))", 0)),
        (200, ("def getBalance(user: abi.Account, *, output: abi.Uint64) -> Expr:", 1)),
        (201, ("def withdraw(amount: abi.Uint64, recipient: abi.Account) -> Expr:", 1)),
        (202, ("def withdraw(amount: abi.Uint64, recipient: abi.Account) -> Expr:", 1)),
        (203, ("def withdraw(amount: abi.Uint64, recipient: abi.Account) -> Expr:", 1)),
        (204, ("def withdraw(amount: abi.Uint64, recipient: abi.Account) -> Expr:", 1)),
        (205, ("def withdraw(amount: abi.Uint64, recipient: abi.Account) -> Expr:", 1)),
        (206, ("Txn.sender()", 0)),
        (207, ("Bytes('balance')", 0)),
        (208, ("Txn.sender()", 0)),
        (209, ("Bytes('balance')", 0)),
        (210, ("App.localGet(Txn.sender(), Bytes('balance'))", 0)),
        (211, ("amount.get()", 0)),
        (212, ("App.localGet(Txn.sender(), Bytes('balance')) - amount.get()", 0)),
        (
            213,
            (
                "App.localPut(Txn.sender(), Bytes('balance'), App.localGet(Txn.sender(), Bytes('balance')) - amount.get())",
                0,
            ),
        ),
        (214, ("InnerTxnBuilder.Begin()", 0)),
        (
            215,
            (
                "InnerTxnBuilder.SetFields({TxnField.type_enum: TxnType.Payment, TxnField.receiver: recipient.address(), TxnField.amount: amount.get(), TxnField.fee: Int(0)})",
                0,
            ),
        ),
        (
            216,
            (
                "InnerTxnBuilder.SetFields({TxnField.type_enum: TxnType.Payment, TxnField.receiver: recipient.address(), TxnField.amount: amount.get(), TxnField.fee: Int(0)})",
                0,
            ),
        ),
        (217, ("recipient.address()", 0)),
        (218, ("recipient.address()", 0)),
        (
            219,
            (
                "InnerTxnBuilder.SetFields({TxnField.type_enum: TxnType.Payment, TxnField.receiver: recipient.address(), TxnField.amount: amount.get(), TxnField.fee: Int(0)})",
                0,
            ),
        ),
        (220, ("amount.get()", 0)),
        (
            221,
            (
                "InnerTxnBuilder.SetFields({TxnField.type_enum: TxnType.Payment, TxnField.receiver: recipient.address(), TxnField.amount: amount.get(), TxnField.fee: Int(0)})",
                0,
            ),
        ),
        (222, ("Int(0)", 0)),
        (
            223,
            (
                "InnerTxnBuilder.SetFields({TxnField.type_enum: TxnType.Payment, TxnField.receiver: recipient.address(), TxnField.amount: amount.get(), TxnField.fee: Int(0)})",
                0,
            ),
        ),
        (224, ("InnerTxnBuilder.Submit()", 0)),
        (225, ("def withdraw(amount: abi.Uint64, recipient: abi.Account) -> Expr:", 1)),
    ]
    assert len(expected) == len(actual)
    print(list(enumerate(actual)))

    for i, a in enumerate(actual):
        assert (
            e := expected[i][1]
        ) == a, f"""discrepancy at index {i=} 
expected:
{e}
!= actual:
{a}"""



================================================
FILE: tests/unit/sourcemap_rps_test.py
================================================
from pathlib import Path
import pytest

from feature_gates import FeatureGates

RPS = Path.cwd() / "tests" / "teal"


@pytest.fixture
def sourcemap_enabled():
    previous = FeatureGates.sourcemap_enabled()
    FeatureGates.set_sourcemap_enabled(True)
    yield
    FeatureGates.set_sourcemap_enabled(previous)


@pytest.fixture
def sourcemap_disabled():
    previous = FeatureGates.sourcemap_enabled()
    FeatureGates.set_sourcemap_enabled(False)
    yield
    FeatureGates.set_sourcemap_enabled(previous)


def compare_and_assert(file, actual):
    with open(file, "r") as f:
        expected_lines = f.read().splitlines()
        actual_lines = actual.splitlines()
        assert len(expected_lines) == len(actual_lines)
        assert expected_lines == actual_lines


def no_regressions_rps():
    from pyteal import compileTeal, Mode
    from tests.teal.rps import approval_program

    compiled = compileTeal(approval_program(), Mode.Application, version=6)
    compare_and_assert(RPS / "rps.teal", compiled)


@pytest.mark.serial
def test_annotated_rps(sourcemap_enabled):
    from pyteal import Compilation, Mode
    from pyteal.compiler.sourcemap import _PyTealSourceMapper
    from tests.teal.rps import approval_program

    with open(RPS / "rps.teal", "r") as f:
        expected_teal = f.read()

    with open(RPS / "rps_annotated.teal", "r") as f:
        expected_annotated = f.read()

    cbundle = Compilation(approval_program(), Mode.Application, version=6).compile(
        with_sourcemap=True,
        annotate_teal=True,
        annotate_teal_headers=True,
        annotate_teal_concise=False,
    )
    teal, annotated = cbundle.teal, cbundle.sourcemap.annotated_teal

    assert expected_teal == teal
    assert expected_annotated == annotated
    _PyTealSourceMapper._validate_annotated(
        False, teal.splitlines(), annotated.splitlines()
    )


@pytest.mark.serial
def test_no_regression_with_sourcemap_as_configured_rps():
    no_regressions_rps()


@pytest.mark.serial
def test_no_regression_with_sourcemap_enabled_rps(sourcemap_enabled):
    from pyteal.stack_frame import NatalStackFrame

    assert NatalStackFrame.sourcemapping_is_off() is False

    no_regressions_rps()


@pytest.mark.serial
def test_no_regression_with_sourcemap_disabled_rps(sourcemap_disabled):
    from pyteal.stack_frame import NatalStackFrame

    assert NatalStackFrame.sourcemapping_is_off()

    no_regressions_rps()



================================================
FILE: tests/unit/sourcemap_test.py
================================================
"""
This test would typically reside right next to `pyteal/compiler/sourcemap.py`.
However, since the path `pyteal/compiler` is on the StackFrame._internal_paths
blacklist, we need to move the test elsewhere to obtain reliable results.
"""

import ast
import json
from pathlib import Path
import time
from unittest import mock

import pytest

from pyteal.compiler.sourcemap import R3SourceMap, R3SourceMapJSON

ALGOBANK = Path.cwd() / "examples" / "application" / "abi"


@pytest.fixture
def StackFrame_keep_all_debugging():
    from pyteal.stack_frame import NatalStackFrame

    NatalStackFrame._keep_all_debugging = True
    yield
    NatalStackFrame._keep_all_debugging = False


@pytest.fixture
def sourcemap_enabled():
    from feature_gates import FeatureGates

    previous = FeatureGates.sourcemap_enabled()
    FeatureGates.set_sourcemap_enabled(True)
    yield
    FeatureGates.set_sourcemap_enabled(previous)


@pytest.fixture
def sourcemap_disabled():
    from feature_gates import FeatureGates

    previous = FeatureGates.sourcemap_enabled()
    FeatureGates.set_sourcemap_enabled(False)
    yield
    FeatureGates.set_sourcemap_enabled(previous)


@pytest.mark.serial
def test_frames(sourcemap_enabled, StackFrame_keep_all_debugging):
    from pyteal.stack_frame import NatalStackFrame

    assert NatalStackFrame.sourcemapping_is_off() is False

    this_file, this_func = "sourcemap_test.py", "test_frames"
    this_lineno, this_frame = 56, NatalStackFrame()._frames[1]
    code = (
        f"    this_lineno, this_frame = {this_lineno}, NatalStackFrame()._frames[1]\n"
    )
    this_col_offset, this_end_col_offset = 34, 51
    frame_info, node = this_frame.frame_info, this_frame.node

    assert frame_info.filename.endswith(this_file)
    assert this_func == frame_info.function
    assert frame_info.code_context
    assert len(frame_info.code_context) == 1
    assert code == frame_info.code_context[0]
    assert this_lineno == frame_info.lineno

    assert node
    assert this_lineno == node.lineno == node.end_lineno
    assert this_col_offset == node.col_offset
    assert this_end_col_offset == node.end_col_offset
    assert isinstance(node, ast.Call)
    assert isinstance(node.parent, ast.Attribute)  # type: ignore
    assert isinstance(node.parent.parent, ast.Subscript)  # type: ignore


@pytest.mark.serial
def test_TealMapItem_source_mapping(sourcemap_enabled):
    from pyteal.stack_frame import NatalStackFrame

    assert NatalStackFrame.sourcemapping_is_off() is False

    import pyteal as pt
    from pyteal.compiler.sourcemap import TealMapItem

    expr = pt.Int(0) + pt.Int(1)
    expr_line_offset, expr_str = 50, "expr = pt.Int(0) + pt.Int(1)"

    def mock_teal(ops):
        return [f"{i + 1}. {op}" for i, op in enumerate(ops)]

    components = []
    b = expr.__teal__(pt.CompileOptions())[0]
    while b:
        components.extend(b.ops)
        b = b.nextBlock  # type: ignore

    teals = mock_teal(components)
    tmis = [
        TealMapItem(op.expr.stack_frames._frames[0].as_pyteal_frame(), i, teals[i], op)
        for i, op in enumerate(components)
    ]

    mock_source_lines = [""] * 500
    mock_source_lines[expr_line_offset] = expr_str
    source_files = ["sourcemap_test.py"]
    r3sm = R3SourceMap(
        filename="dohhh.teal",
        source_root="~",
        entries={(i, 0): tmi.source_mapping() for i, tmi in enumerate(tmis)},
        index=[(0,) for _ in range(3)],
        file_lines=list(map(lambda x: x.teal_line, tmis)),
        source_files=source_files,
        source_files_lines=[mock_source_lines],
    )
    expected_json = '{"version": 3, "sources": ["tests/unit/sourcemap_test.py"], "names": [], "mappings": "AAuFW;AAAY;AAAZ", "file": "dohhh.teal", "sourceRoot": "~"}'

    assert expected_json == json.dumps(r3sm.to_json())

    r3sm_unmarshalled = R3SourceMap.from_json(
        R3SourceMapJSON(**json.loads(expected_json)),  # type: ignore
        sources_content_override=["\n".join(mock_source_lines)],
        target="\n".join(teals),
    )

    # TODO: test various properties of r3sm_unmarshalled

    assert expected_json == json.dumps(r3sm_unmarshalled.to_json())


def compare_and_assert(file, actual):
    with open(file, "r") as f:
        expected_lines = f.read().splitlines()
        actual_lines = actual.splitlines()
        assert len(expected_lines) == len(actual_lines)
        assert expected_lines == actual_lines


def no_regressions_algobank():
    from examples.application.abi.algobank import router
    from pyteal import OptimizeOptions

    approval, clear, contract = router.compile_program(
        version=6, optimize=OptimizeOptions(scratch_slots=True)
    )

    compare_and_assert(
        ALGOBANK / "algobank.json", json.dumps(contract.dictify(), indent=4)
    )
    compare_and_assert(ALGOBANK / "algobank_clear_state.teal", clear)
    compare_and_assert(ALGOBANK / "algobank_approval.teal", approval)


@pytest.mark.serial
def test_no_regression_with_sourcemap_as_configured_algobank():
    no_regressions_algobank()


@pytest.mark.serial
def test_no_regression_with_sourcemap_enabled_algobank(sourcemap_enabled):
    from pyteal.stack_frame import NatalStackFrame

    assert NatalStackFrame.sourcemapping_is_off() is False
    no_regressions_algobank()


@pytest.mark.serial
def test_no_regression_with_sourcemap_disabled_algobank(sourcemap_disabled):
    from pyteal.stack_frame import NatalStackFrame

    assert NatalStackFrame.sourcemapping_is_off() is True

    no_regressions_algobank()


@pytest.mark.serial
def test_sourcemap_fails_because_not_enabled():
    from examples.application.abi.algobank import router
    from pyteal import OptimizeOptions
    from pyteal.errors import SourceMapDisabledError

    with pytest.raises(SourceMapDisabledError) as smde:
        router.compile(
            version=6,
            optimize=OptimizeOptions(scratch_slots=True),
            with_sourcemaps=True,
        )

    assert """Cannot calculate Teal to PyTeal source map because stack frame discovery is turned off.

    To enable source maps: import `from feature_gates import FeatureGates` and call `FeatureGates.set_sourcemap_enabled(True)`.""" in str(
        smde.value
    )


def test_PyTealSourceMapper_validate_build_annotate():
    from pyteal import TealInternalError
    from pyteal.compiler.sourcemap import _PyTealSourceMapper

    # --- CONSTRUCTOR VALIDATIONS --- #
    match = "Please provide non-empty teal_chunks"
    with pytest.raises(TealInternalError, match=match):
        _PyTealSourceMapper([], [], build=False, annotate_teal=False)

    match = "Please provide non-empty components"
    with pytest.raises(TealInternalError, match=match):
        _PyTealSourceMapper(["a chunk"], [], build=False, annotate_teal=False)

    # --- BUILD VALIDATIONS --- #
    ptsm = _PyTealSourceMapper(
        ["a chunk"], ["a component", "another"], build=False, annotate_teal=False
    )

    def full_match(s):
        return f"""{s}
        {_PyTealSourceMapper.UNEXPECTED_ERROR_SUFFIX}"""

    match = full_match(
        r"expected same number of teal chunks \(1\) and components \(2\)"
    )
    with pytest.raises(TealInternalError, match=match):
        ptsm.build()

    ptsm.teal_chunks = ptsm.components = []
    match = full_match("cannot generate empty source map: no components")
    with pytest.raises(TealInternalError, match=match):
        ptsm.build()

    teal_chunks = ["first line\nsecond line", "third line\nfourth line\nfifth line"]
    teal = [
        "first line",
        "second line",
        "third line",
        "fourth line",
        "fifth line",
    ]
    i = 0
    for chunk in teal_chunks:
        for line in chunk.splitlines():
            assert teal[i] == line
            i += 1

    def mock_TealMapItem(s):
        tmi = mock.Mock()
        tmi.teal_line = s
        return tmi

    def mock_R3SourceMap(lines):
        r3sm = mock.Mock()
        r3sm.file_lines = lines
        return r3sm

    ptsm.teal_chunks = teal_chunks
    ptsm._cached_tmis = [mock_TealMapItem(s) for s in teal]
    ptsm._cached_r3sourcemap = mock_R3SourceMap(teal)

    ptsm._validate_build()
    ptsm.teal_chunks.append("sixth line")
    match = full_match(
        r"teal chunks has 6 teal lines which doesn't match the number of cached TealMapItem's \(5\)"
    )
    with pytest.raises(TealInternalError, match=match):
        ptsm._validate_build()

    ptsm._cached_tmis.append(mock_TealMapItem("sixth line"))
    ptsm._cached_r3sourcemap.file_lines.append("sixth line")
    ptsm._validate_build()

    match = full_match(
        r"teal chunks has 6 teal lines which doesn't match the number of cached TealMapItem's \(7\)"
    )
    ptsm._cached_tmis.append(mock_TealMapItem("seventh line"))
    with pytest.raises(TealInternalError, match=match):
        ptsm._validate_build()

    del ptsm._cached_tmis[-1]
    ptsm._validate_build()

    ptsm._cached_tmis[-1] = mock_TealMapItem("NOT the sixth line")
    match = full_match(
        r"teal chunk lines don't match TealMapItem's at index 5. \('sixth line' v. 'NOT the sixth line'\)"
    )
    with pytest.raises(TealInternalError, match=match):
        ptsm._validate_build()

    ptsm._cached_tmis[-1] = mock_TealMapItem("sixth line")
    ptsm._validate_build()

    ptsm._cached_r3sourcemap.file_lines.append("seventh line")
    match = full_match(
        r"there are 6 TealMapItem's which doesn't match the number of file_lines in the cached R3SourceMap \(7\)"
    )
    with pytest.raises(TealInternalError, match=match):
        ptsm._validate_build()

    del ptsm._cached_r3sourcemap.file_lines[-1]
    ptsm._validate_build()

    ptsm._cached_r3sourcemap.file_lines[-1] = "NOT the sixth line"
    match = full_match(
        r"TealMapItem's don't match R3SourceMap.file_lines at index 5. \('sixth line' v. 'NOT the sixth line'\)"
    )
    with pytest.raises(TealInternalError, match=match):
        ptsm._validate_build()

    ptsm._cached_r3sourcemap.file_lines[-1] = "sixth line"
    ptsm._validate_build()

    # --- ANNOTATE VALIDATIONS --- #
    annotated = [f"{teal}   // some other stuff{i}" for i, teal in enumerate(teal)]
    omit_headers = True
    ptsm._validate_annotated(omit_headers, teal, annotated)

    omit_headers = False
    match = full_match(
        r"mismatch between count of teal_lines \(6\) and annotated_lines \(6\) for the case omit_headers=False"
    )
    with pytest.raises(TealInternalError, match=match):
        ptsm._validate_annotated(omit_headers, teal, annotated)

    annotated_w_headers = ["// some header"] + annotated
    ptsm._validate_annotated(omit_headers, teal, annotated_w_headers)

    omit_headers = True
    match = full_match(
        r"mismatch between count of teal_lines \(6\) and annotated_lines \(7\) for the case omit_headers=True"
    )
    with pytest.raises(TealInternalError, match=match):
        ptsm._validate_annotated(omit_headers, teal, annotated_w_headers)

    annotated_3 = annotated[3]
    annotated[3] = "doesn't begin with the teal line"
    match = full_match(
        r"annotated teal ought to begin exactly with the teal line but line 4 \[doesn't begin with the teal line\] doesn't start with \[fourth line\]"
    )
    with pytest.raises(TealInternalError, match=match):
        ptsm._validate_annotated(omit_headers, teal, annotated)

    annotated[3] = annotated_3
    ptsm._validate_annotated(omit_headers, teal, annotated)

    annotated_w_headers[4] = "doesn't begin with the teal line"
    omit_headers = False
    with pytest.raises(TealInternalError, match=match):
        ptsm._validate_annotated(omit_headers, teal, annotated_w_headers)

    annotated_w_headers[4] = annotated_3
    ptsm._validate_annotated(omit_headers, teal, annotated_w_headers)

    omit_headers = True
    annotated_2 = annotated[2]
    annotated[2] = f"{teal[2]}   some other stuff not all // commented out"
    match = full_match(
        rf"annotated teal ought to begin exactly with the teal line followed by annotation in comments but line 3 \[{annotated[2]}\] has non-commented out annotations"
    )
    with pytest.raises(TealInternalError, match=match):
        ptsm._validate_annotated(omit_headers, teal, annotated)

    annotated[2] = annotated_2
    ptsm._validate_annotated(omit_headers, teal, annotated)

    omit_headers = False
    annotated_w_headers[3] = f"{teal[2]}   some other stuff not all // commented out"
    with pytest.raises(TealInternalError, match=match):
        ptsm._validate_annotated(omit_headers, teal, annotated_w_headers)

    annotated_w_headers[3] = annotated_2
    ptsm._validate_annotated(omit_headers, teal, annotated_w_headers)

    # --- ANNOTATE VALIDATIONS - SPECIAL CASE --- #
    meth_sig = "deposit(pay,account)void"
    special = f"method {meth_sig}      //    (30)"
    teal.append(special)
    annotated_w_headers.append(special)
    ptsm._validate_annotated(omit_headers, teal, annotated_w_headers)


def test_examples_sourcemap():
    """
    Test to ensure that examples/application/teal/sourcemap.py doesn't go stale
    """
    from examples.application.sourcemap import Compilation, Mode, program

    examples = Path.cwd() / "examples" / "application" / "teal"

    approval_program = program()

    results = Compilation(approval_program, mode=Mode.Application, version=8).compile(
        with_sourcemap=True, annotate_teal=True, annotate_teal_headers=True
    )

    teal = examples / "sourcemap.teal"
    annotated = examples / "sourcemap_annotated.teal"

    with open(teal) as f:
        assert f.read() == results.teal

    with open(annotated) as f:
        fixture = f.read().splitlines()
        annotated = results.sourcemap.annotated_teal.splitlines()
        for i, (f, a) in enumerate(zip(fixture, annotated)):
            f_cols = f.split()
            a_cols = a.split()
            if f_cols == a_cols:
                continue

            if f_cols[-1] == "annotate_teal_headers=True)":
                assert f_cols[:2] == a_cols[:2], f"index {i} doesn't match"
                assert f_cols[-4:] == a_cols[-4:], f"index {i} doesn't match"
                continue

            # must differ because fixture repeats PYTEAL PATH so omits it
            assert len(f_cols) == len(a_cols) - 1, f"index {i} doesn't match"

            a_comment = a_cols.index("//")
            assert f_cols == (
                a_cols[: a_comment + 1] + a_cols[a_comment + 2 :]
            ), f"index {i} doesn't match"


@pytest.mark.skip(
    reason="""Supressing this flaky test as 
router_test::test_router_compile_program_idempotence is similar in its goals
and we expect flakiness to persist until https://github.com/algorand/pyteal/issues/199
is finally addressed """
)
@pytest.mark.serial
def test_idempotent():
    # make sure we get clean up properly and therefore get idempotent results
    from examples.application.abi.algobank import router
    from pyteal import OptimizeOptions

    approval1, clear1, contract1 = (
        func := lambda: router.compile_program(
            version=6, optimize=OptimizeOptions(scratch_slots=True)
        )
    )()
    approval2, clear2, contract2 = func()

    assert contract1.dictify() == contract2.dictify()
    assert len(clear1.splitlines()) == len(clear2.splitlines())
    assert clear1 == clear2
    assert len(approval1.splitlines()) == len(approval2.splitlines())
    assert approval1 == approval2


# ---- BENCHMARKS - SKIPPED BY DEFAULT ---- #


def time_for_n_secs(f, n):
    start = time.time()

    def since():
        return time.time() - start

    total_time = 0.0
    snapshots = [0.0]
    while total_time < n:
        f()
        total_time = since()
        snapshots.append(total_time)

    trials = [snapshots[i + 1] - s for i, s in enumerate(snapshots[:-1])]
    return trials, total_time


def simple_compilation():
    from examples.application.abi.algobank import router
    from pyteal import OptimizeOptions

    router.compile_program(version=6, optimize=OptimizeOptions(scratch_slots=True))


def source_map_compilation():
    from examples.application.abi.algobank import router
    from pyteal import OptimizeOptions

    router.compile(
        version=6,
        optimize=OptimizeOptions(scratch_slots=True),
        with_sourcemaps=True,
    )


def annotated_teal():
    from examples.application.abi.algobank import router
    from pyteal import OptimizeOptions

    compilation = router.compile(
        version=6,
        optimize=OptimizeOptions(scratch_slots=True),
        with_sourcemaps=True,
    )

    assert compilation.approval_sourcemapper

    return compilation.approval_sourcemapper.annotated_teal()


summaries_only = True


def trial(func):
    trials, tot = time_for_n_secs(simple_compilation, 10)
    avg = tot / len(trials)
    N = len(trials)
    trials = "" if summaries_only else f"{trials=}"
    print(
        f"""
{func.__name__}: {avg=}, {N=}
{trials}"""
    )


@pytest.mark.skip(reason="Benchmarks are too slow to run every time")
@pytest.mark.serial
def test_time_benchmark_with_default_feature_gates():
    from pyteal.stack_frame import NatalStackFrame

    print(f"{NatalStackFrame.sourcemapping_is_off()=}")

    trial(simple_compilation)
    trial(simple_compilation)

    assert False


@pytest.mark.skip(reason="Benchmarks are too slow to run every time")
@pytest.mark.serial
def test_time_benchmark_sourcemap_enabled(sourcemap_enabled):
    """
    UPSHOT: expect deterioration of (5 to 15)X when enabling source maps.
    """
    from pyteal.stack_frame import NatalStackFrame

    print(f"{NatalStackFrame.sourcemapping_is_off()=}")
    print(
        """
keep_all: bool = True,
stop_after_first_pyteal: bool = True,
keep_one_frame_only: bool = True,
"""
    )

    trial(simple_compilation)
    trial(simple_compilation)

    trial(source_map_compilation)
    trial(source_map_compilation)

    trial(annotated_teal)
    trial(annotated_teal)

    assert False



================================================
FILE: tests/unit/user_guide_test.py
================================================
import pytest

import pyteal as pt
from tests.compile_asserts import assert_new_v_old


def user_guide_snippet_dynamic_scratch_var() -> pt.Expr:
    """
    The user guide docs use the test to illustrate `DynamicScratchVar` usage.  If the test breaks, then the user guide docs must be updated along with the test.
    """
    from pyteal import Assert, Int, DynamicScratchVar, ScratchVar, Seq, TealType

    s = ScratchVar(TealType.uint64)
    d = DynamicScratchVar(TealType.uint64)

    return Seq(
        d.set_index(s),
        s.store(Int(7)),
        d.store(d.load() + Int(3)),
        Assert(s.load() == Int(10)),
        Int(1),
    )


@pytest.mark.parametrize("snippet", [user_guide_snippet_dynamic_scratch_var])
@pytest.mark.serial  # Serial due to scratch generation
def test_user_guide_snippets(snippet):
    assert_new_v_old(snippet, 6, "user_guide")


def user_guide_snippet_recursiveIsEven():
    from pyteal import If, Int, Subroutine, TealType

    @Subroutine(TealType.uint64)
    def recursiveIsEven(i):
        return (
            If(i == Int(0))
            .Then(Int(1))
            .ElseIf(i == Int(1))
            .Then(Int(0))
            .Else(recursiveIsEven(i - Int(2)))
        )

    return recursiveIsEven(Int(15))


def user_guide_snippet_ILLEGAL_recursion():
    from pyteal import If, Int, ScratchVar, Seq, Subroutine, TealType

    @Subroutine(TealType.none)
    def ILLEGAL_recursion(i: ScratchVar):
        return (
            If(i.load() == Int(0))
            .Then(i.store(Int(1)))
            .ElseIf(i.load() == Int(1))
            .Then(i.store(Int(0)))
            .Else(Seq(i.store(i.load() - Int(2)), ILLEGAL_recursion(i)))
        )

    i = ScratchVar(TealType.uint64)
    return Seq(i.store(Int(15)), ILLEGAL_recursion(i), Int(1))


def user_guide_snippet_ABIReturnSubroutine():
    from pyteal import (
        ABIReturnSubroutine,
        Expr,
        For,
        Int,
        ScratchVar,
        Seq,
        Txn,
        TealType,
    )
    from pyteal import abi

    # --- BEGIN doc-comment --- #
    @ABIReturnSubroutine
    def abi_sum(to_sum: abi.DynamicArray[abi.Uint64], *, output: abi.Uint64) -> Expr:
        i = ScratchVar(TealType.uint64)
        value_at_index = abi.Uint64()
        return Seq(
            output.set(0),
            For(
                i.store(Int(0)), i.load() < to_sum.length(), i.store(i.load() + Int(1))
            ).Do(
                Seq(
                    to_sum[i.load()].store_into(value_at_index),
                    output.set(output.get() + value_at_index.get()),
                )
            ),
        )

    program = Seq(
        (to_sum_arr := abi.make(abi.DynamicArray[abi.Uint64])).decode(
            Txn.application_args[1]
        ),
        (res := abi.Uint64()).set(abi_sum(to_sum_arr)),
        pt.abi.MethodReturn(res),
        Int(1),
    )
    # --- END doc-comment --- #
    return program


USER_GUIDE_SNIPPETS_COPACETIC = [
    user_guide_snippet_dynamic_scratch_var,
    user_guide_snippet_recursiveIsEven,
    user_guide_snippet_ABIReturnSubroutine,
]


@pytest.mark.parametrize("snippet", USER_GUIDE_SNIPPETS_COPACETIC)
@pytest.mark.serial  # Serial due to scratch generation
def test_user_guide_snippets_good(snippet):
    assert_new_v_old(snippet, 6, "user_guide")


USER_GUIDE_SNIPPETS_ERRORING = {
    user_guide_snippet_ILLEGAL_recursion: (
        pt.TealInputError,
        "ScratchVar arguments not allowed in recursive subroutines, but a recursive call-path was detected: ILLEGAL_recursion()-->ILLEGAL_recursion()",
    )
}


@pytest.mark.parametrize("snippet_etype_e", USER_GUIDE_SNIPPETS_ERRORING.items())
@pytest.mark.serial  # Serial due to scratch generation
def test_user_guide_snippets_bad(snippet_etype_e):
    snippet, etype_e = snippet_etype_e
    etype, e = etype_e

    print(
        f"Test case function=[{snippet.__name__}]. Expecting error of type {etype} with message <{e}>"
    )
    with pytest.raises(etype) as tie:
        pt.compileTeal(snippet(), mode=pt.Mode.Application, version=6)

    assert e in str(tie)



================================================
FILE: tests/unit/teal/abi/app_fn_0arg_0ret.teal
================================================
#pragma version 6
callsub fn0arg0ret_0
int 1
return

// fn_0arg_0ret
fn0arg0ret_0:
retsub


================================================
FILE: tests/unit/teal/abi/app_fn_0arg_uint64_ret.teal
================================================
#pragma version 6
callsub fn0arguint64ret_0
store 1
byte 0x151f7c75
load 1
itob
concat
log
int 1
return

// fn_0arg_uint64_ret
fn0arguint64ret_0:
int 1
store 0
load 0
retsub


================================================
FILE: tests/unit/teal/abi/app_fn_1arg_0ret.teal
================================================
#pragma version 6
txna ApplicationArgs 0
btoi
store 1
load 1
callsub fn1arg0ret_0
int 1
return

// fn_1arg_0ret
fn1arg0ret_0:
store 0
retsub


================================================
FILE: tests/unit/teal/abi/app_fn_1arg_1ret.teal
================================================
#pragma version 6
txna ApplicationArgs 0
btoi
store 3
load 3
callsub fn1arg1ret_0
store 2
byte 0x151f7c75
load 2
itob
concat
log
int 1
return

// fn_1arg_1ret
fn1arg1ret_0:
store 0
load 0
store 1
load 1
retsub


================================================
FILE: tests/unit/teal/abi/app_fn_1tt_arg_uint64_ret.teal
================================================
#pragma version 6
txna ApplicationArgs 0
callsub fn1ttarguint64ret_0
store 2
byte 0x151f7c75
load 2
itob
concat
log
int 1
return

// fn_1tt_arg_uint64_ret
fn1ttarguint64ret_0:
store 0
int 1
store 1
load 1
retsub


================================================
FILE: tests/unit/teal/abi/app_fn_2arg_0ret.teal
================================================
#pragma version 6
txna ApplicationArgs 0
btoi
store 2
txna ApplicationArgs 1
store 3
load 2
load 3
callsub fn2arg0ret_0
int 1
return

// fn_2arg_0ret
fn2arg0ret_0:
store 1
store 0
retsub


================================================
FILE: tests/unit/teal/abi/app_fn_2mixed_arg_1ret.teal
================================================
#pragma version 6
txna ApplicationArgs 0
btoi
store 4
txna ApplicationArgs 1
store 5
load 4
int 5
callsub fn2mixedarg1ret_0
store 3
byte 0x151f7c75
load 3
itob
concat
log
int 1
return

// fn_2mixed_arg_1ret
fn2mixedarg1ret_0:
store 1
store 0
load 1
load 0
itob
stores
load 0
store 2
load 2
retsub


================================================
FILE: tests/unit/teal/abi/app_fn_3mixed_args_0ret.teal
================================================
#pragma version 6
txna ApplicationArgs 0
btoi
store 3
txna ApplicationArgs 1
btoi
store 4
txna ApplicationArgs 2
store 5
load 3
int 4
load 5
callsub fn3mixedargs0ret_0
int 1
return

// fn_3mixed_args_0ret
fn3mixedargs0ret_0:
store 2
store 1
store 0
retsub


================================================
FILE: tests/unit/teal/abi/lsig_fn_0arg_0ret.teal
================================================
#pragma version 6
callsub fn0arg0ret_0
int 1
return

// fn_0arg_0ret
fn0arg0ret_0:
retsub


================================================
FILE: tests/unit/teal/abi/lsig_fn_0arg_uint64_ret.teal
================================================
#pragma version 6
callsub fn0arguint64ret_0
store 0
load 0
itob
pop
int 1
return

// fn_0arg_uint64_ret
fn0arguint64ret_0:
int 1
store 1
load 1
retsub


================================================
FILE: tests/unit/teal/abi/lsig_fn_1arg_0ret.teal
================================================
#pragma version 6
arg 0
btoi
store 0
load 0
callsub fn1arg0ret_0
int 1
return

// fn_1arg_0ret
fn1arg0ret_0:
store 1
retsub


================================================
FILE: tests/unit/teal/abi/lsig_fn_1arg_1ret.teal
================================================
#pragma version 6
arg 0
btoi
store 1
load 1
callsub fn1arg1ret_0
store 0
load 0
itob
pop
int 1
return

// fn_1arg_1ret
fn1arg1ret_0:
store 2
load 2
store 3
load 3
retsub


================================================
FILE: tests/unit/teal/abi/lsig_fn_1tt_arg_uint64_ret.teal
================================================
#pragma version 6
arg 0
callsub fn1ttarguint64ret_0
store 0
load 0
itob
pop
int 1
return

// fn_1tt_arg_uint64_ret
fn1ttarguint64ret_0:
store 1
int 1
store 2
load 2
retsub


================================================
FILE: tests/unit/teal/abi/lsig_fn_2arg_0ret.teal
================================================
#pragma version 6
arg 0
btoi
store 0
arg 1
store 1
load 0
load 1
callsub fn2arg0ret_0
int 1
return

// fn_2arg_0ret
fn2arg0ret_0:
store 3
store 2
retsub


================================================
FILE: tests/unit/teal/abi/lsig_fn_2mixed_arg_1ret.teal
================================================
#pragma version 6
arg 0
btoi
store 1
arg 1
store 2
load 1
int 2
callsub fn2mixedarg1ret_0
store 0
load 0
itob
pop
int 1
return

// fn_2mixed_arg_1ret
fn2mixedarg1ret_0:
store 4
store 3
load 4
load 3
itob
stores
load 3
store 5
load 5
retsub


================================================
FILE: tests/unit/teal/abi/lsig_fn_3mixed_args_0ret.teal
================================================
#pragma version 6
arg 0
btoi
store 0
arg 1
btoi
store 1
arg 2
store 2
load 0
int 1
load 2
callsub fn3mixedargs0ret_0
int 1
return

// fn_3mixed_args_0ret
fn3mixedargs0ret_0:
store 5
store 4
store 3
retsub


================================================
FILE: tests/unit/teal/blackbox/app_utest_any.teal
================================================
#pragma version 6
callsub utestany_0
store 1
byte "nada"
log
load 1
store 2
int 1337
return

// utest_any
utestany_0:
int 0
store 0
load 0
retsub


================================================
FILE: tests/unit/teal/blackbox/app_utest_any_args.teal
================================================
#pragma version 6
txna ApplicationArgs 0
btoi
txna ApplicationArgs 1
txna ApplicationArgs 2
callsub utestanyargs_0
store 4
byte "nada"
log
load 4
store 5
int 1337
return

// utest_any_args
utestanyargs_0:
store 2
store 1
store 0
int 0
store 3
load 3
retsub


================================================
FILE: tests/unit/teal/blackbox/app_utest_bytes.teal
================================================
#pragma version 6
callsub utestbytes_0
store 0
load 0
log
load 0
len
return

// utest_bytes
utestbytes_0:
byte ""
retsub


================================================
FILE: tests/unit/teal/blackbox/app_utest_bytes_args.teal
================================================
#pragma version 6
txna ApplicationArgs 0
btoi
txna ApplicationArgs 1
txna ApplicationArgs 2
callsub utestbytesargs_0
store 3
load 3
log
load 3
len
return

// utest_bytes_args
utestbytesargs_0:
store 2
store 1
store 0
byte ""
retsub


================================================
FILE: tests/unit/teal/blackbox/app_utest_int.teal
================================================
#pragma version 6
callsub utestint_0
store 0
load 0
itob
log
load 0
return

// utest_int
utestint_0:
int 0
retsub


================================================
FILE: tests/unit/teal/blackbox/app_utest_int_args.teal
================================================
#pragma version 6
txna ApplicationArgs 0
btoi
txna ApplicationArgs 1
txna ApplicationArgs 2
callsub utestintargs_0
store 3
load 3
itob
log
load 3
return

// utest_int_args
utestintargs_0:
store 2
store 1
store 0
int 0
retsub


================================================
FILE: tests/unit/teal/blackbox/app_utest_noop.teal
================================================
#pragma version 6
callsub utestnoop_0
int 1337
store 0
load 0
itob
log
load 0
return

// utest_noop
utestnoop_0:
int 0
pop
retsub


================================================
FILE: tests/unit/teal/blackbox/app_utest_noop_args.teal
================================================
#pragma version 6
txna ApplicationArgs 0
btoi
txna ApplicationArgs 1
txna ApplicationArgs 2
callsub utestnoopargs_0
int 1337
store 3
load 3
itob
log
load 3
return

// utest_noop_args
utestnoopargs_0:
store 2
store 1
store 0
int 0
pop
retsub


================================================
FILE: tests/unit/teal/blackbox/lsig_utest_any.teal
================================================
#pragma version 6
callsub utestany_0
store 0
int 1337
return

// utest_any
utestany_0:
int 0
store 1
load 1
retsub


================================================
FILE: tests/unit/teal/blackbox/lsig_utest_any_args.teal
================================================
#pragma version 6
arg 0
btoi
arg 1
arg 2
callsub utestanyargs_0
store 0
int 1337
return

// utest_any_args
utestanyargs_0:
store 3
store 2
store 1
int 0
store 4
load 4
retsub


================================================
FILE: tests/unit/teal/blackbox/lsig_utest_bytes.teal
================================================
#pragma version 6
callsub utestbytes_0
len
return

// utest_bytes
utestbytes_0:
byte ""
retsub


================================================
FILE: tests/unit/teal/blackbox/lsig_utest_bytes_args.teal
================================================
#pragma version 6
arg 0
btoi
arg 1
arg 2
callsub utestbytesargs_0
len
return

// utest_bytes_args
utestbytesargs_0:
store 2
store 1
store 0
byte ""
retsub


================================================
FILE: tests/unit/teal/blackbox/lsig_utest_int.teal
================================================
#pragma version 6
callsub utestint_0
return

// utest_int
utestint_0:
int 0
retsub


================================================
FILE: tests/unit/teal/blackbox/lsig_utest_int_args.teal
================================================
#pragma version 6
arg 0
btoi
arg 1
arg 2
callsub utestintargs_0
return

// utest_int_args
utestintargs_0:
store 2
store 1
store 0
int 0
retsub


================================================
FILE: tests/unit/teal/blackbox/lsig_utest_noop.teal
================================================
#pragma version 6
callsub utestnoop_0
int 1337
return

// utest_noop
utestnoop_0:
int 0
pop
retsub


================================================
FILE: tests/unit/teal/blackbox/lsig_utest_noop_args.teal
================================================
#pragma version 6
arg 0
btoi
arg 1
arg 2
callsub utestnoopargs_0
int 1337
return

// utest_noop_args
utestnoopargs_0:
store 2
store 1
store 0
int 0
pop
retsub


================================================
FILE: tests/unit/teal/pre_v6/sub_even.teal
================================================
#pragma version 5
int 1000
callsub recursiveIsEven_0
pop
int 1001
callsub recursiveIsEven_0
return

// recursiveIsEven
recursiveIsEven_0:
store 0
load 0
int 0
==
bnz recursiveIsEven_0_l4
load 0
int 1
==
bnz recursiveIsEven_0_l3
load 0
int 2
-
load 0
swap
callsub recursiveIsEven_0
swap
store 0
b recursiveIsEven_0_l5
recursiveIsEven_0_l3:
int 0
b recursiveIsEven_0_l5
recursiveIsEven_0_l4:
int 1
recursiveIsEven_0_l5:
retsub


================================================
FILE: tests/unit/teal/pre_v6/sub_fastfib.teal
================================================
#pragma version 5
int 3
callsub fastfibonacci_0
return

// fast_fibonacci
fastfibonacci_0:
store 0
int 0
store 2
int 1
store 3
int 1
store 1
fastfibonacci_0_l1:
load 1
load 0
<=
bz fastfibonacci_0_l3
load 2
load 3
+
store 3
load 3
load 2
-
store 2
load 1
int 1
+
store 1
b fastfibonacci_0_l1
fastfibonacci_0_l3:
load 2
retsub


================================================
FILE: tests/unit/teal/pre_v6/sub_logcat.teal
================================================
#pragma version 5
byte "hello"
int 42
callsub logcat_0
byte "hello42"
==
assert
int 1
return

// logcat
logcat_0:
store 1
store 0
load 0
load 1
itob
concat
store 2
load 2
log
load 2
retsub


================================================
FILE: tests/unit/teal/pre_v6/sub_slowfib.teal
================================================
#pragma version 5
int 3
callsub slowfibonacci_0
return

// slow_fibonacci
slowfibonacci_0:
store 0
load 0
int 1
<=
bnz slowfibonacci_0_l2
load 0
int 2
-
load 0
swap
callsub slowfibonacci_0
swap
store 0
load 0
int 1
-
load 0
swap
callsub slowfibonacci_0
swap
store 0
+
b slowfibonacci_0_l3
slowfibonacci_0_l2:
load 0
slowfibonacci_0_l3:
retsub


================================================
FILE: tests/unit/teal/unchanged/empty_scratches.teal
================================================
#pragma version 6
int 0
store 6
load 6
int 0
stores
int 1
store 6
load 6
byte ""
stores
int 2
store 6
load 6
int 0
stores
int 3
store 6
load 6
byte ""
stores
int 4
store 6
load 6
int 0
stores
int 5
store 6
load 6
byte ""
stores
int 42
return


================================================
FILE: tests/unit/teal/unchanged/lots_o_vars.teal
================================================
#pragma version 6
global CurrentApplicationID
int 0
==
txn NumAppArgs
int 0
==
||
bnz main_l2
int 1
store 0
byte "two"
store 1
int 3
store 2
byte "four"
store 3
int 0
byte "five"
int 5
app_local_put
int 0
byte "six"
byte "six"
app_local_put
int 0
byte "seven"
int 7
app_local_put
int 0
byte "eight"
byte "eight"
app_local_put
byte "nine"
int 9
app_global_put
byte "ten"
byte "ten"
app_global_put
byte "eleven"
int 11
app_global_put
byte "twelve"
byte "twelve"
app_global_put
load 0
int 1337
+
store 0
byte "NGL: "
load 1
concat
store 1
load 2
int 1337
+
store 2
byte "NGL: "
load 3
concat
store 3
int 0
byte "five"
int 1337
int 0
byte "five"
app_local_get
+
app_local_put
int 0
byte "six"
byte "NGL: "
int 0
byte "six"
app_local_get
concat
app_local_put
int 0
byte "seven"
int 0
byte "seven"
app_local_get
app_local_put
int 0
byte "eight"
byte "NGL: "
int 0
byte "eight"
app_local_get
concat
app_local_put
byte "nine"
int 1337
byte "nine"
app_global_get
+
app_global_put
byte "ten"
byte "NGL: "
byte "ten"
app_global_get
concat
app_global_put
byte "eleven"
int 1337
byte "eleven"
app_global_get
+
app_global_put
byte "twelve"
byte "NGL: "
byte "twelve"
app_global_get
concat
app_global_put
txna ApplicationArgs 0
btoi
store 13
txna ApplicationArgs 1
store 14
txna ApplicationArgs 2
btoi
store 6
txna ApplicationArgs 3
store 7
load 0
pop
load 1
pop
load 2
pop
load 3
pop
int 0
byte "five"
app_local_get
pop
int 0
byte "six"
app_local_get
pop
int 0
byte "seven"
app_local_get
pop
int 0
byte "eight"
app_local_get
pop
byte "nine"
app_global_get
pop
byte "ten"
app_global_get
pop
byte "eleven"
app_global_get
pop
byte "twelve"
app_global_get
pop
int 13
store 4
load 4
loads
itob
log
int 14
store 5
load 5
loads
log
int 6
store 4
load 4
loads
itob
log
int 7
store 5
load 5
loads
log
int 1337
b main_l3
main_l2:
int 1
main_l3:
return


================================================
FILE: tests/unit/teal/unchanged/sub_logcat_dynamic.teal
================================================
#pragma version 6
byte "hello"
store 0                   //  0: "hello"
int 0
int 42                    //  >@0,42
callsub logcatdynamic_0   //  <<EMPTY>>
byte "hello42"            //  >"hello42"
load 0                    //  >"hello42","hello42"
==                        //  >1
assert                    //  <<EMPTY>>
int 1                     //  >1
return                    //  <<SUCCESS>

// logcat_dynamic
logcatdynamic_0:          //  >@0,42
store 2                   //  2: 42
store 1                   //  1: @0
load 1
load 1                    //  >@0,@0
loads                     //  >@0,"hello"
load 2                    //  >@0,"hello",42
itob                      //  >@0,"hello","42"
concat                    //  >@0,"hello42"
stores                    //  0: "hello42"
load 1                    //  >@0
loads                     //  >"hello42"
log                     
retsub


================================================
FILE: tests/unit/teal/unchanged/sub_mixed.teal
================================================
#pragma version 6
int 42                     //     >42
byte "x"                   //     >42,"x"
int 0                      //     >42,"x",0
callsub mixedannotations_0 //     >42
return                     // <<SUCCESS>>

// mixed_annotations
mixedannotations_0:        //     >42,"x",0
store 3                    //     3:0
store 2                    //     2:"x"
store 1                    //     1:42
load 3                     //     >0
load 1                     //     >0,42
stores                     //     0:42
load 2                     //     >"x"
byte "="                   //     >"x","="
concat                     //     >"x="
load 1                     //     >"x=",42
itob                       //     >"x=","42"
concat                     //     >"x=42"
log                        //   LOG
load 1                     //     >42
retsub


================================================
FILE: tests/unit/teal/unchanged/swapper.teal
================================================
#pragma version 6
byte "hello"
store 5          //   5: hello   // x
byte "goodbye"
store 6          //   6: goodbye // y
load 5
load 6
callsub cat_1    //   <<EMPTY>>
int 5
int 6
callsub swap_0   //   >5,6
load 5           //   >goodbye
byte "goodbye"
==
assert           //   <<EMPTY>>
load 6           //   >hello
byte "hello"
==
assert           //   <<EMPTY>>
int 1000         //   >1000
return           //   <<SUCCESS>>

// swap
swap_0:
store 1          //   1: 6      // @y  
store 0          //   0: 5      // @x
load 0           //   >5
loads            //   >hello
store 2          //   2: hello  // z
load 0           //   >5
load 1           //   >5,6
loads            //   >5,goodbye
stores           //   5: goodbye
load 1           //   >6
load 2           //   >6,hello
stores           //   6: hello
retsub

// cat
cat_1:
store 4          //   4: goodbye
store 3          //   3: hello
load 3           //   >hello
load 4           //   >hello,goodbye
concat           //   >hellogoodbye
pop              //   >
retsub


================================================
FILE: tests/unit/teal/unchanged/wilt_the_stilt.teal
================================================
#pragma version 6
int 129
store 0         // 0: @129     // pointer to wilt's address
load 0
int 100
stores          // 129: 100    // set wilt's value
int 1
store 0         // 0: @1       // pointer to kobe's address (compiler assigned)
load 0
int 81
stores          // 1: 81       // set kobe's value
int 131
store 0         // 0: @131     // pointer to dt's address
load 0
int 73
stores          // 131: 73     // set dt's value
load 0
loads
int 73          // >73,73
==              // >1
assert          // <<EMPTY>>
load 0          
int 131         // >131,131
==              // >1
assert          // <<EMPTY>>
int 129
store 0         // 0: @129
load 0
loads
int 100         // >100,100
==              // >1
assert          // <<EMPTY>>
load 0
int 129         // >129,129
==              // >1
assert          // <<EMPTY>>
int 100
return


================================================
FILE: tests/unit/teal/user_guide/user_guide_snippet_ABIReturnSubroutine.teal
================================================
#pragma version 6
txna ApplicationArgs 1
store 0
load 0
callsub abisum_0
store 1
byte 0x151f7c75
load 1
itob
concat
log
int 1
return

// abi_sum
abisum_0:
store 2
int 0
store 3
int 0
store 4
abisum_0_l1:
load 4
load 2
int 0
extract_uint16
store 6
load 6
<
bz abisum_0_l3
load 2
int 8
load 4
*
int 2
+
extract_uint64
store 5
load 3
load 5
+
store 3
load 4
int 1
+
store 4
b abisum_0_l1
abisum_0_l3:
load 3
retsub


================================================
FILE: tests/unit/teal/user_guide/user_guide_snippet_dynamic_scratch_var.teal
================================================
#pragma version 6
int 0
store 1
int 7
store 0
load 1
load 1
loads
int 3
+
stores
load 0
int 10
==
assert
int 1
return


================================================
FILE: tests/unit/teal/user_guide/user_guide_snippet_recursiveIsEven.teal
================================================
#pragma version 6
int 15
callsub recursiveIsEven_0
return

// recursiveIsEven
recursiveIsEven_0:
store 0
load 0
int 0
==
bnz recursiveIsEven_0_l4
load 0
int 1
==
bnz recursiveIsEven_0_l3
load 0
int 2
-
load 0
swap
callsub recursiveIsEven_0
swap
store 0
b recursiveIsEven_0_l5
recursiveIsEven_0_l3:
int 0
b recursiveIsEven_0_l5
recursiveIsEven_0_l4:
int 1
recursiveIsEven_0_l5:
retsub


================================================
FILE: .github/ISSUE_TEMPLATE/bug_report.md
================================================
---
name: "\U0001F41C Bug report"
about: Report a reproducible bug.
title: ''
labels: new-bug
assignees: ''

---

### Subject of the issue

<!-- Describe your issue here. -->

### Your environment

<!--
* Software version: `algod -v`
* Node status if applicable: `goal node status`
* Operating System details. 
* In many cases log files and cadaver files are also useful to include. Since these files may be large, an Algorand developer may request them later. These files may include public addresses that you're participating with. If that is a concern please be sure to scrub that data.
-->

### Steps to reproduce

1.
2.

### Expected behaviour

### Actual behaviour



================================================
FILE: .github/ISSUE_TEMPLATE/feature_request.md
================================================
---
name: "\U0001F514 Feature Request"
about: Suggestions for how we can improve the algorand platform.
title: ''
labels: new-feature-request
assignees: ''
---

## Problem

<!-- What is the problem that we’re trying to solve? -->

## Solution

<!-- Do you have a potential/suggested solution? Document more than one if possible. -->

## Dependencies

<!-- Does the solution have any team or design dependencies? -->

## Urgency

<!-- What is the urgency here and why? -->



================================================
FILE: .github/workflows/build.yml
================================================
name: "On Commit Workflow"
on:
  pull_request:
  push:
    tags:
      - v**
    branches:
      - master

jobs:
  build-test:
    runs-on: ubuntu-22.04
    container: python:${{ matrix.python }}
    strategy:
      matrix:
        python: ["3.10", "3.11", "3.12"]
    steps:
      - run: python3 --version
      - name: Check out code
        uses: actions/checkout@v3
      - name: Install Python dependencies, Build, and Test
        run: make setup-build-test

  run-integration-tests:
    runs-on: ubuntu-22.04
    strategy:
      matrix:
        python: ["3.10", "3.11", "3.12"]
    steps:
      - name: Check out code
        uses: actions/checkout@v3
      - uses: actions/setup-python@v4
        with:
          python-version: "${{ matrix.python }}"
      - name: Test Python version
        run: |
          installed="$(python --version)"
          expected="${{ matrix.python }}"
          echo $installed
          [[ $installed =~ "Python ${expected}" ]] && echo "Configured Python" || (echo "Failed to configure Python" && exit 1)
      - name: Integration tests using algod
        run: make algod-integration

  build-docset:
    runs-on: ubuntu-22.04
    strategy:
      matrix:
        python: ["3.10"]
    steps:
      - name: Check out code
        uses: actions/checkout@v3
      - uses: actions/setup-python@v4
        with:
          python-version: "${{ matrix.python }}"
      - name: Install python dependencies
        run: make setup-docs
      - name: Make docs
        run: make bundle-docs
      - name: Archive docset
        if: ${{ !env.ACT }}
        uses: actions/upload-artifact@v4
        with:
          name: pyteal.docset
          path: docs/pyteal.docset.tar.gz

  upload-to-pypi:
    runs-on: ubuntu-22.04
    needs: ['build-test', 'run-integration-tests', 'build-docset']
    if: ${{ github.event_name == 'push' && startsWith(github.ref, 'refs/tags') }}
    steps:
      - name: Set up python
        uses: actions/setup-python@v4
        with:
          python-version: '3.10'
      - name: Check out code
        uses: actions/checkout@v3
      - name: Install dependencies
        run: make setup-wheel
      - name: Build package
        run: make bdist-wheel
      - name: Release
        uses: pypa/gh-action-pypi-publish@release/v1.12
        with:
          user: __token__
          password: ${{ secrets.PYPI_API_TOKEN }}



================================================
FILE: .github/workflows/nightly.yml
================================================
name: "Nightly Build"
on:
  schedule:
    - cron: "10 1 * * *"

jobs:
  nightly-slow-unit-tests:
    name: build-test + nightly-slow if changes in the previous 24 hours
    runs-on: ubuntu-22.04
    container: python:${{ matrix.python }}
    strategy:
      matrix:
        python: ["3.10", "3.11", "3.12"]
    steps:
      - run: python3 --version
      - name: Check out code
        uses: actions/checkout@v3
      - name: Check for code changes
        id: check
        run: make check-code-changes
      - name: Install Python dependencies, Build, and Test
        if: ${{ env.should_run == 'true' }}
        run: make setup-build-test
      - name: Super slow unit tests
        if: ${{ env.should_run == 'true' }}
        run: make nightly-slow

  nightly-run-integration-tests:
    name: run-integration-tests if changes in the previous 24 hours
    runs-on: ubuntu-22.04
    strategy:
      matrix:
        python: ["3.10", "3.11", "3.12"]
    steps:
      - name: Check out code
        uses: actions/checkout@v3
      - name: Check for code changes
        id: check
        run: make check-code-changes
      - uses: actions/setup-python@v4
        if: ${{ env.should_run == 'true' }}
        with:
          python-version: "${{ matrix.python }}"
      - name: Test Python version
        if: ${{ env.should_run == 'true' }}
        run: |
          installed="$(python --version)"
          expected="${{ matrix.python }}"
          echo $installed
          [[ $installed =~ "Python ${expected}" ]] && echo "Configured Python" || (echo "Failed to configure Python" && exit 1)
      - name: Integration tests using algod
        if: ${{ env.should_run == 'true' }}
        run: make algod-integration


